{"instance_id": "scikit-learn__scikit-learn-11578", "repo": "scikit-learn/scikit-learn", "version": "0.20", "environment_setup_commit": "55bf5d93e5674f13a1134d93a11fd0cd11aabcd1", "patch_list": ["diff --git a/dev/null b/sklearn/tests/test_coverup_scikit-learn__scikit-learn-11578.py\nnew file mode 100644\nindex e69de29..cc4f378 100644\n--- /dev/null\n+++ b/sklearn/tests/test_coverup_scikit-learn__scikit-learn-11578.py\n@@ -0,0 +1,50 @@\n+import numpy as np\n+import pytest\n+from sklearn.linear_model import LogisticRegressionCV, LogisticRegression\n+from sklearn.linear_model.logistic import _log_reg_scoring_path\n+from sklearn.preprocessing import LabelBinarizer\n+from sklearn.utils import extmath\n+\n+def test_log_reg_scoring_path_multinomial_bug():\n+    # Setup synthetic data\n+    np.random.seed(1234)\n+    samples = 200\n+    features = 5\n+    folds = 10\n+\n+    X = np.random.random(size=(samples, features))\n+    y = np.random.choice(['a', 'b', 'c'], size=samples)\n+\n+    test_indices = np.random.choice(range(samples), size=int(samples / folds), replace=False)\n+    train_indices = [idx for idx in range(samples) if idx not in test_indices]\n+\n+    # Binarize the labels for y[test]\n+    lb = LabelBinarizer()\n+    lb.fit(y[test_indices])\n+    y_bin = lb.transform(y[test_indices])\n+\n+    # Use LogisticRegressionCV to get expected multinomial scores\n+    log_reg_cv = LogisticRegressionCV(multi_class='multinomial', solver='lbfgs', cv=folds)\n+    log_reg_cv.fit(X[train_indices], y[train_indices])\n+    expected_probs = log_reg_cv.predict_proba(X[test_indices])\n+\n+    # Call _log_reg_scoring_path with multi_class='multinomial'\n+    coefs, _, scores, _ = _log_reg_scoring_path(X, y, train_indices, test_indices, fit_intercept=True, scoring='neg_log_loss', multi_class='multinomial')\n+\n+    # Initialize a LogisticRegression instance with the same coefficients\n+    log_reg = LogisticRegression(fit_intercept=True, multi_class='multinomial')\n+    log_reg.coef_ = coefs[0][:, :-1]\n+    log_reg.intercept_ = coefs[0][:, -1]\n+\n+    # Get probabilities using predict_proba\n+    actual_probs = log_reg.predict_proba(X[test_indices])\n+\n+    # Assert that the probabilities match the expected multinomial probabilities\n+    assert np.allclose(actual_probs, expected_probs), \"Probabilities should match when the bug is fixed\"\n+\n+    # Assert that the scores match the expected multinomial scores\n+    expected_score = -np.mean(np.sum(y_bin * np.log(expected_probs), axis=1))\n+    actual_score = scores[0]\n+    assert np.isclose(actual_score, expected_score), \"Scores should match when the bug is fixed\"\n+\n+# Note: The test will fail if the bug is present.\n"], "arch": "x86_64", "base_commit": "dd69361a0d9c6ccde0d2353b00b86e0e7541a3e3", "test_directives": ["sklearn/tests/test_coverup_scikit-learn__scikit-learn-11578.py"], "coverage_files": ["sklearn/linear_model/logistic.py"], "env_name": "testbed", "run_id": "assertflip", "patch_id": "pred_pre__AssertFlip", "timeout": 1800, "rm_image": false, "force_rebuild": false, "exec_mode": "unit_test", "reproduction_script_name": null, "compute_coverage": true, "install": {"python": "3.6", "packages": "numpy scipy cython pytest pandas matplotlib", "install": "python -m pip install -v --no-use-pep517 --no-build-isolation -e .", "pip_packages": ["cython", "numpy==1.19.2", "setuptools", "scipy==1.5.2"]}, "cache_level": "instance", "test_command": "python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(sklearn/linear_model/logistic\\.py)' -m pytest --no-header -rA  -p no:cacheprovider sklearn/tests/test_coverup_scikit-learn__scikit-learn-11578.py", "req_install_commands": ["conda create -n testbed python=3.6 numpy scipy cython pytest pandas matplotlib -y"]}