+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD d49a6f13af2f22228d430ac64ac2b518937800d0
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit d49a6f13af2f22228d430ac64ac2b518937800d0
Author: Hanmin Qin <qinhanmin2005@sina.com>
Date:   Sun Jul 28 21:57:51 2019 +0800

    DOC what's new clean up for 0.21.3

diff --git a/doc/whats_new/v0.21.rst b/doc/whats_new/v0.21.rst
index 7e2d5d7453..05a88a4fc1 100644
--- a/doc/whats_new/v0.21.rst
+++ b/doc/whats_new/v0.21.rst
@@ -31,14 +31,16 @@ Changelog
 
 - |Fix| Fixed a bug in :class:`cluster.KMeans` where computation was single
   threaded when `n_jobs > 1` or `n_jobs = -1`.
-  :issue:`12949` by :user:`Prabakaran Kumaresshan <nixphix>`.
+  :pr:`12955` by :user:`Prabakaran Kumaresshan <nixphix>`.
 
-:mod:`sklearn.inspection`
+:mod:`sklearn.compose`
 .....................
 
-- |Fix| Fixed a bug in :func:`inspection.plot_partial_dependence` where 
-  ``target`` parameter was not being taken into account for multiclass problems.
-  :pr:`14393` by :user:`Guillem G. Subies <guillemgsubies>`.
+- |Fix| Fixed an issue in :class:`compose.ColumnTransformer` where using
+  DataFrames whose column order differs between :func:``fit`` and
+  :func:``transform`` could lead to silently passing incorrect columns to the
+  ``remainder`` transformer.
+  :pr:`14237` by `Andreas Schuderer <schuderer>`.
 
 :mod:`sklearn.datasets`
 .......................
@@ -59,23 +61,26 @@ Changelog
   :class:`impute.IterativeImputer` so that no errors are thrown when there are
   missing values in training data. :pr:`13974` by `Frank Hoang <fhoang7>`.
 
+:mod:`sklearn.inspection`
+.....................
+
+- |Fix| Fixed a bug in :func:`inspection.plot_partial_dependence` where 
+  ``target`` parameter was not being taken into account for multiclass problems.
+  :pr:`14393` by :user:`Guillem G. Subies <guillemgsubies>`.
+
 :mod:`sklearn.linear_model`
 ...........................
+
 - |Fix| Fixed a bug in :class:`linear_model.LogisticRegressionCV` where
   ``refit=False`` would fail depending on the ``'multiclass'`` and
   ``'penalty'`` parameters (regression introduced in 0.21). :pr:`14087` by
   `Nicolas Hug`_.
+
 - |Fix| Compatibility fix for :class:`linear_model.ARDRegression` and
   Scipy>=1.3.0. Adapts to upstream changes to the default `pinvh` cutoff
   threshold which otherwise results in poor accuracy in some cases.
   :pr:`14067` by :user:`Tim Staley <timstaley>`.
 
-:mod:`sklearn.tree`
-...................
-
-- |Fix| Fixed bug in :func:`tree.export_text` when the tree has one feature and 
-  a single feature name is passed in. :pr:`14053` by `Thomas Fan`
-
 :mod:`sklearn.neighbors`
 ........................
 
@@ -84,14 +89,11 @@ Changelog
   ``tol`` required too strict types. :pr:`14092` by
   :user:`Jérémie du Boisberranger <jeremiedbb>`.
 
-:mod:`sklearn.compose`
-.....................
+:mod:`sklearn.tree`
+...................
 
-- |Fix| Fixed an issue in :class:`compose.ColumnTransformer` where using
-  DataFrames whose column order differs between :func:``fit`` and
-  :func:``transform`` could lead to silently passing incorrect columns to the
-  ``remainder`` transformer.
-  :pr:`14237` by `Andreas Schuderer <schuderer>`.
+- |Fix| Fixed bug in :func:`tree.export_text` when the tree has one feature and 
+  a single feature name is passed in. :pr:`14053` by `Thomas Fan`.
 
 .. _changes_0_21_2:
 
+ git diff d49a6f13af2f22228d430ac64ac2b518937800d0
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -v --no-use-pep517 --no-build-isolation -e .
Using pip 21.2.2 from /opt/miniconda3/envs/testbed/lib/python3.6/site-packages/pip (python 3.6)
Obtaining file:///testbed
    Running command python setup.py egg_info
    running egg_info
    creating /tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info
    writing /tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/PKG-INFO
    writing dependency_links to /tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/dependency_links.txt
    writing requirements to /tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/requires.txt
    writing top-level names to /tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/top_level.txt
    writing manifest file '/tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/SOURCES.txt'
    reading manifest file '/tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/SOURCES.txt'
    reading manifest template 'MANIFEST.in'
    adding license file 'COPYING'
    writing manifest file '/tmp/pip-pip-egg-info-jmymwi3s/scikit_learn.egg-info/SOURCES.txt'
    Partial import of sklearn during the build process.
Requirement already satisfied: numpy>=1.11.0 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from scikit-learn==0.22.dev0) (1.19.2)
Requirement already satisfied: scipy>=0.17.0 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from scikit-learn==0.22.dev0) (1.5.2)
Requirement already satisfied: joblib>=0.11 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from scikit-learn==0.22.dev0) (1.1.1)
Installing collected packages: scikit-learn
  Attempting uninstall: scikit-learn
    Found existing installation: scikit-learn 0.22.dev0
    Uninstalling scikit-learn-0.22.dev0:
      Removing file or directory /opt/miniconda3/envs/testbed/lib/python3.6/site-packages/scikit-learn.egg-link
      Removing pth entries from /opt/miniconda3/envs/testbed/lib/python3.6/site-packages/easy-install.pth:
      Removing entry: /testbed
      Successfully uninstalled scikit-learn-0.22.dev0
  Running setup.py develop for scikit-learn
    Running command /opt/miniconda3/envs/testbed/bin/python -c 'import io, os, sys, setuptools, tokenize; sys.argv[0] = '"'"'/testbed/setup.py'"'"'; __file__='"'"'/testbed/setup.py'"'"';f = getattr(tokenize, '"'"'open'"'"', open)(__file__) if os.path.exists(__file__) else io.StringIO('"'"'from setuptools import setup; setup()'"'"');code = f.read().replace('"'"'\r\n'"'"', '"'"'\n'"'"');f.close();exec(compile(code, __file__, '"'"'exec'"'"'))' develop --no-deps
    C compiler: gcc -pthread -B /opt/miniconda3/envs/testbed/compiler_compat -Wl,--sysroot=/ -Wsign-compare -DNDEBUG -g -fwrapv -O3 -Wall -Wstrict-prototypes -fPIC

    compile options: '-c'
    extra options: '-fopenmp'
    gcc: test_openmp.c
    gcc -pthread -B /opt/miniconda3/envs/testbed/compiler_compat -Wl,--sysroot=/ objects/test_openmp.o -o test_openmp -fopenmp
    running develop
    running build_scripts
    running egg_info
    running build_src
    build_src
    building library "libsvm-skl" sources
    building extension "sklearn.__check_build._check_build" sources
    building extension "sklearn.preprocessing._csr_polynomial_expansion" sources
    building extension "sklearn.cluster._dbscan_inner" sources
    building extension "sklearn.cluster._hierarchical" sources
    building extension "sklearn.cluster._k_means_elkan" sources
    building extension "sklearn.cluster._k_means" sources
    building extension "sklearn.datasets._svmlight_format" sources
    building extension "sklearn.decomposition._online_lda" sources
    building extension "sklearn.decomposition.cdnmf_fast" sources
    building extension "sklearn.ensemble._gradient_boosting" sources
    building extension "sklearn.ensemble._hist_gradient_boosting._gradient_boosting" sources
    building extension "sklearn.ensemble._hist_gradient_boosting.histogram" sources
    building extension "sklearn.ensemble._hist_gradient_boosting.splitting" sources
    building extension "sklearn.ensemble._hist_gradient_boosting._binning" sources
    building extension "sklearn.ensemble._hist_gradient_boosting._predictor" sources
    building extension "sklearn.ensemble._hist_gradient_boosting._loss" sources
    building extension "sklearn.ensemble._hist_gradient_boosting.types" sources
    building extension "sklearn.ensemble._hist_gradient_boosting.utils" sources
    building extension "sklearn.feature_extraction._hashing" sources
    building extension "sklearn.manifold._utils" sources
    building extension "sklearn.manifold._barnes_hut_tsne" sources
    building extension "sklearn.metrics.cluster.expected_mutual_info_fast" sources
    building extension "sklearn.metrics.pairwise_fast" sources
    building extension "sklearn.neighbors.ball_tree" sources
    building extension "sklearn.neighbors.kd_tree" sources
    building extension "sklearn.neighbors.dist_metrics" sources
    building extension "sklearn.neighbors.typedefs" sources
    building extension "sklearn.neighbors.quad_tree" sources
    building extension "sklearn.tree._tree" sources
    building extension "sklearn.tree._splitter" sources
    building extension "sklearn.tree._criterion" sources
    building extension "sklearn.tree._utils" sources
    building extension "sklearn.utils.sparsefuncs_fast" sources
    building extension "sklearn.utils._cython_blas" sources
    building extension "sklearn.utils.arrayfuncs" sources
    building extension "sklearn.utils.murmurhash" sources
    building extension "sklearn.utils.lgamma" sources
    building extension "sklearn.utils.graph_shortest_path" sources
    building extension "sklearn.utils.fast_dict" sources
    building extension "sklearn.utils.seq_dataset" sources
    building extension "sklearn.utils.weight_vector" sources
    building extension "sklearn.utils._random" sources
    building extension "sklearn.utils._logistic_sigmoid" sources
    building extension "sklearn.svm.libsvm" sources
    building extension "sklearn.svm.liblinear" sources
    building extension "sklearn.svm.libsvm_sparse" sources
    building extension "sklearn.linear_model.cd_fast" sources
    building extension "sklearn.linear_model.sgd_fast" sources
    building extension "sklearn.linear_model.sag_fast" sources
    building extension "sklearn._isotonic" sources
    building data_files sources
    build_src: building npy-pkg config files
    writing scikit_learn.egg-info/PKG-INFO
    writing dependency_links to scikit_learn.egg-info/dependency_links.txt
    writing requirements to scikit_learn.egg-info/requires.txt
    writing top-level names to scikit_learn.egg-info/top_level.txt
    reading manifest file 'scikit_learn.egg-info/SOURCES.txt'
    reading manifest template 'MANIFEST.in'
    adding license file 'COPYING'
    writing manifest file 'scikit_learn.egg-info/SOURCES.txt'
    running build_ext
    customize UnixCCompiler
    customize UnixCCompiler using build_clib
    customize UnixCCompiler
    customize UnixCCompiler using build_ext_subclass
    customize UnixCCompiler
    customize UnixCCompiler using build_ext_subclass
    Creating /opt/miniconda3/envs/testbed/lib/python3.6/site-packages/scikit-learn.egg-link (link to .)
    Adding scikit-learn 0.22.dev0 to easy-install.pth file

    Installed /testbed
    Partial import of sklearn during the build process.
Successfully installed scikit-learn-0.22.dev0
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
+ git apply -v -
Checking patch sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py...
<stdin>:23: new blank line at EOF.
+
Applied patch sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py cleanly.
warning: 1 line adds whitespace errors.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(sklearn/cluster/optics_\.py)' -m pytest --no-header -rA -p no:cacheprovider sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(sklearn/cluster/optics_\\.py)']
============================= test session starts ==============================
collected 1 item

sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py F         [100%]

=================================== FAILURES ===================================
______________________ test_optics_min_samples_float_bug _______________________

    def test_optics_min_samples_float_bug():
        # Create a mock dataset
        data = np.random.rand(10, 2)  # 10 samples, 2 features
    
        # Instantiate OPTICS with min_samples as a float less than 1
        clust = OPTICS(min_samples=0.1)
    
        # Call fit to trigger the internal computation
        clust.fit(data)
    
        # Check if min_samples is correctly converted to an integer after internal computation
>       assert isinstance(clust.min_samples, int), "min_samples should be an integer after computation"
E       AssertionError: min_samples should be an integer after computation
E       assert False
E        +  where False = isinstance(0.1, int)
E        +    where 0.1 = OPTICS(algorithm='auto', cluster_method='xi', eps=None, leaf_size=30,\n       max_eps=inf, metric='minkowski', metric_params=None,\n       min_cluster_size=None, min_samples=0.1, n_jobs=None, p=2,\n       predecessor_correction=True, xi=0.05).min_samples

sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py:16: AssertionError
----------------------------- Captured stdout call -----------------------------
0.74 optics_.py(201):         self.max_eps = max_eps
0.74 optics_.py(202):         self.min_samples = min_samples
0.74 optics_.py(203):         self.min_cluster_size = min_cluster_size
0.74 optics_.py(204):         self.algorithm = algorithm
0.74 optics_.py(205):         self.metric = metric
0.74 optics_.py(206):         self.metric_params = metric_params
0.74 optics_.py(207):         self.p = p
0.74 optics_.py(208):         self.leaf_size = leaf_size
0.74 optics_.py(209):         self.cluster_method = cluster_method
0.74 optics_.py(210):         self.eps = eps
0.74 optics_.py(211):         self.xi = xi
0.74 optics_.py(212):         self.predecessor_correction = predecessor_correction
0.74 optics_.py(213):         self.n_jobs = n_jobs
0.74 optics_.py(236):         X = check_array(X, dtype=np.float)
0.74 optics_.py(238):         if self.cluster_method not in ['dbscan', 'xi']:
0.74 optics_.py(244):          self.predecessor_) = compute_optics_graph(
0.74 optics_.py(245):              X=X, min_samples=self.min_samples, algorithm=self.algorithm,
0.74 optics_.py(246):              leaf_size=self.leaf_size, metric=self.metric,
0.74 optics_.py(247):              metric_params=self.metric_params, p=self.p, n_jobs=self.n_jobs,
0.74 optics_.py(248):              max_eps=self.max_eps)
0.74 optics_.py(437):     n_samples = X.shape[0]
0.74 optics_.py(438):     _validate_size(min_samples, n_samples, 'min_samples')
0.74 optics_.py(281):     if size <= 0 or (size !=
0.74 optics_.py(282):                      int(size)
0.74 optics_.py(283):                      and size > 1):
0.74 optics_.py(287):     elif size > n_samples:
0.74 optics_.py(439):     if min_samples <= 1:
0.74 optics_.py(440):         min_samples = max(2, min_samples * n_samples)
0.74 optics_.py(443):     reachability_ = np.empty(n_samples)
0.74 optics_.py(444):     reachability_.fill(np.inf)
0.74 optics_.py(445):     predecessor_ = np.empty(n_samples, dtype=int)
0.74 optics_.py(446):     predecessor_.fill(-1)
0.74 optics_.py(448):     nbrs = NearestNeighbors(n_neighbors=min_samples,
0.74 optics_.py(449):                             algorithm=algorithm,
0.74 optics_.py(450):                             leaf_size=leaf_size,
0.74 optics_.py(451):                             metric=metric,
0.74 optics_.py(452):                             metric_params=metric_params,
0.74 optics_.py(453):                             p=p,
0.74 optics_.py(454):                             n_jobs=n_jobs)
0.74 optics_.py(456):     nbrs.fit(X)
0.74 optics_.py(460):     core_distances_ = _compute_core_distances_(X=X, neighbors=nbrs,
0.74 optics_.py(461):                                                min_samples=min_samples,
0.74 optics_.py(462):                                                working_memory=None)
0.74 optics_.py(317):     n_samples = X.shape[0]
0.74 optics_.py(318):     core_distances = np.empty(n_samples)
0.74 optics_.py(319):     core_distances.fill(np.nan)
0.74 optics_.py(321):     chunk_n_rows = get_chunk_n_rows(row_bytes=16 * min_samples,
0.74 optics_.py(322):                                     max_n_rows=n_samples,
0.74 optics_.py(323):                                     working_memory=working_memory)
0.74 optics_.py(324):     slices = gen_batches(n_samples, chunk_n_rows)
0.74 optics_.py(325):     for sl in slices:
0.74 optics_.py(326):         core_distances[sl] = neighbors.kneighbors(
0.74 optics_.py(327):             X[sl], min_samples)[0][:, -1]
0.75 optics_.py(325):     for sl in slices:
0.75 optics_.py(328):     return core_distances
0.75 optics_.py(464):     core_distances_[core_distances_ > max_eps] = np.inf
0.75 optics_.py(470):     processed = np.zeros(X.shape[0], dtype=bool)
0.75 optics_.py(471):     ordering = np.zeros(X.shape[0], dtype=int)
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(512):     if metric == 'precomputed':
0.75 optics_.py(515):         _params = dict() if metric_params is None else metric_params.copy()
0.75 optics_.py(516):         if metric == 'minkowski' and 'p' not in _params:
0.75 optics_.py(519):             _params['p'] = p
0.75 optics_.py(520):         dists = pairwise_distances(P, np.take(X, unproc, axis=0),
0.75 optics_.py(521):                                    metric, n_jobs=None,
0.75 optics_.py(522):                                    **_params).ravel()
0.75 optics_.py(524):     rdists = np.maximum(dists, core_distances_[point_index])
0.75 optics_.py(525):     improved = np.where(rdists < np.take(reachability_, unproc))
0.75 optics_.py(526):     reachability_[unproc[improved]] = rdists[improved]
0.75 optics_.py(527):     predecessor_[unproc[improved]] = point_index
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.75 optics_.py(475):         index = np.where(processed == 0)[0]
0.75 optics_.py(476):         point = index[np.argmin(reachability_[index])]
0.75 optics_.py(478):         processed[point] = True
0.75 optics_.py(479):         ordering[ordering_idx] = point
0.75 optics_.py(480):         if core_distances_[point] != np.inf:
0.75 optics_.py(481):             _set_reach_dist(core_distances_=core_distances_,
0.75 optics_.py(482):                             reachability_=reachability_,
0.75 optics_.py(483):                             predecessor_=predecessor_,
0.75 optics_.py(484):                             point_index=point,
0.75 optics_.py(485):                             processed=processed, X=X, nbrs=nbrs,
0.75 optics_.py(486):                             metric=metric, metric_params=metric_params,
0.75 optics_.py(487):                             p=p, max_eps=max_eps)
0.75 optics_.py(498):     P = X[point_index:point_index + 1]
0.75 optics_.py(502):     indices = nbrs.radius_neighbors(P, radius=max_eps,
0.75 optics_.py(503):                                     return_distance=False)[0]
0.75 optics_.py(506):     unproc = np.compress(~np.take(processed, indices), indices)
0.75 optics_.py(508):     if not unproc.size:
0.75 optics_.py(509):         return
0.75 optics_.py(472):     for ordering_idx in range(X.shape[0]):
0.76 optics_.py(488):     if np.all(np.isinf(reachability_)):
0.76 optics_.py(492):     return ordering, core_distances_, reachability_, predecessor_
0.76 optics_.py(251):         if self.cluster_method == 'xi':
0.76 optics_.py(252):             labels_, clusters_ = cluster_optics_xi(
0.76 optics_.py(253):                 self.reachability_,
0.76 optics_.py(254):                 self.predecessor_,
0.76 optics_.py(255):                 self.ordering_,
0.76 optics_.py(256):                 self.min_samples,
0.76 optics_.py(257):                 self.min_cluster_size,
0.76 optics_.py(258):                 self.xi,
0.76 optics_.py(259):                 self.predecessor_correction)
0.76 optics_.py(619):     n_samples = len(reachability)
0.76 optics_.py(620):     _validate_size(min_samples, n_samples, 'min_samples')
0.76 optics_.py(281):     if size <= 0 or (size !=
0.76 optics_.py(282):                      int(size)
0.76 optics_.py(283):                      and size > 1):
0.76 optics_.py(287):     elif size > n_samples:
0.76 optics_.py(621):     if min_samples <= 1:
0.76 optics_.py(622):         min_samples = max(2, min_samples * n_samples)
0.76 optics_.py(623):     if min_cluster_size is None:
0.76 optics_.py(624):         min_cluster_size = min_samples
0.76 optics_.py(625):     _validate_size(min_cluster_size, n_samples, 'min_cluster_size')
0.76 optics_.py(281):     if size <= 0 or (size !=
0.76 optics_.py(282):                      int(size)
0.76 optics_.py(287):     elif size > n_samples:
0.76 optics_.py(626):     if min_cluster_size <= 1:
0.76 optics_.py(629):     clusters = _xi_cluster(reachability[ordering], predecessor[ordering],
0.76 optics_.py(630):                            ordering, xi,
0.76 optics_.py(631):                            min_samples, min_cluster_size,
0.76 optics_.py(632):                            predecessor_correction)
0.76 optics_.py(782):     reachability_plot = np.hstack((reachability_plot, np.inf))
0.76 optics_.py(784):     xi_complement = 1 - xi
0.76 optics_.py(785):     sdas = []  # steep down areas, introduced in section 4.3.2 of the paper
0.76 optics_.py(786):     clusters = []
0.76 optics_.py(787):     index = 0
0.76 optics_.py(788):     mib = 0.  # maximum in between, section 4.3.2
0.76 optics_.py(794):     with np.errstate(invalid='ignore'):
0.76 optics_.py(795):         ratio = reachability_plot[:-1] / reachability_plot[1:]
0.76 optics_.py(796):         steep_upward = ratio <= xi_complement
0.76 optics_.py(797):         steep_downward = ratio >= 1 / xi_complement
0.76 optics_.py(798):         downward = ratio > 1
0.76 optics_.py(799):         upward = ratio < 1
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(813):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(814):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(705):         return []
0.76 optics_.py(815):             D_start = steep_index
0.76 optics_.py(816):             D_end = _extend_region(steep_downward, upward,
0.76 optics_.py(817):                                    D_start, min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(818):             D = {'start': D_start, 'end': D_end, 'mib': 0.}
0.76 optics_.py(819):             sdas.append(D)
0.76 optics_.py(820):             index = D_end + 1
0.76 optics_.py(821):             mib = reachability_plot[index]
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(807):             continue
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(825):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(826):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(827):             U_start = steep_index
0.76 optics_.py(828):             U_end = _extend_region(steep_upward, downward, U_start,
0.76 optics_.py(829):                                    min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(830):             index = U_end + 1
0.76 optics_.py(831):             mib = reachability_plot[index]
0.76 optics_.py(833):             U_clusters = []
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(847):                     while (reachability_plot[c_start + 1] >
0.76 optics_.py(848):                            reachability_plot[c_end + 1]
0.76 optics_.py(849):                            and c_start < D['end']):
0.76 optics_.py(850):                         c_start += 1
0.76 optics_.py(847):                     while (reachability_plot[c_start + 1] >
0.76 optics_.py(848):                            reachability_plot[c_end + 1]
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(887):             U_clusters.reverse()
0.76 optics_.py(888):             clusters.extend(U_clusters)
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(813):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(814):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(815):             D_start = steep_index
0.76 optics_.py(816):             D_end = _extend_region(steep_downward, upward,
0.76 optics_.py(817):                                    D_start, min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(818):             D = {'start': D_start, 'end': D_end, 'mib': 0.}
0.76 optics_.py(819):             sdas.append(D)
0.76 optics_.py(820):             index = D_end + 1
0.76 optics_.py(821):             mib = reachability_plot[index]
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(825):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(826):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(827):             U_start = steep_index
0.76 optics_.py(828):             U_end = _extend_region(steep_upward, downward, U_start,
0.76 optics_.py(829):                                    min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(830):             index = U_end + 1
0.76 optics_.py(831):             mib = reachability_plot[index]
0.76 optics_.py(833):             U_clusters = []
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(847):                     while (reachability_plot[c_start + 1] >
0.76 optics_.py(848):                            reachability_plot[c_end + 1]
0.76 optics_.py(849):                            and c_start < D['end']):
0.76 optics_.py(850):                         c_start += 1
0.76 optics_.py(847):                     while (reachability_plot[c_start + 1] >
0.76 optics_.py(848):                            reachability_plot[c_end + 1]
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(851):                 elif reachability_plot[c_end + 1] * xi_complement >= D_max:
0.76 optics_.py(858):                     while (reachability_plot[c_end - 1] > D_max
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(887):             U_clusters.reverse()
0.76 optics_.py(888):             clusters.extend(U_clusters)
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(813):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(814):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(815):             D_start = steep_index
0.76 optics_.py(816):             D_end = _extend_region(steep_downward, upward,
0.76 optics_.py(817):                                    D_start, min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(818):             D = {'start': D_start, 'end': D_end, 'mib': 0.}
0.76 optics_.py(819):             sdas.append(D)
0.76 optics_.py(820):             index = D_end + 1
0.76 optics_.py(821):             mib = reachability_plot[index]
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(825):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(826):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(827):             U_start = steep_index
0.76 optics_.py(828):             U_end = _extend_region(steep_upward, downward, U_start,
0.76 optics_.py(829):                                    min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(830):             index = U_end + 1
0.76 optics_.py(831):             mib = reachability_plot[index]
0.76 optics_.py(833):             U_clusters = []
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(840):                     continue
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(851):                 elif reachability_plot[c_end + 1] * xi_complement >= D_max:
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(887):             U_clusters.reverse()
0.76 optics_.py(888):             clusters.extend(U_clusters)
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(813):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(814):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(815):             D_start = steep_index
0.76 optics_.py(816):             D_end = _extend_region(steep_downward, upward,
0.76 optics_.py(817):                                    D_start, min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(687):         elif not xward_point[index]:
0.76 optics_.py(695):             return end
0.76 optics_.py(818):             D = {'start': D_start, 'end': D_end, 'mib': 0.}
0.76 optics_.py(819):             sdas.append(D)
0.76 optics_.py(820):             index = D_end + 1
0.76 optics_.py(821):             mib = reachability_plot[index]
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(807):             continue
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(806):         if steep_index < index:
0.76 optics_.py(809):         mib = max(mib, np.max(reachability_plot[index:steep_index + 1]))
0.76 optics_.py(812):         if steep_downward[steep_index]:
0.76 optics_.py(825):             sdas = _update_filter_sdas(sdas, mib, xi_complement,
0.76 optics_.py(826):                                        reachability_plot)
0.76 optics_.py(704):     if np.isinf(mib):
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(707):            if mib <= reachability_plot[sda['start']] * xi_complement]
0.76 optics_.py(706):     res = [sda for sda in sdas
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(709):         sda['mib'] = max(sda['mib'], mib)
0.76 optics_.py(708):     for sda in res:
0.76 optics_.py(710):     return res
0.76 optics_.py(827):             U_start = steep_index
0.76 optics_.py(828):             U_end = _extend_region(steep_upward, downward, U_start,
0.76 optics_.py(829):                                    min_samples)
0.76 optics_.py(678):     n_samples = len(steep_point)
0.76 optics_.py(679):     non_xward_points = 0
0.76 optics_.py(680):     index = start
0.76 optics_.py(681):     end = start
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(684):         if steep_point[index]:
0.76 optics_.py(685):             non_xward_points = 0
0.76 optics_.py(686):             end = index
0.76 optics_.py(696):         index += 1
0.76 optics_.py(683):     while index < n_samples:
0.76 optics_.py(697):     return end
0.76 optics_.py(830):             index = U_end + 1
0.76 optics_.py(831):             mib = reachability_plot[index]
0.76 optics_.py(833):             U_clusters = []
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(847):                     while (reachability_plot[c_start + 1] >
0.76 optics_.py(848):                            reachability_plot[c_end + 1]
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(835):                 c_start = D['start']
0.76 optics_.py(836):                 c_end = U_end
0.76 optics_.py(839):                 if reachability_plot[c_end + 1] * xi_complement < D['mib']:
0.76 optics_.py(843):                 D_max = reachability_plot[D['start']]
0.76 optics_.py(844):                 if D_max * xi_complement >= reachability_plot[c_end + 1]:
0.76 optics_.py(851):                 elif reachability_plot[c_end + 1] * xi_complement >= D_max:
0.76 optics_.py(858):                     while (reachability_plot[c_end - 1] > D_max
0.76 optics_.py(863):                 if predecessor_correction:
0.76 optics_.py(864):                     c_start, c_end = _correct_predecessor(reachability_plot,
0.76 optics_.py(865):                                                           predecessor_plot,
0.76 optics_.py(866):                                                           ordering,
0.76 optics_.py(867):                                                           c_start,
0.76 optics_.py(868):                                                           c_end)
0.76 optics_.py(724):     while s < e:
0.76 optics_.py(725):         if reachability_plot[s] > reachability_plot[e]:
0.76 optics_.py(726):             return s, e
0.76 optics_.py(869):                 if c_start is None:
0.76 optics_.py(873):                 if c_end - c_start + 1 < min_cluster_size:
0.76 optics_.py(877):                 if c_start > D['end']:
0.76 optics_.py(881):                 if c_end < U_start:
0.76 optics_.py(884):                 U_clusters.append((c_start, c_end))
0.76 optics_.py(834):             for D in sdas:
0.76 optics_.py(887):             U_clusters.reverse()
0.76 optics_.py(888):             clusters.extend(U_clusters)
0.76 optics_.py(803):     for steep_index in iter(np.flatnonzero(steep_upward | steep_downward)):
0.76 optics_.py(890):     return np.array(clusters)
0.76 optics_.py(633):     labels = _extract_xi_labels(ordering, clusters)
0.76 optics_.py(912):     labels = np.full(len(ordering), -1, dtype=int)
0.76 optics_.py(913):     label = 0
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(916):             labels[c[0]:(c[1] + 1)] = label
0.76 optics_.py(917):             label += 1
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(916):             labels[c[0]:(c[1] + 1)] = label
0.76 optics_.py(917):             label += 1
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(916):             labels[c[0]:(c[1] + 1)] = label
0.76 optics_.py(917):             label += 1
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(916):             labels[c[0]:(c[1] + 1)] = label
0.76 optics_.py(917):             label += 1
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(915):         if not np.any(labels[c[0]:(c[1] + 1)] != -1):
0.76 optics_.py(914):     for c in clusters:
0.76 optics_.py(918):     labels[ordering] = labels.copy()
0.76 optics_.py(919):     return labels
0.76 optics_.py(634):     return labels, clusters
0.76 optics_.py(260):             self.cluster_hierarchy_ = clusters_
0.76 optics_.py(276):         self.labels_ = labels_
0.76 optics_.py(277):         return self
=========================== short test summary info ============================
FAILED sklearn/tests/test_coverup_scikit-learn__scikit-learn-14496.py::test_optics_min_samples_float_bug
========================= 1 failed, 1 warning in 0.49s =========================
+ cat coverage.cover
{"/testbed/sklearn/cluster/optics_.py": {"12": 1, "14": 1, "15": 1, "17": 1, "18": 1, "19": 1, "20": 1, "21": 1, "24": 2, "280": 1, "294": 1, "331": 1, "495": 1, "530": 1, "571": 1, "637": 1, "700": 1, "713": 1, "735": 1, "893": 1, "197": 1, "198": 1, "199": 1, "200": 1, "215": 1, "201": 1, "202": 1, "203": 1, "204": 1, "205": 1, "206": 1, "207": 1, "208": 1, "209": 1, "210": 1, "211": 1, "212": 1, "213": 1, "236": 1, "238": 1, "239": 0, "241": 0, "244": 1, "245": 1, "246": 1, "247": 1, "248": 1, "251": 1, "252": 1, "253": 1, "254": 1, "255": 1, "256": 1, "257": 1, "258": 1, "259": 1, "260": 1, "261": 0, "262": 0, "263": 0, "265": 0, "267": 0, "268": 0, "269": 0, "271": 0, "272": 0, "273": 0, "274": 0, "276": 1, "277": 1, "281": 3, "282": 3, "283": 2, "284": 0, "286": 0, "287": 3, "288": 0, "290": 0, "317": 1, "318": 1, "319": 1, "321": 1, "322": 1, "323": 1, "324": 1, "325": 2, "326": 1, "327": 1, "328": 1, "437": 1, "438": 1, "439": 1, "440": 1, "443": 1, "444": 1, "445": 1, "446": 1, "448": 1, "449": 1, "450": 1, "451": 1, "452": 1, "453": 1, "454": 1, "456": 1, "460": 1, "461": 1, "462": 1, "464": 1, "470": 1, "471": 1, "472": 11, "475": 10, "476": 10, "478": 10, "479": 10, "480": 10, "481": 10, "482": 10, "483": 10, "484": 10, "485": 10, "486": 10, "487": 10, "488": 1, "489": 0, "491": 0, "492": 1, "498": 10, "502": 10, "503": 10, "506": 10, "508": 10, "509": 1, "512": 9, "513": 0, "515": 9, "516": 9, "519": 9, "520": 9, "521": 9, "522": 9, "524": 9, "525": 9, "526": 9, "527": 9, "559": 0, "560": 0, "562": 0, "563": 0, "564": 0, "565": 0, "566": 0, "619": 1, "620": 1, "621": 1, "622": 1, "623": 1, "624": 1, "625": 1, "626": 1, "627": 0, "629": 1, "630": 1, "631": 1, "632": 1, "633": 1, "634": 1, "678": 8, "679": 8, "680": 8, "681": 8, "683": 18, "684": 17, "685": 10, "686": 10, "687": 7, "689": 0, "692": 0, "693": 0, "695": 7, "696": 10, "697": 1, "704": 8, "705": 1, "706": 26, "708": 17, "709": 10, "710": 7, "707": 12, "724": 6, "725": 6, "726": 6, "727": 0, "728": 0, "729": 0, "730": 0, "731": 0, "732": 0, "782": 1, "784": 1, "785": 1, "786": 1, "787": 1, "788": 1, "794": 1, "795": 1, "796": 1, "797": 1, "798": 1, "799": 1, "803": 11, "806": 10, "807": 2, "809": 8, "812": 8, "813": 4, "814": 4, "815": 4, "816": 4, "817": 4, "818": 4, "819": 4, "820": 4, "821": 4, "825": 4, "826": 4, "827": 4, "828": 4, "829": 4, "830": 4, "831": 4, "833": 4, "834": 11, "835": 7, "836": 7, "839": 7, "840": 1, "843": 6, "844": 6, "847": 5, "848": 5, "849": 2, "850": 2, "851": 3, "858": 2, "859": 0, "860": 0, "863": 6, "864": 6, "865": 6, "866": 6, "867": 6, "868": 6, "869": 6, "870": 0, "873": 6, "874": 0, "877": 6, "878": 0, "881": 6, "882": 0, "884": 6, "887": 4, "888": 4, "890": 1, "912": 1, "913": 1, "914": 7, "915": 6, "916": 4, "917": 4, "918": 1, "919": 1}}
+ git checkout d49a6f13af2f22228d430ac64ac2b518937800d0
Note: switching to 'd49a6f13af2f22228d430ac64ac2b518937800d0'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at d49a6f13af DOC what's new clean up for 0.21.3
+ git apply /root/pre_state.patch
error: unrecognized input
