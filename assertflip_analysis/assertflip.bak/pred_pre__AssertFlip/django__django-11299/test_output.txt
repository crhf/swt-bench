+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 6866c91b638de5368c18713fa851bfe56253ea55
+ sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen
+ locale-gen
Generating locales (this might take a while)...
  en_US.UTF-8... done
Generation complete.
+ export LANG=en_US.UTF-8
+ LANG=en_US.UTF-8
+ export LANGUAGE=en_US:en
+ LANGUAGE=en_US:en
+ export LC_ALL=en_US.UTF-8
+ LC_ALL=en_US.UTF-8
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 6866c91b638de5368c18713fa851bfe56253ea55
Author: Jon Dufresne <jon.dufresne@gmail.com>
Date:   Fri Apr 26 16:37:57 2019 -0700

    Fixed #30418 -- Added --skip-checks management command option.

diff --git a/django/core/management/base.py b/django/core/management/base.py
index 0c3a981290..c725e5b75e 100644
--- a/django/core/management/base.py
+++ b/django/core/management/base.py
@@ -95,7 +95,7 @@ class DjangoHelpFormatter(HelpFormatter):
     """
     show_last = {
         '--version', '--verbosity', '--traceback', '--settings', '--pythonpath',
-        '--no-color', '--force-color',
+        '--no-color', '--force-color', '--skip-checks',
     }
 
     def _reordered_actions(self, actions):
@@ -223,7 +223,7 @@ class BaseCommand:
     requires_system_checks = True
     # Arguments, common to all commands, which aren't defined by the argument
     # parser.
-    base_stealth_options = ('skip_checks', 'stderr', 'stdout')
+    base_stealth_options = ('stderr', 'stdout')
     # Command-specific options not defined by the argument parser.
     stealth_options = ()
 
@@ -286,6 +286,11 @@ class BaseCommand:
             '--force-color', action='store_true',
             help='Force colorization of the command output.',
         )
+        if self.requires_system_checks:
+            parser.add_argument(
+                '--skip-checks', action='store_true',
+                help='Skip system checks.',
+            )
         self.add_arguments(parser)
         return parser
 
@@ -357,7 +362,7 @@ class BaseCommand:
         if options.get('stderr'):
             self.stderr = OutputWrapper(options['stderr'])
 
-        if self.requires_system_checks and not options.get('skip_checks'):
+        if self.requires_system_checks and not options['skip_checks']:
             self.check()
         if self.requires_migrations_checks:
             self.check_migrations()
diff --git a/docs/ref/django-admin.txt b/docs/ref/django-admin.txt
index b531978dd6..a269f6f8c6 100644
--- a/docs/ref/django-admin.txt
+++ b/docs/ref/django-admin.txt
@@ -1724,6 +1724,19 @@ Forces colorization of the command output if it would otherwise be disabled
 as discussed in :ref:`syntax-coloring`. For example, you may want to pipe
 colored output to another command.
 
+.. django-admin-option:: --skip-checks
+
+.. versionadded:: 3.0
+
+Skips running system checks prior to running the command. This option is only
+available if the
+:attr:`~django.core.management.BaseCommand.requires_system_checks` command
+attribute is set to ``True``.
+
+Example usage::
+
+    django-admin migrate --skip-checks
+
 Extra niceties
 ==============
 
diff --git a/docs/releases/3.0.txt b/docs/releases/3.0.txt
index e4a9789efb..66dfde0b5d 100644
--- a/docs/releases/3.0.txt
+++ b/docs/releases/3.0.txt
@@ -180,6 +180,9 @@ Management Commands
 * :djadmin:`inspectdb` now introspects :class:`~django.db.models.OneToOneField`
   when a foreign key has a unique or primary key constraint.
 
+* The new :option:`--skip-checks` option skips running system checks prior to
+  running the command.
+
 Migrations
 ~~~~~~~~~~
 
diff --git a/tests/user_commands/tests.py b/tests/user_commands/tests.py
index 2d1f8f834d..76991b1122 100644
--- a/tests/user_commands/tests.py
+++ b/tests/user_commands/tests.py
@@ -253,6 +253,16 @@ class CommandRunTests(AdminScriptTestCase):
         self.assertNoOutput(err)
         self.assertEqual(out.strip(), 'Set foo')
 
+    def test_skip_checks(self):
+        self.write_settings('settings.py', apps=['django.contrib.staticfiles', 'user_commands'], sdict={
+            # (staticfiles.E001) The STATICFILES_DIRS setting is not a tuple or
+            # list.
+            'STATICFILES_DIRS': '"foo"',
+        })
+        out, err = self.run_manage(['set_option', '--skip-checks', '--set', 'foo'])
+        self.assertNoOutput(err)
+        self.assertEqual(out.strip(), 'Set foo')
+
 
 class UtilsTests(SimpleTestCase):
 
+ git diff 6866c91b638de5368c18713fa851bfe56253ea55
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
Requirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190430084830) (2025.2)
Requirement already satisfied: sqlparse in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190430084830) (0.4.4)
Installing collected packages: Django
  Attempting uninstall: Django
    Found existing installation: Django 3.0.dev20190430084830
    Uninstalling Django-3.0.dev20190430084830:
      Successfully uninstalled Django-3.0.dev20190430084830
  Running setup.py develop for Django
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
Successfully installed Django-3.0.dev20190430084830
+ git apply -v -
Checking patch tests/test_coverup_django__django-11299.py...
Applied patch tests/test_coverup_django__django-11299.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/query\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_coverup_django__django-11299
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(django/db/models/sql/query\\.py)']
0.32 query.py(8): """
0.32 query.py(9): import difflib
0.32 query.py(10): import functools
0.32 query.py(11): import inspect
0.32 query.py(12): import sys
0.32 query.py(13): import warnings
0.32 query.py(14): from collections import Counter, namedtuple
0.32 query.py(15): from collections.abc import Iterator, Mapping
0.32 query.py(16): from itertools import chain, count, product
0.32 query.py(17): from string import ascii_uppercase
0.32 query.py(19): from django.core.exceptions import (
0.32 query.py(22): from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections
0.32 query.py(23): from django.db.models.aggregates import Count
0.32 query.py(24): from django.db.models.constants import LOOKUP_SEP
0.32 query.py(25): from django.db.models.expressions import (
0.32 query.py(28): from django.db.models.fields import Field
0.32 query.py(29): from django.db.models.fields.related_lookups import MultiColSource
0.32 query.py(30): from django.db.models.lookups import Lookup
0.32 query.py(31): from django.db.models.query_utils import (
0.32 query.py(34): from django.db.models.sql.constants import (
0.33 query.py(37): from django.db.models.sql.datastructures import (
0.33 query.py(40): from django.db.models.sql.where import (
0.33 query.py(43): from django.utils.deprecation import RemovedInDjango40Warning
0.33 query.py(44): from django.utils.functional import cached_property
0.33 query.py(45): from django.utils.tree import Node
0.33 query.py(47): __all__ = ['Query', 'RawQuery']
0.33 query.py(50): def get_field_names_from_opts(opts):
0.33 query.py(57): def get_children_from_q(q):
0.33 query.py(65): JoinInfo = namedtuple(
0.33 query.py(66):     'JoinInfo',
0.33 query.py(67):     ('final_field', 'targets', 'opts', 'joins', 'path', 'transform_function')
0.33 query.py(71): def _get_col(target, field, alias, simple_col):
0.33 query.py(77): class RawQuery:
0.33 query.py(77): class RawQuery:
0.33 query.py(78):     """A single raw SQL query."""
0.33 query.py(80):     def __init__(self, sql, using, params=None):
0.33 query.py(92):     def chain(self, using):
0.33 query.py(95):     def clone(self, using):
0.33 query.py(98):     def get_columns(self):
0.33 query.py(105):     def __iter__(self):
0.33 query.py(117):     def __repr__(self):
0.33 query.py(120):     @property
0.33 query.py(124):     def __str__(self):
0.33 query.py(127):     def _execute_query(self):
0.33 query.py(145): class Query(BaseExpression):
0.33 query.py(145): class Query(BaseExpression):
0.33 query.py(146):     """A single SQL query."""
0.33 query.py(148):     alias_prefix = 'T'
0.33 query.py(149):     subq_aliases = frozenset([alias_prefix])
0.33 query.py(151):     compiler = 'SQLCompiler'
0.33 query.py(153):     def __init__(self, model, where=WhereNode):
0.33 query.py(237):     @property
0.33 query.py(244):     @property
0.33 query.py(248):     @cached_property
0.33 query.py(253):     def __str__(self):
0.33 query.py(264):     def sql_with_params(self):
0.33 query.py(271):     def __deepcopy__(self, memo):
0.33 query.py(277):     def get_compiler(self, using=None, connection=None):
0.33 query.py(284):     def get_meta(self):
0.33 query.py(292):     def clone(self):
0.33 query.py(338):     def chain(self, klass=None):
0.33 query.py(353):     def relabeled_clone(self, change_map):
0.33 query.py(358):     def rewrite_cols(self, annotation, col_cnt):
0.33 query.py(410):     def get_aggregation(self, using, added_aggregate_names):
0.33 query.py(506):     def get_count(self, using):
0.33 query.py(517):     def has_filters(self):
0.33 query.py(520):     def has_results(self, using):
0.33 query.py(532):     def explain(self, using, format=None, **options):
0.33 query.py(540):     def combine(self, rhs, connector):
0.33 query.py(641):     def deferred_to_data(self, target, callback):
0.33 query.py(727):     def table_alias(self, table_name, create=False, filtered_relation=None):
0.33 query.py(752):     def ref_alias(self, alias):
0.33 query.py(756):     def unref_alias(self, alias, amount=1):
0.33 query.py(760):     def promote_joins(self, aliases):
0.33 query.py(794):     def demote_joins(self, aliases):
0.33 query.py(813):     def reset_refcounts(self, to_counts):
0.33 query.py(822):     def change_aliases(self, change_map):
0.33 query.py(858):     def bump_prefix(self, outer_query):
0.33 query.py(907):     def get_initial_alias(self):
0.33 query.py(919):     def count_active_tables(self):
0.33 query.py(927):     def join(self, join, reuse=None, reuse_with_filtered_relation=False):
0.33 query.py(975):     def join_parent_model(self, opts, model, alias, seen):
0.33 query.py(1008):     def add_annotation(self, annotation, alias, is_summary=False):
0.33 query.py(1015):     def resolve_expression(self, query, *args, **kwargs):
0.33 query.py(1043):     def as_sql(self, compiler, connection):
0.33 query.py(1049):     def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col):
0.33 query.py(1069):     def solve_lookup_type(self, lookup):
0.33 query.py(1087):     def check_query_object_type(self, value, opts, field):
0.33 query.py(1098):     def check_related_objects(self, field, value, opts):
0.33 query.py(1118):     def build_lookup(self, lookups, lhs, rhs):
0.33 query.py(1163):     def try_transform(self, lhs, name):
0.33 query.py(1185):                      reuse_with_filtered_relation=False, simple_col=False):
0.33 query.py(1304):     def add_filter(self, filter_clause):
0.33 query.py(1307):     def add_q(self, q_object):
0.33 query.py(1324):     def build_where(self, q_object):
0.33 query.py(1329):                simple_col=False):
0.33 query.py(1355):     def build_filtered_relation_q(self, q_object, reuse, branch_negated=False, current_negated=False):
0.33 query.py(1377):     def add_filtered_relation(self, filtered_relation, alias):
0.33 query.py(1390):     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):
0.33 query.py(1487):                     reuse_with_filtered_relation=False):
0.33 query.py(1588):     def trim_joins(self, targets, joins, path):
0.33 query.py(1616):     def resolve_ref(self, name, allow_joins=True, reuse=None, summarize=False, simple_col=False):
0.33 query.py(1645):     def split_exclude(self, filter_expr, can_reuse, names_with_path):
0.33 query.py(1715):     def set_empty(self):
0.33 query.py(1718):     def is_empty(self):
0.33 query.py(1721):     def set_limits(self, low=None, high=None):
0.33 query.py(1744):     def clear_limits(self):
0.33 query.py(1748):     def has_limit_one(self):
0.33 query.py(1751):     def can_filter(self):
0.33 query.py(1759):     def clear_select_clause(self):
0.33 query.py(1767):     def clear_select_fields(self):
0.33 query.py(1776):     def set_select(self, cols):
0.33 query.py(1780):     def add_distinct_fields(self, *field_names):
0.33 query.py(1787):     def add_fields(self, field_names, allow_m2m=True):
0.33 query.py(1825):     def add_ordering(self, *ordering):
0.33 query.py(1850):     def clear_ordering(self, force_empty):
0.33 query.py(1860):     def set_group_by(self):
0.33 query.py(1887):     def add_select_related(self, fields):
0.33 query.py(1903):     def add_extra(self, select, select_params, where, params, tables, order_by):
0.33 query.py(1935):     def clear_deferred_loading(self):
0.33 query.py(1939):     def add_deferred_loading(self, field_names):
0.33 query.py(1959):     def add_immediate_loading(self, field_names):
0.33 query.py(1983):     def get_loaded_field_names(self):
0.33 query.py(2002):     def get_loaded_field_names_cb(self, target, model, fields):
0.33 query.py(2006):     def set_annotation_mask(self, names):
0.33 query.py(2014):     def append_annotation_mask(self, names):
0.33 query.py(2018):     def set_extra_mask(self, names):
0.33 query.py(2029):     def set_values(self, fields):
0.33 query.py(2064):     @property
0.33 query.py(2083):     @property
0.33 query.py(2098):     def trim_start(self, names_with_path):
0.33 query.py(2168):     def is_nullable(self, field):
0.33 query.py(2187): def get_order_dir(field, default='ASC'):
0.33 query.py(2201): def add_to_dict(data, key, value):
0.33 query.py(2212): def is_reverse_o2o(field):
0.33 query.py(2220): class JoinPromoter:
0.33 query.py(2220): class JoinPromoter:
0.33 query.py(2224):     """
0.33 query.py(2226):     def __init__(self, connector, num_children, negated):
0.33 query.py(2241):     def add_votes(self, votes):
0.33 query.py(2248):     def update_join_types(self, query):
Testing against Django installed in '/testbed/django'
Skipping setup of unused database(s): other.
Operations to perform:
  Synchronize unmigrated apps: auth, contenttypes, messages, sessions, staticfiles
  Apply all migrations: admin, sites
Synchronizing apps without migrations:
  Creating tables...
    Creating table django_content_type
    Creating table auth_permission
    Creating table auth_group
    Creating table auth_user
    Creating table django_session
    Running deferred SQL...
Running migrations:
  Applying admin.0001_initial...0.65 query.py(154):         self.model = model
0.65 query.py(155):         self.alias_refcount = {}
0.65 query.py(161):         self.alias_map = {}
0.65 query.py(165):         self.external_aliases = set()
0.65 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.65 query.py(167):         self.default_cols = True
0.65 query.py(168):         self.default_ordering = True
0.65 query.py(169):         self.standard_ordering = True
0.65 query.py(170):         self.used_aliases = set()
0.65 query.py(171):         self.filter_is_sticky = False
0.65 query.py(172):         self.subquery = False
0.65 query.py(180):         self.select = ()
0.65 query.py(181):         self.where = where()
0.65 query.py(182):         self.where_class = where
0.65 query.py(189):         self.group_by = None
0.65 query.py(190):         self.order_by = ()
0.65 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.65 query.py(192):         self.distinct = False
0.65 query.py(193):         self.distinct_fields = ()
0.65 query.py(194):         self.select_for_update = False
0.65 query.py(195):         self.select_for_update_nowait = False
0.65 query.py(196):         self.select_for_update_skip_locked = False
0.65 query.py(197):         self.select_for_update_of = ()
0.65 query.py(199):         self.select_related = False
0.65 query.py(201):         self.max_depth = 5
0.65 query.py(205):         self.values_select = ()
0.65 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.65 query.py(209):         self.annotation_select_mask = None
0.65 query.py(210):         self._annotation_select_cache = None
0.65 query.py(213):         self.combinator = None
0.65 query.py(214):         self.combinator_all = False
0.65 query.py(215):         self.combined_queries = ()
0.65 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.65 query.py(220):         self.extra_select_mask = None
0.65 query.py(221):         self._extra_select_cache = None
0.65 query.py(223):         self.extra_tables = ()
0.65 query.py(224):         self.extra_order_by = ()
0.65 query.py(229):         self.deferred_loading = (frozenset(), True)
0.65 query.py(231):         self._filtered_relations = {}
0.65 query.py(233):         self.explain_query = False
0.65 query.py(234):         self.explain_format = None
0.65 query.py(235):         self.explain_options = {}
0.65 query.py(343):         obj = self.clone()
0.65 query.py(297):         obj = Empty()
0.65 query.py(298):         obj.__class__ = self.__class__
0.65 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.65 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.65 query.py(303):         obj.alias_map = self.alias_map.copy()
0.65 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.65 query.py(305):         obj.table_map = self.table_map.copy()
0.65 query.py(306):         obj.where = self.where.clone()
0.65 query.py(307):         obj.annotations = self.annotations.copy()
0.65 query.py(308):         if self.annotation_select_mask is None:
0.65 query.py(309):             obj.annotation_select_mask = None
0.65 query.py(317):         obj._annotation_select_cache = None
0.65 query.py(318):         obj.extra = self.extra.copy()
0.65 query.py(319):         if self.extra_select_mask is None:
0.65 query.py(320):             obj.extra_select_mask = None
0.65 query.py(323):         if self._extra_select_cache is None:
0.65 query.py(324):             obj._extra_select_cache = None
0.65 query.py(327):         if 'subq_aliases' in self.__dict__:
0.65 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.65 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.65 query.py(332):         try:
0.65 query.py(333):             del obj.base_table
0.65 query.py(334):         except AttributeError:
0.65 query.py(335):             pass
0.65 query.py(336):         return obj
0.65 query.py(344):         if klass and obj.__class__ != klass:
0.65 query.py(346):         if not obj.filter_is_sticky:
0.65 query.py(347):             obj.used_aliases = set()
0.65 query.py(348):         obj.filter_is_sticky = False
0.65 query.py(349):         if hasattr(obj, '_setup_query'):
0.65 query.py(351):         return obj
0.65 query.py(154):         self.model = model
0.65 query.py(155):         self.alias_refcount = {}
0.65 query.py(161):         self.alias_map = {}
0.65 query.py(165):         self.external_aliases = set()
0.65 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.65 query.py(167):         self.default_cols = True
0.65 query.py(168):         self.default_ordering = True
0.65 query.py(169):         self.standard_ordering = True
0.65 query.py(170):         self.used_aliases = set()
0.65 query.py(171):         self.filter_is_sticky = False
0.65 query.py(172):         self.subquery = False
0.65 query.py(180):         self.select = ()
0.65 query.py(181):         self.where = where()
0.65 query.py(182):         self.where_class = where
0.65 query.py(189):         self.group_by = None
0.65 query.py(190):         self.order_by = ()
0.65 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.65 query.py(192):         self.distinct = False
0.65 query.py(193):         self.distinct_fields = ()
0.65 query.py(194):         self.select_for_update = False
0.65 query.py(195):         self.select_for_update_nowait = False
0.65 query.py(196):         self.select_for_update_skip_locked = False
0.65 query.py(197):         self.select_for_update_of = ()
0.65 query.py(199):         self.select_related = False
0.65 query.py(201):         self.max_depth = 5
0.65 query.py(205):         self.values_select = ()
0.65 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.65 query.py(209):         self.annotation_select_mask = None
0.65 query.py(210):         self._annotation_select_cache = None
0.65 query.py(213):         self.combinator = None
0.65 query.py(214):         self.combinator_all = False
0.65 query.py(215):         self.combined_queries = ()
0.65 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.65 query.py(220):         self.extra_select_mask = None
0.65 query.py(221):         self._extra_select_cache = None
0.65 query.py(223):         self.extra_tables = ()
0.65 query.py(224):         self.extra_order_by = ()
0.65 query.py(229):         self.deferred_loading = (frozenset(), True)
0.65 query.py(231):         self._filtered_relations = {}
0.65 query.py(233):         self.explain_query = False
0.65 query.py(234):         self.explain_format = None
0.65 query.py(235):         self.explain_options = {}
0.65 query.py(154):         self.model = model
0.65 query.py(155):         self.alias_refcount = {}
0.65 query.py(161):         self.alias_map = {}
0.65 query.py(165):         self.external_aliases = set()
0.65 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.65 query.py(167):         self.default_cols = True
0.65 query.py(168):         self.default_ordering = True
0.65 query.py(169):         self.standard_ordering = True
0.65 query.py(170):         self.used_aliases = set()
0.65 query.py(171):         self.filter_is_sticky = False
0.65 query.py(172):         self.subquery = False
0.65 query.py(180):         self.select = ()
0.65 query.py(181):         self.where = where()
0.65 query.py(182):         self.where_class = where
0.65 query.py(189):         self.group_by = None
0.65 query.py(190):         self.order_by = ()
0.65 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.65 query.py(192):         self.distinct = False
0.65 query.py(193):         self.distinct_fields = ()
0.65 query.py(194):         self.select_for_update = False
0.65 query.py(195):         self.select_for_update_nowait = False
0.65 query.py(196):         self.select_for_update_skip_locked = False
0.65 query.py(197):         self.select_for_update_of = ()
0.65 query.py(199):         self.select_related = False
0.65 query.py(201):         self.max_depth = 5
0.65 query.py(205):         self.values_select = ()
0.65 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.65 query.py(209):         self.annotation_select_mask = None
0.65 query.py(210):         self._annotation_select_cache = None
0.65 query.py(213):         self.combinator = None
0.65 query.py(214):         self.combinator_all = False
0.65 query.py(215):         self.combined_queries = ()
0.65 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.65 query.py(220):         self.extra_select_mask = None
0.65 query.py(221):         self._extra_select_cache = None
0.65 query.py(223):         self.extra_tables = ()
0.65 query.py(224):         self.extra_order_by = ()
0.65 query.py(229):         self.deferred_loading = (frozenset(), True)
0.65 query.py(231):         self._filtered_relations = {}
0.65 query.py(233):         self.explain_query = False
0.65 query.py(234):         self.explain_format = None
0.65 query.py(235):         self.explain_options = {}
0.65 query.py(278):         if using is None and connection is None:
0.65 query.py(280):         if using:
0.65 query.py(281):             connection = connections[using]
0.65 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.66 query.py(290):         return self.model._meta
0.66 query.py(290):         return self.model._meta
0.66 query.py(290):         return self.model._meta
 OK
  Applying admin.0002_logentry_remove_auto_add...0.66 query.py(154):         self.model = model
0.66 query.py(155):         self.alias_refcount = {}
0.66 query.py(161):         self.alias_map = {}
0.66 query.py(165):         self.external_aliases = set()
0.66 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.66 query.py(167):         self.default_cols = True
0.66 query.py(168):         self.default_ordering = True
0.66 query.py(169):         self.standard_ordering = True
0.66 query.py(170):         self.used_aliases = set()
0.66 query.py(171):         self.filter_is_sticky = False
0.66 query.py(172):         self.subquery = False
0.66 query.py(180):         self.select = ()
0.66 query.py(181):         self.where = where()
0.66 query.py(182):         self.where_class = where
0.66 query.py(189):         self.group_by = None
0.66 query.py(190):         self.order_by = ()
0.66 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.66 query.py(192):         self.distinct = False
0.66 query.py(193):         self.distinct_fields = ()
0.66 query.py(194):         self.select_for_update = False
0.66 query.py(195):         self.select_for_update_nowait = False
0.66 query.py(196):         self.select_for_update_skip_locked = False
0.66 query.py(197):         self.select_for_update_of = ()
0.66 query.py(199):         self.select_related = False
0.66 query.py(201):         self.max_depth = 5
0.66 query.py(205):         self.values_select = ()
0.66 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.66 query.py(209):         self.annotation_select_mask = None
0.66 query.py(210):         self._annotation_select_cache = None
0.66 query.py(213):         self.combinator = None
0.66 query.py(214):         self.combinator_all = False
0.66 query.py(215):         self.combined_queries = ()
0.66 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.66 query.py(220):         self.extra_select_mask = None
0.66 query.py(221):         self._extra_select_cache = None
0.66 query.py(223):         self.extra_tables = ()
0.66 query.py(224):         self.extra_order_by = ()
0.66 query.py(229):         self.deferred_loading = (frozenset(), True)
0.66 query.py(231):         self._filtered_relations = {}
0.66 query.py(233):         self.explain_query = False
0.66 query.py(234):         self.explain_format = None
0.66 query.py(235):         self.explain_options = {}
0.66 query.py(343):         obj = self.clone()
0.66 query.py(297):         obj = Empty()
0.66 query.py(298):         obj.__class__ = self.__class__
0.66 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.66 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.66 query.py(303):         obj.alias_map = self.alias_map.copy()
0.66 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.66 query.py(305):         obj.table_map = self.table_map.copy()
0.66 query.py(306):         obj.where = self.where.clone()
0.66 query.py(307):         obj.annotations = self.annotations.copy()
0.66 query.py(308):         if self.annotation_select_mask is None:
0.66 query.py(309):             obj.annotation_select_mask = None
0.66 query.py(317):         obj._annotation_select_cache = None
0.66 query.py(318):         obj.extra = self.extra.copy()
0.66 query.py(319):         if self.extra_select_mask is None:
0.66 query.py(320):             obj.extra_select_mask = None
0.66 query.py(323):         if self._extra_select_cache is None:
0.66 query.py(324):             obj._extra_select_cache = None
0.66 query.py(327):         if 'subq_aliases' in self.__dict__:
0.66 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.66 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.66 query.py(332):         try:
0.66 query.py(333):             del obj.base_table
0.66 query.py(334):         except AttributeError:
0.66 query.py(335):             pass
0.66 query.py(336):         return obj
0.66 query.py(344):         if klass and obj.__class__ != klass:
0.66 query.py(346):         if not obj.filter_is_sticky:
0.66 query.py(347):             obj.used_aliases = set()
0.66 query.py(348):         obj.filter_is_sticky = False
0.66 query.py(349):         if hasattr(obj, '_setup_query'):
0.66 query.py(351):         return obj
0.66 query.py(154):         self.model = model
0.66 query.py(155):         self.alias_refcount = {}
0.66 query.py(161):         self.alias_map = {}
0.66 query.py(165):         self.external_aliases = set()
0.66 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.66 query.py(167):         self.default_cols = True
0.66 query.py(168):         self.default_ordering = True
0.66 query.py(169):         self.standard_ordering = True
0.66 query.py(170):         self.used_aliases = set()
0.66 query.py(171):         self.filter_is_sticky = False
0.66 query.py(172):         self.subquery = False
0.66 query.py(180):         self.select = ()
0.66 query.py(181):         self.where = where()
0.66 query.py(182):         self.where_class = where
0.66 query.py(189):         self.group_by = None
0.66 query.py(190):         self.order_by = ()
0.66 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.66 query.py(192):         self.distinct = False
0.66 query.py(193):         self.distinct_fields = ()
0.66 query.py(194):         self.select_for_update = False
0.66 query.py(195):         self.select_for_update_nowait = False
0.66 query.py(196):         self.select_for_update_skip_locked = False
0.66 query.py(197):         self.select_for_update_of = ()
0.66 query.py(199):         self.select_related = False
0.66 query.py(201):         self.max_depth = 5
0.66 query.py(205):         self.values_select = ()
0.66 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.66 query.py(209):         self.annotation_select_mask = None
0.66 query.py(210):         self._annotation_select_cache = None
0.66 query.py(213):         self.combinator = None
0.66 query.py(214):         self.combinator_all = False
0.66 query.py(215):         self.combined_queries = ()
0.66 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.66 query.py(220):         self.extra_select_mask = None
0.66 query.py(221):         self._extra_select_cache = None
0.66 query.py(223):         self.extra_tables = ()
0.66 query.py(224):         self.extra_order_by = ()
0.66 query.py(229):         self.deferred_loading = (frozenset(), True)
0.66 query.py(231):         self._filtered_relations = {}
0.66 query.py(233):         self.explain_query = False
0.66 query.py(234):         self.explain_format = None
0.66 query.py(235):         self.explain_options = {}
0.66 query.py(154):         self.model = model
0.66 query.py(155):         self.alias_refcount = {}
0.66 query.py(161):         self.alias_map = {}
0.66 query.py(165):         self.external_aliases = set()
0.66 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.66 query.py(167):         self.default_cols = True
0.66 query.py(168):         self.default_ordering = True
0.66 query.py(169):         self.standard_ordering = True
0.66 query.py(170):         self.used_aliases = set()
0.66 query.py(171):         self.filter_is_sticky = False
0.66 query.py(172):         self.subquery = False
0.66 query.py(180):         self.select = ()
0.66 query.py(181):         self.where = where()
0.66 query.py(182):         self.where_class = where
0.66 query.py(189):         self.group_by = None
0.66 query.py(190):         self.order_by = ()
0.66 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.66 query.py(192):         self.distinct = False
0.66 query.py(193):         self.distinct_fields = ()
0.66 query.py(194):         self.select_for_update = False
0.66 query.py(195):         self.select_for_update_nowait = False
0.66 query.py(196):         self.select_for_update_skip_locked = False
0.66 query.py(197):         self.select_for_update_of = ()
0.66 query.py(199):         self.select_related = False
0.66 query.py(201):         self.max_depth = 5
0.66 query.py(205):         self.values_select = ()
0.66 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.66 query.py(209):         self.annotation_select_mask = None
0.66 query.py(210):         self._annotation_select_cache = None
0.66 query.py(213):         self.combinator = None
0.66 query.py(214):         self.combinator_all = False
0.66 query.py(215):         self.combined_queries = ()
0.66 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.66 query.py(220):         self.extra_select_mask = None
0.66 query.py(221):         self._extra_select_cache = None
0.66 query.py(223):         self.extra_tables = ()
0.66 query.py(224):         self.extra_order_by = ()
0.66 query.py(229):         self.deferred_loading = (frozenset(), True)
0.66 query.py(231):         self._filtered_relations = {}
0.66 query.py(233):         self.explain_query = False
0.66 query.py(234):         self.explain_format = None
0.66 query.py(235):         self.explain_options = {}
0.66 query.py(278):         if using is None and connection is None:
0.66 query.py(280):         if using:
0.66 query.py(281):             connection = connections[using]
0.66 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.66 query.py(290):         return self.model._meta
0.66 query.py(290):         return self.model._meta
0.66 query.py(290):         return self.model._meta
 OK
  Applying admin.0003_logentry_add_action_flag_choices...0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(343):         obj = self.clone()
0.67 query.py(297):         obj = Empty()
0.67 query.py(298):         obj.__class__ = self.__class__
0.67 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.67 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.67 query.py(303):         obj.alias_map = self.alias_map.copy()
0.67 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.67 query.py(305):         obj.table_map = self.table_map.copy()
0.67 query.py(306):         obj.where = self.where.clone()
0.67 query.py(307):         obj.annotations = self.annotations.copy()
0.67 query.py(308):         if self.annotation_select_mask is None:
0.67 query.py(309):             obj.annotation_select_mask = None
0.67 query.py(317):         obj._annotation_select_cache = None
0.67 query.py(318):         obj.extra = self.extra.copy()
0.67 query.py(319):         if self.extra_select_mask is None:
0.67 query.py(320):             obj.extra_select_mask = None
0.67 query.py(323):         if self._extra_select_cache is None:
0.67 query.py(324):             obj._extra_select_cache = None
0.67 query.py(327):         if 'subq_aliases' in self.__dict__:
0.67 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.67 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.67 query.py(332):         try:
0.67 query.py(333):             del obj.base_table
0.67 query.py(334):         except AttributeError:
0.67 query.py(335):             pass
0.67 query.py(336):         return obj
0.67 query.py(344):         if klass and obj.__class__ != klass:
0.67 query.py(346):         if not obj.filter_is_sticky:
0.67 query.py(347):             obj.used_aliases = set()
0.67 query.py(348):         obj.filter_is_sticky = False
0.67 query.py(349):         if hasattr(obj, '_setup_query'):
0.67 query.py(351):         return obj
0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(278):         if using is None and connection is None:
0.67 query.py(280):         if using:
0.67 query.py(281):             connection = connections[using]
0.67 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.67 query.py(290):         return self.model._meta
0.67 query.py(290):         return self.model._meta
0.67 query.py(290):         return self.model._meta
 OK
  Applying sites.0001_initial...0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(343):         obj = self.clone()
0.68 query.py(297):         obj = Empty()
0.68 query.py(298):         obj.__class__ = self.__class__
0.68 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.68 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.68 query.py(303):         obj.alias_map = self.alias_map.copy()
0.68 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.68 query.py(305):         obj.table_map = self.table_map.copy()
0.68 query.py(306):         obj.where = self.where.clone()
0.68 query.py(307):         obj.annotations = self.annotations.copy()
0.68 query.py(308):         if self.annotation_select_mask is None:
0.68 query.py(309):             obj.annotation_select_mask = None
0.68 query.py(317):         obj._annotation_select_cache = None
0.68 query.py(318):         obj.extra = self.extra.copy()
0.68 query.py(319):         if self.extra_select_mask is None:
0.68 query.py(320):             obj.extra_select_mask = None
0.68 query.py(323):         if self._extra_select_cache is None:
0.68 query.py(324):             obj._extra_select_cache = None
0.68 query.py(327):         if 'subq_aliases' in self.__dict__:
0.68 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.68 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.68 query.py(332):         try:
0.68 query.py(333):             del obj.base_table
0.68 query.py(334):         except AttributeError:
0.68 query.py(335):             pass
0.68 query.py(336):         return obj
0.68 query.py(344):         if klass and obj.__class__ != klass:
0.68 query.py(346):         if not obj.filter_is_sticky:
0.68 query.py(347):             obj.used_aliases = set()
0.68 query.py(348):         obj.filter_is_sticky = False
0.68 query.py(349):         if hasattr(obj, '_setup_query'):
0.68 query.py(351):         return obj
0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(278):         if using is None and connection is None:
0.68 query.py(280):         if using:
0.68 query.py(281):             connection = connections[using]
0.68 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
 OK
  Applying sites.0002_alter_domain_unique...0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(343):         obj = self.clone()
0.68 query.py(297):         obj = Empty()
0.68 query.py(298):         obj.__class__ = self.__class__
0.68 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.68 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.68 query.py(303):         obj.alias_map = self.alias_map.copy()
0.68 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.68 query.py(305):         obj.table_map = self.table_map.copy()
0.68 query.py(306):         obj.where = self.where.clone()
0.68 query.py(307):         obj.annotations = self.annotations.copy()
0.68 query.py(308):         if self.annotation_select_mask is None:
0.68 query.py(309):             obj.annotation_select_mask = None
0.68 query.py(317):         obj._annotation_select_cache = None
0.68 query.py(318):         obj.extra = self.extra.copy()
0.68 query.py(319):         if self.extra_select_mask is None:
0.68 query.py(320):             obj.extra_select_mask = None
0.68 query.py(323):         if self._extra_select_cache is None:
0.68 query.py(324):             obj._extra_select_cache = None
0.68 query.py(327):         if 'subq_aliases' in self.__dict__:
0.68 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.68 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.68 query.py(332):         try:
0.68 query.py(333):             del obj.base_table
0.68 query.py(334):         except AttributeError:
0.68 query.py(335):             pass
0.68 query.py(336):         return obj
0.68 query.py(344):         if klass and obj.__class__ != klass:
0.68 query.py(346):         if not obj.filter_is_sticky:
0.68 query.py(347):             obj.used_aliases = set()
0.68 query.py(348):         obj.filter_is_sticky = False
0.68 query.py(349):         if hasattr(obj, '_setup_query'):
0.68 query.py(351):         return obj
0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(278):         if using is None and connection is None:
0.68 query.py(280):         if using:
0.68 query.py(281):             connection = connections[using]
0.68 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
 OK
0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(343):         obj = self.clone()
0.68 query.py(297):         obj = Empty()
0.68 query.py(298):         obj.__class__ = self.__class__
0.68 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.68 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.68 query.py(303):         obj.alias_map = self.alias_map.copy()
0.68 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.68 query.py(305):         obj.table_map = self.table_map.copy()
0.68 query.py(306):         obj.where = self.where.clone()
0.68 query.py(307):         obj.annotations = self.annotations.copy()
0.68 query.py(308):         if self.annotation_select_mask is None:
0.68 query.py(309):             obj.annotation_select_mask = None
0.68 query.py(317):         obj._annotation_select_cache = None
0.68 query.py(318):         obj.extra = self.extra.copy()
0.68 query.py(319):         if self.extra_select_mask is None:
0.68 query.py(320):             obj.extra_select_mask = None
0.68 query.py(323):         if self._extra_select_cache is None:
0.68 query.py(324):             obj._extra_select_cache = None
0.68 query.py(327):         if 'subq_aliases' in self.__dict__:
0.68 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.68 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.68 query.py(332):         try:
0.68 query.py(333):             del obj.base_table
0.68 query.py(334):         except AttributeError:
0.68 query.py(335):             pass
0.68 query.py(336):         return obj
0.68 query.py(344):         if klass and obj.__class__ != klass:
0.68 query.py(346):         if not obj.filter_is_sticky:
0.68 query.py(347):             obj.used_aliases = set()
0.68 query.py(348):         obj.filter_is_sticky = False
0.68 query.py(349):         if hasattr(obj, '_setup_query'):
0.68 query.py(351):         return obj
0.68 query.py(278):         if using is None and connection is None:
0.68 query.py(280):         if using:
0.68 query.py(281):             connection = connections[using]
0.68 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.68 query.py(912):         if self.alias_map:
0.68 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.68 query.py(290):         return self.model._meta
0.68 query.py(943):         if reuse_with_filtered_relation and reuse:
0.68 query.py(950):                 a for a, j in self.alias_map.items()
0.68 query.py(950):                 a for a, j in self.alias_map.items()
0.68 query.py(953):         if reuse_aliases:
0.68 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.68 query.py(735):         alias_list = self.table_map.get(table_name)
0.68 query.py(736):         if not create and alias_list:
0.68 query.py(742):         if alias_list:
0.68 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.68 query.py(748):             self.table_map[table_name] = [alias]
0.68 query.py(749):         self.alias_refcount[alias] = 1
0.68 query.py(750):         return alias, True
0.68 query.py(965):         if join.join_type:
0.68 query.py(971):         join.table_alias = alias
0.68 query.py(972):         self.alias_map[alias] = join
0.68 query.py(973):         return alias
0.68 query.py(917):         return alias
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(290):         return self.model._meta
0.68 query.py(655):         field_names, defer = self.deferred_loading
0.68 query.py(656):         if not field_names:
0.68 query.py(657):             return
0.68 query.py(912):         if self.alias_map:
0.68 query.py(913):             alias = self.base_table
0.68 query.py(250):         for alias in self.alias_map:
0.68 query.py(251):             return alias
0.68 query.py(914):             self.ref_alias(alias)
0.68 query.py(754):         self.alias_refcount[alias] += 1
0.68 query.py(917):         return alias
0.68 query.py(984):         if model in seen:
0.68 query.py(985):             return seen[model]
0.68 query.py(984):         if model in seen:
0.68 query.py(985):             return seen[model]
0.68 query.py(984):         if model in seen:
0.68 query.py(985):             return seen[model]
0.68 query.py(984):         if model in seen:
0.68 query.py(985):             return seen[model]
0.68 query.py(2070):         if self._annotation_select_cache is not None:
0.68 query.py(2072):         elif not self.annotations:
0.68 query.py(2073):             return {}
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(2085):         if self._extra_select_cache is not None:
0.68 query.py(2087):         if not self.extra:
0.68 query.py(2088):             return {}
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
0.68 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.68 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.68 query.py(820):             self.unref_alias(alias, unref_amount)
0.68 query.py(758):         self.alias_refcount[alias] -= amount
0.68 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(343):         obj = self.clone()
0.69 query.py(297):         obj = Empty()
0.69 query.py(298):         obj.__class__ = self.__class__
0.69 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.69 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.69 query.py(303):         obj.alias_map = self.alias_map.copy()
0.69 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.69 query.py(305):         obj.table_map = self.table_map.copy()
0.69 query.py(306):         obj.where = self.where.clone()
0.69 query.py(307):         obj.annotations = self.annotations.copy()
0.69 query.py(308):         if self.annotation_select_mask is None:
0.69 query.py(309):             obj.annotation_select_mask = None
0.69 query.py(317):         obj._annotation_select_cache = None
0.69 query.py(318):         obj.extra = self.extra.copy()
0.69 query.py(319):         if self.extra_select_mask is None:
0.69 query.py(320):             obj.extra_select_mask = None
0.69 query.py(323):         if self._extra_select_cache is None:
0.69 query.py(324):             obj._extra_select_cache = None
0.69 query.py(327):         if 'subq_aliases' in self.__dict__:
0.69 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.69 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.69 query.py(332):         try:
0.69 query.py(333):             del obj.base_table
0.69 query.py(334):         except AttributeError:
0.69 query.py(335):             pass
0.69 query.py(336):         return obj
0.69 query.py(344):         if klass and obj.__class__ != klass:
0.69 query.py(346):         if not obj.filter_is_sticky:
0.69 query.py(347):             obj.used_aliases = set()
0.69 query.py(348):         obj.filter_is_sticky = False
0.69 query.py(349):         if hasattr(obj, '_setup_query'):
0.69 query.py(351):         return obj
0.69 query.py(1757):         return not self.low_mark and self.high_mark is None
0.69 query.py(343):         obj = self.clone()
0.69 query.py(297):         obj = Empty()
0.69 query.py(298):         obj.__class__ = self.__class__
0.69 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.69 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.69 query.py(303):         obj.alias_map = self.alias_map.copy()
0.69 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.69 query.py(305):         obj.table_map = self.table_map.copy()
0.69 query.py(306):         obj.where = self.where.clone()
0.69 query.py(307):         obj.annotations = self.annotations.copy()
0.69 query.py(308):         if self.annotation_select_mask is None:
0.69 query.py(309):             obj.annotation_select_mask = None
0.69 query.py(317):         obj._annotation_select_cache = None
0.69 query.py(318):         obj.extra = self.extra.copy()
0.69 query.py(319):         if self.extra_select_mask is None:
0.69 query.py(320):             obj.extra_select_mask = None
0.69 query.py(323):         if self._extra_select_cache is None:
0.69 query.py(324):             obj._extra_select_cache = None
0.69 query.py(327):         if 'subq_aliases' in self.__dict__:
0.69 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.69 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.69 query.py(332):         try:
0.69 query.py(333):             del obj.base_table
0.69 query.py(334):         except AttributeError:
0.69 query.py(335):             pass
0.69 query.py(336):         return obj
0.69 query.py(344):         if klass and obj.__class__ != klass:
0.69 query.py(346):         if not obj.filter_is_sticky:
0.69 query.py(347):             obj.used_aliases = set()
0.69 query.py(348):         obj.filter_is_sticky = False
0.69 query.py(349):         if hasattr(obj, '_setup_query'):
0.69 query.py(351):         return obj
0.69 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.69 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.69 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.69 query.py(1331):         connector = q_object.connector
0.69 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.69 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.69 query.py(1334):         target_clause = self.where_class(connector=connector,
0.69 query.py(1335):                                          negated=q_object.negated)
0.69 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.69 query.py(2227):         self.connector = connector
0.69 query.py(2228):         self.negated = negated
0.69 query.py(2229):         if self.negated:
0.69 query.py(2235):             self.effective_connector = self.connector
0.69 query.py(2236):         self.num_children = num_children
0.69 query.py(2239):         self.votes = Counter()
0.69 query.py(1337):         for child in q_object.children:
0.69 query.py(1338):             if isinstance(child, Node):
0.69 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.69 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.69 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.69 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.69 query.py(1214):         if isinstance(filter_expr, dict):
0.69 query.py(1216):         arg, value = filter_expr
0.69 query.py(1217):         if not arg:
0.69 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.69 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.69 query.py(1074):         if self.annotations:
0.69 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.69 query.py(290):         return self.model._meta
0.69 query.py(1405):         path, names_with_path = [], []
0.69 query.py(1406):         for pos, name in enumerate(names):
0.69 query.py(1407):             cur_names_with_path = (name, [])
0.69 query.py(1408):             if name == 'pk':
0.69 query.py(1411):             field = None
0.69 query.py(1412):             filtered_relation = None
0.69 query.py(1413):             try:
0.69 query.py(1414):                 field = opts.get_field(name)
0.69 query.py(1421):             if field is not None:
0.69 query.py(1425):                 if field.is_relation and not field.related_model:
0.69 query.py(1432):                 try:
0.69 query.py(1433):                     model = field.model._meta.concrete_model
0.69 query.py(1454):             if model is not opts.model:
0.69 query.py(1460):             if hasattr(field, 'get_path_info'):
0.69 query.py(1477):                 final_field = field
0.69 query.py(1478):                 targets = (field,)
0.69 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.69 query.py(1483):                 break
0.69 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.69 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.69 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.69 query.py(1085):         return lookup_parts, field_parts, False
0.69 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.69 query.py(1227):         if not allow_joins and len(parts) > 1:
0.69 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.69 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.69 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.69 query.py(1055):         elif isinstance(value, (list, tuple)):
0.69 query.py(1067):         return value
0.69 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.69 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.69 query.py(1234):         clause = self.where_class()
0.69 query.py(1235):         if reffed_expression:
0.69 query.py(1240):         opts = self.get_meta()
0.69 query.py(290):         return self.model._meta
0.69 query.py(1241):         alias = self.get_initial_alias()
0.69 query.py(912):         if self.alias_map:
0.69 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.69 query.py(290):         return self.model._meta
0.69 query.py(943):         if reuse_with_filtered_relation and reuse:
0.69 query.py(950):                 a for a, j in self.alias_map.items()
0.69 query.py(950):                 a for a, j in self.alias_map.items()
0.69 query.py(953):         if reuse_aliases:
0.69 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.69 query.py(735):         alias_list = self.table_map.get(table_name)
0.69 query.py(736):         if not create and alias_list:
0.69 query.py(742):         if alias_list:
0.69 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.69 query.py(748):             self.table_map[table_name] = [alias]
0.69 query.py(749):         self.alias_refcount[alias] = 1
0.69 query.py(750):         return alias, True
0.69 query.py(965):         if join.join_type:
0.69 query.py(971):         join.table_alias = alias
0.69 query.py(972):         self.alias_map[alias] = join
0.69 query.py(973):         return alias
0.69 query.py(917):         return alias
0.69 query.py(1242):         allow_many = not branch_negated or not split_subq
0.69 query.py(1244):         try:
0.69 query.py(1245):             join_info = self.setup_joins(
0.69 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.69 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.69 query.py(1518):         joins = [alias]
0.69 query.py(1524):         def final_transformer(field, alias):
0.69 query.py(1529):         last_field_exception = None
0.69 query.py(1530):         for pivot in range(len(names), 0, -1):
0.69 query.py(1531):             try:
0.69 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.69 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.69 query.py(1405):         path, names_with_path = [], []
0.69 query.py(1406):         for pos, name in enumerate(names):
0.69 query.py(1407):             cur_names_with_path = (name, [])
0.69 query.py(1408):             if name == 'pk':
0.69 query.py(1411):             field = None
0.69 query.py(1412):             filtered_relation = None
0.69 query.py(1413):             try:
0.69 query.py(1414):                 field = opts.get_field(name)
0.69 query.py(1421):             if field is not None:
0.69 query.py(1425):                 if field.is_relation and not field.related_model:
0.69 query.py(1432):                 try:
0.69 query.py(1433):                     model = field.model._meta.concrete_model
0.69 query.py(1454):             if model is not opts.model:
0.69 query.py(1460):             if hasattr(field, 'get_path_info'):
0.69 query.py(1477):                 final_field = field
0.69 query.py(1478):                 targets = (field,)
0.69 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.69 query.py(1483):                 break
0.69 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.69 query.py(1545):                 transforms = names[pivot:]
0.69 query.py(1546):                 break
0.69 query.py(1547):         for name in transforms:
0.69 query.py(1562):         for join in path:
0.69 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.69 query.py(1251):             if isinstance(value, Iterator):
0.69 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.69 query.py(1100):         if field.is_relation:
0.69 query.py(1257):             self._lookup_joins = join_info.joins
0.69 query.py(1263):         used_joins.update(join_info.joins)
0.69 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.69 query.py(1601):         joins = joins[:]
0.69 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.69 query.py(1614):         return targets, joins[-1], joins
0.69 query.py(1265):         if can_reuse is not None:
0.69 query.py(1266):             can_reuse.update(join_list)
0.69 query.py(1268):         if join_info.final_field.is_relation:
0.69 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.69 query.py(72):     if simple_col:
0.69 query.py(74):     return target.get_col(alias, field)
0.69 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.69 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.69 query.py(1129):         for name in transforms:
0.69 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.69 query.py(1134):         if not lookup_class:
0.69 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.69 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.69 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.69 query.py(1161):         return lookup
0.69 query.py(1281):         lookup_type = condition.lookup_name
0.69 query.py(1282):         clause.add(condition, AND)
0.69 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.69 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.69 query.py(1302):         return clause, used_joins if not require_outer else ()
0.69 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.69 query.py(2246):         self.votes.update(votes)
0.70 query.py(1350):             if child_clause:
0.70 query.py(1351):                 target_clause.add(child_clause, connector)
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.70 query.py(2255):         to_promote = set()
0.70 query.py(2256):         to_demote = set()
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.70 query.py(2282):             if self.effective_connector == 'AND' or (
0.70 query.py(2284):                 to_demote.add(table)
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2300):         query.promote_joins(to_promote)
0.70 query.py(771):         aliases = list(aliases)
0.70 query.py(772):         while aliases:
0.70 query.py(2301):         query.demote_joins(to_demote)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(806):             alias = aliases.pop(0)
0.70 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.70 query.py(805):         while aliases:
0.70 query.py(2302):         return to_demote
0.70 query.py(1353):         return target_clause, needed_inner
0.70 query.py(1320):         if clause:
0.70 query.py(1321):             self.where.add(clause, AND)
0.70 query.py(1322):         self.demote_joins(existing_inner)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(655):         field_names, defer = self.deferred_loading
0.70 query.py(656):         if not field_names:
0.70 query.py(657):             return
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(290):         return self.model._meta
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.70 query.py(820):             self.unref_alias(alias, unref_amount)
0.70 query.py(758):         self.alias_refcount[alias] -= amount
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 query.py(290):         return self.model._meta
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1757):         return not self.low_mark and self.high_mark is None
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.70 query.py(1331):         connector = q_object.connector
0.70 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.70 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.70 query.py(1334):         target_clause = self.where_class(connector=connector,
0.70 query.py(1335):                                          negated=q_object.negated)
0.70 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.70 query.py(2227):         self.connector = connector
0.70 query.py(2228):         self.negated = negated
0.70 query.py(2229):         if self.negated:
0.70 query.py(2235):             self.effective_connector = self.connector
0.70 query.py(2236):         self.num_children = num_children
0.70 query.py(2239):         self.votes = Counter()
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1338):             if isinstance(child, Node):
0.70 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.70 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.70 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.70 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.70 query.py(1214):         if isinstance(filter_expr, dict):
0.70 query.py(1216):         arg, value = filter_expr
0.70 query.py(1217):         if not arg:
0.70 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.70 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.70 query.py(1074):         if self.annotations:
0.70 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.70 query.py(290):         return self.model._meta
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.70 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.70 query.py(1085):         return lookup_parts, field_parts, False
0.70 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.70 query.py(1227):         if not allow_joins and len(parts) > 1:
0.70 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.70 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.70 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.70 query.py(1055):         elif isinstance(value, (list, tuple)):
0.70 query.py(1067):         return value
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1234):         clause = self.where_class()
0.70 query.py(1235):         if reffed_expression:
0.70 query.py(1240):         opts = self.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 query.py(1241):         alias = self.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.70 query.py(290):         return self.model._meta
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.70 query.py(735):         alias_list = self.table_map.get(table_name)
0.70 query.py(736):         if not create and alias_list:
0.70 query.py(742):         if alias_list:
0.70 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.70 query.py(748):             self.table_map[table_name] = [alias]
0.70 query.py(749):         self.alias_refcount[alias] = 1
0.70 query.py(750):         return alias, True
0.70 query.py(965):         if join.join_type:
0.70 query.py(971):         join.table_alias = alias
0.70 query.py(972):         self.alias_map[alias] = join
0.70 query.py(973):         return alias
0.70 query.py(917):         return alias
0.70 query.py(1242):         allow_many = not branch_negated or not split_subq
0.70 query.py(1244):         try:
0.70 query.py(1245):             join_info = self.setup_joins(
0.70 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.70 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1251):             if isinstance(value, Iterator):
0.70 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.70 query.py(1100):         if field.is_relation:
0.70 query.py(1257):             self._lookup_joins = join_info.joins
0.70 query.py(1263):         used_joins.update(join_info.joins)
0.70 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1265):         if can_reuse is not None:
0.70 query.py(1266):             can_reuse.update(join_list)
0.70 query.py(1268):         if join_info.final_field.is_relation:
0.70 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.70 query.py(72):     if simple_col:
0.70 query.py(74):     return target.get_col(alias, field)
0.70 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.70 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.70 query.py(1129):         for name in transforms:
0.70 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.70 query.py(1134):         if not lookup_class:
0.70 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.70 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.70 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(1161):         return lookup
0.70 query.py(1281):         lookup_type = condition.lookup_name
0.70 query.py(1282):         clause.add(condition, AND)
0.70 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.70 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.70 query.py(1302):         return clause, used_joins if not require_outer else ()
0.70 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.70 query.py(2246):         self.votes.update(votes)
0.70 query.py(1350):             if child_clause:
0.70 query.py(1351):                 target_clause.add(child_clause, connector)
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.70 query.py(2255):         to_promote = set()
0.70 query.py(2256):         to_demote = set()
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.70 query.py(2282):             if self.effective_connector == 'AND' or (
0.70 query.py(2284):                 to_demote.add(table)
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2300):         query.promote_joins(to_promote)
0.70 query.py(771):         aliases = list(aliases)
0.70 query.py(772):         while aliases:
0.70 query.py(2301):         query.demote_joins(to_demote)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(806):             alias = aliases.pop(0)
0.70 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.70 query.py(805):         while aliases:
0.70 query.py(2302):         return to_demote
0.70 query.py(1353):         return target_clause, needed_inner
0.70 query.py(1320):         if clause:
0.70 query.py(1321):             self.where.add(clause, AND)
0.70 query.py(1322):         self.demote_joins(existing_inner)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(655):         field_names, defer = self.deferred_loading
0.70 query.py(656):         if not field_names:
0.70 query.py(657):             return
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(290):         return self.model._meta
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.70 query.py(820):             self.unref_alias(alias, unref_amount)
0.70 query.py(758):         self.alias_refcount[alias] -= amount
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(1757):         return not self.low_mark and self.high_mark is None
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.70 query.py(1331):         connector = q_object.connector
0.70 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.70 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.70 query.py(1334):         target_clause = self.where_class(connector=connector,
0.70 query.py(1335):                                          negated=q_object.negated)
0.70 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.70 query.py(2227):         self.connector = connector
0.70 query.py(2228):         self.negated = negated
0.70 query.py(2229):         if self.negated:
0.70 query.py(2235):             self.effective_connector = self.connector
0.70 query.py(2236):         self.num_children = num_children
0.70 query.py(2239):         self.votes = Counter()
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1338):             if isinstance(child, Node):
0.70 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.70 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.70 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.70 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.70 query.py(1214):         if isinstance(filter_expr, dict):
0.70 query.py(1216):         arg, value = filter_expr
0.70 query.py(1217):         if not arg:
0.70 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.70 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.70 query.py(1074):         if self.annotations:
0.70 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.70 query.py(290):         return self.model._meta
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.70 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.70 query.py(1085):         return lookup_parts, field_parts, False
0.70 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.70 query.py(1227):         if not allow_joins and len(parts) > 1:
0.70 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.70 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.70 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.70 query.py(1055):         elif isinstance(value, (list, tuple)):
0.70 query.py(1067):         return value
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1234):         clause = self.where_class()
0.70 query.py(1235):         if reffed_expression:
0.70 query.py(1240):         opts = self.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 query.py(1241):         alias = self.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.70 query.py(290):         return self.model._meta
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.70 query.py(735):         alias_list = self.table_map.get(table_name)
0.70 query.py(736):         if not create and alias_list:
0.70 query.py(742):         if alias_list:
0.70 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.70 query.py(748):             self.table_map[table_name] = [alias]
0.70 query.py(749):         self.alias_refcount[alias] = 1
0.70 query.py(750):         return alias, True
0.70 query.py(965):         if join.join_type:
0.70 query.py(971):         join.table_alias = alias
0.70 query.py(972):         self.alias_map[alias] = join
0.70 query.py(973):         return alias
0.70 query.py(917):         return alias
0.70 query.py(1242):         allow_many = not branch_negated or not split_subq
0.70 query.py(1244):         try:
0.70 query.py(1245):             join_info = self.setup_joins(
0.70 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.70 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1251):             if isinstance(value, Iterator):
0.70 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.70 query.py(1100):         if field.is_relation:
0.70 query.py(1257):             self._lookup_joins = join_info.joins
0.70 query.py(1263):         used_joins.update(join_info.joins)
0.70 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1265):         if can_reuse is not None:
0.70 query.py(1266):             can_reuse.update(join_list)
0.70 query.py(1268):         if join_info.final_field.is_relation:
0.70 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.70 query.py(72):     if simple_col:
0.70 query.py(74):     return target.get_col(alias, field)
0.70 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.70 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.70 query.py(1129):         for name in transforms:
0.70 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.70 query.py(1134):         if not lookup_class:
0.70 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.70 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.70 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(1161):         return lookup
0.70 query.py(1281):         lookup_type = condition.lookup_name
0.70 query.py(1282):         clause.add(condition, AND)
0.70 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.70 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.70 query.py(1302):         return clause, used_joins if not require_outer else ()
0.70 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.70 query.py(2246):         self.votes.update(votes)
0.70 query.py(1350):             if child_clause:
0.70 query.py(1351):                 target_clause.add(child_clause, connector)
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1338):             if isinstance(child, Node):
0.70 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.70 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.70 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.70 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.70 query.py(1214):         if isinstance(filter_expr, dict):
0.70 query.py(1216):         arg, value = filter_expr
0.70 query.py(1217):         if not arg:
0.70 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.70 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.70 query.py(1074):         if self.annotations:
0.70 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.70 query.py(290):         return self.model._meta
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.70 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.70 query.py(1085):         return lookup_parts, field_parts, False
0.70 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.70 query.py(1227):         if not allow_joins and len(parts) > 1:
0.70 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.70 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.70 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.70 query.py(1055):         elif isinstance(value, (list, tuple)):
0.70 query.py(1067):         return value
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1234):         clause = self.where_class()
0.70 query.py(1235):         if reffed_expression:
0.70 query.py(1240):         opts = self.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 query.py(1241):         alias = self.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(1242):         allow_many = not branch_negated or not split_subq
0.70 query.py(1244):         try:
0.70 query.py(1245):             join_info = self.setup_joins(
0.70 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.70 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1251):             if isinstance(value, Iterator):
0.70 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.70 query.py(1100):         if field.is_relation:
0.70 query.py(1257):             self._lookup_joins = join_info.joins
0.70 query.py(1263):         used_joins.update(join_info.joins)
0.70 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1265):         if can_reuse is not None:
0.70 query.py(1266):             can_reuse.update(join_list)
0.70 query.py(1268):         if join_info.final_field.is_relation:
0.70 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.70 query.py(72):     if simple_col:
0.70 query.py(74):     return target.get_col(alias, field)
0.70 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.70 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.70 query.py(1129):         for name in transforms:
0.70 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.70 query.py(1134):         if not lookup_class:
0.70 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.70 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.70 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(1161):         return lookup
0.70 query.py(1281):         lookup_type = condition.lookup_name
0.70 query.py(1282):         clause.add(condition, AND)
0.70 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.70 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.70 query.py(1302):         return clause, used_joins if not require_outer else ()
0.70 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.70 query.py(2246):         self.votes.update(votes)
0.70 query.py(1350):             if child_clause:
0.70 query.py(1351):                 target_clause.add(child_clause, connector)
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.70 query.py(2255):         to_promote = set()
0.70 query.py(2256):         to_demote = set()
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.70 query.py(2282):             if self.effective_connector == 'AND' or (
0.70 query.py(2284):                 to_demote.add(table)
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2300):         query.promote_joins(to_promote)
0.70 query.py(771):         aliases = list(aliases)
0.70 query.py(772):         while aliases:
0.70 query.py(2301):         query.demote_joins(to_demote)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(806):             alias = aliases.pop(0)
0.70 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.70 query.py(805):         while aliases:
0.70 query.py(2302):         return to_demote
0.70 query.py(1353):         return target_clause, needed_inner
0.70 query.py(1320):         if clause:
0.70 query.py(1321):             self.where.add(clause, AND)
0.70 query.py(1322):         self.demote_joins(existing_inner)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(1757):         return not self.low_mark and self.high_mark is None
0.70 query.py(1757):         return not self.low_mark and self.high_mark is None
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1855):         self.order_by = ()
0.70 query.py(1856):         self.extra_order_by = ()
0.70 query.py(1857):         if force_empty:
0.70 query.py(1834):         errors = []
0.70 query.py(1835):         for item in ordering:
0.70 query.py(1843):         if errors:
0.70 query.py(1845):         if ordering:
0.70 query.py(1848):             self.default_ordering = False
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(655):         field_names, defer = self.deferred_loading
0.70 query.py(656):         if not field_names:
0.70 query.py(657):             return
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.70 query.py(820):             self.unref_alias(alias, unref_amount)
0.70 query.py(758):         self.alias_refcount[alias] -= amount
0.70 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1757):         return not self.low_mark and self.high_mark is None
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.70 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.70 query.py(1331):         connector = q_object.connector
0.70 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.70 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.70 query.py(1334):         target_clause = self.where_class(connector=connector,
0.70 query.py(1335):                                          negated=q_object.negated)
0.70 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.70 query.py(2227):         self.connector = connector
0.70 query.py(2228):         self.negated = negated
0.70 query.py(2229):         if self.negated:
0.70 query.py(2235):             self.effective_connector = self.connector
0.70 query.py(2236):         self.num_children = num_children
0.70 query.py(2239):         self.votes = Counter()
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1338):             if isinstance(child, Node):
0.70 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.70 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.70 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.70 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.70 query.py(1214):         if isinstance(filter_expr, dict):
0.70 query.py(1216):         arg, value = filter_expr
0.70 query.py(1217):         if not arg:
0.70 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.70 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.70 query.py(1074):         if self.annotations:
0.70 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.70 query.py(290):         return self.model._meta
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.70 query.py(1462):                 if not allow_many:
0.70 query.py(1468):                 last = pathinfos[-1]
0.70 query.py(1469):                 path.extend(pathinfos)
0.70 query.py(1470):                 final_field = last.join_field
0.70 query.py(1471):                 opts = last.to_opts
0.70 query.py(1472):                 targets = last.target_fields
0.70 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.70 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1415):             except FieldDoesNotExist:
0.70 query.py(1416):                 if name in self.annotation_select:
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.70 query.py(1421):             if field is not None:
0.70 query.py(1441):                 pos -= 1
0.70 query.py(1442):                 if pos == -1 or fail_on_missing:
0.70 query.py(1450):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.70 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.70 query.py(1085):         return lookup_parts, field_parts, False
0.70 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.70 query.py(1227):         if not allow_joins and len(parts) > 1:
0.70 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.70 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.70 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.70 query.py(1055):         elif isinstance(value, (list, tuple)):
0.70 query.py(1067):         return value
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.70 query.py(1234):         clause = self.where_class()
0.70 query.py(1235):         if reffed_expression:
0.70 query.py(1240):         opts = self.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 query.py(1241):         alias = self.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.70 query.py(290):         return self.model._meta
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.70 query.py(735):         alias_list = self.table_map.get(table_name)
0.70 query.py(736):         if not create and alias_list:
0.70 query.py(742):         if alias_list:
0.70 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.70 query.py(748):             self.table_map[table_name] = [alias]
0.70 query.py(749):         self.alias_refcount[alias] = 1
0.70 query.py(750):         return alias, True
0.70 query.py(965):         if join.join_type:
0.70 query.py(971):         join.table_alias = alias
0.70 query.py(972):         self.alias_map[alias] = join
0.70 query.py(973):         return alias
0.70 query.py(917):         return alias
0.70 query.py(1242):         allow_many = not branch_negated or not split_subq
0.70 query.py(1244):         try:
0.70 query.py(1245):             join_info = self.setup_joins(
0.70 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.70 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.70 query.py(1462):                 if not allow_many:
0.70 query.py(1468):                 last = pathinfos[-1]
0.70 query.py(1469):                 path.extend(pathinfos)
0.70 query.py(1470):                 final_field = last.join_field
0.70 query.py(1471):                 opts = last.to_opts
0.70 query.py(1472):                 targets = last.target_fields
0.70 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.70 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1563):             if join.filtered_relation:
0.70 query.py(1567):                 filtered_relation = None
0.70 query.py(1568):                 table_alias = None
0.70 query.py(1569):             opts = join.to_opts
0.70 query.py(1570):             if join.direct:
0.70 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.70 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(2184):         ) or field.null
0.70 query.py(1574):             connection = Join(
0.70 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.70 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.70 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.70 query.py(1579):             alias = self.join(
0.70 query.py(1580):                 connection, reuse=reuse,
0.70 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.70 query.py(735):         alias_list = self.table_map.get(table_name)
0.70 query.py(736):         if not create and alias_list:
0.70 query.py(742):         if alias_list:
0.70 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.70 query.py(748):             self.table_map[table_name] = [alias]
0.70 query.py(749):         self.alias_refcount[alias] = 1
0.70 query.py(750):         return alias, True
0.70 query.py(965):         if join.join_type:
0.70 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.70 query.py(969):                 join_type = INNER
0.70 query.py(970):             join.join_type = join_type
0.70 query.py(971):         join.table_alias = alias
0.70 query.py(972):         self.alias_map[alias] = join
0.70 query.py(973):         return alias
0.70 query.py(1583):             joins.append(alias)
0.70 query.py(1584):             if filtered_relation:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1251):             if isinstance(value, Iterator):
0.70 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.70 query.py(1100):         if field.is_relation:
0.70 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.70 query.py(1112):             elif hasattr(value, '_meta'):
0.70 query.py(1114):             elif hasattr(value, '__iter__'):
0.70 query.py(1115):                 for v in value:
0.70 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.70 query.py(1092):         if hasattr(value, '_meta'):
0.70 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.70 query.py(1115):                 for v in value:
0.70 query.py(1257):             self._lookup_joins = join_info.joins
0.70 query.py(1263):         used_joins.update(join_info.joins)
0.70 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1603):             if len(joins) == 1 or not info.direct:
0.70 query.py(1605):             if info.filtered_relation:
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1609):             if not cur_targets.issubset(join_targets):
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1613):             self.unref_alias(joins.pop())
0.70 query.py(758):         self.alias_refcount[alias] -= amount
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1265):         if can_reuse is not None:
0.70 query.py(1266):             can_reuse.update(join_list)
0.70 query.py(1268):         if join_info.final_field.is_relation:
0.70 query.py(1270):             num_lookups = len(lookups)
0.70 query.py(1271):             if num_lookups > 1:
0.70 query.py(1273):             if len(targets) == 1:
0.70 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.70 query.py(72):     if simple_col:
0.70 query.py(74):     return target.get_col(alias, field)
0.70 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.70 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.70 query.py(1129):         for name in transforms:
0.70 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.70 query.py(1134):         if not lookup_class:
0.70 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.70 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.70 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(1161):         return lookup
0.70 query.py(1281):         lookup_type = condition.lookup_name
0.70 query.py(1282):         clause.add(condition, AND)
0.70 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.70 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.70 query.py(1302):         return clause, used_joins if not require_outer else ()
0.70 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.70 query.py(2246):         self.votes.update(votes)
0.70 query.py(1350):             if child_clause:
0.70 query.py(1351):                 target_clause.add(child_clause, connector)
0.70 query.py(1337):         for child in q_object.children:
0.70 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.70 query.py(2255):         to_promote = set()
0.70 query.py(2256):         to_demote = set()
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.70 query.py(2282):             if self.effective_connector == 'AND' or (
0.70 query.py(2284):                 to_demote.add(table)
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.70 query.py(2282):             if self.effective_connector == 'AND' or (
0.70 query.py(2284):                 to_demote.add(table)
0.70 query.py(2259):         for table, votes in self.votes.items():
0.70 query.py(2300):         query.promote_joins(to_promote)
0.70 query.py(771):         aliases = list(aliases)
0.70 query.py(772):         while aliases:
0.70 query.py(2301):         query.demote_joins(to_demote)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(806):             alias = aliases.pop(0)
0.70 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.70 query.py(805):         while aliases:
0.70 query.py(806):             alias = aliases.pop(0)
0.70 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.70 query.py(805):         while aliases:
0.70 query.py(2302):         return to_demote
0.70 query.py(1353):         return target_clause, needed_inner
0.70 query.py(1320):         if clause:
0.70 query.py(1321):             self.where.add(clause, AND)
0.70 query.py(1322):         self.demote_joins(existing_inner)
0.70 query.py(804):         aliases = list(aliases)
0.70 query.py(805):         while aliases:
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(2030):         self.select_related = False
0.70 query.py(2031):         self.clear_deferred_loading()
0.70 query.py(1937):         self.deferred_loading = (frozenset(), True)
0.70 query.py(2032):         self.clear_select_fields()
0.70 query.py(1773):         self.select = ()
0.70 query.py(1774):         self.values_select = ()
0.70 query.py(2034):         if self.group_by is True:
0.70 query.py(2039):         if fields:
0.70 query.py(2040):             field_names = []
0.70 query.py(2041):             extra_names = []
0.70 query.py(2042):             annotation_names = []
0.70 query.py(2043):             if not self.extra and not self.annotations:
0.70 query.py(2046):                 field_names = list(fields)
0.70 query.py(2056):             self.set_extra_mask(extra_names)
0.70 query.py(2023):         if names is None:
0.70 query.py(2026):             self.extra_select_mask = set(names)
0.70 query.py(2027):         self._extra_select_cache = None
0.70 query.py(2057):             self.set_annotation_mask(annotation_names)
0.70 query.py(2008):         if names is None:
0.70 query.py(2011):             self.annotation_select_mask = set(names)
0.70 query.py(2012):         self._annotation_select_cache = None
0.70 query.py(2061):         self.values_select = tuple(field_names)
0.70 query.py(2062):         self.add_fields(field_names, True)
0.70 query.py(1792):         alias = self.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(1793):         opts = self.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 query.py(1795):         try:
0.70 query.py(1796):             cols = []
0.70 query.py(1797):             for name in field_names:
0.70 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.70 query.py(1462):                 if not allow_many:
0.70 query.py(1468):                 last = pathinfos[-1]
0.70 query.py(1469):                 path.extend(pathinfos)
0.70 query.py(1470):                 final_field = last.join_field
0.70 query.py(1471):                 opts = last.to_opts
0.70 query.py(1472):                 targets = last.target_fields
0.70 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.70 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1563):             if join.filtered_relation:
0.70 query.py(1567):                 filtered_relation = None
0.70 query.py(1568):                 table_alias = None
0.70 query.py(1569):             opts = join.to_opts
0.70 query.py(1570):             if join.direct:
0.70 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.70 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(2184):         ) or field.null
0.70 query.py(1574):             connection = Join(
0.70 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.70 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.70 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.70 query.py(1579):             alias = self.join(
0.70 query.py(1580):                 connection, reuse=reuse,
0.70 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(954):             if join.table_alias in reuse_aliases:
0.70 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.70 query.py(960):             self.ref_alias(reuse_alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(961):             return reuse_alias
0.70 query.py(1583):             joins.append(alias)
0.70 query.py(1584):             if filtered_relation:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.70 query.py(1802):                     join_info.targets,
0.70 query.py(1803):                     join_info.joins,
0.70 query.py(1804):                     join_info.path,
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1603):             if len(joins) == 1 or not info.direct:
0.70 query.py(1605):             if info.filtered_relation:
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1609):             if not cur_targets.issubset(join_targets):
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.70 query.py(1613):             self.unref_alias(joins.pop())
0.70 query.py(758):         self.alias_refcount[alias] -= amount
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1806):                 for target in targets:
0.70 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.70 query.py(1525):             return field.get_col(alias)
0.70 query.py(1806):                 for target in targets:
0.70 query.py(1797):             for name in field_names:
0.70 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.70 query.py(1802):                     join_info.targets,
0.70 query.py(1803):                     join_info.joins,
0.70 query.py(1804):                     join_info.path,
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1806):                 for target in targets:
0.70 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.70 query.py(1525):             return field.get_col(alias)
0.70 query.py(1806):                 for target in targets:
0.70 query.py(1797):             for name in field_names:
0.70 query.py(1808):             if cols:
0.70 query.py(1809):                 self.set_select(cols)
0.70 query.py(1777):         self.default_cols = False
0.70 query.py(1778):         self.select = tuple(cols)
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(2085):         if self._extra_select_cache is not None:
0.70 query.py(2087):         if not self.extra:
0.70 query.py(2088):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(290):         return self.model._meta
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.70 query.py(1462):                 if not allow_many:
0.70 query.py(1468):                 last = pathinfos[-1]
0.70 query.py(1469):                 path.extend(pathinfos)
0.70 query.py(1470):                 final_field = last.join_field
0.70 query.py(1471):                 opts = last.to_opts
0.70 query.py(1472):                 targets = last.target_fields
0.70 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.70 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1563):             if join.filtered_relation:
0.70 query.py(1567):                 filtered_relation = None
0.70 query.py(1568):                 table_alias = None
0.70 query.py(1569):             opts = join.to_opts
0.70 query.py(1570):             if join.direct:
0.70 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.70 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(2184):         ) or field.null
0.70 query.py(1574):             connection = Join(
0.70 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.70 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.70 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.70 query.py(1579):             alias = self.join(
0.70 query.py(1580):                 connection, reuse=reuse,
0.70 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(954):             if join.table_alias in reuse_aliases:
0.70 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.70 query.py(960):             self.ref_alias(reuse_alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(961):             return reuse_alias
0.70 query.py(1583):             joins.append(alias)
0.70 query.py(1584):             if filtered_relation:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1603):             if len(joins) == 1 or not info.direct:
0.70 query.py(1605):             if info.filtered_relation:
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1609):             if not cur_targets.issubset(join_targets):
0.70 query.py(1610):                 break
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1525):             return field.get_col(alias)
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.70 query.py(1462):                 if not allow_many:
0.70 query.py(1468):                 last = pathinfos[-1]
0.70 query.py(1469):                 path.extend(pathinfos)
0.70 query.py(1470):                 final_field = last.join_field
0.70 query.py(1471):                 opts = last.to_opts
0.70 query.py(1472):                 targets = last.target_fields
0.70 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.70 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1563):             if join.filtered_relation:
0.70 query.py(1567):                 filtered_relation = None
0.70 query.py(1568):                 table_alias = None
0.70 query.py(1569):             opts = join.to_opts
0.70 query.py(1570):             if join.direct:
0.70 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.70 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.70 query.py(2184):         ) or field.null
0.70 query.py(1574):             connection = Join(
0.70 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.70 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.70 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.70 query.py(1579):             alias = self.join(
0.70 query.py(1580):                 connection, reuse=reuse,
0.70 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(954):             if join.table_alias in reuse_aliases:
0.70 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.70 query.py(960):             self.ref_alias(reuse_alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(961):             return reuse_alias
0.70 query.py(1583):             joins.append(alias)
0.70 query.py(1584):             if filtered_relation:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1603):             if len(joins) == 1 or not info.direct:
0.70 query.py(1605):             if info.filtered_relation:
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1608):             cur_targets = {t.column for t in targets}
0.70 query.py(1609):             if not cur_targets.issubset(join_targets):
0.70 query.py(1610):                 break
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1525):             return field.get_col(alias)
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(2070):         if self._annotation_select_cache is not None:
0.70 query.py(2072):         elif not self.annotations:
0.70 query.py(2073):             return {}
0.70 query.py(290):         return self.model._meta
0.70 query.py(2195):     dirn = ORDER_DIR[default]
0.70 query.py(2196):     if field[0] == '-':
0.70 query.py(2198):     return field, dirn[0]
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 query.py(1518):         joins = [alias]
0.70 query.py(1524):         def final_transformer(field, alias):
0.70 query.py(1529):         last_field_exception = None
0.70 query.py(1530):         for pivot in range(len(names), 0, -1):
0.70 query.py(1531):             try:
0.70 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.70 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.70 query.py(1405):         path, names_with_path = [], []
0.70 query.py(1406):         for pos, name in enumerate(names):
0.70 query.py(1407):             cur_names_with_path = (name, [])
0.70 query.py(1408):             if name == 'pk':
0.70 query.py(1411):             field = None
0.70 query.py(1412):             filtered_relation = None
0.70 query.py(1413):             try:
0.70 query.py(1414):                 field = opts.get_field(name)
0.70 query.py(1421):             if field is not None:
0.70 query.py(1425):                 if field.is_relation and not field.related_model:
0.70 query.py(1432):                 try:
0.70 query.py(1433):                     model = field.model._meta.concrete_model
0.70 query.py(1454):             if model is not opts.model:
0.70 query.py(1460):             if hasattr(field, 'get_path_info'):
0.70 query.py(1477):                 final_field = field
0.70 query.py(1478):                 targets = (field,)
0.70 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.70 query.py(1483):                 break
0.70 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.70 query.py(1545):                 transforms = names[pivot:]
0.70 query.py(1546):                 break
0.70 query.py(1547):         for name in transforms:
0.70 query.py(1562):         for join in path:
0.70 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.70 query.py(1601):         joins = joins[:]
0.70 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.70 query.py(1614):         return targets, joins[-1], joins
0.70 query.py(1525):             return field.get_col(alias)
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(290):         return self.model._meta
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.71 query.py(1331):         connector = q_object.connector
0.71 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.71 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.71 query.py(1334):         target_clause = self.where_class(connector=connector,
0.71 query.py(1335):                                          negated=q_object.negated)
0.71 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.71 query.py(2227):         self.connector = connector
0.71 query.py(2228):         self.negated = negated
0.71 query.py(2229):         if self.negated:
0.71 query.py(2235):             self.effective_connector = self.connector
0.71 query.py(2236):         self.num_children = num_children
0.71 query.py(2239):         self.votes = Counter()
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.71 query.py(290):         return self.model._meta
0.71 query.py(943):         if reuse_with_filtered_relation and reuse:
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(953):         if reuse_aliases:
0.71 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.71 query.py(735):         alias_list = self.table_map.get(table_name)
0.71 query.py(736):         if not create and alias_list:
0.71 query.py(742):         if alias_list:
0.71 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.71 query.py(748):             self.table_map[table_name] = [alias]
0.71 query.py(749):         self.alias_refcount[alias] = 1
0.71 query.py(750):         return alias, True
0.71 query.py(965):         if join.join_type:
0.71 query.py(971):         join.table_alias = alias
0.71 query.py(972):         self.alias_map[alias] = join
0.71 query.py(973):         return alias
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.71 query.py(2255):         to_promote = set()
0.71 query.py(2256):         to_demote = set()
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.71 query.py(2282):             if self.effective_connector == 'AND' or (
0.71 query.py(2284):                 to_demote.add(table)
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2300):         query.promote_joins(to_promote)
0.71 query.py(771):         aliases = list(aliases)
0.71 query.py(772):         while aliases:
0.71 query.py(2301):         query.demote_joins(to_demote)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(806):             alias = aliases.pop(0)
0.71 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.71 query.py(805):         while aliases:
0.71 query.py(2302):         return to_demote
0.71 query.py(1353):         return target_clause, needed_inner
0.71 query.py(1320):         if clause:
0.71 query.py(1321):             self.where.add(clause, AND)
0.71 query.py(1322):         self.demote_joins(existing_inner)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(655):         field_names, defer = self.deferred_loading
0.71 query.py(656):         if not field_names:
0.71 query.py(657):             return
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(2070):         if self._annotation_select_cache is not None:
0.71 query.py(2072):         elif not self.annotations:
0.71 query.py(2073):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(290):         return self.model._meta
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(290):         return self.model._meta
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.71 query.py(1331):         connector = q_object.connector
0.71 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.71 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.71 query.py(1334):         target_clause = self.where_class(connector=connector,
0.71 query.py(1335):                                          negated=q_object.negated)
0.71 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.71 query.py(2227):         self.connector = connector
0.71 query.py(2228):         self.negated = negated
0.71 query.py(2229):         if self.negated:
0.71 query.py(2235):             self.effective_connector = self.connector
0.71 query.py(2236):         self.num_children = num_children
0.71 query.py(2239):         self.votes = Counter()
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.71 query.py(290):         return self.model._meta
0.71 query.py(943):         if reuse_with_filtered_relation and reuse:
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(953):         if reuse_aliases:
0.71 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.71 query.py(735):         alias_list = self.table_map.get(table_name)
0.71 query.py(736):         if not create and alias_list:
0.71 query.py(742):         if alias_list:
0.71 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.71 query.py(748):             self.table_map[table_name] = [alias]
0.71 query.py(749):         self.alias_refcount[alias] = 1
0.71 query.py(750):         return alias, True
0.71 query.py(965):         if join.join_type:
0.71 query.py(971):         join.table_alias = alias
0.71 query.py(972):         self.alias_map[alias] = join
0.71 query.py(973):         return alias
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.71 query.py(2255):         to_promote = set()
0.71 query.py(2256):         to_demote = set()
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.71 query.py(2282):             if self.effective_connector == 'AND' or (
0.71 query.py(2284):                 to_demote.add(table)
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2300):         query.promote_joins(to_promote)
0.71 query.py(771):         aliases = list(aliases)
0.71 query.py(772):         while aliases:
0.71 query.py(2301):         query.demote_joins(to_demote)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(806):             alias = aliases.pop(0)
0.71 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.71 query.py(805):         while aliases:
0.71 query.py(2302):         return to_demote
0.71 query.py(1353):         return target_clause, needed_inner
0.71 query.py(1320):         if clause:
0.71 query.py(1321):             self.where.add(clause, AND)
0.71 query.py(1322):         self.demote_joins(existing_inner)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(655):         field_names, defer = self.deferred_loading
0.71 query.py(656):         if not field_names:
0.71 query.py(657):             return
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(2070):         if self._annotation_select_cache is not None:
0.71 query.py(2072):         elif not self.annotations:
0.71 query.py(2073):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(290):         return self.model._meta
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.71 query.py(1331):         connector = q_object.connector
0.71 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.71 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.71 query.py(1334):         target_clause = self.where_class(connector=connector,
0.71 query.py(1335):                                          negated=q_object.negated)
0.71 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.71 query.py(2227):         self.connector = connector
0.71 query.py(2228):         self.negated = negated
0.71 query.py(2229):         if self.negated:
0.71 query.py(2235):             self.effective_connector = self.connector
0.71 query.py(2236):         self.num_children = num_children
0.71 query.py(2239):         self.votes = Counter()
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.71 query.py(290):         return self.model._meta
0.71 query.py(943):         if reuse_with_filtered_relation and reuse:
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(953):         if reuse_aliases:
0.71 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.71 query.py(735):         alias_list = self.table_map.get(table_name)
0.71 query.py(736):         if not create and alias_list:
0.71 query.py(742):         if alias_list:
0.71 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.71 query.py(748):             self.table_map[table_name] = [alias]
0.71 query.py(749):         self.alias_refcount[alias] = 1
0.71 query.py(750):         return alias, True
0.71 query.py(965):         if join.join_type:
0.71 query.py(971):         join.table_alias = alias
0.71 query.py(972):         self.alias_map[alias] = join
0.71 query.py(973):         return alias
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.71 query.py(2255):         to_promote = set()
0.71 query.py(2256):         to_demote = set()
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.71 query.py(2282):             if self.effective_connector == 'AND' or (
0.71 query.py(2284):                 to_demote.add(table)
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2300):         query.promote_joins(to_promote)
0.71 query.py(771):         aliases = list(aliases)
0.71 query.py(772):         while aliases:
0.71 query.py(2301):         query.demote_joins(to_demote)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(806):             alias = aliases.pop(0)
0.71 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.71 query.py(805):         while aliases:
0.71 query.py(2302):         return to_demote
0.71 query.py(1353):         return target_clause, needed_inner
0.71 query.py(1320):         if clause:
0.71 query.py(1321):             self.where.add(clause, AND)
0.71 query.py(1322):         self.demote_joins(existing_inner)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1855):         self.order_by = ()
0.71 query.py(1856):         self.extra_order_by = ()
0.71 query.py(1857):         if force_empty:
0.71 query.py(1834):         errors = []
0.71 query.py(1835):         for item in ordering:
0.71 query.py(1843):         if errors:
0.71 query.py(1845):         if ordering:
0.71 query.py(1848):             self.default_ordering = False
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(655):         field_names, defer = self.deferred_loading
0.71 query.py(656):         if not field_names:
0.71 query.py(657):             return
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(2070):         if self._annotation_select_cache is not None:
0.71 query.py(2072):         elif not self.annotations:
0.71 query.py(2073):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(154):         self.model = model
0.71 query.py(155):         self.alias_refcount = {}
0.71 query.py(161):         self.alias_map = {}
0.71 query.py(165):         self.external_aliases = set()
0.71 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.71 query.py(167):         self.default_cols = True
0.71 query.py(168):         self.default_ordering = True
0.71 query.py(169):         self.standard_ordering = True
0.71 query.py(170):         self.used_aliases = set()
0.71 query.py(171):         self.filter_is_sticky = False
0.71 query.py(172):         self.subquery = False
0.71 query.py(180):         self.select = ()
0.71 query.py(181):         self.where = where()
0.71 query.py(182):         self.where_class = where
0.71 query.py(189):         self.group_by = None
0.71 query.py(190):         self.order_by = ()
0.71 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.71 query.py(192):         self.distinct = False
0.71 query.py(193):         self.distinct_fields = ()
0.71 query.py(194):         self.select_for_update = False
0.71 query.py(195):         self.select_for_update_nowait = False
0.71 query.py(196):         self.select_for_update_skip_locked = False
0.71 query.py(197):         self.select_for_update_of = ()
0.71 query.py(199):         self.select_related = False
0.71 query.py(201):         self.max_depth = 5
0.71 query.py(205):         self.values_select = ()
0.71 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.71 query.py(209):         self.annotation_select_mask = None
0.71 query.py(210):         self._annotation_select_cache = None
0.71 query.py(213):         self.combinator = None
0.71 query.py(214):         self.combinator_all = False
0.71 query.py(215):         self.combined_queries = ()
0.71 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.71 query.py(220):         self.extra_select_mask = None
0.71 query.py(221):         self._extra_select_cache = None
0.71 query.py(223):         self.extra_tables = ()
0.71 query.py(224):         self.extra_order_by = ()
0.71 query.py(229):         self.deferred_loading = (frozenset(), True)
0.71 query.py(231):         self._filtered_relations = {}
0.71 query.py(233):         self.explain_query = False
0.71 query.py(234):         self.explain_format = None
0.71 query.py(235):         self.explain_options = {}
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(334):         except AttributeError:
0.71 query.py(335):             pass
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.71 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.71 query.py(1331):         connector = q_object.connector
0.71 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.71 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.71 query.py(1334):         target_clause = self.where_class(connector=connector,
0.71 query.py(1335):                                          negated=q_object.negated)
0.71 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.71 query.py(2227):         self.connector = connector
0.71 query.py(2228):         self.negated = negated
0.71 query.py(2229):         if self.negated:
0.71 query.py(2235):             self.effective_connector = self.connector
0.71 query.py(2236):         self.num_children = num_children
0.71 query.py(2239):         self.votes = Counter()
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.71 query.py(290):         return self.model._meta
0.71 query.py(943):         if reuse_with_filtered_relation and reuse:
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(950):                 a for a, j in self.alias_map.items()
0.71 query.py(953):         if reuse_aliases:
0.71 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.71 query.py(735):         alias_list = self.table_map.get(table_name)
0.71 query.py(736):         if not create and alias_list:
0.71 query.py(742):         if alias_list:
0.71 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.71 query.py(748):             self.table_map[table_name] = [alias]
0.71 query.py(749):         self.alias_refcount[alias] = 1
0.71 query.py(750):         return alias, True
0.71 query.py(965):         if join.join_type:
0.71 query.py(971):         join.table_alias = alias
0.71 query.py(972):         self.alias_map[alias] = join
0.71 query.py(973):         return alias
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1338):             if isinstance(child, Node):
0.71 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.71 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.71 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.71 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.71 query.py(1214):         if isinstance(filter_expr, dict):
0.71 query.py(1216):         arg, value = filter_expr
0.71 query.py(1217):         if not arg:
0.71 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.71 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.71 query.py(1074):         if self.annotations:
0.71 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.71 query.py(290):         return self.model._meta
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.71 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.71 query.py(1085):         return lookup_parts, field_parts, False
0.71 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.71 query.py(1227):         if not allow_joins and len(parts) > 1:
0.71 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.71 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.71 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.71 query.py(1055):         elif isinstance(value, (list, tuple)):
0.71 query.py(1067):         return value
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.71 query.py(1234):         clause = self.where_class()
0.71 query.py(1235):         if reffed_expression:
0.71 query.py(1240):         opts = self.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 query.py(1241):         alias = self.get_initial_alias()
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(1242):         allow_many = not branch_negated or not split_subq
0.71 query.py(1244):         try:
0.71 query.py(1245):             join_info = self.setup_joins(
0.71 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.71 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.71 query.py(1518):         joins = [alias]
0.71 query.py(1524):         def final_transformer(field, alias):
0.71 query.py(1529):         last_field_exception = None
0.71 query.py(1530):         for pivot in range(len(names), 0, -1):
0.71 query.py(1531):             try:
0.71 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.71 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.71 query.py(1405):         path, names_with_path = [], []
0.71 query.py(1406):         for pos, name in enumerate(names):
0.71 query.py(1407):             cur_names_with_path = (name, [])
0.71 query.py(1408):             if name == 'pk':
0.71 query.py(1411):             field = None
0.71 query.py(1412):             filtered_relation = None
0.71 query.py(1413):             try:
0.71 query.py(1414):                 field = opts.get_field(name)
0.71 query.py(1421):             if field is not None:
0.71 query.py(1425):                 if field.is_relation and not field.related_model:
0.71 query.py(1432):                 try:
0.71 query.py(1433):                     model = field.model._meta.concrete_model
0.71 query.py(1454):             if model is not opts.model:
0.71 query.py(1460):             if hasattr(field, 'get_path_info'):
0.71 query.py(1477):                 final_field = field
0.71 query.py(1478):                 targets = (field,)
0.71 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.71 query.py(1483):                 break
0.71 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.71 query.py(1545):                 transforms = names[pivot:]
0.71 query.py(1546):                 break
0.71 query.py(1547):         for name in transforms:
0.71 query.py(1562):         for join in path:
0.71 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.71 query.py(1251):             if isinstance(value, Iterator):
0.71 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.71 query.py(1100):         if field.is_relation:
0.71 query.py(1257):             self._lookup_joins = join_info.joins
0.71 query.py(1263):         used_joins.update(join_info.joins)
0.71 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.71 query.py(1601):         joins = joins[:]
0.71 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.71 query.py(1614):         return targets, joins[-1], joins
0.71 query.py(1265):         if can_reuse is not None:
0.71 query.py(1266):             can_reuse.update(join_list)
0.71 query.py(1268):         if join_info.final_field.is_relation:
0.71 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.71 query.py(72):     if simple_col:
0.71 query.py(74):     return target.get_col(alias, field)
0.71 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.71 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.71 query.py(1129):         for name in transforms:
0.71 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.71 query.py(1134):         if not lookup_class:
0.71 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.71 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.71 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.71 query.py(1161):         return lookup
0.71 query.py(1281):         lookup_type = condition.lookup_name
0.71 query.py(1282):         clause.add(condition, AND)
0.71 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.71 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.71 query.py(1302):         return clause, used_joins if not require_outer else ()
0.71 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.71 query.py(2246):         self.votes.update(votes)
0.71 query.py(1350):             if child_clause:
0.71 query.py(1351):                 target_clause.add(child_clause, connector)
0.71 query.py(1337):         for child in q_object.children:
0.71 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.71 query.py(2255):         to_promote = set()
0.71 query.py(2256):         to_demote = set()
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.71 query.py(2282):             if self.effective_connector == 'AND' or (
0.71 query.py(2284):                 to_demote.add(table)
0.71 query.py(2259):         for table, votes in self.votes.items():
0.71 query.py(2300):         query.promote_joins(to_promote)
0.71 query.py(771):         aliases = list(aliases)
0.71 query.py(772):         while aliases:
0.71 query.py(2301):         query.demote_joins(to_demote)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(806):             alias = aliases.pop(0)
0.71 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.71 query.py(805):         while aliases:
0.71 query.py(2302):         return to_demote
0.71 query.py(1353):         return target_clause, needed_inner
0.71 query.py(1320):         if clause:
0.71 query.py(1321):             self.where.add(clause, AND)
0.71 query.py(1322):         self.demote_joins(existing_inner)
0.71 query.py(804):         aliases = list(aliases)
0.71 query.py(805):         while aliases:
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(1757):         return not self.low_mark and self.high_mark is None
0.71 query.py(343):         obj = self.clone()
0.71 query.py(297):         obj = Empty()
0.71 query.py(298):         obj.__class__ = self.__class__
0.71 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.71 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.71 query.py(303):         obj.alias_map = self.alias_map.copy()
0.71 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.71 query.py(305):         obj.table_map = self.table_map.copy()
0.71 query.py(306):         obj.where = self.where.clone()
0.71 query.py(307):         obj.annotations = self.annotations.copy()
0.71 query.py(308):         if self.annotation_select_mask is None:
0.71 query.py(309):             obj.annotation_select_mask = None
0.71 query.py(317):         obj._annotation_select_cache = None
0.71 query.py(318):         obj.extra = self.extra.copy()
0.71 query.py(319):         if self.extra_select_mask is None:
0.71 query.py(320):             obj.extra_select_mask = None
0.71 query.py(323):         if self._extra_select_cache is None:
0.71 query.py(324):             obj._extra_select_cache = None
0.71 query.py(327):         if 'subq_aliases' in self.__dict__:
0.71 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.71 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.71 query.py(332):         try:
0.71 query.py(333):             del obj.base_table
0.71 query.py(336):         return obj
0.71 query.py(344):         if klass and obj.__class__ != klass:
0.71 query.py(346):         if not obj.filter_is_sticky:
0.71 query.py(347):             obj.used_aliases = set()
0.71 query.py(348):         obj.filter_is_sticky = False
0.71 query.py(349):         if hasattr(obj, '_setup_query'):
0.71 query.py(351):         return obj
0.71 query.py(1855):         self.order_by = ()
0.71 query.py(1856):         self.extra_order_by = ()
0.71 query.py(1857):         if force_empty:
0.71 query.py(1834):         errors = []
0.71 query.py(1835):         for item in ordering:
0.71 query.py(1843):         if errors:
0.71 query.py(1845):         if ordering:
0.71 query.py(1848):             self.default_ordering = False
0.71 query.py(278):         if using is None and connection is None:
0.71 query.py(280):         if using:
0.71 query.py(281):             connection = connections[using]
0.71 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(290):         return self.model._meta
0.71 query.py(655):         field_names, defer = self.deferred_loading
0.71 query.py(656):         if not field_names:
0.71 query.py(657):             return
0.71 query.py(912):         if self.alias_map:
0.71 query.py(913):             alias = self.base_table
0.71 query.py(250):         for alias in self.alias_map:
0.71 query.py(251):             return alias
0.71 query.py(914):             self.ref_alias(alias)
0.71 query.py(754):         self.alias_refcount[alias] += 1
0.71 query.py(917):         return alias
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(984):         if model in seen:
0.71 query.py(985):             return seen[model]
0.71 query.py(2070):         if self._annotation_select_cache is not None:
0.71 query.py(2072):         elif not self.annotations:
0.71 query.py(2073):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.71 query.py(2085):         if self._extra_select_cache is not None:
0.71 query.py(2087):         if not self.extra:
0.71 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(1757):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.72 query.py(1331):         connector = q_object.connector
0.72 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.72 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.72 query.py(1334):         target_clause = self.where_class(connector=connector,
0.72 query.py(1335):                                          negated=q_object.negated)
0.72 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.72 query.py(2227):         self.connector = connector
0.72 query.py(2228):         self.negated = negated
0.72 query.py(2229):         if self.negated:
0.72 query.py(2235):             self.effective_connector = self.connector
0.72 query.py(2236):         self.num_children = num_children
0.72 query.py(2239):         self.votes = Counter()
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.72 query.py(290):         return self.model._meta
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2246):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2246):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.72 query.py(2255):         to_promote = set()
0.72 query.py(2256):         to_demote = set()
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2282):             if self.effective_connector == 'AND' or (
0.72 query.py(2284):                 to_demote.add(table)
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2300):         query.promote_joins(to_promote)
0.72 query.py(771):         aliases = list(aliases)
0.72 query.py(772):         while aliases:
0.72 query.py(2301):         query.demote_joins(to_demote)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(2302):         return to_demote
0.72 query.py(1353):         return target_clause, needed_inner
0.72 query.py(1320):         if clause:
0.72 query.py(1321):             self.where.add(clause, AND)
0.72 query.py(1322):         self.demote_joins(existing_inner)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(1757):         return not self.low_mark and self.high_mark is None
0.72 query.py(1757):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1855):         self.order_by = ()
0.72 query.py(1856):         self.extra_order_by = ()
0.72 query.py(1857):         if force_empty:
0.72 query.py(1834):         errors = []
0.72 query.py(1835):         for item in ordering:
0.72 query.py(1843):         if errors:
0.72 query.py(1845):         if ordering:
0.72 query.py(1848):             self.default_ordering = False
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(655):         field_names, defer = self.deferred_loading
0.72 query.py(656):         if not field_names:
0.72 query.py(657):             return
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1757):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.72 query.py(1331):         connector = q_object.connector
0.72 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.72 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.72 query.py(1334):         target_clause = self.where_class(connector=connector,
0.72 query.py(1335):                                          negated=q_object.negated)
0.72 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.72 query.py(2227):         self.connector = connector
0.72 query.py(2228):         self.negated = negated
0.72 query.py(2229):         if self.negated:
0.72 query.py(2235):             self.effective_connector = self.connector
0.72 query.py(2236):         self.num_children = num_children
0.72 query.py(2239):         self.votes = Counter()
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.72 query.py(1462):                 if not allow_many:
0.72 query.py(1468):                 last = pathinfos[-1]
0.72 query.py(1469):                 path.extend(pathinfos)
0.72 query.py(1470):                 final_field = last.join_field
0.72 query.py(1471):                 opts = last.to_opts
0.72 query.py(1472):                 targets = last.target_fields
0.72 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.72 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1415):             except FieldDoesNotExist:
0.72 query.py(1416):                 if name in self.annotation_select:
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.72 query.py(1421):             if field is not None:
0.72 query.py(1441):                 pos -= 1
0.72 query.py(1442):                 if pos == -1 or fail_on_missing:
0.72 query.py(1450):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.72 query.py(290):         return self.model._meta
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.72 query.py(1462):                 if not allow_many:
0.72 query.py(1468):                 last = pathinfos[-1]
0.72 query.py(1469):                 path.extend(pathinfos)
0.72 query.py(1470):                 final_field = last.join_field
0.72 query.py(1471):                 opts = last.to_opts
0.72 query.py(1472):                 targets = last.target_fields
0.72 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.72 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1563):             if join.filtered_relation:
0.72 query.py(1567):                 filtered_relation = None
0.72 query.py(1568):                 table_alias = None
0.72 query.py(1569):             opts = join.to_opts
0.72 query.py(1570):             if join.direct:
0.72 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.72 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(2184):         ) or field.null
0.72 query.py(1574):             connection = Join(
0.72 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.72 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.72 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.72 query.py(1579):             alias = self.join(
0.72 query.py(1580):                 connection, reuse=reuse,
0.72 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.72 query.py(969):                 join_type = INNER
0.72 query.py(970):             join.join_type = join_type
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(1583):             joins.append(alias)
0.72 query.py(1584):             if filtered_relation:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.72 query.py(1112):             elif hasattr(value, '_meta'):
0.72 query.py(1114):             elif hasattr(value, '__iter__'):
0.72 query.py(1115):                 for v in value:
0.72 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.72 query.py(1092):         if hasattr(value, '_meta'):
0.72 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.72 query.py(1115):                 for v in value:
0.72 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.72 query.py(1092):         if hasattr(value, '_meta'):
0.72 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.72 query.py(1115):                 for v in value:
0.72 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.72 query.py(1092):         if hasattr(value, '_meta'):
0.72 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.72 query.py(1115):                 for v in value:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1603):             if len(joins) == 1 or not info.direct:
0.72 query.py(1605):             if info.filtered_relation:
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1609):             if not cur_targets.issubset(join_targets):
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1613):             self.unref_alias(joins.pop())
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1270):             num_lookups = len(lookups)
0.72 query.py(1271):             if num_lookups > 1:
0.72 query.py(1273):             if len(targets) == 1:
0.72 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2246):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.72 query.py(2255):         to_promote = set()
0.72 query.py(2256):         to_demote = set()
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2282):             if self.effective_connector == 'AND' or (
0.72 query.py(2284):                 to_demote.add(table)
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2282):             if self.effective_connector == 'AND' or (
0.72 query.py(2284):                 to_demote.add(table)
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2300):         query.promote_joins(to_promote)
0.72 query.py(771):         aliases = list(aliases)
0.72 query.py(772):         while aliases:
0.72 query.py(2301):         query.demote_joins(to_demote)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(2302):         return to_demote
0.72 query.py(1353):         return target_clause, needed_inner
0.72 query.py(1320):         if clause:
0.72 query.py(1321):             self.where.add(clause, AND)
0.72 query.py(1322):         self.demote_joins(existing_inner)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(2030):         self.select_related = False
0.72 query.py(2031):         self.clear_deferred_loading()
0.72 query.py(1937):         self.deferred_loading = (frozenset(), True)
0.72 query.py(2032):         self.clear_select_fields()
0.72 query.py(1773):         self.select = ()
0.72 query.py(1774):         self.values_select = ()
0.72 query.py(2034):         if self.group_by is True:
0.72 query.py(2039):         if fields:
0.72 query.py(2040):             field_names = []
0.72 query.py(2041):             extra_names = []
0.72 query.py(2042):             annotation_names = []
0.72 query.py(2043):             if not self.extra and not self.annotations:
0.72 query.py(2046):                 field_names = list(fields)
0.72 query.py(2056):             self.set_extra_mask(extra_names)
0.72 query.py(2023):         if names is None:
0.72 query.py(2026):             self.extra_select_mask = set(names)
0.72 query.py(2027):         self._extra_select_cache = None
0.72 query.py(2057):             self.set_annotation_mask(annotation_names)
0.72 query.py(2008):         if names is None:
0.72 query.py(2011):             self.annotation_select_mask = set(names)
0.72 query.py(2012):         self._annotation_select_cache = None
0.72 query.py(2061):         self.values_select = tuple(field_names)
0.72 query.py(2062):         self.add_fields(field_names, True)
0.72 query.py(1792):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(1793):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1795):         try:
0.72 query.py(1796):             cols = []
0.72 query.py(1797):             for name in field_names:
0.72 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.72 query.py(1462):                 if not allow_many:
0.72 query.py(1468):                 last = pathinfos[-1]
0.72 query.py(1469):                 path.extend(pathinfos)
0.72 query.py(1470):                 final_field = last.join_field
0.72 query.py(1471):                 opts = last.to_opts
0.72 query.py(1472):                 targets = last.target_fields
0.72 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.72 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1563):             if join.filtered_relation:
0.72 query.py(1567):                 filtered_relation = None
0.72 query.py(1568):                 table_alias = None
0.72 query.py(1569):             opts = join.to_opts
0.72 query.py(1570):             if join.direct:
0.72 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.72 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(2184):         ) or field.null
0.72 query.py(1574):             connection = Join(
0.72 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.72 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.72 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.72 query.py(1579):             alias = self.join(
0.72 query.py(1580):                 connection, reuse=reuse,
0.72 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(954):             if join.table_alias in reuse_aliases:
0.72 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.72 query.py(960):             self.ref_alias(reuse_alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(961):             return reuse_alias
0.72 query.py(1583):             joins.append(alias)
0.72 query.py(1584):             if filtered_relation:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.72 query.py(1802):                     join_info.targets,
0.72 query.py(1803):                     join_info.joins,
0.72 query.py(1804):                     join_info.path,
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1603):             if len(joins) == 1 or not info.direct:
0.72 query.py(1605):             if info.filtered_relation:
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1609):             if not cur_targets.issubset(join_targets):
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.72 query.py(1613):             self.unref_alias(joins.pop())
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1806):                 for target in targets:
0.72 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.72 query.py(1525):             return field.get_col(alias)
0.72 query.py(1806):                 for target in targets:
0.72 query.py(1797):             for name in field_names:
0.72 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.72 query.py(1802):                     join_info.targets,
0.72 query.py(1803):                     join_info.joins,
0.72 query.py(1804):                     join_info.path,
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1806):                 for target in targets:
0.72 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.72 query.py(1525):             return field.get_col(alias)
0.72 query.py(1806):                 for target in targets:
0.72 query.py(1797):             for name in field_names:
0.72 query.py(1808):             if cols:
0.72 query.py(1809):                 self.set_select(cols)
0.72 query.py(1777):         self.default_cols = False
0.72 query.py(1778):         self.select = tuple(cols)
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(290):         return self.model._meta
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.72 query.py(1462):                 if not allow_many:
0.72 query.py(1468):                 last = pathinfos[-1]
0.72 query.py(1469):                 path.extend(pathinfos)
0.72 query.py(1470):                 final_field = last.join_field
0.72 query.py(1471):                 opts = last.to_opts
0.72 query.py(1472):                 targets = last.target_fields
0.72 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.72 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1563):             if join.filtered_relation:
0.72 query.py(1567):                 filtered_relation = None
0.72 query.py(1568):                 table_alias = None
0.72 query.py(1569):             opts = join.to_opts
0.72 query.py(1570):             if join.direct:
0.72 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.72 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(2184):         ) or field.null
0.72 query.py(1574):             connection = Join(
0.72 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.72 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.72 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.72 query.py(1579):             alias = self.join(
0.72 query.py(1580):                 connection, reuse=reuse,
0.72 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(954):             if join.table_alias in reuse_aliases:
0.72 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.72 query.py(960):             self.ref_alias(reuse_alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(961):             return reuse_alias
0.72 query.py(1583):             joins.append(alias)
0.72 query.py(1584):             if filtered_relation:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1603):             if len(joins) == 1 or not info.direct:
0.72 query.py(1605):             if info.filtered_relation:
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1609):             if not cur_targets.issubset(join_targets):
0.72 query.py(1610):                 break
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1525):             return field.get_col(alias)
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.72 query.py(1462):                 if not allow_many:
0.72 query.py(1468):                 last = pathinfos[-1]
0.72 query.py(1469):                 path.extend(pathinfos)
0.72 query.py(1470):                 final_field = last.join_field
0.72 query.py(1471):                 opts = last.to_opts
0.72 query.py(1472):                 targets = last.target_fields
0.72 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.72 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1563):             if join.filtered_relation:
0.72 query.py(1567):                 filtered_relation = None
0.72 query.py(1568):                 table_alias = None
0.72 query.py(1569):             opts = join.to_opts
0.72 query.py(1570):             if join.direct:
0.72 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.72 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(2184):         ) or field.null
0.72 query.py(1574):             connection = Join(
0.72 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.72 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.72 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.72 query.py(1579):             alias = self.join(
0.72 query.py(1580):                 connection, reuse=reuse,
0.72 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(954):             if join.table_alias in reuse_aliases:
0.72 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.72 query.py(960):             self.ref_alias(reuse_alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(961):             return reuse_alias
0.72 query.py(1583):             joins.append(alias)
0.72 query.py(1584):             if filtered_relation:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1603):             if len(joins) == 1 or not info.direct:
0.72 query.py(1605):             if info.filtered_relation:
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1608):             cur_targets = {t.column for t in targets}
0.72 query.py(1609):             if not cur_targets.issubset(join_targets):
0.72 query.py(1610):                 break
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1525):             return field.get_col(alias)
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(2195):     dirn = ORDER_DIR[default]
0.72 query.py(2196):     if field[0] == '-':
0.72 query.py(2198):     return field, dirn[0]
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1525):             return field.get_col(alias)
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 query.py(290):         return self.model._meta
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1757):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.72 query.py(1331):         connector = q_object.connector
0.72 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.72 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.72 query.py(1334):         target_clause = self.where_class(connector=connector,
0.72 query.py(1335):                                          negated=q_object.negated)
0.72 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.72 query.py(2227):         self.connector = connector
0.72 query.py(2228):         self.negated = negated
0.72 query.py(2229):         if self.negated:
0.72 query.py(2235):             self.effective_connector = self.connector
0.72 query.py(2236):         self.num_children = num_children
0.72 query.py(2239):         self.votes = Counter()
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.72 query.py(290):         return self.model._meta
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2246):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.72 query.py(2255):         to_promote = set()
0.72 query.py(2256):         to_demote = set()
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2282):             if self.effective_connector == 'AND' or (
0.72 query.py(2284):                 to_demote.add(table)
0.72 query.py(2259):         for table, votes in self.votes.items():
0.72 query.py(2300):         query.promote_joins(to_promote)
0.72 query.py(771):         aliases = list(aliases)
0.72 query.py(772):         while aliases:
0.72 query.py(2301):         query.demote_joins(to_demote)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(2302):         return to_demote
0.72 query.py(1353):         return target_clause, needed_inner
0.72 query.py(1320):         if clause:
0.72 query.py(1321):             self.where.add(clause, AND)
0.72 query.py(1322):         self.demote_joins(existing_inner)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(655):         field_names, defer = self.deferred_loading
0.72 query.py(656):         if not field_names:
0.72 query.py(657):             return
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 query.py(2070):         if self._annotation_select_cache is not None:
0.72 query.py(2072):         elif not self.annotations:
0.72 query.py(2073):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(2085):         if self._extra_select_cache is not None:
0.72 query.py(2087):         if not self.extra:
0.72 query.py(2088):             return {}
0.72 query.py(290):         return self.model._meta
0.72 query.py(290):         return self.model._meta
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 query.py(290):         return self.model._meta
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1757):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.73 query.py(1331):         connector = q_object.connector
0.73 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.73 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.73 query.py(1334):         target_clause = self.where_class(connector=connector,
0.73 query.py(1335):                                          negated=q_object.negated)
0.73 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.73 query.py(2227):         self.connector = connector
0.73 query.py(2228):         self.negated = negated
0.73 query.py(2229):         if self.negated:
0.73 query.py(2235):             self.effective_connector = self.connector
0.73 query.py(2236):         self.num_children = num_children
0.73 query.py(2239):         self.votes = Counter()
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.73 query.py(290):         return self.model._meta
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2246):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.73 query.py(2255):         to_promote = set()
0.73 query.py(2256):         to_demote = set()
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2282):             if self.effective_connector == 'AND' or (
0.73 query.py(2284):                 to_demote.add(table)
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2300):         query.promote_joins(to_promote)
0.73 query.py(771):         aliases = list(aliases)
0.73 query.py(772):         while aliases:
0.73 query.py(2301):         query.demote_joins(to_demote)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(2302):         return to_demote
0.73 query.py(1353):         return target_clause, needed_inner
0.73 query.py(1320):         if clause:
0.73 query.py(1321):             self.where.add(clause, AND)
0.73 query.py(1322):         self.demote_joins(existing_inner)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(655):         field_names, defer = self.deferred_loading
0.73 query.py(656):         if not field_names:
0.73 query.py(657):             return
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(290):         return self.model._meta
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(1757):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.73 query.py(1331):         connector = q_object.connector
0.73 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.73 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.73 query.py(1334):         target_clause = self.where_class(connector=connector,
0.73 query.py(1335):                                          negated=q_object.negated)
0.73 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.73 query.py(2227):         self.connector = connector
0.73 query.py(2228):         self.negated = negated
0.73 query.py(2229):         if self.negated:
0.73 query.py(2235):             self.effective_connector = self.connector
0.73 query.py(2236):         self.num_children = num_children
0.73 query.py(2239):         self.votes = Counter()
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.73 query.py(290):         return self.model._meta
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2246):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2246):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.73 query.py(2255):         to_promote = set()
0.73 query.py(2256):         to_demote = set()
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2282):             if self.effective_connector == 'AND' or (
0.73 query.py(2284):                 to_demote.add(table)
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2300):         query.promote_joins(to_promote)
0.73 query.py(771):         aliases = list(aliases)
0.73 query.py(772):         while aliases:
0.73 query.py(2301):         query.demote_joins(to_demote)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(2302):         return to_demote
0.73 query.py(1353):         return target_clause, needed_inner
0.73 query.py(1320):         if clause:
0.73 query.py(1321):             self.where.add(clause, AND)
0.73 query.py(1322):         self.demote_joins(existing_inner)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(1757):         return not self.low_mark and self.high_mark is None
0.73 query.py(1757):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1855):         self.order_by = ()
0.73 query.py(1856):         self.extra_order_by = ()
0.73 query.py(1857):         if force_empty:
0.73 query.py(1834):         errors = []
0.73 query.py(1835):         for item in ordering:
0.73 query.py(1843):         if errors:
0.73 query.py(1845):         if ordering:
0.73 query.py(1848):             self.default_ordering = False
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(655):         field_names, defer = self.deferred_loading
0.73 query.py(656):         if not field_names:
0.73 query.py(657):             return
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1757):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.73 query.py(1331):         connector = q_object.connector
0.73 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.73 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.73 query.py(1334):         target_clause = self.where_class(connector=connector,
0.73 query.py(1335):                                          negated=q_object.negated)
0.73 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.73 query.py(2227):         self.connector = connector
0.73 query.py(2228):         self.negated = negated
0.73 query.py(2229):         if self.negated:
0.73 query.py(2235):             self.effective_connector = self.connector
0.73 query.py(2236):         self.num_children = num_children
0.73 query.py(2239):         self.votes = Counter()
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1415):             except FieldDoesNotExist:
0.73 query.py(1416):                 if name in self.annotation_select:
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.73 query.py(1421):             if field is not None:
0.73 query.py(1441):                 pos -= 1
0.73 query.py(1442):                 if pos == -1 or fail_on_missing:
0.73 query.py(1450):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.73 query.py(290):         return self.model._meta
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2184):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.73 query.py(969):                 join_type = INNER
0.73 query.py(970):             join.join_type = join_type
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.73 query.py(1112):             elif hasattr(value, '_meta'):
0.73 query.py(1114):             elif hasattr(value, '__iter__'):
0.73 query.py(1115):                 for v in value:
0.73 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.73 query.py(1092):         if hasattr(value, '_meta'):
0.73 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.73 query.py(1115):                 for v in value:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1613):             self.unref_alias(joins.pop())
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1270):             num_lookups = len(lookups)
0.73 query.py(1271):             if num_lookups > 1:
0.73 query.py(1273):             if len(targets) == 1:
0.73 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2246):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.73 query.py(2255):         to_promote = set()
0.73 query.py(2256):         to_demote = set()
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2282):             if self.effective_connector == 'AND' or (
0.73 query.py(2284):                 to_demote.add(table)
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2282):             if self.effective_connector == 'AND' or (
0.73 query.py(2284):                 to_demote.add(table)
0.73 query.py(2259):         for table, votes in self.votes.items():
0.73 query.py(2300):         query.promote_joins(to_promote)
0.73 query.py(771):         aliases = list(aliases)
0.73 query.py(772):         while aliases:
0.73 query.py(2301):         query.demote_joins(to_demote)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(2302):         return to_demote
0.73 query.py(1353):         return target_clause, needed_inner
0.73 query.py(1320):         if clause:
0.73 query.py(1321):             self.where.add(clause, AND)
0.73 query.py(1322):         self.demote_joins(existing_inner)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(2030):         self.select_related = False
0.73 query.py(2031):         self.clear_deferred_loading()
0.73 query.py(1937):         self.deferred_loading = (frozenset(), True)
0.73 query.py(2032):         self.clear_select_fields()
0.73 query.py(1773):         self.select = ()
0.73 query.py(1774):         self.values_select = ()
0.73 query.py(2034):         if self.group_by is True:
0.73 query.py(2039):         if fields:
0.73 query.py(2040):             field_names = []
0.73 query.py(2041):             extra_names = []
0.73 query.py(2042):             annotation_names = []
0.73 query.py(2043):             if not self.extra and not self.annotations:
0.73 query.py(2046):                 field_names = list(fields)
0.73 query.py(2056):             self.set_extra_mask(extra_names)
0.73 query.py(2023):         if names is None:
0.73 query.py(2026):             self.extra_select_mask = set(names)
0.73 query.py(2027):         self._extra_select_cache = None
0.73 query.py(2057):             self.set_annotation_mask(annotation_names)
0.73 query.py(2008):         if names is None:
0.73 query.py(2011):             self.annotation_select_mask = set(names)
0.73 query.py(2012):         self._annotation_select_cache = None
0.73 query.py(2061):         self.values_select = tuple(field_names)
0.73 query.py(2062):         self.add_fields(field_names, True)
0.73 query.py(1792):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1793):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1795):         try:
0.73 query.py(1796):             cols = []
0.73 query.py(1797):             for name in field_names:
0.73 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2184):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.73 query.py(1802):                     join_info.targets,
0.73 query.py(1803):                     join_info.joins,
0.73 query.py(1804):                     join_info.path,
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1613):             self.unref_alias(joins.pop())
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1806):                 for target in targets:
0.73 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(1806):                 for target in targets:
0.73 query.py(1797):             for name in field_names:
0.73 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.73 query.py(1802):                     join_info.targets,
0.73 query.py(1803):                     join_info.joins,
0.73 query.py(1804):                     join_info.path,
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1806):                 for target in targets:
0.73 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(1806):                 for target in targets:
0.73 query.py(1797):             for name in field_names:
0.73 query.py(1808):             if cols:
0.73 query.py(1809):                 self.set_select(cols)
0.73 query.py(1777):         self.default_cols = False
0.73 query.py(1778):         self.select = tuple(cols)
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(290):         return self.model._meta
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2184):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1610):                 break
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2184):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1610):                 break
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(2070):         if self._annotation_select_cache is not None:
0.73 query.py(2072):         elif not self.annotations:
0.73 query.py(2073):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(2195):     dirn = ORDER_DIR[default]
0.73 query.py(2196):     if field[0] == '-':
0.73 query.py(2198):     return field, dirn[0]
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(2085):         if self._extra_select_cache is not None:
0.73 query.py(2087):         if not self.extra:
0.73 query.py(2088):             return {}
0.73 query.py(290):         return self.model._meta
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 query.py(290):         return self.model._meta
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(521):         q = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(522):         if not q.distinct:
0.74 query.py(523):             if q.group_by is True:
0.74 query.py(526):             q.clear_select_clause()
0.74 query.py(1761):         self.select = ()
0.74 query.py(1762):         self.default_cols = False
0.74 query.py(1763):         self.select_related = False
0.74 query.py(1764):         self.set_extra_mask(())
0.74 query.py(2023):         if names is None:
0.74 query.py(2026):             self.extra_select_mask = set(names)
0.74 query.py(2027):         self._extra_select_cache = None
0.74 query.py(1765):         self.set_annotation_mask(())
0.74 query.py(2008):         if names is None:
0.74 query.py(2011):             self.annotation_select_mask = set(names)
0.74 query.py(2012):         self._annotation_select_cache = None
0.74 query.py(527):         q.clear_ordering(True)
0.74 query.py(1855):         self.order_by = ()
0.74 query.py(1856):         self.extra_order_by = ()
0.74 query.py(1857):         if force_empty:
0.74 query.py(1858):             self.default_ordering = False
0.74 query.py(528):         q.set_limits(high=1)
0.74 query.py(1730):         if high is not None:
0.74 query.py(1731):             if self.high_mark is not None:
0.74 query.py(1734):                 self.high_mark = self.low_mark + high
0.74 query.py(1735):         if low is not None:
0.74 query.py(1741):         if self.low_mark == self.high_mark:
0.74 query.py(529):         compiler = q.get_compiler(using=using)
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 query.py(530):         return compiler.has_results()
0.74 query.py(1908):         if select:
0.74 query.py(1913):             select_pairs = {}
0.74 query.py(1914):             if select_params:
0.74 query.py(1917):                 param_iter = iter([])
0.74 query.py(1918):             for name, entry in select.items():
0.74 query.py(1919):                 entry = str(entry)
0.74 query.py(1920):                 entry_params = []
0.74 query.py(1921):                 pos = entry.find("%s")
0.74 query.py(1922):                 while pos != -1:
0.74 query.py(1926):                 select_pairs[name] = (entry, entry_params)
0.74 query.py(1918):             for name, entry in select.items():
0.74 query.py(1927):             self.extra.update(select_pairs)
0.74 query.py(1928):         if where or params:
0.74 query.py(1930):         if tables:
0.74 query.py(1932):         if order_by:
0.74 query.py(2023):         if names is None:
0.74 query.py(2026):             self.extra_select_mask = set(names)
0.74 query.py(2027):         self._extra_select_cache = None
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2089):         elif self.extra_select_mask is not None:
0.74 query.py(2090):             self._extra_select_cache = {
0.74 query.py(2091):                 k: v for k, v in self.extra.items()
0.74 query.py(2090):             self._extra_select_cache = {
0.74 query.py(2091):                 k: v for k, v in self.extra.items()
0.74 query.py(2092):                 if k in self.extra_select_mask
0.74 query.py(2090):             self._extra_select_cache = {
0.74 query.py(2094):             return self._extra_select_cache
0.74 query.py(2070):         if self._annotation_select_cache is not None:
0.74 query.py(2072):         elif not self.annotations:
0.74 query.py(2073):             return {}
0.74 query.py(290):         return self.model._meta
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2086):             return self._extra_select_cache
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.74 query.py(820):             self.unref_alias(alias, unref_amount)
0.74 query.py(758):         self.alias_refcount[alias] -= amount
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1757):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2227):         self.connector = connector
0.74 query.py(2228):         self.negated = negated
0.74 query.py(2229):         if self.negated:
0.74 query.py(2235):             self.effective_connector = self.connector
0.74 query.py(2236):         self.num_children = num_children
0.74 query.py(2239):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1409):                 name = opts.pk.name
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.74 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1409):                 name = opts.pk.name
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1545):                 transforms = names[pivot:]
0.74 query.py(1546):                 break
0.74 query.py(1547):         for name in transforms:
0.74 query.py(1562):         for join in path:
0.74 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.74 query.py(1251):             if isinstance(value, Iterator):
0.74 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.74 query.py(1100):         if field.is_relation:
0.74 query.py(1257):             self._lookup_joins = join_info.joins
0.74 query.py(1263):         used_joins.update(join_info.joins)
0.74 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.74 query.py(1601):         joins = joins[:]
0.74 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.74 query.py(1614):         return targets, joins[-1], joins
0.74 query.py(1265):         if can_reuse is not None:
0.74 query.py(1266):             can_reuse.update(join_list)
0.74 query.py(1268):         if join_info.final_field.is_relation:
0.74 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.74 query.py(72):     if simple_col:
0.74 query.py(74):     return target.get_col(alias, field)
0.74 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.74 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.74 query.py(1129):         for name in transforms:
0.74 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.74 query.py(1134):         if not lookup_class:
0.74 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.74 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.74 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.74 query.py(1161):         return lookup
0.74 query.py(1281):         lookup_type = condition.lookup_name
0.74 query.py(1282):         clause.add(condition, AND)
0.74 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.74 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.74 query.py(1302):         return clause, used_joins if not require_outer else ()
0.74 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.74 query.py(2246):         self.votes.update(votes)
0.74 query.py(1350):             if child_clause:
0.74 query.py(1351):                 target_clause.add(child_clause, connector)
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.74 query.py(2255):         to_promote = set()
0.74 query.py(2256):         to_demote = set()
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.74 query.py(2282):             if self.effective_connector == 'AND' or (
0.74 query.py(2284):                 to_demote.add(table)
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2300):         query.promote_joins(to_promote)
0.74 query.py(771):         aliases = list(aliases)
0.74 query.py(772):         while aliases:
0.74 query.py(2301):         query.demote_joins(to_demote)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(806):             alias = aliases.pop(0)
0.74 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.74 query.py(805):         while aliases:
0.74 query.py(2302):         return to_demote
0.74 query.py(1353):         return target_clause, needed_inner
0.74 query.py(1320):         if clause:
0.74 query.py(1321):             self.where.add(clause, AND)
0.74 query.py(1322):         self.demote_joins(existing_inner)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(1757):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(345):             obj.__class__ = klass
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(350):             obj._setup_query()
0.74 query.py(351):         return obj
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 query.py(912):         if self.alias_map:
0.74 query.py(913):             alias = self.base_table
0.74 query.py(250):         for alias in self.alias_map:
0.74 query.py(251):             return alias
0.74 query.py(914):             self.ref_alias(alias)
0.74 query.py(754):         self.alias_refcount[alias] += 1
0.74 query.py(917):         return alias
0.74 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.74 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.74 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 query.py(290):         return self.model._meta
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1757):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2227):         self.connector = connector
0.74 query.py(2228):         self.negated = negated
0.74 query.py(2229):         if self.negated:
0.74 query.py(2235):             self.effective_connector = self.connector
0.74 query.py(2236):         self.num_children = num_children
0.74 query.py(2239):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.74 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1545):                 transforms = names[pivot:]
0.74 query.py(1546):                 break
0.74 query.py(1547):         for name in transforms:
0.74 query.py(1562):         for join in path:
0.74 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.74 query.py(1251):             if isinstance(value, Iterator):
0.74 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.74 query.py(1100):         if field.is_relation:
0.74 query.py(1257):             self._lookup_joins = join_info.joins
0.74 query.py(1263):         used_joins.update(join_info.joins)
0.74 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.74 query.py(1601):         joins = joins[:]
0.74 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.74 query.py(1614):         return targets, joins[-1], joins
0.74 query.py(1265):         if can_reuse is not None:
0.74 query.py(1266):             can_reuse.update(join_list)
0.74 query.py(1268):         if join_info.final_field.is_relation:
0.74 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.74 query.py(72):     if simple_col:
0.74 query.py(74):     return target.get_col(alias, field)
0.74 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.74 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.74 query.py(1129):         for name in transforms:
0.74 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.74 query.py(1134):         if not lookup_class:
0.74 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.74 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.74 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.74 query.py(1161):         return lookup
0.74 query.py(1281):         lookup_type = condition.lookup_name
0.74 query.py(1282):         clause.add(condition, AND)
0.74 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.74 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.74 query.py(1302):         return clause, used_joins if not require_outer else ()
0.74 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.74 query.py(2246):         self.votes.update(votes)
0.74 query.py(1350):             if child_clause:
0.74 query.py(1351):                 target_clause.add(child_clause, connector)
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.74 query.py(2255):         to_promote = set()
0.74 query.py(2256):         to_demote = set()
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.74 query.py(2282):             if self.effective_connector == 'AND' or (
0.74 query.py(2284):                 to_demote.add(table)
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2300):         query.promote_joins(to_promote)
0.74 query.py(771):         aliases = list(aliases)
0.74 query.py(772):         while aliases:
0.74 query.py(2301):         query.demote_joins(to_demote)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(806):             alias = aliases.pop(0)
0.74 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.74 query.py(805):         while aliases:
0.74 query.py(2302):         return to_demote
0.74 query.py(1353):         return target_clause, needed_inner
0.74 query.py(1320):         if clause:
0.74 query.py(1321):             self.where.add(clause, AND)
0.74 query.py(1322):         self.demote_joins(existing_inner)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(290):         return self.model._meta
0.74 query.py(655):         field_names, defer = self.deferred_loading
0.74 query.py(656):         if not field_names:
0.74 query.py(657):             return
0.74 query.py(912):         if self.alias_map:
0.74 query.py(913):             alias = self.base_table
0.74 query.py(250):         for alias in self.alias_map:
0.74 query.py(251):             return alias
0.74 query.py(914):             self.ref_alias(alias)
0.74 query.py(754):         self.alias_refcount[alias] += 1
0.74 query.py(917):         return alias
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 query.py(2070):         if self._annotation_select_cache is not None:
0.74 query.py(2072):         elif not self.annotations:
0.74 query.py(2073):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(2085):         if self._extra_select_cache is not None:
0.74 query.py(2087):         if not self.extra:
0.74 query.py(2088):             return {}
0.74 query.py(290):         return self.model._meta
0.74 query.py(290):         return self.model._meta
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.74 query.py(820):             self.unref_alias(alias, unref_amount)
0.74 query.py(758):         self.alias_refcount[alias] -= amount
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 query.py(290):         return self.model._meta
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1757):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2227):         self.connector = connector
0.74 query.py(2228):         self.negated = negated
0.74 query.py(2229):         if self.negated:
0.74 query.py(2235):             self.effective_connector = self.connector
0.74 query.py(2236):         self.num_children = num_children
0.74 query.py(2239):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.74 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1545):                 transforms = names[pivot:]
0.74 query.py(1546):                 break
0.74 query.py(1547):         for name in transforms:
0.74 query.py(1562):         for join in path:
0.74 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.74 query.py(1251):             if isinstance(value, Iterator):
0.74 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.74 query.py(1100):         if field.is_relation:
0.74 query.py(1257):             self._lookup_joins = join_info.joins
0.74 query.py(1263):         used_joins.update(join_info.joins)
0.74 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.74 query.py(1601):         joins = joins[:]
0.74 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.74 query.py(1614):         return targets, joins[-1], joins
0.74 query.py(1265):         if can_reuse is not None:
0.74 query.py(1266):             can_reuse.update(join_list)
0.74 query.py(1268):         if join_info.final_field.is_relation:
0.74 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.74 query.py(72):     if simple_col:
0.74 query.py(74):     return target.get_col(alias, field)
0.74 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.74 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.74 query.py(1129):         for name in transforms:
0.74 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.74 query.py(1134):         if not lookup_class:
0.74 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.74 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.74 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.74 query.py(1161):         return lookup
0.74 query.py(1281):         lookup_type = condition.lookup_name
0.74 query.py(1282):         clause.add(condition, AND)
0.74 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.74 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.74 query.py(1302):         return clause, used_joins if not require_outer else ()
0.74 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.74 query.py(2246):         self.votes.update(votes)
0.74 query.py(1350):             if child_clause:
0.74 query.py(1351):                 target_clause.add(child_clause, connector)
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.74 query.py(2255):         to_promote = set()
0.74 query.py(2256):         to_demote = set()
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.74 query.py(2282):             if self.effective_connector == 'AND' or (
0.74 query.py(2284):                 to_demote.add(table)
0.74 query.py(2259):         for table, votes in self.votes.items():
0.74 query.py(2300):         query.promote_joins(to_promote)
0.74 query.py(771):         aliases = list(aliases)
0.74 query.py(772):         while aliases:
0.74 query.py(2301):         query.demote_joins(to_demote)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(806):             alias = aliases.pop(0)
0.74 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.74 query.py(805):         while aliases:
0.74 query.py(2302):         return to_demote
0.74 query.py(1353):         return target_clause, needed_inner
0.74 query.py(1320):         if clause:
0.74 query.py(1321):             self.where.add(clause, AND)
0.74 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(290):         return self.model._meta
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(1757):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.75 query.py(1331):         connector = q_object.connector
0.75 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.75 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.75 query.py(1334):         target_clause = self.where_class(connector=connector,
0.75 query.py(1335):                                          negated=q_object.negated)
0.75 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.75 query.py(2227):         self.connector = connector
0.75 query.py(2228):         self.negated = negated
0.75 query.py(2229):         if self.negated:
0.75 query.py(2235):             self.effective_connector = self.connector
0.75 query.py(2236):         self.num_children = num_children
0.75 query.py(2239):         self.votes = Counter()
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.75 query.py(290):         return self.model._meta
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2246):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2246):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2255):         to_promote = set()
0.75 query.py(2256):         to_demote = set()
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2282):             if self.effective_connector == 'AND' or (
0.75 query.py(2284):                 to_demote.add(table)
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2300):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2301):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2302):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(1757):         return not self.low_mark and self.high_mark is None
0.75 query.py(1757):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1855):         self.order_by = ()
0.75 query.py(1856):         self.extra_order_by = ()
0.75 query.py(1857):         if force_empty:
0.75 query.py(1834):         errors = []
0.75 query.py(1835):         for item in ordering:
0.75 query.py(1843):         if errors:
0.75 query.py(1845):         if ordering:
0.75 query.py(1848):             self.default_ordering = False
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1757):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.75 query.py(1331):         connector = q_object.connector
0.75 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.75 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.75 query.py(1334):         target_clause = self.where_class(connector=connector,
0.75 query.py(1335):                                          negated=q_object.negated)
0.75 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.75 query.py(2227):         self.connector = connector
0.75 query.py(2228):         self.negated = negated
0.75 query.py(2229):         if self.negated:
0.75 query.py(2235):             self.effective_connector = self.connector
0.75 query.py(2236):         self.num_children = num_children
0.75 query.py(2239):         self.votes = Counter()
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.75 query.py(1462):                 if not allow_many:
0.75 query.py(1468):                 last = pathinfos[-1]
0.75 query.py(1469):                 path.extend(pathinfos)
0.75 query.py(1470):                 final_field = last.join_field
0.75 query.py(1471):                 opts = last.to_opts
0.75 query.py(1472):                 targets = last.target_fields
0.75 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.75 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1415):             except FieldDoesNotExist:
0.75 query.py(1416):                 if name in self.annotation_select:
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.75 query.py(1421):             if field is not None:
0.75 query.py(1441):                 pos -= 1
0.75 query.py(1442):                 if pos == -1 or fail_on_missing:
0.75 query.py(1450):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.75 query.py(290):         return self.model._meta
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.75 query.py(1462):                 if not allow_many:
0.75 query.py(1468):                 last = pathinfos[-1]
0.75 query.py(1469):                 path.extend(pathinfos)
0.75 query.py(1470):                 final_field = last.join_field
0.75 query.py(1471):                 opts = last.to_opts
0.75 query.py(1472):                 targets = last.target_fields
0.75 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.75 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1563):             if join.filtered_relation:
0.75 query.py(1567):                 filtered_relation = None
0.75 query.py(1568):                 table_alias = None
0.75 query.py(1569):             opts = join.to_opts
0.75 query.py(1570):             if join.direct:
0.75 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.75 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(2184):         ) or field.null
0.75 query.py(1574):             connection = Join(
0.75 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.75 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.75 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.75 query.py(1579):             alias = self.join(
0.75 query.py(1580):                 connection, reuse=reuse,
0.75 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.75 query.py(969):                 join_type = INNER
0.75 query.py(970):             join.join_type = join_type
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(1583):             joins.append(alias)
0.75 query.py(1584):             if filtered_relation:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.75 query.py(1112):             elif hasattr(value, '_meta'):
0.75 query.py(1114):             elif hasattr(value, '__iter__'):
0.75 query.py(1115):                 for v in value:
0.75 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.75 query.py(1092):         if hasattr(value, '_meta'):
0.75 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.75 query.py(1115):                 for v in value:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1603):             if len(joins) == 1 or not info.direct:
0.75 query.py(1605):             if info.filtered_relation:
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1609):             if not cur_targets.issubset(join_targets):
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1613):             self.unref_alias(joins.pop())
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1270):             num_lookups = len(lookups)
0.75 query.py(1271):             if num_lookups > 1:
0.75 query.py(1273):             if len(targets) == 1:
0.75 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2246):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2255):         to_promote = set()
0.75 query.py(2256):         to_demote = set()
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2282):             if self.effective_connector == 'AND' or (
0.75 query.py(2284):                 to_demote.add(table)
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2282):             if self.effective_connector == 'AND' or (
0.75 query.py(2284):                 to_demote.add(table)
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2300):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2301):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2302):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(2030):         self.select_related = False
0.75 query.py(2031):         self.clear_deferred_loading()
0.75 query.py(1937):         self.deferred_loading = (frozenset(), True)
0.75 query.py(2032):         self.clear_select_fields()
0.75 query.py(1773):         self.select = ()
0.75 query.py(1774):         self.values_select = ()
0.75 query.py(2034):         if self.group_by is True:
0.75 query.py(2039):         if fields:
0.75 query.py(2040):             field_names = []
0.75 query.py(2041):             extra_names = []
0.75 query.py(2042):             annotation_names = []
0.75 query.py(2043):             if not self.extra and not self.annotations:
0.75 query.py(2046):                 field_names = list(fields)
0.75 query.py(2056):             self.set_extra_mask(extra_names)
0.75 query.py(2023):         if names is None:
0.75 query.py(2026):             self.extra_select_mask = set(names)
0.75 query.py(2027):         self._extra_select_cache = None
0.75 query.py(2057):             self.set_annotation_mask(annotation_names)
0.75 query.py(2008):         if names is None:
0.75 query.py(2011):             self.annotation_select_mask = set(names)
0.75 query.py(2012):         self._annotation_select_cache = None
0.75 query.py(2061):         self.values_select = tuple(field_names)
0.75 query.py(2062):         self.add_fields(field_names, True)
0.75 query.py(1792):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1793):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1795):         try:
0.75 query.py(1796):             cols = []
0.75 query.py(1797):             for name in field_names:
0.75 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.75 query.py(1462):                 if not allow_many:
0.75 query.py(1468):                 last = pathinfos[-1]
0.75 query.py(1469):                 path.extend(pathinfos)
0.75 query.py(1470):                 final_field = last.join_field
0.75 query.py(1471):                 opts = last.to_opts
0.75 query.py(1472):                 targets = last.target_fields
0.75 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.75 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1563):             if join.filtered_relation:
0.75 query.py(1567):                 filtered_relation = None
0.75 query.py(1568):                 table_alias = None
0.75 query.py(1569):             opts = join.to_opts
0.75 query.py(1570):             if join.direct:
0.75 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.75 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(2184):         ) or field.null
0.75 query.py(1574):             connection = Join(
0.75 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.75 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.75 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.75 query.py(1579):             alias = self.join(
0.75 query.py(1580):                 connection, reuse=reuse,
0.75 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(954):             if join.table_alias in reuse_aliases:
0.75 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.75 query.py(960):             self.ref_alias(reuse_alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(961):             return reuse_alias
0.75 query.py(1583):             joins.append(alias)
0.75 query.py(1584):             if filtered_relation:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.75 query.py(1802):                     join_info.targets,
0.75 query.py(1803):                     join_info.joins,
0.75 query.py(1804):                     join_info.path,
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1603):             if len(joins) == 1 or not info.direct:
0.75 query.py(1605):             if info.filtered_relation:
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1609):             if not cur_targets.issubset(join_targets):
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.75 query.py(1613):             self.unref_alias(joins.pop())
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1806):                 for target in targets:
0.75 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.75 query.py(1525):             return field.get_col(alias)
0.75 query.py(1806):                 for target in targets:
0.75 query.py(1797):             for name in field_names:
0.75 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.75 query.py(1802):                     join_info.targets,
0.75 query.py(1803):                     join_info.joins,
0.75 query.py(1804):                     join_info.path,
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1806):                 for target in targets:
0.75 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.75 query.py(1525):             return field.get_col(alias)
0.75 query.py(1806):                 for target in targets:
0.75 query.py(1797):             for name in field_names:
0.75 query.py(1808):             if cols:
0.75 query.py(1809):                 self.set_select(cols)
0.75 query.py(1777):         self.default_cols = False
0.75 query.py(1778):         self.select = tuple(cols)
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(290):         return self.model._meta
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.75 query.py(1462):                 if not allow_many:
0.75 query.py(1468):                 last = pathinfos[-1]
0.75 query.py(1469):                 path.extend(pathinfos)
0.75 query.py(1470):                 final_field = last.join_field
0.75 query.py(1471):                 opts = last.to_opts
0.75 query.py(1472):                 targets = last.target_fields
0.75 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.75 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1563):             if join.filtered_relation:
0.75 query.py(1567):                 filtered_relation = None
0.75 query.py(1568):                 table_alias = None
0.75 query.py(1569):             opts = join.to_opts
0.75 query.py(1570):             if join.direct:
0.75 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.75 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(2184):         ) or field.null
0.75 query.py(1574):             connection = Join(
0.75 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.75 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.75 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.75 query.py(1579):             alias = self.join(
0.75 query.py(1580):                 connection, reuse=reuse,
0.75 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(954):             if join.table_alias in reuse_aliases:
0.75 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.75 query.py(960):             self.ref_alias(reuse_alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(961):             return reuse_alias
0.75 query.py(1583):             joins.append(alias)
0.75 query.py(1584):             if filtered_relation:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1603):             if len(joins) == 1 or not info.direct:
0.75 query.py(1605):             if info.filtered_relation:
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1609):             if not cur_targets.issubset(join_targets):
0.75 query.py(1610):                 break
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1525):             return field.get_col(alias)
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.75 query.py(1462):                 if not allow_many:
0.75 query.py(1468):                 last = pathinfos[-1]
0.75 query.py(1469):                 path.extend(pathinfos)
0.75 query.py(1470):                 final_field = last.join_field
0.75 query.py(1471):                 opts = last.to_opts
0.75 query.py(1472):                 targets = last.target_fields
0.75 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.75 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1563):             if join.filtered_relation:
0.75 query.py(1567):                 filtered_relation = None
0.75 query.py(1568):                 table_alias = None
0.75 query.py(1569):             opts = join.to_opts
0.75 query.py(1570):             if join.direct:
0.75 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.75 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(2184):         ) or field.null
0.75 query.py(1574):             connection = Join(
0.75 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.75 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.75 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.75 query.py(1579):             alias = self.join(
0.75 query.py(1580):                 connection, reuse=reuse,
0.75 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(954):             if join.table_alias in reuse_aliases:
0.75 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.75 query.py(960):             self.ref_alias(reuse_alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(961):             return reuse_alias
0.75 query.py(1583):             joins.append(alias)
0.75 query.py(1584):             if filtered_relation:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1603):             if len(joins) == 1 or not info.direct:
0.75 query.py(1605):             if info.filtered_relation:
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1608):             cur_targets = {t.column for t in targets}
0.75 query.py(1609):             if not cur_targets.issubset(join_targets):
0.75 query.py(1610):                 break
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1525):             return field.get_col(alias)
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(2195):     dirn = ORDER_DIR[default]
0.75 query.py(2196):     if field[0] == '-':
0.75 query.py(2198):     return field, dirn[0]
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1525):             return field.get_col(alias)
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 query.py(290):         return self.model._meta
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1757):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.75 query.py(1331):         connector = q_object.connector
0.75 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.75 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.75 query.py(1334):         target_clause = self.where_class(connector=connector,
0.75 query.py(1335):                                          negated=q_object.negated)
0.75 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.75 query.py(2227):         self.connector = connector
0.75 query.py(2228):         self.negated = negated
0.75 query.py(2229):         if self.negated:
0.75 query.py(2235):             self.effective_connector = self.connector
0.75 query.py(2236):         self.num_children = num_children
0.75 query.py(2239):         self.votes = Counter()
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.75 query.py(290):         return self.model._meta
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2246):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2255):         to_promote = set()
0.75 query.py(2256):         to_demote = set()
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2282):             if self.effective_connector == 'AND' or (
0.75 query.py(2284):                 to_demote.add(table)
0.75 query.py(2259):         for table, votes in self.votes.items():
0.75 query.py(2300):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2301):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2302):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 query.py(2070):         if self._annotation_select_cache is not None:
0.75 query.py(2072):         elif not self.annotations:
0.75 query.py(2073):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(2085):         if self._extra_select_cache is not None:
0.75 query.py(2087):         if not self.extra:
0.75 query.py(2088):             return {}
0.75 query.py(290):         return self.model._meta
0.75 query.py(290):         return self.model._meta
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 query.py(290):         return self.model._meta
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1757):         return not self.low_mark and self.high_mark is None
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.76 query.py(1331):         connector = q_object.connector
0.76 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.76 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.76 query.py(1334):         target_clause = self.where_class(connector=connector,
0.76 query.py(1335):                                          negated=q_object.negated)
0.76 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.76 query.py(2227):         self.connector = connector
0.76 query.py(2228):         self.negated = negated
0.76 query.py(2229):         if self.negated:
0.76 query.py(2235):             self.effective_connector = self.connector
0.76 query.py(2236):         self.num_children = num_children
0.76 query.py(2239):         self.votes = Counter()
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1338):             if isinstance(child, Node):
0.76 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.76 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.76 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.76 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.76 query.py(1214):         if isinstance(filter_expr, dict):
0.76 query.py(1216):         arg, value = filter_expr
0.76 query.py(1217):         if not arg:
0.76 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.76 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.76 query.py(1074):         if self.annotations:
0.76 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.76 query.py(290):         return self.model._meta
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.76 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.76 query.py(1085):         return lookup_parts, field_parts, False
0.76 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.76 query.py(1227):         if not allow_joins and len(parts) > 1:
0.76 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.76 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.76 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.76 query.py(1055):         elif isinstance(value, (list, tuple)):
0.76 query.py(1067):         return value
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1234):         clause = self.where_class()
0.76 query.py(1235):         if reffed_expression:
0.76 query.py(1240):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1241):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.76 query.py(290):         return self.model._meta
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(917):         return alias
0.76 query.py(1242):         allow_many = not branch_negated or not split_subq
0.76 query.py(1244):         try:
0.76 query.py(1245):             join_info = self.setup_joins(
0.76 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.76 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1251):             if isinstance(value, Iterator):
0.76 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.76 query.py(1100):         if field.is_relation:
0.76 query.py(1257):             self._lookup_joins = join_info.joins
0.76 query.py(1263):         used_joins.update(join_info.joins)
0.76 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1265):         if can_reuse is not None:
0.76 query.py(1266):             can_reuse.update(join_list)
0.76 query.py(1268):         if join_info.final_field.is_relation:
0.76 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.76 query.py(72):     if simple_col:
0.76 query.py(74):     return target.get_col(alias, field)
0.76 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.76 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.76 query.py(1129):         for name in transforms:
0.76 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.76 query.py(1134):         if not lookup_class:
0.76 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.76 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.76 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(1161):         return lookup
0.76 query.py(1281):         lookup_type = condition.lookup_name
0.76 query.py(1282):         clause.add(condition, AND)
0.76 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.76 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.76 query.py(1302):         return clause, used_joins if not require_outer else ()
0.76 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.76 query.py(2246):         self.votes.update(votes)
0.76 query.py(1350):             if child_clause:
0.76 query.py(1351):                 target_clause.add(child_clause, connector)
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.76 query.py(2255):         to_promote = set()
0.76 query.py(2256):         to_demote = set()
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2282):             if self.effective_connector == 'AND' or (
0.76 query.py(2284):                 to_demote.add(table)
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2300):         query.promote_joins(to_promote)
0.76 query.py(771):         aliases = list(aliases)
0.76 query.py(772):         while aliases:
0.76 query.py(2301):         query.demote_joins(to_demote)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(2302):         return to_demote
0.76 query.py(1353):         return target_clause, needed_inner
0.76 query.py(1320):         if clause:
0.76 query.py(1321):             self.where.add(clause, AND)
0.76 query.py(1322):         self.demote_joins(existing_inner)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(655):         field_names, defer = self.deferred_loading
0.76 query.py(656):         if not field_names:
0.76 query.py(657):             return
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(250):         for alias in self.alias_map:
0.76 query.py(251):             return alias
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(290):         return self.model._meta
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(1757):         return not self.low_mark and self.high_mark is None
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.76 query.py(1331):         connector = q_object.connector
0.76 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.76 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.76 query.py(1334):         target_clause = self.where_class(connector=connector,
0.76 query.py(1335):                                          negated=q_object.negated)
0.76 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.76 query.py(2227):         self.connector = connector
0.76 query.py(2228):         self.negated = negated
0.76 query.py(2229):         if self.negated:
0.76 query.py(2235):             self.effective_connector = self.connector
0.76 query.py(2236):         self.num_children = num_children
0.76 query.py(2239):         self.votes = Counter()
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1338):             if isinstance(child, Node):
0.76 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.76 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.76 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.76 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.76 query.py(1214):         if isinstance(filter_expr, dict):
0.76 query.py(1216):         arg, value = filter_expr
0.76 query.py(1217):         if not arg:
0.76 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.76 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.76 query.py(1074):         if self.annotations:
0.76 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.76 query.py(290):         return self.model._meta
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.76 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.76 query.py(1085):         return lookup_parts, field_parts, False
0.76 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.76 query.py(1227):         if not allow_joins and len(parts) > 1:
0.76 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.76 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.76 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.76 query.py(1055):         elif isinstance(value, (list, tuple)):
0.76 query.py(1067):         return value
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1234):         clause = self.where_class()
0.76 query.py(1235):         if reffed_expression:
0.76 query.py(1240):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1241):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.76 query.py(290):         return self.model._meta
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(917):         return alias
0.76 query.py(1242):         allow_many = not branch_negated or not split_subq
0.76 query.py(1244):         try:
0.76 query.py(1245):             join_info = self.setup_joins(
0.76 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.76 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1251):             if isinstance(value, Iterator):
0.76 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.76 query.py(1100):         if field.is_relation:
0.76 query.py(1257):             self._lookup_joins = join_info.joins
0.76 query.py(1263):         used_joins.update(join_info.joins)
0.76 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1265):         if can_reuse is not None:
0.76 query.py(1266):             can_reuse.update(join_list)
0.76 query.py(1268):         if join_info.final_field.is_relation:
0.76 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.76 query.py(72):     if simple_col:
0.76 query.py(74):     return target.get_col(alias, field)
0.76 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.76 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.76 query.py(1129):         for name in transforms:
0.76 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.76 query.py(1134):         if not lookup_class:
0.76 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.76 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.76 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(1161):         return lookup
0.76 query.py(1281):         lookup_type = condition.lookup_name
0.76 query.py(1282):         clause.add(condition, AND)
0.76 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.76 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.76 query.py(1302):         return clause, used_joins if not require_outer else ()
0.76 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.76 query.py(2246):         self.votes.update(votes)
0.76 query.py(1350):             if child_clause:
0.76 query.py(1351):                 target_clause.add(child_clause, connector)
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1338):             if isinstance(child, Node):
0.76 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.76 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.76 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.76 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.76 query.py(1214):         if isinstance(filter_expr, dict):
0.76 query.py(1216):         arg, value = filter_expr
0.76 query.py(1217):         if not arg:
0.76 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.76 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.76 query.py(1074):         if self.annotations:
0.76 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.76 query.py(290):         return self.model._meta
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.76 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.76 query.py(1085):         return lookup_parts, field_parts, False
0.76 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.76 query.py(1227):         if not allow_joins and len(parts) > 1:
0.76 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.76 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.76 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.76 query.py(1055):         elif isinstance(value, (list, tuple)):
0.76 query.py(1067):         return value
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1234):         clause = self.where_class()
0.76 query.py(1235):         if reffed_expression:
0.76 query.py(1240):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1241):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(250):         for alias in self.alias_map:
0.76 query.py(251):             return alias
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1242):         allow_many = not branch_negated or not split_subq
0.76 query.py(1244):         try:
0.76 query.py(1245):             join_info = self.setup_joins(
0.76 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.76 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1251):             if isinstance(value, Iterator):
0.76 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.76 query.py(1100):         if field.is_relation:
0.76 query.py(1257):             self._lookup_joins = join_info.joins
0.76 query.py(1263):         used_joins.update(join_info.joins)
0.76 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1265):         if can_reuse is not None:
0.76 query.py(1266):             can_reuse.update(join_list)
0.76 query.py(1268):         if join_info.final_field.is_relation:
0.76 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.76 query.py(72):     if simple_col:
0.76 query.py(74):     return target.get_col(alias, field)
0.76 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.76 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.76 query.py(1129):         for name in transforms:
0.76 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.76 query.py(1134):         if not lookup_class:
0.76 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.76 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.76 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(1161):         return lookup
0.76 query.py(1281):         lookup_type = condition.lookup_name
0.76 query.py(1282):         clause.add(condition, AND)
0.76 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.76 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.76 query.py(1302):         return clause, used_joins if not require_outer else ()
0.76 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.76 query.py(2246):         self.votes.update(votes)
0.76 query.py(1350):             if child_clause:
0.76 query.py(1351):                 target_clause.add(child_clause, connector)
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.76 query.py(2255):         to_promote = set()
0.76 query.py(2256):         to_demote = set()
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2282):             if self.effective_connector == 'AND' or (
0.76 query.py(2284):                 to_demote.add(table)
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2300):         query.promote_joins(to_promote)
0.76 query.py(771):         aliases = list(aliases)
0.76 query.py(772):         while aliases:
0.76 query.py(2301):         query.demote_joins(to_demote)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(2302):         return to_demote
0.76 query.py(1353):         return target_clause, needed_inner
0.76 query.py(1320):         if clause:
0.76 query.py(1321):             self.where.add(clause, AND)
0.76 query.py(1322):         self.demote_joins(existing_inner)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(1757):         return not self.low_mark and self.high_mark is None
0.76 query.py(1757):         return not self.low_mark and self.high_mark is None
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1855):         self.order_by = ()
0.76 query.py(1856):         self.extra_order_by = ()
0.76 query.py(1857):         if force_empty:
0.76 query.py(1834):         errors = []
0.76 query.py(1835):         for item in ordering:
0.76 query.py(1843):         if errors:
0.76 query.py(1845):         if ordering:
0.76 query.py(1848):             self.default_ordering = False
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(655):         field_names, defer = self.deferred_loading
0.76 query.py(656):         if not field_names:
0.76 query.py(657):             return
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(250):         for alias in self.alias_map:
0.76 query.py(251):             return alias
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(984):         if model in seen:
0.76 query.py(985):             return seen[model]
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1757):         return not self.low_mark and self.high_mark is None
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.76 query.py(1331):         connector = q_object.connector
0.76 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.76 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.76 query.py(1334):         target_clause = self.where_class(connector=connector,
0.76 query.py(1335):                                          negated=q_object.negated)
0.76 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.76 query.py(2227):         self.connector = connector
0.76 query.py(2228):         self.negated = negated
0.76 query.py(2229):         if self.negated:
0.76 query.py(2235):             self.effective_connector = self.connector
0.76 query.py(2236):         self.num_children = num_children
0.76 query.py(2239):         self.votes = Counter()
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1338):             if isinstance(child, Node):
0.76 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.76 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.76 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.76 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.76 query.py(1214):         if isinstance(filter_expr, dict):
0.76 query.py(1216):         arg, value = filter_expr
0.76 query.py(1217):         if not arg:
0.76 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.76 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.76 query.py(1074):         if self.annotations:
0.76 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.76 query.py(290):         return self.model._meta
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1415):             except FieldDoesNotExist:
0.76 query.py(1416):                 if name in self.annotation_select:
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.76 query.py(1421):             if field is not None:
0.76 query.py(1441):                 pos -= 1
0.76 query.py(1442):                 if pos == -1 or fail_on_missing:
0.76 query.py(1450):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.76 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.76 query.py(1085):         return lookup_parts, field_parts, False
0.76 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.76 query.py(1227):         if not allow_joins and len(parts) > 1:
0.76 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.76 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.76 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.76 query.py(1055):         elif isinstance(value, (list, tuple)):
0.76 query.py(1067):         return value
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1234):         clause = self.where_class()
0.76 query.py(1235):         if reffed_expression:
0.76 query.py(1240):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1241):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.76 query.py(290):         return self.model._meta
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(917):         return alias
0.76 query.py(1242):         allow_many = not branch_negated or not split_subq
0.76 query.py(1244):         try:
0.76 query.py(1245):             join_info = self.setup_joins(
0.76 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.76 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2184):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.76 query.py(969):                 join_type = INNER
0.76 query.py(970):             join.join_type = join_type
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1251):             if isinstance(value, Iterator):
0.76 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.76 query.py(1100):         if field.is_relation:
0.76 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.76 query.py(1112):             elif hasattr(value, '_meta'):
0.76 query.py(1114):             elif hasattr(value, '__iter__'):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.76 query.py(1092):         if hasattr(value, '_meta'):
0.76 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1257):             self._lookup_joins = join_info.joins
0.76 query.py(1263):         used_joins.update(join_info.joins)
0.76 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1613):             self.unref_alias(joins.pop())
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1265):         if can_reuse is not None:
0.76 query.py(1266):             can_reuse.update(join_list)
0.76 query.py(1268):         if join_info.final_field.is_relation:
0.76 query.py(1270):             num_lookups = len(lookups)
0.76 query.py(1271):             if num_lookups > 1:
0.76 query.py(1273):             if len(targets) == 1:
0.76 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.76 query.py(72):     if simple_col:
0.76 query.py(74):     return target.get_col(alias, field)
0.76 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.76 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.76 query.py(1129):         for name in transforms:
0.76 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.76 query.py(1134):         if not lookup_class:
0.76 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.76 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.76 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(1161):         return lookup
0.76 query.py(1281):         lookup_type = condition.lookup_name
0.76 query.py(1282):         clause.add(condition, AND)
0.76 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.76 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.76 query.py(1302):         return clause, used_joins if not require_outer else ()
0.76 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.76 query.py(2246):         self.votes.update(votes)
0.76 query.py(1350):             if child_clause:
0.76 query.py(1351):                 target_clause.add(child_clause, connector)
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.76 query.py(2255):         to_promote = set()
0.76 query.py(2256):         to_demote = set()
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2282):             if self.effective_connector == 'AND' or (
0.76 query.py(2284):                 to_demote.add(table)
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2282):             if self.effective_connector == 'AND' or (
0.76 query.py(2284):                 to_demote.add(table)
0.76 query.py(2259):         for table, votes in self.votes.items():
0.76 query.py(2300):         query.promote_joins(to_promote)
0.76 query.py(771):         aliases = list(aliases)
0.76 query.py(772):         while aliases:
0.76 query.py(2301):         query.demote_joins(to_demote)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(2302):         return to_demote
0.76 query.py(1353):         return target_clause, needed_inner
0.76 query.py(1320):         if clause:
0.76 query.py(1321):             self.where.add(clause, AND)
0.76 query.py(1322):         self.demote_joins(existing_inner)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(2030):         self.select_related = False
0.76 query.py(2031):         self.clear_deferred_loading()
0.76 query.py(1937):         self.deferred_loading = (frozenset(), True)
0.76 query.py(2032):         self.clear_select_fields()
0.76 query.py(1773):         self.select = ()
0.76 query.py(1774):         self.values_select = ()
0.76 query.py(2034):         if self.group_by is True:
0.76 query.py(2039):         if fields:
0.76 query.py(2040):             field_names = []
0.76 query.py(2041):             extra_names = []
0.76 query.py(2042):             annotation_names = []
0.76 query.py(2043):             if not self.extra and not self.annotations:
0.76 query.py(2046):                 field_names = list(fields)
0.76 query.py(2056):             self.set_extra_mask(extra_names)
0.76 query.py(2023):         if names is None:
0.76 query.py(2026):             self.extra_select_mask = set(names)
0.76 query.py(2027):         self._extra_select_cache = None
0.76 query.py(2057):             self.set_annotation_mask(annotation_names)
0.76 query.py(2008):         if names is None:
0.76 query.py(2011):             self.annotation_select_mask = set(names)
0.76 query.py(2012):         self._annotation_select_cache = None
0.76 query.py(2061):         self.values_select = tuple(field_names)
0.76 query.py(2062):         self.add_fields(field_names, True)
0.76 query.py(1792):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(250):         for alias in self.alias_map:
0.76 query.py(251):             return alias
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1793):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1795):         try:
0.76 query.py(1796):             cols = []
0.76 query.py(1797):             for name in field_names:
0.76 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2184):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.76 query.py(1802):                     join_info.targets,
0.76 query.py(1803):                     join_info.joins,
0.76 query.py(1804):                     join_info.path,
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1613):             self.unref_alias(joins.pop())
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1806):                 for target in targets:
0.76 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(1806):                 for target in targets:
0.76 query.py(1797):             for name in field_names:
0.76 query.py(1800):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1801):                 targets, final_alias, joins = self.trim_joins(
0.76 query.py(1802):                     join_info.targets,
0.76 query.py(1803):                     join_info.joins,
0.76 query.py(1804):                     join_info.path,
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1806):                 for target in targets:
0.76 query.py(1807):                     cols.append(join_info.transform_function(target, final_alias))
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(1806):                 for target in targets:
0.76 query.py(1797):             for name in field_names:
0.76 query.py(1808):             if cols:
0.76 query.py(1809):                 self.set_select(cols)
0.76 query.py(1777):         self.default_cols = False
0.76 query.py(1778):         self.select = tuple(cols)
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(290):         return self.model._meta
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2184):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1610):                 break
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2182):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2184):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1610):                 break
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(2070):         if self._annotation_select_cache is not None:
0.76 query.py(2072):         elif not self.annotations:
0.76 query.py(2073):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(2195):     dirn = ORDER_DIR[default]
0.76 query.py(2196):     if field[0] == '-':
0.76 query.py(2198):     return field, dirn[0]
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(2085):         if self._extra_select_cache is not None:
0.76 query.py(2087):         if not self.extra:
0.76 query.py(2088):             return {}
0.76 query.py(290):         return self.model._meta
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 query.py(290):         return self.model._meta
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(278):         if using is None and connection is None:
0.77 query.py(280):         if using:
0.77 query.py(281):             connection = connections[using]
0.77 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.77 query.py(912):         if self.alias_map:
0.77 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.77 query.py(290):         return self.model._meta
0.77 query.py(943):         if reuse_with_filtered_relation and reuse:
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(953):         if reuse_aliases:
0.77 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.77 query.py(735):         alias_list = self.table_map.get(table_name)
0.77 query.py(736):         if not create and alias_list:
0.77 query.py(742):         if alias_list:
0.77 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.77 query.py(748):             self.table_map[table_name] = [alias]
0.77 query.py(749):         self.alias_refcount[alias] = 1
0.77 query.py(750):         return alias, True
0.77 query.py(965):         if join.join_type:
0.77 query.py(971):         join.table_alias = alias
0.77 query.py(972):         self.alias_map[alias] = join
0.77 query.py(973):         return alias
0.77 query.py(917):         return alias
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(290):         return self.model._meta
0.77 query.py(655):         field_names, defer = self.deferred_loading
0.77 query.py(656):         if not field_names:
0.77 query.py(657):             return
0.77 query.py(912):         if self.alias_map:
0.77 query.py(913):             alias = self.base_table
0.77 query.py(250):         for alias in self.alias_map:
0.77 query.py(251):             return alias
0.77 query.py(914):             self.ref_alias(alias)
0.77 query.py(754):         self.alias_refcount[alias] += 1
0.77 query.py(917):         return alias
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 query.py(2070):         if self._annotation_select_cache is not None:
0.77 query.py(2072):         elif not self.annotations:
0.77 query.py(2073):             return {}
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(2085):         if self._extra_select_cache is not None:
0.77 query.py(2087):         if not self.extra:
0.77 query.py(2088):             return {}
0.77 query.py(290):         return self.model._meta
0.77 query.py(290):         return self.model._meta
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.77 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.77 query.py(820):             self.unref_alias(alias, unref_amount)
0.77 query.py(758):         self.alias_refcount[alias] -= amount
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 query.py(154):         self.model = model
0.80 query.py(155):         self.alias_refcount = {}
0.80 query.py(161):         self.alias_map = {}
0.80 query.py(165):         self.external_aliases = set()
0.80 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.80 query.py(167):         self.default_cols = True
0.80 query.py(168):         self.default_ordering = True
0.80 query.py(169):         self.standard_ordering = True
0.80 query.py(170):         self.used_aliases = set()
0.80 query.py(171):         self.filter_is_sticky = False
0.80 query.py(172):         self.subquery = False
0.80 query.py(180):         self.select = ()
0.80 query.py(181):         self.where = where()
0.80 query.py(182):         self.where_class = where
0.80 query.py(189):         self.group_by = None
0.80 query.py(190):         self.order_by = ()
0.80 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.80 query.py(192):         self.distinct = False
0.80 query.py(193):         self.distinct_fields = ()
0.80 query.py(194):         self.select_for_update = False
0.80 query.py(195):         self.select_for_update_nowait = False
0.80 query.py(196):         self.select_for_update_skip_locked = False
0.80 query.py(197):         self.select_for_update_of = ()
0.80 query.py(199):         self.select_related = False
0.80 query.py(201):         self.max_depth = 5
0.80 query.py(205):         self.values_select = ()
0.80 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.80 query.py(209):         self.annotation_select_mask = None
0.80 query.py(210):         self._annotation_select_cache = None
0.80 query.py(213):         self.combinator = None
0.80 query.py(214):         self.combinator_all = False
0.80 query.py(215):         self.combined_queries = ()
0.80 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.80 query.py(220):         self.extra_select_mask = None
0.80 query.py(221):         self._extra_select_cache = None
0.80 query.py(223):         self.extra_tables = ()
0.80 query.py(224):         self.extra_order_by = ()
0.80 query.py(229):         self.deferred_loading = (frozenset(), True)
0.80 query.py(231):         self._filtered_relations = {}
0.80 query.py(233):         self.explain_query = False
0.80 query.py(234):         self.explain_format = None
0.80 query.py(235):         self.explain_options = {}
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1757):         return not self.low_mark and self.high_mark is None
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1855):         self.order_by = ()
0.80 query.py(1856):         self.extra_order_by = ()
0.80 query.py(1857):         if force_empty:
0.80 query.py(1834):         errors = []
0.80 query.py(1835):         for item in ordering:
0.80 query.py(1836):             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):
0.80 query.py(1838):             if getattr(item, 'contains_aggregate', False):
0.80 query.py(1835):         for item in ordering:
0.80 query.py(1843):         if errors:
0.80 query.py(1845):         if ordering:
0.80 query.py(1846):             self.order_by += ordering
0.80 query.py(278):         if using is None and connection is None:
0.80 query.py(280):         if using:
0.80 query.py(281):             connection = connections[using]
0.80 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.80 query.py(912):         if self.alias_map:
0.80 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.80 query.py(290):         return self.model._meta
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.80 query.py(735):         alias_list = self.table_map.get(table_name)
0.80 query.py(736):         if not create and alias_list:
0.80 query.py(742):         if alias_list:
0.80 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.80 query.py(748):             self.table_map[table_name] = [alias]
0.80 query.py(749):         self.alias_refcount[alias] = 1
0.80 query.py(750):         return alias, True
0.80 query.py(965):         if join.join_type:
0.80 query.py(971):         join.table_alias = alias
0.80 query.py(972):         self.alias_map[alias] = join
0.80 query.py(973):         return alias
0.80 query.py(917):         return alias
0.80 query.py(2085):         if self._extra_select_cache is not None:
0.80 query.py(2087):         if not self.extra:
0.80 query.py(2088):             return {}
0.80 query.py(290):         return self.model._meta
0.80 query.py(655):         field_names, defer = self.deferred_loading
0.80 query.py(656):         if not field_names:
0.80 query.py(657):             return
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(250):         for alias in self.alias_map:
0.80 query.py(251):             return alias
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 query.py(2070):         if self._annotation_select_cache is not None:
0.80 query.py(2072):         elif not self.annotations:
0.80 query.py(2073):             return {}
0.80 query.py(2085):         if self._extra_select_cache is not None:
0.80 query.py(2087):         if not self.extra:
0.80 query.py(2088):             return {}
0.80 query.py(2085):         if self._extra_select_cache is not None:
0.80 query.py(2087):         if not self.extra:
0.80 query.py(2088):             return {}
0.80 query.py(2085):         if self._extra_select_cache is not None:
0.80 query.py(2087):         if not self.extra:
0.80 query.py(2088):             return {}
0.80 query.py(2085):         if self._extra_select_cache is not None:
0.80 query.py(2087):         if not self.extra:
0.80 query.py(2088):             return {}
0.80 query.py(2195):     dirn = ORDER_DIR[default]
0.80 query.py(2196):     if field[0] == '-':
0.80 query.py(2198):     return field, dirn[0]
0.80 query.py(2070):         if self._annotation_select_cache is not None:
0.80 query.py(2072):         elif not self.annotations:
0.80 query.py(2073):             return {}
0.80 query.py(290):         return self.model._meta
0.80 query.py(2195):     dirn = ORDER_DIR[default]
0.80 query.py(2196):     if field[0] == '-':
0.80 query.py(2198):     return field, dirn[0]
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1525):             return field.get_col(alias)
0.80 query.py(290):         return self.model._meta
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.80 query.py(820):             self.unref_alias(alias, unref_amount)
0.80 query.py(758):         self.alias_refcount[alias] -= amount
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 query.py(154):         self.model = model
0.80 query.py(155):         self.alias_refcount = {}
0.80 query.py(161):         self.alias_map = {}
0.80 query.py(165):         self.external_aliases = set()
0.80 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.80 query.py(167):         self.default_cols = True
0.80 query.py(168):         self.default_ordering = True
0.80 query.py(169):         self.standard_ordering = True
0.80 query.py(170):         self.used_aliases = set()
0.80 query.py(171):         self.filter_is_sticky = False
0.80 query.py(172):         self.subquery = False
0.80 query.py(180):         self.select = ()
0.80 query.py(181):         self.where = where()
0.80 query.py(182):         self.where_class = where
0.80 query.py(189):         self.group_by = None
0.80 query.py(190):         self.order_by = ()
0.80 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.80 query.py(192):         self.distinct = False
0.80 query.py(193):         self.distinct_fields = ()
0.80 query.py(194):         self.select_for_update = False
0.80 query.py(195):         self.select_for_update_nowait = False
0.80 query.py(196):         self.select_for_update_skip_locked = False
0.80 query.py(197):         self.select_for_update_of = ()
0.80 query.py(199):         self.select_related = False
0.80 query.py(201):         self.max_depth = 5
0.80 query.py(205):         self.values_select = ()
0.80 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.80 query.py(209):         self.annotation_select_mask = None
0.80 query.py(210):         self._annotation_select_cache = None
0.80 query.py(213):         self.combinator = None
0.80 query.py(214):         self.combinator_all = False
0.80 query.py(215):         self.combined_queries = ()
0.80 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.80 query.py(220):         self.extra_select_mask = None
0.80 query.py(221):         self._extra_select_cache = None
0.80 query.py(223):         self.extra_tables = ()
0.80 query.py(224):         self.extra_order_by = ()
0.80 query.py(229):         self.deferred_loading = (frozenset(), True)
0.80 query.py(231):         self._filtered_relations = {}
0.80 query.py(233):         self.explain_query = False
0.80 query.py(234):         self.explain_format = None
0.80 query.py(235):         self.explain_options = {}
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1757):         return not self.low_mark and self.high_mark is None
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.81 query.py(1855):         self.order_by = ()
0.81 query.py(1856):         self.extra_order_by = ()
0.81 query.py(1857):         if force_empty:
0.81 query.py(1834):         errors = []
0.81 query.py(1835):         for item in ordering:
0.81 query.py(1836):             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):
0.81 query.py(1838):             if getattr(item, 'contains_aggregate', False):
0.81 query.py(1835):         for item in ordering:
0.81 query.py(1843):         if errors:
0.81 query.py(1845):         if ordering:
0.81 query.py(1846):             self.order_by += ordering
0.81 query.py(278):         if using is None and connection is None:
0.81 query.py(280):         if using:
0.81 query.py(281):             connection = connections[using]
0.81 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.81 query.py(912):         if self.alias_map:
0.81 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.81 query.py(290):         return self.model._meta
0.81 query.py(943):         if reuse_with_filtered_relation and reuse:
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(953):         if reuse_aliases:
0.81 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.81 query.py(735):         alias_list = self.table_map.get(table_name)
0.81 query.py(736):         if not create and alias_list:
0.81 query.py(742):         if alias_list:
0.81 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.81 query.py(748):             self.table_map[table_name] = [alias]
0.81 query.py(749):         self.alias_refcount[alias] = 1
0.81 query.py(750):         return alias, True
0.81 query.py(965):         if join.join_type:
0.81 query.py(971):         join.table_alias = alias
0.81 query.py(972):         self.alias_map[alias] = join
0.81 query.py(973):         return alias
0.81 query.py(917):         return alias
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(290):         return self.model._meta
0.81 query.py(655):         field_names, defer = self.deferred_loading
0.81 query.py(656):         if not field_names:
0.81 query.py(657):             return
0.81 query.py(912):         if self.alias_map:
0.81 query.py(913):             alias = self.base_table
0.81 query.py(250):         for alias in self.alias_map:
0.81 query.py(251):             return alias
0.81 query.py(914):             self.ref_alias(alias)
0.81 query.py(754):         self.alias_refcount[alias] += 1
0.81 query.py(917):         return alias
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 query.py(2070):         if self._annotation_select_cache is not None:
0.81 query.py(2072):         elif not self.annotations:
0.81 query.py(2073):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
test_check_constraint_sql_generation (test_coverup_django__django-11299.CheckConstraintSQLTest) ...  query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2085):         if self._extra_select_cache is not None:
0.81 query.py(2087):         if not self.extra:
0.81 query.py(2088):             return {}
0.81 query.py(2195):     dirn = ORDER_DIR[default]
0.81 query.py(2196):     if field[0] == '-':
0.81 query.py(2198):     return field, dirn[0]
0.81 query.py(2070):         if self._annotation_select_cache is not None:
0.81 query.py(2072):         elif not self.annotations:
0.81 query.py(2073):             return {}
0.81 query.py(290):         return self.model._meta
0.81 query.py(2195):     dirn = ORDER_DIR[default]
0.81 query.py(2196):     if field[0] == '-':
0.81 query.py(2198):     return field, dirn[0]
0.81 query.py(912):         if self.alias_map:
0.81 query.py(913):             alias = self.base_table
0.81 query.py(914):             self.ref_alias(alias)
0.81 query.py(754):         self.alias_refcount[alias] += 1
0.81 query.py(917):         return alias
0.81 query.py(1518):         joins = [alias]
0.81 query.py(1524):         def final_transformer(field, alias):
0.81 query.py(1529):         last_field_exception = None
0.81 query.py(1530):         for pivot in range(len(names), 0, -1):
0.81 query.py(1531):             try:
0.81 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.81 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1545):                 transforms = names[pivot:]
0.81 query.py(1546):                 break
0.81 query.py(1547):         for name in transforms:
0.81 query.py(1562):         for join in path:
0.81 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.81 query.py(1601):         joins = joins[:]
0.81 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.81 query.py(1614):         return targets, joins[-1], joins
0.81 query.py(1525):             return field.get_col(alias)
0.81 query.py(290):         return self.model._meta
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.81 query.py(820):             self.unref_alias(alias, unref_amount)
0.81 query.py(758):         self.alias_refcount[alias] -= amount
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
System check identified no issues (0 silenced).
0.85 query.py(154):         self.model = model
0.85 query.py(155):         self.alias_refcount = {}
0.85 query.py(161):         self.alias_map = {}
0.85 query.py(165):         self.external_aliases = set()
0.85 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.85 query.py(167):         self.default_cols = True
0.85 query.py(168):         self.default_ordering = True
0.85 query.py(169):         self.standard_ordering = True
0.85 query.py(170):         self.used_aliases = set()
0.85 query.py(171):         self.filter_is_sticky = False
0.85 query.py(172):         self.subquery = False
0.85 query.py(180):         self.select = ()
0.85 query.py(181):         self.where = where()
0.85 query.py(182):         self.where_class = where
0.85 query.py(189):         self.group_by = None
0.85 query.py(190):         self.order_by = ()
0.85 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.85 query.py(192):         self.distinct = False
0.85 query.py(193):         self.distinct_fields = ()
0.85 query.py(194):         self.select_for_update = False
0.85 query.py(195):         self.select_for_update_nowait = False
0.85 query.py(196):         self.select_for_update_skip_locked = False
0.85 query.py(197):         self.select_for_update_of = ()
0.85 query.py(199):         self.select_related = False
0.85 query.py(201):         self.max_depth = 5
0.85 query.py(205):         self.values_select = ()
0.85 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.85 query.py(209):         self.annotation_select_mask = None
0.85 query.py(210):         self._annotation_select_cache = None
0.85 query.py(213):         self.combinator = None
0.85 query.py(214):         self.combinator_all = False
0.85 query.py(215):         self.combined_queries = ()
0.85 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.85 query.py(220):         self.extra_select_mask = None
0.85 query.py(221):         self._extra_select_cache = None
0.85 query.py(223):         self.extra_tables = ()
0.85 query.py(224):         self.extra_order_by = ()
0.85 query.py(229):         self.deferred_loading = (frozenset(), True)
0.85 query.py(231):         self._filtered_relations = {}
0.85 query.py(233):         self.explain_query = False
0.85 query.py(234):         self.explain_format = None
0.85 query.py(235):         self.explain_options = {}
0.85 query.py(1325):         return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True)[0]
0.85 query.py(1331):         connector = q_object.connector
0.85 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.85 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.85 query.py(1334):         target_clause = self.where_class(connector=connector,
0.85 query.py(1335):                                          negated=q_object.negated)
0.85 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.85 query.py(2227):         self.connector = connector
0.85 query.py(2228):         self.negated = negated
0.85 query.py(2229):         if self.negated:
0.85 query.py(2235):             self.effective_connector = self.connector
0.85 query.py(2236):         self.num_children = num_children
0.85 query.py(2239):         self.votes = Counter()
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1339):                 child_clause, needed_inner = self._add_q(
0.85 query.py(1340):                     child, used_aliases, branch_negated,
0.85 query.py(1341):                     current_negated, allow_joins, split_subq)
0.85 query.py(1331):         connector = q_object.connector
0.85 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.85 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.85 query.py(1334):         target_clause = self.where_class(connector=connector,
0.85 query.py(1335):                                          negated=q_object.negated)
0.85 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.85 query.py(2227):         self.connector = connector
0.85 query.py(2228):         self.negated = negated
0.85 query.py(2229):         if self.negated:
0.85 query.py(2235):             self.effective_connector = self.connector
0.85 query.py(2236):         self.num_children = num_children
0.85 query.py(2239):         self.votes = Counter()
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.85 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.85 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.85 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.85 query.py(1214):         if isinstance(filter_expr, dict):
0.85 query.py(1216):         arg, value = filter_expr
0.85 query.py(1217):         if not arg:
0.85 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.85 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.85 query.py(1074):         if self.annotations:
0.85 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.85 query.py(290):         return self.model._meta
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.85 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.85 query.py(1085):         return lookup_parts, field_parts, False
0.85 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.85 query.py(1227):         if not allow_joins and len(parts) > 1:
0.85 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.85 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.85 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.85 query.py(1055):         elif isinstance(value, (list, tuple)):
0.85 query.py(1067):         return value
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1234):         clause = self.where_class()
0.85 query.py(1235):         if reffed_expression:
0.85 query.py(1240):         opts = self.get_meta()
0.85 query.py(290):         return self.model._meta
0.85 query.py(1241):         alias = self.get_initial_alias()
0.85 query.py(912):         if self.alias_map:
0.85 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.85 query.py(290):         return self.model._meta
0.85 query.py(943):         if reuse_with_filtered_relation and reuse:
0.85 query.py(950):                 a for a, j in self.alias_map.items()
0.85 query.py(950):                 a for a, j in self.alias_map.items()
0.85 query.py(953):         if reuse_aliases:
0.85 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.85 query.py(735):         alias_list = self.table_map.get(table_name)
0.85 query.py(736):         if not create and alias_list:
0.85 query.py(742):         if alias_list:
0.85 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.85 query.py(748):             self.table_map[table_name] = [alias]
0.85 query.py(749):         self.alias_refcount[alias] = 1
0.85 query.py(750):         return alias, True
0.85 query.py(965):         if join.join_type:
0.85 query.py(971):         join.table_alias = alias
0.85 query.py(972):         self.alias_map[alias] = join
0.85 query.py(973):         return alias
0.85 query.py(917):         return alias
0.85 query.py(1242):         allow_many = not branch_negated or not split_subq
0.85 query.py(1244):         try:
0.85 query.py(1245):             join_info = self.setup_joins(
0.85 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.85 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.85 query.py(1518):         joins = [alias]
0.85 query.py(1524):         def final_transformer(field, alias):
0.85 query.py(1529):         last_field_exception = None
0.85 query.py(1530):         for pivot in range(len(names), 0, -1):
0.85 query.py(1531):             try:
0.85 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.85 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1545):                 transforms = names[pivot:]
0.85 query.py(1546):                 break
0.85 query.py(1547):         for name in transforms:
0.85 query.py(1562):         for join in path:
0.85 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.85 query.py(1251):             if isinstance(value, Iterator):
0.85 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.85 query.py(1100):         if field.is_relation:
0.85 query.py(1257):             self._lookup_joins = join_info.joins
0.85 query.py(1263):         used_joins.update(join_info.joins)
0.85 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.85 query.py(1601):         joins = joins[:]
0.85 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.85 query.py(1614):         return targets, joins[-1], joins
0.85 query.py(1265):         if can_reuse is not None:
0.85 query.py(1266):             can_reuse.update(join_list)
0.85 query.py(1268):         if join_info.final_field.is_relation:
0.85 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.85 query.py(72):     if simple_col:
0.85 query.py(74):     return target.get_col(alias, field)
0.85 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.85 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.85 query.py(1129):         for name in transforms:
0.85 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.85 query.py(1134):         if not lookup_class:
0.85 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.85 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.85 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.85 query.py(1161):         return lookup
0.85 query.py(1281):         lookup_type = condition.lookup_name
0.85 query.py(1282):         clause.add(condition, AND)
0.85 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.85 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.85 query.py(1302):         return clause, used_joins if not require_outer else ()
0.85 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.85 query.py(2246):         self.votes.update(votes)
0.85 query.py(1350):             if child_clause:
0.85 query.py(1351):                 target_clause.add(child_clause, connector)
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.85 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.85 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.85 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.85 query.py(1214):         if isinstance(filter_expr, dict):
0.85 query.py(1216):         arg, value = filter_expr
0.85 query.py(1217):         if not arg:
0.85 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.85 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.85 query.py(1074):         if self.annotations:
0.85 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.85 query.py(290):         return self.model._meta
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.85 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.85 query.py(1085):         return lookup_parts, field_parts, False
0.85 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.85 query.py(1227):         if not allow_joins and len(parts) > 1:
0.85 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.85 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.85 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.85 query.py(1055):         elif isinstance(value, (list, tuple)):
0.85 query.py(1067):         return value
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1234):         clause = self.where_class()
0.85 query.py(1235):         if reffed_expression:
0.85 query.py(1240):         opts = self.get_meta()
0.85 query.py(290):         return self.model._meta
0.85 query.py(1241):         alias = self.get_initial_alias()
0.85 query.py(912):         if self.alias_map:
0.85 query.py(913):             alias = self.base_table
0.85 query.py(250):         for alias in self.alias_map:
0.85 query.py(251):             return alias
0.85 query.py(914):             self.ref_alias(alias)
0.85 query.py(754):         self.alias_refcount[alias] += 1
0.85 query.py(917):         return alias
0.85 query.py(1242):         allow_many = not branch_negated or not split_subq
0.85 query.py(1244):         try:
0.85 query.py(1245):             join_info = self.setup_joins(
0.85 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.85 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.85 query.py(1518):         joins = [alias]
0.85 query.py(1524):         def final_transformer(field, alias):
0.85 query.py(1529):         last_field_exception = None
0.85 query.py(1530):         for pivot in range(len(names), 0, -1):
0.85 query.py(1531):             try:
0.85 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.85 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1545):                 transforms = names[pivot:]
0.85 query.py(1546):                 break
0.85 query.py(1547):         for name in transforms:
0.85 query.py(1562):         for join in path:
0.85 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.85 query.py(1251):             if isinstance(value, Iterator):
0.85 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.85 query.py(1100):         if field.is_relation:
0.85 query.py(1257):             self._lookup_joins = join_info.joins
0.85 query.py(1263):         used_joins.update(join_info.joins)
0.85 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.85 query.py(1601):         joins = joins[:]
0.85 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.85 query.py(1614):         return targets, joins[-1], joins
0.85 query.py(1265):         if can_reuse is not None:
0.85 query.py(1266):             can_reuse.update(join_list)
0.85 query.py(1268):         if join_info.final_field.is_relation:
0.85 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.85 query.py(72):     if simple_col:
0.85 query.py(74):     return target.get_col(alias, field)
0.85 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.85 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.85 query.py(1129):         for name in transforms:
0.85 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.85 query.py(1134):         if not lookup_class:
0.85 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.85 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.85 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.85 query.py(1161):         return lookup
0.85 query.py(1281):         lookup_type = condition.lookup_name
0.85 query.py(1282):         clause.add(condition, AND)
0.85 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.85 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.85 query.py(1302):         return clause, used_joins if not require_outer else ()
0.85 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.85 query.py(2246):         self.votes.update(votes)
0.85 query.py(1350):             if child_clause:
0.85 query.py(1351):                 target_clause.add(child_clause, connector)
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.85 query.py(2255):         to_promote = set()
0.85 query.py(2256):         to_demote = set()
0.85 query.py(2259):         for table, votes in self.votes.items():
0.85 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.85 query.py(2282):             if self.effective_connector == 'AND' or (
0.85 query.py(2284):                 to_demote.add(table)
0.85 query.py(2259):         for table, votes in self.votes.items():
0.85 query.py(2300):         query.promote_joins(to_promote)
0.85 query.py(771):         aliases = list(aliases)
0.85 query.py(772):         while aliases:
0.85 query.py(2301):         query.demote_joins(to_demote)
0.85 query.py(804):         aliases = list(aliases)
0.85 query.py(805):         while aliases:
0.85 query.py(806):             alias = aliases.pop(0)
0.85 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.85 query.py(805):         while aliases:
0.85 query.py(2302):         return to_demote
0.85 query.py(1353):         return target_clause, needed_inner
0.85 query.py(1342):                 joinpromoter.add_votes(needed_inner)
0.85 query.py(2246):         self.votes.update(votes)
0.85 query.py(1350):             if child_clause:
0.85 query.py(1351):                 target_clause.add(child_clause, connector)
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.85 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.85 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.85 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.85 query.py(1214):         if isinstance(filter_expr, dict):
0.85 query.py(1216):         arg, value = filter_expr
0.85 query.py(1217):         if not arg:
0.85 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.85 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.85 query.py(1074):         if self.annotations:
0.85 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.85 query.py(290):         return self.model._meta
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.85 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.85 query.py(1085):         return lookup_parts, field_parts, False
0.85 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.85 query.py(1227):         if not allow_joins and len(parts) > 1:
0.85 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.85 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.85 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.85 query.py(1055):         elif isinstance(value, (list, tuple)):
0.85 query.py(1067):         return value
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1234):         clause = self.where_class()
0.85 query.py(1235):         if reffed_expression:
0.85 query.py(1240):         opts = self.get_meta()
0.85 query.py(290):         return self.model._meta
0.85 query.py(1241):         alias = self.get_initial_alias()
0.85 query.py(912):         if self.alias_map:
0.85 query.py(913):             alias = self.base_table
0.85 query.py(914):             self.ref_alias(alias)
0.85 query.py(754):         self.alias_refcount[alias] += 1
0.85 query.py(917):         return alias
0.85 query.py(1242):         allow_many = not branch_negated or not split_subq
0.85 query.py(1244):         try:
0.85 query.py(1245):             join_info = self.setup_joins(
0.85 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.85 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.85 query.py(1518):         joins = [alias]
0.85 query.py(1524):         def final_transformer(field, alias):
0.85 query.py(1529):         last_field_exception = None
0.85 query.py(1530):         for pivot in range(len(names), 0, -1):
0.85 query.py(1531):             try:
0.85 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.85 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1545):                 transforms = names[pivot:]
0.85 query.py(1546):                 break
0.85 query.py(1547):         for name in transforms:
0.85 query.py(1562):         for join in path:
0.85 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.85 query.py(1251):             if isinstance(value, Iterator):
0.85 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.85 query.py(1100):         if field.is_relation:
0.85 query.py(1257):             self._lookup_joins = join_info.joins
0.85 query.py(1263):         used_joins.update(join_info.joins)
0.85 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.85 query.py(1601):         joins = joins[:]
0.85 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.85 query.py(1614):         return targets, joins[-1], joins
0.85 query.py(1265):         if can_reuse is not None:
0.85 query.py(1266):             can_reuse.update(join_list)
0.85 query.py(1268):         if join_info.final_field.is_relation:
0.85 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.85 query.py(72):     if simple_col:
0.85 query.py(73):         return SimpleCol(target, field)
0.85 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.85 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.85 query.py(1129):         for name in transforms:
0.85 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.85 query.py(1134):         if not lookup_class:
0.85 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.85 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.85 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.85 query.py(1161):         return lookup
0.85 query.py(1281):         lookup_type = condition.lookup_name
0.85 query.py(1282):         clause.add(condition, AND)
0.85 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.85 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.85 query.py(1302):         return clause, used_joins if not require_outer else ()
0.85 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.85 query.py(2246):         self.votes.update(votes)
0.85 query.py(1350):             if child_clause:
0.85 query.py(1351):                 target_clause.add(child_clause, connector)
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.85 query.py(2255):         to_promote = set()
0.85 query.py(2256):         to_demote = set()
0.85 query.py(2259):         for table, votes in self.votes.items():
0.85 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.85 query.py(2282):             if self.effective_connector == 'AND' or (
0.85 query.py(2283):                     self.effective_connector == 'OR' and votes == self.num_children):
0.85 query.py(2284):                 to_demote.add(table)
0.85 query.py(2259):         for table, votes in self.votes.items():
0.85 query.py(2300):         query.promote_joins(to_promote)
0.85 query.py(771):         aliases = list(aliases)
0.85 query.py(772):         while aliases:
0.85 query.py(2301):         query.demote_joins(to_demote)
0.85 query.py(804):         aliases = list(aliases)
0.85 query.py(805):         while aliases:
0.85 query.py(806):             alias = aliases.pop(0)
0.85 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.85 query.py(805):         while aliases:
0.85 query.py(2302):         return to_demote
0.85 query.py(1353):         return target_clause, needed_inner
0.85 query.py(278):         if using is None and connection is None:
0.85 query.py(280):         if using:
0.85 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.85 query.py(2085):         if self._extra_select_cache is not None:
0.85 query.py(2087):         if not self.extra:
0.85 query.py(2088):             return {}
0.85 query.py(2085):         if self._extra_select_cache is not None:
0.85 query.py(2087):         if not self.extra:
0.85 query.py(2088):             return {}
0.85 query.py(2085):         if self._extra_select_cache is not None:
0.85 query.py(2087):         if not self.extra:
0.85 query.py(2088):             return {}
0.85 query.py(154):         self.model = model
0.85 query.py(155):         self.alias_refcount = {}
0.85 query.py(161):         self.alias_map = {}
0.85 query.py(165):         self.external_aliases = set()
0.85 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.85 query.py(167):         self.default_cols = True
0.85 query.py(168):         self.default_ordering = True
0.85 query.py(169):         self.standard_ordering = True
0.85 query.py(170):         self.used_aliases = set()
0.85 query.py(171):         self.filter_is_sticky = False
0.85 query.py(172):         self.subquery = False
0.85 query.py(180):         self.select = ()
0.85 query.py(181):         self.where = where()
0.85 query.py(182):         self.where_class = where
0.85 query.py(189):         self.group_by = None
0.85 query.py(190):         self.order_by = ()
0.85 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.85 query.py(192):         self.distinct = False
0.85 query.py(193):         self.distinct_fields = ()
0.85 query.py(194):         self.select_for_update = False
0.85 query.py(195):         self.select_for_update_nowait = False
0.85 query.py(196):         self.select_for_update_skip_locked = False
0.85 query.py(197):         self.select_for_update_of = ()
0.85 query.py(199):         self.select_related = False
0.85 query.py(201):         self.max_depth = 5
0.85 query.py(205):         self.values_select = ()
0.85 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.85 query.py(209):         self.annotation_select_mask = None
0.85 query.py(210):         self._annotation_select_cache = None
0.85 query.py(213):         self.combinator = None
0.85 query.py(214):         self.combinator_all = False
0.85 query.py(215):         self.combined_queries = ()
0.85 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.85 query.py(220):         self.extra_select_mask = None
0.85 query.py(221):         self._extra_select_cache = None
0.85 query.py(223):         self.extra_tables = ()
0.85 query.py(224):         self.extra_order_by = ()
0.85 query.py(229):         self.deferred_loading = (frozenset(), True)
0.85 query.py(231):         self._filtered_relations = {}
0.85 query.py(233):         self.explain_query = False
0.85 query.py(234):         self.explain_format = None
0.85 query.py(235):         self.explain_options = {}
0.85 query.py(1325):         return self._add_q(q_object, used_aliases=set(), allow_joins=False, simple_col=True)[0]
0.85 query.py(1331):         connector = q_object.connector
0.85 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.85 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.85 query.py(1334):         target_clause = self.where_class(connector=connector,
0.85 query.py(1335):                                          negated=q_object.negated)
0.85 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.85 query.py(2227):         self.connector = connector
0.85 query.py(2228):         self.negated = negated
0.85 query.py(2229):         if self.negated:
0.85 query.py(2235):             self.effective_connector = self.connector
0.85 query.py(2236):         self.num_children = num_children
0.85 query.py(2239):         self.votes = Counter()
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1339):                 child_clause, needed_inner = self._add_q(
0.85 query.py(1340):                     child, used_aliases, branch_negated,
0.85 query.py(1341):                     current_negated, allow_joins, split_subq)
0.85 query.py(1331):         connector = q_object.connector
0.85 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.85 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.85 query.py(1334):         target_clause = self.where_class(connector=connector,
0.85 query.py(1335):                                          negated=q_object.negated)
0.85 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.85 query.py(2227):         self.connector = connector
0.85 query.py(2228):         self.negated = negated
0.85 query.py(2229):         if self.negated:
0.85 query.py(2235):             self.effective_connector = self.connector
0.85 query.py(2236):         self.num_children = num_children
0.85 query.py(2239):         self.votes = Counter()
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.85 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.85 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.85 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.85 query.py(1214):         if isinstance(filter_expr, dict):
0.85 query.py(1216):         arg, value = filter_expr
0.85 query.py(1217):         if not arg:
0.85 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.85 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.85 query.py(1074):         if self.annotations:
0.85 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.85 query.py(290):         return self.model._meta
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.85 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.85 query.py(1085):         return lookup_parts, field_parts, False
0.85 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.85 query.py(1227):         if not allow_joins and len(parts) > 1:
0.85 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.85 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.85 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.85 query.py(1055):         elif isinstance(value, (list, tuple)):
0.85 query.py(1067):         return value
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1234):         clause = self.where_class()
0.85 query.py(1235):         if reffed_expression:
0.85 query.py(1240):         opts = self.get_meta()
0.85 query.py(290):         return self.model._meta
0.85 query.py(1241):         alias = self.get_initial_alias()
0.85 query.py(912):         if self.alias_map:
0.85 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.85 query.py(290):         return self.model._meta
0.85 query.py(943):         if reuse_with_filtered_relation and reuse:
0.85 query.py(950):                 a for a, j in self.alias_map.items()
0.85 query.py(950):                 a for a, j in self.alias_map.items()
0.85 query.py(953):         if reuse_aliases:
0.85 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.85 query.py(735):         alias_list = self.table_map.get(table_name)
0.85 query.py(736):         if not create and alias_list:
0.85 query.py(742):         if alias_list:
0.85 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.85 query.py(748):             self.table_map[table_name] = [alias]
0.85 query.py(749):         self.alias_refcount[alias] = 1
0.85 query.py(750):         return alias, True
0.85 query.py(965):         if join.join_type:
0.85 query.py(971):         join.table_alias = alias
0.85 query.py(972):         self.alias_map[alias] = join
0.85 query.py(973):         return alias
0.85 query.py(917):         return alias
0.85 query.py(1242):         allow_many = not branch_negated or not split_subq
0.85 query.py(1244):         try:
0.85 query.py(1245):             join_info = self.setup_joins(
0.85 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.85 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.85 query.py(1518):         joins = [alias]
0.85 query.py(1524):         def final_transformer(field, alias):
0.85 query.py(1529):         last_field_exception = None
0.85 query.py(1530):         for pivot in range(len(names), 0, -1):
0.85 query.py(1531):             try:
0.85 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.85 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1545):                 transforms = names[pivot:]
0.85 query.py(1546):                 break
0.85 query.py(1547):         for name in transforms:
0.85 query.py(1562):         for join in path:
0.85 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.85 query.py(1251):             if isinstance(value, Iterator):
0.85 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.85 query.py(1100):         if field.is_relation:
0.85 query.py(1257):             self._lookup_joins = join_info.joins
0.85 query.py(1263):         used_joins.update(join_info.joins)
0.85 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.85 query.py(1601):         joins = joins[:]
0.85 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.85 query.py(1614):         return targets, joins[-1], joins
0.85 query.py(1265):         if can_reuse is not None:
0.85 query.py(1266):             can_reuse.update(join_list)
0.85 query.py(1268):         if join_info.final_field.is_relation:
0.85 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.85 query.py(72):     if simple_col:
0.85 query.py(74):     return target.get_col(alias, field)
0.85 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.85 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.85 query.py(1129):         for name in transforms:
0.85 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.85 query.py(1134):         if not lookup_class:
0.85 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.85 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.85 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.85 query.py(1161):         return lookup
0.85 query.py(1281):         lookup_type = condition.lookup_name
0.85 query.py(1282):         clause.add(condition, AND)
0.85 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.85 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.85 query.py(1302):         return clause, used_joins if not require_outer else ()
0.85 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.85 query.py(2246):         self.votes.update(votes)
0.85 query.py(1350):             if child_clause:
0.85 query.py(1351):                 target_clause.add(child_clause, connector)
0.85 query.py(1337):         for child in q_object.children:
0.85 query.py(1338):             if isinstance(child, Node):
0.85 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.85 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.85 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.85 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.85 query.py(1214):         if isinstance(filter_expr, dict):
0.85 query.py(1216):         arg, value = filter_expr
0.85 query.py(1217):         if not arg:
0.85 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.85 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.85 query.py(1074):         if self.annotations:
0.85 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.85 query.py(290):         return self.model._meta
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.85 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.85 query.py(1085):         return lookup_parts, field_parts, False
0.85 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.85 query.py(1227):         if not allow_joins and len(parts) > 1:
0.85 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.85 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.85 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.85 query.py(1055):         elif isinstance(value, (list, tuple)):
0.85 query.py(1067):         return value
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.85 query.py(1234):         clause = self.where_class()
0.85 query.py(1235):         if reffed_expression:
0.85 query.py(1240):         opts = self.get_meta()
0.85 query.py(290):         return self.model._meta
0.85 query.py(1241):         alias = self.get_initial_alias()
0.85 query.py(912):         if self.alias_map:
0.85 query.py(913):             alias = self.base_table
0.85 query.py(250):         for alias in self.alias_map:
0.85 query.py(251):             return alias
0.85 query.py(914):             self.ref_alias(alias)
0.85 query.py(754):         self.alias_refcount[alias] += 1
0.85 query.py(917):         return alias
0.85 query.py(1242):         allow_many = not branch_negated or not split_subq
0.85 query.py(1244):         try:
0.85 query.py(1245):             join_info = self.setup_joins(
0.85 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.85 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.85 query.py(1518):         joins = [alias]
0.85 query.py(1524):         def final_transformer(field, alias):
0.85 query.py(1529):         last_field_exception = None
0.85 query.py(1530):         for pivot in range(len(names), 0, -1):
0.85 query.py(1531):             try:
0.85 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.85 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.85 query.py(1405):         path, names_with_path = [], []
0.85 query.py(1406):         for pos, name in enumerate(names):
0.85 query.py(1407):             cur_names_with_path = (name, [])
0.85 query.py(1408):             if name == 'pk':
0.85 query.py(1411):             field = None
0.85 query.py(1412):             filtered_relation = None
0.85 query.py(1413):             try:
0.85 query.py(1414):                 field = opts.get_field(name)
0.85 query.py(1421):             if field is not None:
0.85 query.py(1425):                 if field.is_relation and not field.related_model:
0.85 query.py(1432):                 try:
0.85 query.py(1433):                     model = field.model._meta.concrete_model
0.85 query.py(1454):             if model is not opts.model:
0.85 query.py(1460):             if hasattr(field, 'get_path_info'):
0.85 query.py(1477):                 final_field = field
0.85 query.py(1478):                 targets = (field,)
0.85 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.85 query.py(1483):                 break
0.85 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.85 query.py(1545):                 transforms = names[pivot:]
0.85 query.py(1546):                 break
0.85 query.py(1547):         for name in transforms:
0.85 query.py(1562):         for join in path:
0.85 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.85 query.py(1251):             if isinstance(value, Iterator):
0.85 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.85 query.py(1100):         if field.is_relation:
0.85 query.py(1257):             self._lookup_joins = join_info.joins
0.85 query.py(1263):         used_joins.update(join_info.joins)
0.85 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.85 query.py(1601):         joins = joins[:]
0.86 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.86 query.py(1614):         return targets, joins[-1], joins
0.86 query.py(1265):         if can_reuse is not None:
0.86 query.py(1266):             can_reuse.update(join_list)
0.86 query.py(1268):         if join_info.final_field.is_relation:
0.86 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.86 query.py(72):     if simple_col:
0.86 query.py(74):     return target.get_col(alias, field)
0.86 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.86 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.86 query.py(1129):         for name in transforms:
0.86 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.86 query.py(1134):         if not lookup_class:
0.86 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.86 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.86 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.86 query.py(1161):         return lookup
0.86 query.py(1281):         lookup_type = condition.lookup_name
0.86 query.py(1282):         clause.add(condition, AND)
0.86 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.86 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.86 query.py(1302):         return clause, used_joins if not require_outer else ()
0.86 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.86 query.py(2246):         self.votes.update(votes)
0.86 query.py(1350):             if child_clause:
0.86 query.py(1351):                 target_clause.add(child_clause, connector)
0.86 query.py(1337):         for child in q_object.children:
0.86 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.86 query.py(2255):         to_promote = set()
0.86 query.py(2256):         to_demote = set()
0.86 query.py(2259):         for table, votes in self.votes.items():
0.86 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.86 query.py(2282):             if self.effective_connector == 'AND' or (
0.86 query.py(2284):                 to_demote.add(table)
0.86 query.py(2259):         for table, votes in self.votes.items():
0.86 query.py(2300):         query.promote_joins(to_promote)
0.86 query.py(771):         aliases = list(aliases)
0.86 query.py(772):         while aliases:
0.86 query.py(2301):         query.demote_joins(to_demote)
0.86 query.py(804):         aliases = list(aliases)
0.86 query.py(805):         while aliases:
0.86 query.py(806):             alias = aliases.pop(0)
0.86 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.86 query.py(805):         while aliases:
0.86 query.py(2302):         return to_demote
0.86 query.py(1353):         return target_clause, needed_inner
0.86 query.py(1342):                 joinpromoter.add_votes(needed_inner)
0.86 query.py(2246):         self.votes.update(votes)
0.86 query.py(1350):             if child_clause:
0.86 query.py(1351):                 target_clause.add(child_clause, connector)
0.86 query.py(1337):         for child in q_object.children:
0.86 query.py(1338):             if isinstance(child, Node):
0.86 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.86 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.86 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.86 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.86 query.py(1214):         if isinstance(filter_expr, dict):
0.86 query.py(1216):         arg, value = filter_expr
0.86 query.py(1217):         if not arg:
0.86 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.86 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.86 query.py(1074):         if self.annotations:
0.86 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.86 query.py(290):         return self.model._meta
0.86 query.py(1405):         path, names_with_path = [], []
0.86 query.py(1406):         for pos, name in enumerate(names):
0.86 query.py(1407):             cur_names_with_path = (name, [])
0.86 query.py(1408):             if name == 'pk':
0.86 query.py(1411):             field = None
0.86 query.py(1412):             filtered_relation = None
0.86 query.py(1413):             try:
0.86 query.py(1414):                 field = opts.get_field(name)
0.86 query.py(1421):             if field is not None:
0.86 query.py(1425):                 if field.is_relation and not field.related_model:
0.86 query.py(1432):                 try:
0.86 query.py(1433):                     model = field.model._meta.concrete_model
0.86 query.py(1454):             if model is not opts.model:
0.86 query.py(1460):             if hasattr(field, 'get_path_info'):
0.86 query.py(1477):                 final_field = field
0.86 query.py(1478):                 targets = (field,)
0.86 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.86 query.py(1483):                 break
0.86 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.86 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.86 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.86 query.py(1085):         return lookup_parts, field_parts, False
0.86 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.86 query.py(1227):         if not allow_joins and len(parts) > 1:
0.86 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.86 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.86 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.86 query.py(1055):         elif isinstance(value, (list, tuple)):
0.86 query.py(1067):         return value
0.86 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.86 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.86 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.86 query.py(1234):         clause = self.where_class()
0.86 query.py(1235):         if reffed_expression:
0.86 query.py(1240):         opts = self.get_meta()
0.86 query.py(290):         return self.model._meta
0.86 query.py(1241):         alias = self.get_initial_alias()
0.86 query.py(912):         if self.alias_map:
0.86 query.py(913):             alias = self.base_table
0.86 query.py(914):             self.ref_alias(alias)
0.86 query.py(754):         self.alias_refcount[alias] += 1
0.86 query.py(917):         return alias
0.86 query.py(1242):         allow_many = not branch_negated or not split_subq
0.86 query.py(1244):         try:
0.86 query.py(1245):             join_info = self.setup_joins(
0.86 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.86 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.86 query.py(1518):         joins = [alias]
0.86 query.py(1524):         def final_transformer(field, alias):
0.86 query.py(1529):         last_field_exception = None
0.86 query.py(1530):         for pivot in range(len(names), 0, -1):
0.86 query.py(1531):             try:
0.86 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.86 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.86 query.py(1405):         path, names_with_path = [], []
0.86 query.py(1406):         for pos, name in enumerate(names):
0.86 query.py(1407):             cur_names_with_path = (name, [])
0.86 query.py(1408):             if name == 'pk':
0.86 query.py(1411):             field = None
0.86 query.py(1412):             filtered_relation = None
0.86 query.py(1413):             try:
0.86 query.py(1414):                 field = opts.get_field(name)
0.86 query.py(1421):             if field is not None:
0.86 query.py(1425):                 if field.is_relation and not field.related_model:
0.86 query.py(1432):                 try:
0.86 query.py(1433):                     model = field.model._meta.concrete_model
0.86 query.py(1454):             if model is not opts.model:
0.86 query.py(1460):             if hasattr(field, 'get_path_info'):
0.86 query.py(1477):                 final_field = field
0.86 query.py(1478):                 targets = (field,)
0.86 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.86 query.py(1483):                 break
0.86 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.86 query.py(1545):                 transforms = names[pivot:]
0.86 query.py(1546):                 break
0.86 query.py(1547):         for name in transforms:
0.86 query.py(1562):         for join in path:
0.86 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.86 query.py(1251):             if isinstance(value, Iterator):
0.86 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.86 query.py(1100):         if field.is_relation:
0.86 query.py(1257):             self._lookup_joins = join_info.joins
0.86 query.py(1263):         used_joins.update(join_info.joins)
0.86 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.86 query.py(1601):         joins = joins[:]
0.86 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.86 query.py(1614):         return targets, joins[-1], joins
0.86 query.py(1265):         if can_reuse is not None:
0.86 query.py(1266):             can_reuse.update(join_list)
0.86 query.py(1268):         if join_info.final_field.is_relation:
0.86 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.86 query.py(72):     if simple_col:
0.86 query.py(73):         return SimpleCol(target, field)
0.86 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.86 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.86 query.py(1129):         for name in transforms:
0.86 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.86 query.py(1134):         if not lookup_class:
0.86 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.86 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.86 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.86 query.py(1161):         return lookup
0.86 query.py(1281):         lookup_type = condition.lookup_name
0.86 query.py(1282):         clause.add(condition, AND)
0.86 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.86 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.86 query.py(1302):         return clause, used_joins if not require_outer else ()
0.86 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.86 query.py(2246):         self.votes.update(votes)
0.86 query.py(1350):             if child_clause:
0.86 query.py(1351):                 target_clause.add(child_clause, connector)
0.86 query.py(1337):         for child in q_object.children:
0.86 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.86 query.py(2255):         to_promote = set()
0.86 query.py(2256):         to_demote = set()
0.86 query.py(2259):         for table, votes in self.votes.items():
0.86 query.py(2270):             if self.effective_connector == 'OR' and votes < self.num_children:
0.86 query.py(2282):             if self.effective_connector == 'AND' or (
0.86 query.py(2283):                     self.effective_connector == 'OR' and votes == self.num_children):
0.86 query.py(2284):                 to_demote.add(table)
0.86 query.py(2259):         for table, votes in self.votes.items():
0.86 query.py(2300):         query.promote_joins(to_promote)
0.86 query.py(771):         aliases = list(aliases)
0.86 query.py(772):         while aliases:
0.86 query.py(2301):         query.demote_joins(to_demote)
0.86 query.py(804):         aliases = list(aliases)
0.86 query.py(805):         while aliases:
0.86 query.py(806):             alias = aliases.pop(0)
0.86 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.86 query.py(805):         while aliases:
0.86 query.py(2302):         return to_demote
0.86 query.py(1353):         return target_clause, needed_inner
0.86 query.py(278):         if using is None and connection is None:
0.86 query.py(280):         if using:
0.86 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.86 query.py(2085):         if self._extra_select_cache is not None:
0.86 query.py(2087):         if not self.extra:
0.86 query.py(2088):             return {}
0.86 query.py(2085):         if self._extra_select_cache is not None:
0.86 query.py(2087):         if not self.extra:
0.86 query.py(2088):             return {}
0.86 query.py(2085):         if self._extra_select_cache is not None:
0.86 query.py(2087):         if not self.extra:
0.86 query.py(2088):             return {}
FAIL

======================================================================
FAIL: test_check_constraint_sql_generation (test_coverup_django__django-11299.CheckConstraintSQLTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "./tests/test_coverup_django__django-11299.py", line 47, in test_check_constraint_sql_generation
    self.assertNotIn('"test_app_testconstraint"."field_1"', sql_str)
AssertionError: '"test_app_testconstraint"."field_1"' unexpectedly found in 'ALTER TABLE "test_app_testconstraint" ADD CONSTRAINT "field_1_has_value_if_flag_set" CHECK ((("test_app_testconstraint"."field_1" IS NOT NULL AND "test_app_testconstraint"."flag" = 1) OR "flag" = 0))'

----------------------------------------------------------------------
Ran 1 test in 0.007s

FAILED (failures=1)
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
+ cat coverage.cover
{"/testbed/django/db/models/sql/query.py": {"9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "19": 1, "22": 1, "23": 1, "24": 1, "25": 1, "28": 1, "29": 1, "30": 1, "31": 1, "34": 1, "37": 1, "40": 1, "43": 1, "44": 1, "45": 1, "47": 1, "50": 1, "57": 1, "65": 1, "66": 1, "67": 1, "71": 1, "77": 2, "145": 2, "2187": 1, "2201": 1, "2212": 1, "2220": 2, "51": 0, "52": 0, "53": 0, "58": 0, "59": 0, "60": 0, "62": 0, "72": 36, "73": 2, "74": 34, "80": 1, "92": 1, "95": 1, "98": 1, "105": 1, "117": 1, "120": 1, "124": 1, "127": 1, "81": 0, "82": 0, "83": 0, "84": 0, "88": 0, "89": 0, "90": 0, "93": 0, "96": 0, "99": 0, "100": 0, "101": 0, "102": 0, "103": 0, "108": 0, "109": 0, "112": 0, "114": 0, "115": 0, "118": 0, "122": 0, "125": 0, "128": 0, "132": 0, "133": 0, "134": 0, "135": 0, "136": 0, "137": 0, "139": 0, "141": 0, "142": 0, "148": 1, "149": 1, "151": 1, "153": 1, "237": 1, "244": 1, "248": 1, "253": 1, "264": 1, "271": 1, "277": 1, "284": 1, "292": 1, "338": 1, "353": 1, "358": 1, "410": 1, "506": 1, "517": 1, "520": 1, "532": 1, "540": 1, "641": 1, "727": 1, "752": 1, "756": 1, "760": 1, "794": 1, "813": 1, "822": 1, "858": 1, "907": 1, "919": 1, "927": 1, "975": 1, "1008": 1, "1015": 1, "1043": 1, "1049": 1, "1069": 1, "1087": 1, "1098": 1, "1118": 1, "1163": 1, "1185": 1, "1304": 1, "1307": 1, "1324": 1, "1329": 1, "1355": 1, "1377": 1, "1390": 1, "1487": 1, "1588": 1, "1616": 1, "1645": 1, "1715": 1, "1718": 1, "1721": 1, "1744": 1, "1748": 1, "1751": 1, "1759": 1, "1767": 1, "1776": 1, "1780": 1, "1787": 1, "1825": 1, "1850": 1, "1860": 1, "1887": 1, "1903": 1, "1935": 1, "1939": 1, "1959": 1, "1983": 1, "2002": 1, "2006": 1, "2014": 1, "2018": 1, "2029": 1, "2064": 1, "2083": 1, "2098": 1, "2168": 1, "154": 72, "155": 72, "161": 72, "165": 72, "166": 72, "167": 72, "168": 72, "169": 72, "170": 72, "171": 72, "172": 72, "180": 72, "181": 72, "182": 72, "189": 72, "190": 72, "191": 72, "192": 72, "193": 72, "194": 72, "195": 72, "196": 72, "197": 72, "199": 72, "201": 72, "205": 72, "208": 72, "209": 72, "210": 72, "213": 72, "214": 72, "215": 72, "219": 72, "220": 72, "221": 72, "223": 72, "224": 72, "229": 72, "231": 72, "233": 72, "234": 72, "235": 72, "239": 0, "240": 0, "241": 0, "242": 0, "246": 0, "250": 36, "251": 36, "261": 0, "262": 0, "269": 0, "273": 0, "274": 0, "275": 0, "278": 46, "279": 0, "280": 46, "281": 44, "282": 46, "290": 220, "297": 80, "298": 80, "300": 80, "302": 80, "303": 80, "304": 80, "305": 80, "306": 80, "307": 80, "308": 80, "309": 80, "311": 0, "317": 80, "318": 80, "319": 80, "320": 80, "322": 0, "323": 80, "324": 80, "326": 0, "327": 80, "328": 0, "329": 80, "330": 80, "332": 80, "333": 80, "334": 73, "335": 73, "336": 80, "343": 79, "344": 79, "345": 1, "346": 79, "347": 79, "348": 79, "349": 79, "350": 1, "351": 79, "354": 0, "355": 0, "356": 0, "370": 0, "371": 0, "372": 0, "376": 0, "379": 0, "380": 0, "384": 0, "385": 0, "388": 0, "389": 0, "390": 0, "391": 0, "394": 0, "397": 0, "398": 0, "399": 0, "400": 0, "401": 0, "405": 0, "406": 0, "407": 0, "408": 0, "414": 0, "415": 0, "416": 0, "418": 0, "419": 0, "433": 0, "434": 0, "435": 0, "436": 0, "437": 0, "438": 0, "439": 0, "440": 0, "441": 0, "445": 0, "446": 0, "452": 0, "453": 0, "456": 0, "457": 0, "458": 0, "460": 0, "461": 0, "464": 0, "465": 0, "466": 0, "467": 0, "468": 0, "469": 0, "470": 0, "471": 0, "473": 0, "474": 0, "478": 0, "479": 0, "480": 0, "481": 0, "482": 0, "484": 0, "487": 0, "488": 0, "489": 0, "490": 0, "492": 0, "493": 0, "494": 0, "495": 0, "496": 0, "497": 0, "498": 0, "499": 0, "501": 0, "502": 0, "504": 0, "420": 0, "454": 0, "510": 0, "511": 0, "512": 0, "513": 0, "514": 0, "515": 0, "518": 0, "521": 1, "522": 1, "523": 1, "524": 0, "525": 0, "526": 1, "527": 1, "528": 1, "529": 1, "530": 1, "533": 0, "534": 0, "535": 0, "536": 0, "537": 0, "538": 0, "549": 0, "550": 0, "551": 0, "552": 0, "553": 0, "554": 0, "555": 0, "556": 0, "559": 0, "560": 0, "574": 0, "577": 0, "578": 0, "579": 0, "580": 0, "581": 0, "584": 0, "585": 0, "586": 0, "589": 0, "590": 0, "591": 0, "592": 0, "596": 0, "597": 0, "598": 0, "599": 0, "604": 0, "605": 0, "606": 0, "610": 0, "611": 0, "612": 0, "615": 0, "616": 0, "618": 0, "620": 0, "624": 0, "625": 0, "626": 0, "627": 0, "628": 0, "629": 0, "630": 0, "631": 0, "632": 0, "633": 0, "634": 0, "638": 0, "639": 0, "655": 21, "656": 21, "657": 21, "658": 0, "659": 0, "660": 0, "661": 0, "662": 0, "663": 0, "664": 0, "665": 0, "666": 0, "667": 0, "668": 0, "669": 0, "670": 0, "671": 0, "673": 0, "674": 0, "678": 0, "679": 0, "680": 0, "681": 0, "682": 0, "683": 0, "684": 0, "685": 0, "686": 0, "687": 0, "688": 0, "690": 0, "695": 0, "696": 0, "697": 0, "698": 0, "699": 0, "700": 0, "701": 0, "706": 0, "707": 0, "708": 0, "709": 0, "711": 0, "712": 0, "713": 0, "718": 0, "722": 0, "723": 0, "724": 0, "725": 0, "735": 35, "736": 35, "737": 0, "738": 0, "739": 0, "742": 35, "743": 0, "744": 0, "747": 35, "748": 35, "749": 35, "750": 35, "754": 70, "758": 42, "771": 27, "772": 27, "773": 0, "774": 0, "778": 0, "780": 0, "781": 0, "782": 0, "783": 0, "784": 0, "785": 0, "786": 0, "789": 0, "790": 0, "791": 0, "804": 50, "805": 82, "806": 32, "807": 32, "808": 0, "809": 0, "810": 0, "811": 0, "818": 59, "819": 32, "820": 32, "828": 0, "832": 0, "833": 0, "834": 0, "835": 0, "836": 0, "837": 0, "841": 0, "842": 0, "843": 0, "844": 0, "845": 0, "846": 0, "847": 0, "848": 0, "850": 0, "851": 0, "852": 0, "853": 0, "854": 0, "855": 0, "856": 0, "865": 0, "883": 0, "885": 0, "891": 0, "892": 0, "893": 0, "894": 0, "895": 0, "896": 0, "897": 0, "898": 0, "900": 0, "901": 0, "902": 0, "904": 0, "874": 0, "875": 0, "876": 0, "877": 0, "878": 0, "879": 0, "880": 0, "881": 0, "912": 85, "913": 55, "914": 55, "916": 30, "917": 85, "925": 3, "943": 50, "945": 0, "950": 135, "953": 50, "954": 15, "955": 0, "959": 15, "960": 15, "961": 15, "964": 35, "965": 35, "966": 5, "967": 0, "969": 5, "970": 5, "971": 35, "972": 35, "973": 35, "946": 0, "951": 35, "984": 70, "985": 70, "986": 0, "987": 0, "988": 0, "989": 0, "990": 0, "991": 0, "992": 0, "993": 0, "994": 0, "999": 0, "1000": 0, "1001": 0, "1002": 0, "1003": 0, "1004": 0, "1005": 0, "1006": 0, "1010": 0, "1011": 0, "1012": 0, "1013": 0, "1016": 0, "1018": 0, "1019": 0, "1022": 0, "1023": 0, "1024": 0, "1025": 0, "1026": 0, "1027": 0, "1028": 0, "1029": 0, "1030": 0, "1031": 0, "1033": 0, "1034": 0, "1041": 0, "1036": 0, "1038": 0, "1044": 0, "1045": 0, "1046": 0, "1047": 0, "1050": 36, "1051": 0, "1052": 0, "1053": 0, "1054": 0, "1055": 36, "1058": 0, "1059": 0, "1060": 0, "1061": 0, "1062": 0, "1063": 0, "1066": 0, "1067": 36, "1073": 36, "1074": 36, "1075": 0, "1076": 0, "1077": 0, "1078": 36, "1079": 36, "1080": 36, "1081": 0, "1082": 0, "1083": 0, "1085": 36, "1092": 7, "1093": 7, "1094": 0, "1095": 0, "1096": 0, "1100": 36, "1106": 5, "1107": 0, "1108": 0, "1109": 0, "1110": 0, "1112": 5, "1113": 0, "1114": 5, "1115": 12, "1116": 7, "1128": 36, "1129": 36, "1130": 0, "1133": 36, "1134": 36, "1135": 0, "1136": 0, "1139": 0, "1140": 0, "1141": 0, "1142": 0, "1143": 0, "1145": 36, "1148": 36, "1149": 0, "1150": 0, "1151": 0, "1157": 36, "1158": 0, "1159": 0, "1161": 36, "1168": 0, "1169": 0, "1170": 0, "1172": 0, "1173": 0, "1174": 0, "1175": 0, "1177": 0, "1178": 0, "1179": 0, "1180": 0, "1214": 36, "1215": 0, "1216": 36, "1217": 36, "1218": 0, "1219": 36, "1221": 36, "1222": 0, "1223": 0, "1227": 36, "1228": 0, "1230": 36, "1231": 36, "1232": 83, "1234": 36, "1235": 36, "1236": 0, "1237": 0, "1238": 0, "1240": 36, "1241": 36, "1242": 36, "1244": 36, "1245": 36, "1246": 36, "1247": 36, "1251": 36, "1252": 0, "1253": 36, "1257": 36, "1258": 0, "1259": 0, "1263": 36, "1264": 36, "1265": 36, "1266": 36, "1268": 36, "1270": 5, "1271": 5, "1272": 0, "1273": 5, "1274": 5, "1276": 0, "1278": 31, "1280": 36, "1281": 36, "1282": 36, "1284": 36, "1285": 36, "1286": 0, "1287": 0, "1288": 0, "1289": 0, "1299": 0, "1300": 0, "1301": 0, "1302": 36, "1305": 0, "1318": 46, "1319": 23, "1320": 23, "1321": 23, "1322": 23, "1325": 2, "1331": 27, "1332": 27, "1333": 27, "1334": 27, "1335": 27, "1336": 27, "1337": 65, "1338": 38, "1339": 2, "1340": 2, "1341": 2, "1342": 2, "1344": 36, "1345": 36, "1346": 36, "1347": 36, "1349": 36, "1350": 38, "1351": 38, "1352": 27, "1353": 27, "1357": 0, "1358": 0, "1359": 0, "1360": 0, "1361": 0, "1362": 0, "1363": 0, "1364": 0, "1365": 0, "1368": 0, "1369": 0, "1370": 0, "1371": 0, "1372": 0, "1374": 0, "1375": 0, "1378": 0, "1379": 0, "1380": 0, "1381": 0, "1382": 0, "1383": 0, "1384": 0, "1385": 0, "1386": 0, "1388": 0, "1405": 99, "1406": 124, "1407": 114, "1408": 114, "1409": 2, "1411": 114, "1412": 114, "1413": 114, "1414": 114, "1415": 5, "1416": 5, "1417": 0, "1418": 5, "1419": 0, "1420": 0, "1421": 114, "1425": 109, "1426": 0, "1427": 0, "1430": 0, "1432": 109, "1433": 109, "1434": 0, "1437": 0, "1441": 5, "1442": 5, "1443": 0, "1444": 0, "1445": 0, "1446": 0, "1448": 0, "1449": 0, "1450": 5, "1454": 109, "1455": 0, "1456": 0, "1457": 0, "1458": 0, "1459": 0, "1460": 109, "1461": 25, "1462": 25, "1463": 0, "1464": 0, "1465": 0, "1466": 0, "1467": 0, "1468": 25, "1469": 25, "1470": 25, "1471": 25, "1472": 25, "1473": 25, "1474": 25, "1477": 84, "1478": 84, "1479": 84, "1480": 0, "1481": 0, "1482": 0, "1483": 84, "1484": 99, "1518": 63, "1524": 63, "1529": 63, "1530": 63, "1531": 63, "1532": 63, "1533": 63, "1535": 0, "1536": 0, "1539": 0, "1541": 0, "1545": 63, "1546": 63, "1547": 63, "1548": 0, "1558": 0, "1562": 83, "1563": 20, "1564": 0, "1565": 0, "1567": 20, "1568": 20, "1569": 20, "1570": 20, "1571": 20, "1573": 0, "1574": 20, "1575": 20, "1576": 20, "1578": 20, "1579": 20, "1580": 20, "1581": 20, "1583": 20, "1584": 20, "1585": 0, "1586": 63, "1525": 27, "1549": 0, "1550": 0, "1551": 0, "1552": 0, "1554": 0, "1555": 0, "1557": 0, "1601": 63, "1602": 73, "1603": 20, "1604": 0, "1605": 20, "1606": 0, "1607": 60, "1608": 60, "1609": 20, "1610": 10, "1611": 30, "1612": 30, "1613": 10, "1614": 63, "1617": 0, "1618": 0, "1619": 0, "1620": 0, "1625": 0, "1627": 0, "1629": 0, "1630": 0, "1631": 0, "1632": 0, "1633": 0, "1634": 0, "1635": 0, "1639": 0, "1640": 0, "1641": 0, "1642": 0, "1643": 0, "1664": 0, "1665": 0, "1666": 0, "1668": 0, "1669": 0, "1670": 0, "1673": 0, "1679": 0, "1680": 0, "1681": 0, "1682": 0, "1683": 0, "1684": 0, "1685": 0, "1686": 0, "1687": 0, "1690": 0, "1691": 0, "1694": 0, "1695": 0, "1696": 0, "1697": 0, "1699": 0, "1700": 0, "1701": 0, "1702": 0, "1703": 0, "1704": 0, "1705": 0, "1706": 0, "1713": 0, "1716": 0, "1719": 0, "1730": 1, "1731": 1, "1732": 0, "1734": 1, "1735": 1, "1736": 0, "1737": 0, "1739": 0, "1741": 1, "1742": 0, "1746": 0, "1749": 0, "1757": 40, "1761": 1, "1762": 1, "1763": 1, "1764": 1, "1765": 1, "1773": 5, "1774": 5, "1777": 5, "1778": 5, "1784": 0, "1785": 0, "1792": 5, "1793": 5, "1795": 5, "1796": 5, "1797": 15, "1800": 10, "1801": 10, "1802": 10, "1803": 10, "1804": 10, "1806": 20, "1807": 10, "1808": 5, "1809": 5, "1810": 0, "1811": 0, "1812": 0, "1813": 0, "1816": 0, "1818": 0, "1819": 0, "1820": 0, "1822": 0, "1823": 0, "1834": 9, "1835": 11, "1836": 2, "1837": 0, "1838": 2, "1839": 0, "1840": 0, "1841": 0, "1843": 9, "1844": 0, "1845": 9, "1846": 2, "1848": 7, "1855": 10, "1856": 10, "1857": 10, "1858": 1, "1869": 0, "1870": 0, "1871": 0, "1872": 0, "1873": 0, "1874": 0, "1875": 0, "1877": 0, "1879": 0, "1880": 0, "1881": 0, "1883": 0, "1884": 0, "1885": 0, "1893": 0, "1894": 0, "1896": 0, "1897": 0, "1898": 0, "1899": 0, "1900": 0, "1901": 0, "1908": 1, "1913": 1, "1914": 1, "1915": 0, "1917": 1, "1918": 2, "1919": 1, "1920": 1, "1921": 1, "1922": 1, "1923": 0, "1924": 0, "1925": 0, "1926": 1, "1927": 1, "1928": 1, "1929": 0, "1930": 1, "1931": 0, "1932": 1, "1933": 0, "1937": 5, "1951": 0, "1952": 0, "1954": 0, "1957": 0, "1969": 0, "1970": 0, "1971": 0, "1972": 0, "1973": 0, "1975": 0, "1978": 0, "1981": 0, "1994": 0, "1995": 0, "1996": 0, "1997": 0, "1998": 0, "1999": 0, "2000": 0, "2004": 0, "2008": 6, "2009": 0, "2011": 6, "2012": 6, "2015": 0, "2016": 0, "2023": 7, "2024": 0, "2026": 7, "2027": 7, "2030": 5, "2031": 5, "2032": 5, "2034": 5, "2035": 0, "2036": 0, "2037": 0, "2039": 5, "2040": 5, "2041": 5, "2042": 5, "2043": 5, "2046": 5, "2048": 0, "2049": 0, "2050": 0, "2051": 0, "2052": 0, "2053": 0, "2055": 0, "2056": 5, "2057": 5, "2059": 0, "2061": 5, "2062": 5, "2070": 59, "2071": 0, "2072": 59, "2073": 59, "2074": 0, "2075": 0, "2076": 0, "2079": 0, "2081": 0, "2077": 0, "2085": 164, "2086": 1, "2087": 163, "2088": 162, "2089": 1, "2090": 3, "2091": 2, "2094": 1, "2096": 0, "2092": 1, "2111": 0, "2112": 0, "2113": 0, "2114": 0, "2119": 0, "2122": 0, "2123": 0, "2124": 0, "2125": 0, "2126": 0, "2127": 0, "2128": 0, "2130": 0, "2132": 0, "2133": 0, "2134": 0, "2135": 0, "2136": 0, "2137": 0, "2138": 0, "2139": 0, "2140": 0, "2141": 0, "2145": 0, "2146": 0, "2147": 0, "2148": 0, "2149": 0, "2150": 0, "2151": 0, "2152": 0, "2157": 0, "2158": 0, "2161": 0, "2162": 0, "2163": 0, "2164": 0, "2165": 0, "2166": 0, "2120": 0, "2182": 20, "2183": 0, "2184": 20, "2195": 34, "2196": 34, "2197": 0, "2198": 34, "2206": 0, "2207": 0, "2209": 0, "2217": 0, "2226": 1, "2241": 1, "2248": 1, "2227": 27, "2228": 27, "2229": 27, "2230": 0, "2231": 0, "2233": 0, "2235": 27, "2236": 27, "2239": 27, "2246": 38, "2255": 27, "2256": 27, "2259": 59, "2270": 32, "2271": 0, "2282": 32, "2283": 2, "2284": 32, "2300": 27, "2301": 27, "2302": 27}}
+ git checkout 6866c91b638de5368c18713fa851bfe56253ea55
Note: switching to '6866c91b638de5368c18713fa851bfe56253ea55'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 6866c91b63 Fixed #30418 -- Added --skip-checks management command option.
+ git apply /root/pre_state.patch
error: unrecognized input
