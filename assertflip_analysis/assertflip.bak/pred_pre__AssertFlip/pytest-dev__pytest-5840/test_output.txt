+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 73c5b7f4b11a81e971f7d1bb18072e06a87060f4
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 73c5b7f4b11a81e971f7d1bb18072e06a87060f4
Merge: 23102a7d8 8f2f51be6
Author: Bruno Oliveira <nicoddemus@gmail.com>
Date:   Wed Sep 11 22:14:31 2019 -0300

    Clarify docs by showing tox.ini considered before setup.cfg (#5839)
    
    Clarify docs by showing tox.ini considered before setup.cfg

+ git diff 73c5b7f4b11a81e971f7d1bb18072e06a87060f4
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: py>=1.5.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (1.11.0)
Requirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (23.1)
Requirement already satisfied: attrs>=17.4.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (23.1.0)
Requirement already satisfied: more-itertools>=4.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (10.1.0)
Requirement already satisfied: atomicwrites>=1.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (1.4.1)
Requirement already satisfied: pluggy<1.0,>=0.12 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (0.13.1)
Requirement already satisfied: wcwidth in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.3.dev14+g73c5b7f4b) (0.2.6)
Building wheels for collected packages: pytest
  Building editable for pytest (pyproject.toml): started
  Building editable for pytest (pyproject.toml): finished with status 'done'
  Created wheel for pytest: filename=pytest-5.1.3.dev14+g73c5b7f4b-0.editable-py3-none-any.whl size=4806 sha256=3169a6cfa42a85d6973722828e910224937725a0b3fb5020a60fa779ea706c88
  Stored in directory: /tmp/pip-ephem-wheel-cache-dyt3n52l/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4
Successfully built pytest
Installing collected packages: pytest
  Attempting uninstall: pytest
    Found existing installation: pytest 5.1.3.dev14+g73c5b7f4b
    Uninstalling pytest-5.1.3.dev14+g73c5b7f4b:
      Successfully uninstalled pytest-5.1.3.dev14+g73c5b7f4b
Successfully installed pytest-5.1.3.dev14+g73c5b7f4b
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git apply -v -
Checking patch testing/test_coverup_pytest-dev__pytest-5840.py...
Applied patch testing/test_coverup_pytest-dev__pytest-5840.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(src/_pytest/config/__init__\.py|src/_pytest/pathlib\.py)' -m pytest -rA testing/test_coverup_pytest-dev__pytest-5840.py
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(src/_pytest/config/__init__\\.py|src/_pytest/pathlib\\.py)']
0.07 pathlib.py(1): import atexit
0.07 pathlib.py(2): import fnmatch
0.07 pathlib.py(3): import itertools
0.07 pathlib.py(4): import operator
0.07 pathlib.py(5): import os
0.07 pathlib.py(6): import shutil
0.07 pathlib.py(7): import sys
0.07 pathlib.py(8): import uuid
0.07 pathlib.py(9): import warnings
0.07 pathlib.py(10): from functools import partial
0.07 pathlib.py(11): from os.path import expanduser
0.07 pathlib.py(12): from os.path import expandvars
0.07 pathlib.py(13): from os.path import isabs
0.07 pathlib.py(14): from os.path import normcase
0.07 pathlib.py(15): from os.path import sep
0.07 pathlib.py(16): from posixpath import sep as posix_sep
0.07 pathlib.py(18): from _pytest.warning_types import PytestWarning
0.07 pathlib.py(20): if sys.version_info[:2] >= (3, 6):
0.07 pathlib.py(21):     from pathlib import Path, PurePath
0.07 pathlib.py(25): __all__ = ["Path", "PurePath"]
0.07 pathlib.py(28): LOCK_TIMEOUT = 60 * 60 * 3
0.07 pathlib.py(30): get_lock_path = operator.methodcaller("joinpath", ".lock")
0.07 pathlib.py(33): def ensure_reset_dir(path):
0.07 pathlib.py(42): def on_rm_rf_error(func, path: str, exc, *, start_path):
0.07 pathlib.py(79): def rm_rf(path: Path):
0.07 pathlib.py(87): def find_prefixed(root, prefix):
0.07 pathlib.py(95): def extract_suffixes(iter, prefix):
0.07 pathlib.py(106): def find_suffixes(root, prefix):
0.07 pathlib.py(112): def parse_num(maybe_num):
0.07 pathlib.py(120): def _force_symlink(root, target, link_to):
0.07 pathlib.py(140): def make_numbered_dir(root, prefix):
0.07 pathlib.py(161): def create_cleanup_lock(p):
0.07 pathlib.py(178): def register_cleanup_lock_removal(lock_path, register=atexit.register):
0.07 pathlib.py(195): def maybe_delete_a_numbered_dir(path):
0.07 pathlib.py(221): def ensure_deletable(path, consider_lock_dead_if_created_before):
0.07 pathlib.py(240): def try_cleanup(path, consider_lock_dead_if_created_before):
0.07 pathlib.py(246): def cleanup_candidates(root, prefix, keep):
0.07 pathlib.py(258): def cleanup_numbered_dir(root, prefix, keep, consider_lock_dead_if_created_before):
0.07 pathlib.py(266): def make_numbered_dir_with_cleanup(root, prefix, keep, lock_timeout):
0.07 pathlib.py(289): def resolve_from_str(input, root):
0.07 pathlib.py(300): def fnmatch_ex(pattern, path):
0.07 pathlib.py(335): def parts(s):
0.07 pathlib.py(340): def unique_path(path):
0.08 __init__.py(1): """ command line options, ini-file and conftest.py processing. """
0.08 __init__.py(2): import argparse
0.08 __init__.py(3): import copy
0.08 __init__.py(4): import inspect
0.08 __init__.py(5): import os
0.08 __init__.py(6): import shlex
0.08 __init__.py(7): import sys
0.08 __init__.py(8): import types
0.08 __init__.py(9): import warnings
0.08 __init__.py(10): from functools import lru_cache
0.08 __init__.py(11): from pathlib import Path
0.08 __init__.py(13): import attr
0.08 __init__.py(14): import py
0.08 __init__.py(15): from packaging.version import Version
0.08 __init__.py(16): from pluggy import HookimplMarker
0.08 __init__.py(17): from pluggy import HookspecMarker
0.08 __init__.py(18): from pluggy import PluginManager
0.08 __init__.py(20): import _pytest._code
0.08 __init__.py(21): import _pytest.assertion
0.08 __init__.py(22): import _pytest.deprecated
0.08 __init__.py(23): import _pytest.hookspec  # the extension point definitions
0.08 __init__.py(24): from .exceptions import PrintHelp
0.08 __init__.py(25): from .exceptions import UsageError
0.08 __init__.py(26): from .findpaths import determine_setup
0.08 __init__.py(27): from .findpaths import exists
0.08 __init__.py(28): from _pytest._code import ExceptionInfo
0.08 __init__.py(29): from _pytest._code import filter_traceback
0.08 __init__.py(30): from _pytest.compat import importlib_metadata
0.09 __init__.py(31): from _pytest.outcomes import fail
0.09 __init__.py(32): from _pytest.outcomes import Skipped
0.09 __init__.py(33): from _pytest.pathlib import unique_path
0.09 __init__.py(34): from _pytest.warning_types import PytestConfigWarning
0.09 __init__.py(36): hookimpl = HookimplMarker("pytest")
0.09 __init__.py(37): hookspec = HookspecMarker("pytest")
0.09 __init__.py(40): class ConftestImportFailure(Exception):
0.09 __init__.py(40): class ConftestImportFailure(Exception):
0.09 __init__.py(41):     def __init__(self, path, excinfo):
0.09 __init__.py(47): def main(args=None, plugins=None):
0.09 __init__.py(88): class cmdline:  # compatibility namespace
0.09 __init__.py(88): class cmdline:  # compatibility namespace
0.09 __init__.py(89):     main = staticmethod(main)
0.09 __init__.py(92): def filename_arg(path, optname):
0.09 __init__.py(103): def directory_arg(path, optname):
0.09 __init__.py(115): essential_plugins = (  # fmt: off
0.09 __init__.py(123): default_plugins = essential_plugins + (
0.09 __init__.py(150): builtin_plugins = set(default_plugins)
0.09 __init__.py(151): builtin_plugins.add("pytester")
0.09 __init__.py(154): def get_config(args=None, plugins=None):
0.09 __init__.py(173): def get_plugin_manager():
0.09 __init__.py(185): def _prepareconfig(args=None, plugins=None):
0.09 __init__.py(216): def _fail_on_non_top_pytest_plugins(conftestpath, confcutdir):
0.09 __init__.py(229): class PytestPluginManager(PluginManager):
0.09 __init__.py(229): class PytestPluginManager(PluginManager):
0.09 __init__.py(230):     """
0.09 __init__.py(239):     def __init__(self):
0.09 __init__.py(267):     def parse_hookimpl_opts(self, plugin, name):
0.09 __init__.py(296):     def parse_hookspec_opts(self, module_or_class, name):
0.09 __init__.py(313):     def register(self, plugin, name=None):
0.09 __init__.py(334):     def getplugin(self, name):
0.09 __init__.py(338):     def hasplugin(self, name):
0.09 __init__.py(342):     def pytest_configure(self, config):
0.09 __init__.py(360):     def _set_initial_conftests(self, namespace):
0.09 __init__.py(391):     def _try_load_conftest(self, anchor):
0.09 __init__.py(399):     @lru_cache(maxsize=128)
0.09 __init__.py(400):     def _getconftestmodules(self, path):
0.09 __init__.py(425):     def _rget_with_confmod(self, name, path):
0.09 __init__.py(434):     def _importconftest(self, conftestpath):
0.09 __init__.py(473):     def consider_preparse(self, args):
0.09 __init__.py(492):     def consider_pluginarg(self, arg):
0.09 __init__.py(517):     def consider_conftest(self, conftestmodule):
0.09 __init__.py(520):     def consider_env(self):
0.09 __init__.py(523):     def consider_module(self, mod):
0.09 __init__.py(526):     def _import_plugin_specs(self, spec):
0.09 __init__.py(531):     def import_plugin(self, modname, consider_entry_points=False):
0.09 __init__.py(579): def _get_plugin_specs_as_list(specs):
0.09 __init__.py(599): def _ensure_removed_sysmodule(modname):
0.09 __init__.py(606): class Notset:
0.09 __init__.py(606): class Notset:
0.09 __init__.py(607):     def __repr__(self):
0.09 __init__.py(611): notset = Notset()
0.09 __init__.py(614): def _iter_rewritable_modules(package_files):
0.09 __init__.py(626): class Config:
0.09 __init__.py(626): class Config:
0.09 __init__.py(627):     """
0.09 __init__.py(646):     @attr.s(frozen=True)
0.09 __init__.py(647):     class InvocationParams:
0.09 __init__.py(646):     @attr.s(frozen=True)
0.09 __init__.py(648):         """Holds parameters passed during ``pytest.main()``
0.09 __init__.py(658):         args = attr.ib()
0.09 __init__.py(659):         plugins = attr.ib()
0.09 __init__.py(660):         dir = attr.ib()
0.09 <attrs generated init _pytest.config.Config.InvocationParams>(1): def __init__(self, args, plugins, dir):
0.09 __init__.py(662):     def __init__(self, pluginmanager, *, invocation_params=None):
0.09 __init__.py(689):     @property
0.09 __init__.py(690):     def invocation_dir(self):
0.09 __init__.py(694):     def add_cleanup(self, func):
0.09 __init__.py(699):     def _do_configure(self):
0.09 __init__.py(706):     def _ensure_unconfigure(self):
0.09 __init__.py(715):     def get_terminal_writer(self):
0.09 __init__.py(718):     def pytest_cmdline_parse(self, pluginmanager, args):
0.09 __init__.py(742):     def notify_exception(self, excinfo, option=None):
0.09 __init__.py(756):     def cwd_relative_nodeid(self, nodeid):
0.09 __init__.py(763):     @classmethod
0.09 __init__.py(764):     def fromdictargs(cls, option_dict, args):
0.09 __init__.py(773):     def _processopt(self, opt):
0.09 __init__.py(781):     @hookimpl(trylast=True)
0.09 __init__.py(782):     def pytest_load_initial_conftests(self, early_config):
0.09 __init__.py(785):     def _initini(self, args):
0.09 __init__.py(802):     def _consider_importhook(self, args):
0.09 __init__.py(820):     def _mark_plugins_for_rewrite(self, hook):
0.09 __init__.py(842):     def _validate_args(self, args, via):
0.09 __init__.py(854):     def _preparse(self, args, addopts=True):
0.09 __init__.py(903):     def _checkversion(self):
0.09 __init__.py(919):     def parse(self, args, addopts=True):
0.09 __init__.py(945):     def addinivalue_line(self, name, line):
0.09 __init__.py(953):     def getini(self, name):
0.09 __init__.py(964):     def _getini(self, name):
0.09 __init__.py(995):     def _getconftest_pathlist(self, name, path):
0.09 __init__.py(1009):     def _get_override_ini_value(self, name):
0.09 __init__.py(1024):     def getoption(self, name, default=notset, skip=False):
0.09 __init__.py(1048):     def getvalue(self, name, path=None):
0.09 __init__.py(1052):     def getvalueorskip(self, name, path=None):
0.09 __init__.py(1057): def _assertion_supported():
0.09 __init__.py(1066): def _warn_about_missing_assertion(mode):
0.09 __init__.py(1084): def setns(obj, dic):
0.09 __init__.py(1106): def create_terminal_writer(config, *args, **kwargs):
0.09 __init__.py(1119): def _strtobool(val):
0.15 __init__.py(55):     from _pytest.main import ExitCode
0.15 __init__.py(57):     try:
0.15 __init__.py(58):         try:
0.15 __init__.py(59):             config = _prepareconfig(args, plugins)
0.15 __init__.py(186):     warning = None
0.15 __init__.py(187):     if args is None:
0.15 __init__.py(188):         args = sys.argv[1:]
0.15 __init__.py(195):     config = get_config(args, plugins)
0.15 __init__.py(156):     pluginmanager = PytestPluginManager()
0.15 __init__.py(240):         super().__init__("pytest")
0.15 __init__.py(241):         self._conftest_plugins = set()
0.15 __init__.py(244):         self._dirpath2confmods = {}
0.15 __init__.py(245):         self._conftestpath2mod = {}
0.15 __init__.py(246):         self._confcutdir = None
0.15 __init__.py(247):         self._noconftest = False
0.15 __init__.py(248):         self._duplicatepaths = set()
0.15 __init__.py(250):         self.add_hookspecs(_pytest.hookspec)
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(299):             method = getattr(module_or_class, name)
0.15 __init__.py(301):             if name.startswith("pytest_"):
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(304):                 known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(306):                     "firstresult": hasattr(method, "firstresult")
0.15 __init__.py(307):                     or "firstresult" in known_marks,
0.15 __init__.py(308):                     "historic": hasattr(method, "historic")
0.15 __init__.py(309):                     or "historic" in known_marks,
0.15 __init__.py(305):                 opts = {
0.15 __init__.py(311):         return opts
0.15 __init__.py(297):         opts = super().parse_hookspec_opts(module_or_class, name)
0.15 __init__.py(298):         if opts is None:
0.15 __init__.py(311):         return opts
0.15 __init__.py(251):         self.register(self)
0.15 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.15 __init__.py(324):         ret = super().register(plugin, name)
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(325):         if ret:
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.15 __init__.py(332):         return ret
0.15 __init__.py(252):         if os.environ.get("PYTEST_DEBUG"):
0.15 __init__.py(263):         self.rewrite_hook = _pytest.assertion.DummyRewriteHook()
0.15 __init__.py(265):         self._configured = False
0.15 __init__.py(157):     config = Config(
0.15 __init__.py(158):         pluginmanager,
0.15 __init__.py(159):         invocation_params=Config.InvocationParams(
0.15 __init__.py(160):             args=args, plugins=plugins, dir=Path().resolve()
0.15 __init__.py(159):         invocation_params=Config.InvocationParams(
0.15 <attrs generated init _pytest.config.Config.InvocationParams>(2):     _setattr = _cached_setattr_get(self)
0.15 <attrs generated init _pytest.config.Config.InvocationParams>(3):     _inst_dict = self.__dict__
0.15 <attrs generated init _pytest.config.Config.InvocationParams>(4):     _inst_dict['args'] = args
0.15 <attrs generated init _pytest.config.Config.InvocationParams>(5):     _inst_dict['plugins'] = plugins
0.15 <attrs generated init _pytest.config.Config.InvocationParams>(6):     _inst_dict['dir'] = dir
0.15 __init__.py(157):     config = Config(
0.15 __init__.py(663):         from .argparsing import Parser, FILE_OR_DIR
0.15 __init__.py(665):         if invocation_params is None:
0.15 __init__.py(670):         self.option = argparse.Namespace()
0.15 __init__.py(671):         self.invocation_params = invocation_params
0.15 __init__.py(673):         _a = FILE_OR_DIR
0.15 __init__.py(674):         self._parser = Parser(
0.15 __init__.py(675):             usage="%(prog)s [options] [{}] [{}] [...]".format(_a, _a),
0.15 __init__.py(676):             processopt=self._processopt,
0.15 __init__.py(674):         self._parser = Parser(
0.15 __init__.py(678):         self.pluginmanager = pluginmanager
0.15 __init__.py(679):         self.trace = self.pluginmanager.trace.root.get("config")
0.15 __init__.py(680):         self.hook = self.pluginmanager.hook
0.15 __init__.py(681):         self._inicache = {}
0.15 __init__.py(682):         self._override_ini = ()
0.15 __init__.py(683):         self._opt2dest = {}
0.15 __init__.py(684):         self._cleanup = []
0.15 __init__.py(685):         self.pluginmanager.register(self, "pytestconfig")
0.15 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.15 __init__.py(324):         ret = super().register(plugin, name)
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(325):         if ret:
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.15 __init__.py(332):         return ret
0.15 __init__.py(686):         self._configured = False
0.15 __init__.py(687):         self.hook.pytest_addoption.call_historic(kwargs=dict(parser=self._parser))
0.15 __init__.py(164):     if args is not None:
0.15 __init__.py(166):         pluginmanager.consider_preparse(args)
0.15 __init__.py(474):         i = 0
0.15 __init__.py(475):         n = len(args)
0.15 __init__.py(476):         while i < n:
0.15 __init__.py(477):             opt = args[i]
0.15 __init__.py(478):             i += 1
0.15 __init__.py(479):             if isinstance(opt, str):
0.15 __init__.py(480):                 if opt == "-p":
0.15 __init__.py(486):                 elif opt.startswith("-p"):
0.15 __init__.py(476):         while i < n:
0.15 __init__.py(477):             opt = args[i]
0.15 __init__.py(478):             i += 1
0.15 __init__.py(479):             if isinstance(opt, str):
0.15 __init__.py(480):                 if opt == "-p":
0.15 __init__.py(486):                 elif opt.startswith("-p"):
0.15 __init__.py(476):         while i < n:
0.15 __init__.py(168):     for spec in default_plugins:
0.15 __init__.py(169):         pluginmanager.import_plugin(spec)
0.15 __init__.py(540):         assert isinstance(modname, str), (
0.15 __init__.py(543):         modname = str(modname)
0.15 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.15 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.15 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.15 __init__.py(550):         if consider_entry_points:
0.15 __init__.py(555):         try:
0.15 __init__.py(556):             __import__(importspec)
0.15 __init__.py(575):             mod = sys.modules[importspec]
0.15 __init__.py(576):             self.register(mod, modname)
0.15 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.15 __init__.py(324):         ret = super().register(plugin, name)
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(775):             self._opt2dest[name] = opt.dest
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.15 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.15 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(775):             self._opt2dest[name] = opt.dest
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.15 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.15 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(775):             self._opt2dest[name] = opt.dest
0.15 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.15 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(274):         if name == "pytest_plugins":
0.15 __init__.py(277):         method = getattr(plugin, name)
0.15 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.15 __init__.py(281):         if not inspect.isroutine(method):
0.15 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.15 __init__.py(286):             opts = {}
0.15 __init__.py(287):         if opts is not None:
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.15 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.15 __init__.py(294):         return opts
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(325):         if ret:
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.15 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.15 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.15 __init__.py(331):                 self.consider_module(plugin)
0.15 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.15 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.15 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.15 __init__.py(588):         if isinstance(specs, str):
0.15 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.15 __init__.py(595):         return list(specs)
0.15 __init__.py(528):         for import_spec in plugins:
0.15 __init__.py(332):         return ret
0.15 __init__.py(168):     for spec in default_plugins:
0.15 __init__.py(169):         pluginmanager.import_plugin(spec)
0.15 __init__.py(540):         assert isinstance(modname, str), (
0.15 __init__.py(543):         modname = str(modname)
0.15 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.15 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.15 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.15 __init__.py(550):         if consider_entry_points:
0.15 __init__.py(555):         try:
0.15 __init__.py(556):             __import__(importspec)
0.15 __init__.py(575):             mod = sys.modules[importspec]
0.15 __init__.py(576):             self.register(mod, modname)
0.15 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.15 __init__.py(324):         ret = super().register(plugin, name)
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.15 __init__.py(271):         if not name.startswith("pytest_"):
0.15 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(325):         if ret:
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.16 __init__.py(331):                 self.consider_module(plugin)
0.16 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.16 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.16 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.16 __init__.py(588):         if isinstance(specs, str):
0.16 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.16 __init__.py(595):         return list(specs)
0.16 __init__.py(528):         for import_spec in plugins:
0.16 __init__.py(332):         return ret
0.16 __init__.py(168):     for spec in default_plugins:
0.16 __init__.py(169):         pluginmanager.import_plugin(spec)
0.16 __init__.py(540):         assert isinstance(modname, str), (
0.16 __init__.py(543):         modname = str(modname)
0.16 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.16 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.16 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.16 __init__.py(550):         if consider_entry_points:
0.16 __init__.py(555):         try:
0.16 __init__.py(556):             __import__(importspec)
0.16 __init__.py(575):             mod = sys.modules[importspec]
0.16 __init__.py(576):             self.register(mod, modname)
0.16 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.16 __init__.py(324):         ret = super().register(plugin, name)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(325):         if ret:
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.16 __init__.py(331):                 self.consider_module(plugin)
0.16 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.16 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.16 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.16 __init__.py(588):         if isinstance(specs, str):
0.16 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.16 __init__.py(595):         return list(specs)
0.16 __init__.py(528):         for import_spec in plugins:
0.16 __init__.py(332):         return ret
0.16 __init__.py(168):     for spec in default_plugins:
0.16 __init__.py(169):         pluginmanager.import_plugin(spec)
0.16 __init__.py(540):         assert isinstance(modname, str), (
0.16 __init__.py(543):         modname = str(modname)
0.16 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.16 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.16 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.16 __init__.py(550):         if consider_entry_points:
0.16 __init__.py(555):         try:
0.16 __init__.py(556):             __import__(importspec)
0.16 __init__.py(575):             mod = sys.modules[importspec]
0.16 __init__.py(576):             self.register(mod, modname)
0.16 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.16 __init__.py(324):         ret = super().register(plugin, name)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(325):         if ret:
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.16 __init__.py(331):                 self.consider_module(plugin)
0.16 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.16 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.16 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.16 __init__.py(588):         if isinstance(specs, str):
0.16 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.16 __init__.py(595):         return list(specs)
0.16 __init__.py(528):         for import_spec in plugins:
0.16 __init__.py(332):         return ret
0.16 __init__.py(168):     for spec in default_plugins:
0.16 __init__.py(169):         pluginmanager.import_plugin(spec)
0.16 __init__.py(540):         assert isinstance(modname, str), (
0.16 __init__.py(543):         modname = str(modname)
0.16 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.16 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.16 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.16 __init__.py(550):         if consider_entry_points:
0.16 __init__.py(555):         try:
0.16 __init__.py(556):             __import__(importspec)
0.16 __init__.py(575):             mod = sys.modules[importspec]
0.16 __init__.py(576):             self.register(mod, modname)
0.16 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.16 __init__.py(324):         ret = super().register(plugin, name)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(325):         if ret:
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.16 __init__.py(331):                 self.consider_module(plugin)
0.16 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.16 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.16 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.16 __init__.py(588):         if isinstance(specs, str):
0.16 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.16 __init__.py(595):         return list(specs)
0.16 __init__.py(528):         for import_spec in plugins:
0.16 __init__.py(332):         return ret
0.16 __init__.py(168):     for spec in default_plugins:
0.16 __init__.py(169):         pluginmanager.import_plugin(spec)
0.16 __init__.py(540):         assert isinstance(modname, str), (
0.16 __init__.py(543):         modname = str(modname)
0.16 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.16 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.16 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.16 __init__.py(550):         if consider_entry_points:
0.16 __init__.py(555):         try:
0.16 __init__.py(556):             __import__(importspec)
0.16 __init__.py(575):             mod = sys.modules[importspec]
0.16 __init__.py(576):             self.register(mod, modname)
0.16 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.16 __init__.py(324):         ret = super().register(plugin, name)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(775):             self._opt2dest[name] = opt.dest
0.16 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.16 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.16 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.16 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(286):             opts = {}
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(274):         if name == "pytest_plugins":
0.16 __init__.py(277):         method = getattr(plugin, name)
0.16 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.16 __init__.py(281):         if not inspect.isroutine(method):
0.16 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.16 __init__.py(287):         if opts is not None:
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.16 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.16 __init__.py(294):         return opts
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(271):         if not name.startswith("pytest_"):
0.16 __init__.py(272):             return
0.16 __init__.py(325):         if ret:
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.16 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.16 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.16 __init__.py(331):                 self.consider_module(plugin)
0.16 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.16 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.16 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.16 __init__.py(588):         if isinstance(specs, str):
0.16 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.16 __init__.py(595):         return list(specs)
0.16 __init__.py(528):         for import_spec in plugins:
0.16 __init__.py(332):         return ret
0.16 __init__.py(168):     for spec in default_plugins:
0.16 __init__.py(169):         pluginmanager.import_plugin(spec)
0.16 __init__.py(540):         assert isinstance(modname, str), (
0.16 __init__.py(543):         modname = str(modname)
0.16 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.16 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.16 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.16 __init__.py(550):         if consider_entry_points:
0.16 __init__.py(555):         try:
0.16 __init__.py(556):             __import__(importspec)
0.17 __init__.py(575):             mod = sys.modules[importspec]
0.17 __init__.py(576):             self.register(mod, modname)
0.17 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.17 __init__.py(324):         ret = super().register(plugin, name)
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(286):             opts = {}
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.17 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(286):             opts = {}
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(325):         if ret:
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.17 __init__.py(331):                 self.consider_module(plugin)
0.17 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.17 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.17 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.17 __init__.py(588):         if isinstance(specs, str):
0.17 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.17 __init__.py(595):         return list(specs)
0.17 __init__.py(528):         for import_spec in plugins:
0.17 __init__.py(332):         return ret
0.17 __init__.py(168):     for spec in default_plugins:
0.17 __init__.py(169):         pluginmanager.import_plugin(spec)
0.17 __init__.py(540):         assert isinstance(modname, str), (
0.17 __init__.py(543):         modname = str(modname)
0.17 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.17 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.17 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.17 __init__.py(550):         if consider_entry_points:
0.17 __init__.py(555):         try:
0.17 __init__.py(556):             __import__(importspec)
0.17 __init__.py(575):             mod = sys.modules[importspec]
0.17 __init__.py(576):             self.register(mod, modname)
0.17 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.17 __init__.py(324):         ret = super().register(plugin, name)
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(286):             opts = {}
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(775):             self._opt2dest[name] = opt.dest
0.17 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.17 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(286):             opts = {}
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(325):         if ret:
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.17 __init__.py(331):                 self.consider_module(plugin)
0.17 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.17 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.17 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.17 __init__.py(588):         if isinstance(specs, str):
0.17 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.17 __init__.py(595):         return list(specs)
0.17 __init__.py(528):         for import_spec in plugins:
0.17 __init__.py(332):         return ret
0.17 __init__.py(168):     for spec in default_plugins:
0.17 __init__.py(169):         pluginmanager.import_plugin(spec)
0.17 __init__.py(540):         assert isinstance(modname, str), (
0.17 __init__.py(543):         modname = str(modname)
0.17 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.17 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.17 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.17 __init__.py(550):         if consider_entry_points:
0.17 __init__.py(555):         try:
0.17 __init__.py(556):             __import__(importspec)
0.17 __init__.py(575):             mod = sys.modules[importspec]
0.17 __init__.py(576):             self.register(mod, modname)
0.17 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.17 __init__.py(324):         ret = super().register(plugin, name)
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(286):             opts = {}
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(274):         if name == "pytest_plugins":
0.17 __init__.py(277):         method = getattr(plugin, name)
0.17 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.17 __init__.py(281):         if not inspect.isroutine(method):
0.17 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.17 __init__.py(287):         if opts is not None:
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.17 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.17 __init__.py(294):         return opts
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(271):         if not name.startswith("pytest_"):
0.17 __init__.py(272):             return
0.17 __init__.py(325):         if ret:
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.17 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.17 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.17 __init__.py(331):                 self.consider_module(plugin)
0.17 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.17 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.17 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.17 __init__.py(588):         if isinstance(specs, str):
0.17 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.17 __init__.py(595):         return list(specs)
0.17 __init__.py(528):         for import_spec in plugins:
0.17 __init__.py(332):         return ret
0.17 __init__.py(168):     for spec in default_plugins:
0.17 __init__.py(169):         pluginmanager.import_plugin(spec)
0.17 __init__.py(540):         assert isinstance(modname, str), (
0.17 __init__.py(543):         modname = str(modname)
0.17 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.17 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.17 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.17 __init__.py(550):         if consider_entry_points:
0.17 __init__.py(555):         try:
0.17 __init__.py(556):             __import__(importspec)
0.17 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(775):             self._opt2dest[name] = opt.dest
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.18 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.18 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(775):             self._opt2dest[name] = opt.dest
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(775):             self._opt2dest[name] = opt.dest
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.18 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.18 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(775):             self._opt2dest[name] = opt.dest
0.18 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.18 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.18 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.18 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(325):         if ret:
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.18 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.18 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.18 __init__.py(331):                 self.consider_module(plugin)
0.18 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.18 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.18 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.18 __init__.py(588):         if isinstance(specs, str):
0.18 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.18 __init__.py(595):         return list(specs)
0.18 __init__.py(528):         for import_spec in plugins:
0.18 __init__.py(332):         return ret
0.18 __init__.py(168):     for spec in default_plugins:
0.18 __init__.py(169):         pluginmanager.import_plugin(spec)
0.18 __init__.py(540):         assert isinstance(modname, str), (
0.18 __init__.py(543):         modname = str(modname)
0.18 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.18 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.18 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.18 __init__.py(550):         if consider_entry_points:
0.18 __init__.py(555):         try:
0.18 __init__.py(556):             __import__(importspec)
0.18 __init__.py(575):             mod = sys.modules[importspec]
0.18 __init__.py(576):             self.register(mod, modname)
0.18 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.18 __init__.py(324):         ret = super().register(plugin, name)
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(272):             return
0.18 __init__.py(271):         if not name.startswith("pytest_"):
0.18 __init__.py(274):         if name == "pytest_plugins":
0.18 __init__.py(277):         method = getattr(plugin, name)
0.18 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.18 __init__.py(281):         if not inspect.isroutine(method):
0.18 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.18 __init__.py(286):             opts = {}
0.18 __init__.py(287):         if opts is not None:
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.18 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.18 __init__.py(294):         return opts
0.19 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.19 __init__.py(775):             self._opt2dest[name] = opt.dest
0.19 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.19 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.19 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.19 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(274):         if name == "pytest_plugins":
0.19 __init__.py(277):         method = getattr(plugin, name)
0.19 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.19 __init__.py(281):         if not inspect.isroutine(method):
0.19 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.19 __init__.py(286):             opts = {}
0.19 __init__.py(287):         if opts is not None:
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(294):         return opts
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(274):         if name == "pytest_plugins":
0.19 __init__.py(277):         method = getattr(plugin, name)
0.19 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.19 __init__.py(281):         if not inspect.isroutine(method):
0.19 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.19 __init__.py(286):             opts = {}
0.19 __init__.py(287):         if opts is not None:
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(294):         return opts
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(274):         if name == "pytest_plugins":
0.19 __init__.py(277):         method = getattr(plugin, name)
0.19 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.19 __init__.py(281):         if not inspect.isroutine(method):
0.19 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.19 __init__.py(286):             opts = {}
0.19 __init__.py(287):         if opts is not None:
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(294):         return opts
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(274):         if name == "pytest_plugins":
0.19 __init__.py(277):         method = getattr(plugin, name)
0.19 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.19 __init__.py(281):         if not inspect.isroutine(method):
0.19 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.19 __init__.py(286):             opts = {}
0.19 __init__.py(287):         if opts is not None:
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(294):         return opts
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(274):         if name == "pytest_plugins":
0.19 __init__.py(277):         method = getattr(plugin, name)
0.19 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.19 __init__.py(281):         if not inspect.isroutine(method):
0.19 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.19 __init__.py(286):             opts = {}
0.19 __init__.py(287):         if opts is not None:
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.19 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.19 __init__.py(294):         return opts
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(272):             return
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(272):             return
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(272):             return
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(272):             return
0.19 __init__.py(271):         if not name.startswith("pytest_"):
0.19 __init__.py(272):             return
0.19 __init__.py(325):         if ret:
0.19 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.19 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.19 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.19 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.19 __init__.py(331):                 self.consider_module(plugin)
0.19 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.19 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.19 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.19 __init__.py(588):         if isinstance(specs, str):
0.19 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.19 __init__.py(595):         return list(specs)
0.19 __init__.py(528):         for import_spec in plugins:
0.19 __init__.py(332):         return ret
0.19 __init__.py(168):     for spec in default_plugins:
0.19 __init__.py(169):         pluginmanager.import_plugin(spec)
0.19 __init__.py(540):         assert isinstance(modname, str), (
0.19 __init__.py(543):         modname = str(modname)
0.19 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.19 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.19 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.19 __init__.py(550):         if consider_entry_points:
0.19 __init__.py(555):         try:
0.19 __init__.py(556):             __import__(importspec)
0.20 __init__.py(575):             mod = sys.modules[importspec]
0.20 __init__.py(576):             self.register(mod, modname)
0.20 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.20 __init__.py(324):         ret = super().register(plugin, name)
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.20 __init__.py(271):         if not name.startswith("pytest_"):
0.20 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(325):         if ret:
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.21 __init__.py(331):                 self.consider_module(plugin)
0.21 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.21 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.21 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.21 __init__.py(588):         if isinstance(specs, str):
0.21 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.21 __init__.py(595):         return list(specs)
0.21 __init__.py(528):         for import_spec in plugins:
0.21 __init__.py(332):         return ret
0.21 __init__.py(168):     for spec in default_plugins:
0.21 __init__.py(169):         pluginmanager.import_plugin(spec)
0.21 __init__.py(540):         assert isinstance(modname, str), (
0.21 __init__.py(543):         modname = str(modname)
0.21 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.21 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.21 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.21 __init__.py(550):         if consider_entry_points:
0.21 __init__.py(555):         try:
0.21 __init__.py(556):             __import__(importspec)
0.21 __init__.py(575):             mod = sys.modules[importspec]
0.21 __init__.py(576):             self.register(mod, modname)
0.21 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.21 __init__.py(324):         ret = super().register(plugin, name)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(325):         if ret:
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.21 __init__.py(331):                 self.consider_module(plugin)
0.21 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.21 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.21 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.21 __init__.py(588):         if isinstance(specs, str):
0.21 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.21 __init__.py(595):         return list(specs)
0.21 __init__.py(528):         for import_spec in plugins:
0.21 __init__.py(332):         return ret
0.21 __init__.py(168):     for spec in default_plugins:
0.21 __init__.py(169):         pluginmanager.import_plugin(spec)
0.21 __init__.py(540):         assert isinstance(modname, str), (
0.21 __init__.py(543):         modname = str(modname)
0.21 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.21 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.21 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.21 __init__.py(550):         if consider_entry_points:
0.21 __init__.py(555):         try:
0.21 __init__.py(556):             __import__(importspec)
0.21 __init__.py(575):             mod = sys.modules[importspec]
0.21 __init__.py(576):             self.register(mod, modname)
0.21 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.21 __init__.py(324):         ret = super().register(plugin, name)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(325):         if ret:
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.21 __init__.py(331):                 self.consider_module(plugin)
0.21 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.21 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.21 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.21 __init__.py(588):         if isinstance(specs, str):
0.21 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.21 __init__.py(595):         return list(specs)
0.21 __init__.py(528):         for import_spec in plugins:
0.21 __init__.py(332):         return ret
0.21 __init__.py(168):     for spec in default_plugins:
0.21 __init__.py(169):         pluginmanager.import_plugin(spec)
0.21 __init__.py(540):         assert isinstance(modname, str), (
0.21 __init__.py(543):         modname = str(modname)
0.21 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.21 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.21 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.21 __init__.py(550):         if consider_entry_points:
0.21 __init__.py(555):         try:
0.21 __init__.py(556):             __import__(importspec)
0.21 __init__.py(575):             mod = sys.modules[importspec]
0.21 __init__.py(576):             self.register(mod, modname)
0.21 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.21 __init__.py(324):         ret = super().register(plugin, name)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(775):             self._opt2dest[name] = opt.dest
0.21 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.21 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.21 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.21 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(274):         if name == "pytest_plugins":
0.21 __init__.py(277):         method = getattr(plugin, name)
0.21 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.21 __init__.py(281):         if not inspect.isroutine(method):
0.21 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.21 __init__.py(286):             opts = {}
0.21 __init__.py(287):         if opts is not None:
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.21 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.21 __init__.py(294):         return opts
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(325):         if ret:
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.21 __init__.py(331):                 self.consider_module(plugin)
0.21 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.21 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.21 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.21 __init__.py(588):         if isinstance(specs, str):
0.21 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.21 __init__.py(595):         return list(specs)
0.21 __init__.py(528):         for import_spec in plugins:
0.21 __init__.py(332):         return ret
0.21 __init__.py(168):     for spec in default_plugins:
0.21 __init__.py(169):         pluginmanager.import_plugin(spec)
0.21 __init__.py(540):         assert isinstance(modname, str), (
0.21 __init__.py(543):         modname = str(modname)
0.21 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.21 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.21 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.21 __init__.py(550):         if consider_entry_points:
0.21 __init__.py(555):         try:
0.21 __init__.py(556):             __import__(importspec)
0.21 __init__.py(575):             mod = sys.modules[importspec]
0.21 __init__.py(576):             self.register(mod, modname)
0.21 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.21 __init__.py(324):         ret = super().register(plugin, name)
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(271):         if not name.startswith("pytest_"):
0.21 __init__.py(272):             return
0.21 __init__.py(325):         if ret:
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.21 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.21 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.21 __init__.py(331):                 self.consider_module(plugin)
0.21 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.21 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.21 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.21 __init__.py(588):         if isinstance(specs, str):
0.21 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.21 __init__.py(595):         return list(specs)
0.21 __init__.py(528):         for import_spec in plugins:
0.21 __init__.py(332):         return ret
0.21 __init__.py(168):     for spec in default_plugins:
0.21 __init__.py(169):         pluginmanager.import_plugin(spec)
0.21 __init__.py(540):         assert isinstance(modname, str), (
0.21 __init__.py(543):         modname = str(modname)
0.21 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.21 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.21 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.21 __init__.py(550):         if consider_entry_points:
0.21 __init__.py(555):         try:
0.21 __init__.py(556):             __import__(importspec)
0.22 __init__.py(575):             mod = sys.modules[importspec]
0.22 __init__.py(576):             self.register(mod, modname)
0.22 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.22 __init__.py(324):         ret = super().register(plugin, name)
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(325):         if ret:
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.22 __init__.py(331):                 self.consider_module(plugin)
0.22 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.22 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.22 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.22 __init__.py(588):         if isinstance(specs, str):
0.22 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.22 __init__.py(595):         return list(specs)
0.22 __init__.py(528):         for import_spec in plugins:
0.22 __init__.py(332):         return ret
0.22 __init__.py(168):     for spec in default_plugins:
0.22 __init__.py(169):         pluginmanager.import_plugin(spec)
0.22 __init__.py(540):         assert isinstance(modname, str), (
0.22 __init__.py(543):         modname = str(modname)
0.22 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.22 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.22 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.22 __init__.py(550):         if consider_entry_points:
0.22 __init__.py(555):         try:
0.22 __init__.py(556):             __import__(importspec)
0.22 __init__.py(575):             mod = sys.modules[importspec]
0.22 __init__.py(576):             self.register(mod, modname)
0.22 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.22 __init__.py(324):         ret = super().register(plugin, name)
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(325):         if ret:
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.22 __init__.py(331):                 self.consider_module(plugin)
0.22 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.22 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.22 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.22 __init__.py(588):         if isinstance(specs, str):
0.22 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.22 __init__.py(595):         return list(specs)
0.22 __init__.py(528):         for import_spec in plugins:
0.22 __init__.py(332):         return ret
0.22 __init__.py(168):     for spec in default_plugins:
0.22 __init__.py(169):         pluginmanager.import_plugin(spec)
0.22 __init__.py(540):         assert isinstance(modname, str), (
0.22 __init__.py(543):         modname = str(modname)
0.22 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.22 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.22 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.22 __init__.py(550):         if consider_entry_points:
0.22 __init__.py(555):         try:
0.22 __init__.py(556):             __import__(importspec)
0.22 __init__.py(575):             mod = sys.modules[importspec]
0.22 __init__.py(576):             self.register(mod, modname)
0.22 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.22 __init__.py(324):         ret = super().register(plugin, name)
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(325):         if ret:
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.22 __init__.py(331):                 self.consider_module(plugin)
0.22 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.22 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.22 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.22 __init__.py(588):         if isinstance(specs, str):
0.22 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.22 __init__.py(595):         return list(specs)
0.22 __init__.py(528):         for import_spec in plugins:
0.22 __init__.py(332):         return ret
0.22 __init__.py(168):     for spec in default_plugins:
0.22 __init__.py(169):         pluginmanager.import_plugin(spec)
0.22 __init__.py(540):         assert isinstance(modname, str), (
0.22 __init__.py(543):         modname = str(modname)
0.22 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.22 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.22 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.22 __init__.py(550):         if consider_entry_points:
0.22 __init__.py(555):         try:
0.22 __init__.py(556):             __import__(importspec)
0.22 __init__.py(575):             mod = sys.modules[importspec]
0.22 __init__.py(576):             self.register(mod, modname)
0.22 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.22 __init__.py(324):         ret = super().register(plugin, name)
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(775):             self._opt2dest[name] = opt.dest
0.22 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.22 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(286):             opts = {}
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(274):         if name == "pytest_plugins":
0.22 __init__.py(277):         method = getattr(plugin, name)
0.22 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.22 __init__.py(281):         if not inspect.isroutine(method):
0.22 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.22 __init__.py(287):         if opts is not None:
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.22 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.22 __init__.py(294):         return opts
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(271):         if not name.startswith("pytest_"):
0.22 __init__.py(272):             return
0.22 __init__.py(325):         if ret:
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.22 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.22 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.22 __init__.py(331):                 self.consider_module(plugin)
0.22 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.22 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.22 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.22 __init__.py(588):         if isinstance(specs, str):
0.22 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.22 __init__.py(595):         return list(specs)
0.22 __init__.py(528):         for import_spec in plugins:
0.22 __init__.py(332):         return ret
0.22 __init__.py(168):     for spec in default_plugins:
0.22 __init__.py(169):         pluginmanager.import_plugin(spec)
0.22 __init__.py(540):         assert isinstance(modname, str), (
0.22 __init__.py(543):         modname = str(modname)
0.22 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.22 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.22 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.22 __init__.py(550):         if consider_entry_points:
0.22 __init__.py(555):         try:
0.22 __init__.py(556):             __import__(importspec)
0.23 __init__.py(575):             mod = sys.modules[importspec]
0.23 __init__.py(576):             self.register(mod, modname)
0.23 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.23 __init__.py(324):         ret = super().register(plugin, name)
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(775):             self._opt2dest[name] = opt.dest
0.23 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.23 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(325):         if ret:
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.23 __init__.py(331):                 self.consider_module(plugin)
0.23 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.23 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.23 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.23 __init__.py(588):         if isinstance(specs, str):
0.23 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.23 __init__.py(595):         return list(specs)
0.23 __init__.py(528):         for import_spec in plugins:
0.23 __init__.py(332):         return ret
0.23 __init__.py(168):     for spec in default_plugins:
0.23 __init__.py(169):         pluginmanager.import_plugin(spec)
0.23 __init__.py(540):         assert isinstance(modname, str), (
0.23 __init__.py(543):         modname = str(modname)
0.23 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.23 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.23 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.23 __init__.py(550):         if consider_entry_points:
0.23 __init__.py(555):         try:
0.23 __init__.py(556):             __import__(importspec)
0.23 __init__.py(575):             mod = sys.modules[importspec]
0.23 __init__.py(576):             self.register(mod, modname)
0.23 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.23 __init__.py(324):         ret = super().register(plugin, name)
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(325):         if ret:
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.23 __init__.py(331):                 self.consider_module(plugin)
0.23 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.23 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.23 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.23 __init__.py(588):         if isinstance(specs, str):
0.23 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.23 __init__.py(595):         return list(specs)
0.23 __init__.py(528):         for import_spec in plugins:
0.23 __init__.py(332):         return ret
0.23 __init__.py(168):     for spec in default_plugins:
0.23 __init__.py(169):         pluginmanager.import_plugin(spec)
0.23 __init__.py(540):         assert isinstance(modname, str), (
0.23 __init__.py(543):         modname = str(modname)
0.23 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.23 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.23 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.23 __init__.py(550):         if consider_entry_points:
0.23 __init__.py(555):         try:
0.23 __init__.py(556):             __import__(importspec)
0.23 __init__.py(575):             mod = sys.modules[importspec]
0.23 __init__.py(576):             self.register(mod, modname)
0.23 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.23 __init__.py(324):         ret = super().register(plugin, name)
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(274):         if name == "pytest_plugins":
0.23 __init__.py(277):         method = getattr(plugin, name)
0.23 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.23 __init__.py(281):         if not inspect.isroutine(method):
0.23 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.23 __init__.py(286):             opts = {}
0.23 __init__.py(287):         if opts is not None:
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.23 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.23 __init__.py(294):         return opts
0.23 __init__.py(271):         if not name.startswith("pytest_"):
0.23 __init__.py(272):             return
0.23 __init__.py(325):         if ret:
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.23 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.23 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.23 __init__.py(331):                 self.consider_module(plugin)
0.23 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.23 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.23 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.23 __init__.py(588):         if isinstance(specs, str):
0.23 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.23 __init__.py(595):         return list(specs)
0.23 __init__.py(528):         for import_spec in plugins:
0.23 __init__.py(332):         return ret
0.23 __init__.py(168):     for spec in default_plugins:
0.23 __init__.py(170):     return config
0.23 __init__.py(196):     pluginmanager = config.pluginmanager
0.23 __init__.py(197):     try:
0.23 __init__.py(198):         if plugins:
0.23 __init__.py(204):         if warning:
0.23 __init__.py(208):         return pluginmanager.hook.pytest_cmdline_parse(
0.23 __init__.py(209):             pluginmanager=pluginmanager, args=args
0.23 __init__.py(208):         return pluginmanager.hook.pytest_cmdline_parse(
0.23 __init__.py(719):         try:
0.23 __init__.py(720):             self.parse(args)
0.23 __init__.py(921):         assert not hasattr(
0.23 __init__.py(922):             self, "args"
0.23 __init__.py(921):         assert not hasattr(
0.23 __init__.py(924):         assert self.invocation_params.args == args
0.23 __init__.py(925):         self.hook.pytest_addhooks.call_historic(
0.23 __init__.py(926):             kwargs=dict(pluginmanager=self.pluginmanager)
0.23 __init__.py(925):         self.hook.pytest_addhooks.call_historic(
0.23 __init__.py(928):         self._preparse(args, addopts=addopts)
0.23 __init__.py(855):         if addopts:
0.23 __init__.py(856):             env_addopts = os.environ.get("PYTEST_ADDOPTS", "")
0.23 __init__.py(857):             if len(env_addopts):
0.23 __init__.py(862):         self._initini(args)
0.23 __init__.py(786):         ns, unknown_args = self._parser.parse_known_and_unknown_args(
0.23 __init__.py(787):             args, namespace=copy.copy(self.option)
0.23 __init__.py(786):         ns, unknown_args = self._parser.parse_known_and_unknown_args(
0.23 __init__.py(789):         r = determine_setup(
0.23 __init__.py(790):             ns.inifilename,
0.23 __init__.py(791):             ns.file_or_dir + unknown_args,
0.23 __init__.py(792):             rootdir_cmd_arg=ns.rootdir or None,
0.23 __init__.py(793):             config=self,
0.23 __init__.py(789):         r = determine_setup(
0.23 __init__.py(795):         self.rootdir, self.inifile, self.inicfg = r
0.23 __init__.py(796):         self._parser.extra_info["rootdir"] = self.rootdir
0.23 __init__.py(797):         self._parser.extra_info["inifile"] = self.inifile
0.23 __init__.py(798):         self._parser.addini("addopts", "extra command line options", "args")
0.23 __init__.py(799):         self._parser.addini("minversion", "minimally required pytest version")
0.23 __init__.py(800):         self._override_ini = ns.override_ini or ()
0.23 __init__.py(863):         if addopts:
0.23 __init__.py(865):                 self._validate_args(self.getini("addopts"), "via addopts config") + args
0.23 __init__.py(958):         try:
0.23 __init__.py(959):             return self._inicache[name]
0.23 __init__.py(960):         except KeyError:
0.23 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.23 __init__.py(965):         try:
0.23 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.23 __init__.py(969):         value = self._get_override_ini_value(name)
0.23 __init__.py(1010):         value = None
0.23 __init__.py(1014):         for ini_config in self._override_ini:
0.23 __init__.py(1022):         return value
0.23 __init__.py(970):         if value is None:
0.23 __init__.py(971):             try:
0.23 __init__.py(972):                 value = self.inicfg[name]
0.23 __init__.py(979):         if type == "pathlist":
0.23 __init__.py(985):         elif type == "args":
0.23 __init__.py(986):             return shlex.split(value)
0.23 __init__.py(962):             return val
0.23 __init__.py(844):         self._parser._config_source_hint = via
0.23 __init__.py(845):         try:
0.23 __init__.py(846):             self._parser.parse_known_and_unknown_args(
0.23 __init__.py(847):                 args, namespace=copy.copy(self.option)
0.23 __init__.py(846):             self._parser.parse_known_and_unknown_args(
0.24 __init__.py(850):             del self._parser._config_source_hint
0.24 __init__.py(852):         return args
0.24 __init__.py(864):             args[:] = (
0.24 __init__.py(868):         self._checkversion()
0.24 __init__.py(904):         import pytest
0.24 __init__.py(906):         minver = self.inicfg.get("minversion", None)
0.24 __init__.py(907):         if minver:
0.24 __init__.py(908):             if Version(minver) > Version(pytest.__version__):
0.24 __init__.py(869):         self._consider_importhook(args)
0.24 __init__.py(809):         ns, unknown_args = self._parser.parse_known_and_unknown_args(args)
0.24 __init__.py(810):         mode = getattr(ns, "assertmode", "plain")
0.24 __init__.py(811):         if mode == "rewrite":
0.24 __init__.py(812):             try:
0.24 __init__.py(813):                 hook = _pytest.assertion.install_importhook(self)
0.24 __init__.py(958):         try:
0.24 __init__.py(959):             return self._inicache[name]
0.24 __init__.py(960):         except KeyError:
0.24 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.24 __init__.py(965):         try:
0.24 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.24 __init__.py(969):         value = self._get_override_ini_value(name)
0.24 __init__.py(1010):         value = None
0.24 __init__.py(1014):         for ini_config in self._override_ini:
0.24 __init__.py(1022):         return value
0.24 __init__.py(970):         if value is None:
0.24 __init__.py(971):             try:
0.24 __init__.py(972):                 value = self.inicfg[name]
0.24 __init__.py(979):         if type == "pathlist":
0.24 __init__.py(985):         elif type == "args":
0.24 __init__.py(986):             return shlex.split(value)
0.24 __init__.py(962):             return val
0.24 __init__.py(697):         self._cleanup.append(func)
0.24 __init__.py(817):                 self._mark_plugins_for_rewrite(hook)
0.24 __init__.py(826):         self.pluginmanager.rewrite_hook = hook
0.24 __init__.py(828):         if os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(839):         for name in _iter_rewritable_modules(package_files):
0.24 __init__.py(615):     for fn in package_files:
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(834):             for dist in importlib_metadata.distributions()
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(835):             if any(ep.group == "pytest11" for ep in dist.entry_points)
0.24 __init__.py(832):         package_files = (
0.24 __init__.py(818):         _warn_about_missing_assertion(mode)
0.24 __init__.py(1067):     if not _assertion_supported():
0.24 __init__.py(1058):     try:
0.24 __init__.py(1059):         assert False
0.24 __init__.py(1060):     except AssertionError:
0.24 __init__.py(1061):         return True
0.24 __init__.py(870):         self.pluginmanager.consider_preparse(args)
0.24 __init__.py(474):         i = 0
0.24 __init__.py(475):         n = len(args)
0.24 __init__.py(476):         while i < n:
0.24 __init__.py(477):             opt = args[i]
0.24 __init__.py(478):             i += 1
0.24 __init__.py(479):             if isinstance(opt, str):
0.24 __init__.py(480):                 if opt == "-p":
0.24 __init__.py(486):                 elif opt.startswith("-p"):
0.24 __init__.py(476):         while i < n:
0.24 __init__.py(477):             opt = args[i]
0.24 __init__.py(478):             i += 1
0.24 __init__.py(479):             if isinstance(opt, str):
0.24 __init__.py(480):                 if opt == "-p":
0.24 __init__.py(481):                     try:
0.24 __init__.py(482):                         parg = args[i]
0.24 __init__.py(485):                     i += 1
0.24 __init__.py(490):                 self.consider_pluginarg(parg)
0.24 __init__.py(493):         if arg.startswith("no:"):
0.24 __init__.py(507):             name = arg
0.24 __init__.py(510):             if self._name2plugin.get(name, -1) is None:
0.24 __init__.py(512):             if not name.startswith("pytest_"):
0.24 __init__.py(513):                 if self._name2plugin.get("pytest_" + name, -1) is None:
0.24 __init__.py(515):             self.import_plugin(arg, consider_entry_points=True)
0.24 __init__.py(540):         assert isinstance(modname, str), (
0.24 __init__.py(543):         modname = str(modname)
0.24 __init__.py(544):         if self.is_blocked(modname) or self.get_plugin(modname) is not None:
0.24 __init__.py(547):         importspec = "_pytest." + modname if modname in builtin_plugins else modname
0.24 __init__.py(548):         self.rewrite_hook.mark_rewrite(importspec)
0.24 __init__.py(550):         if consider_entry_points:
0.24 __init__.py(551):             loaded = self.load_setuptools_entrypoints("pytest11", name=modname)
0.25 __init__.py(552):             if loaded:
0.25 __init__.py(555):         try:
0.25 __init__.py(556):             __import__(importspec)
0.25 pathlib.py(317):     path = PurePath(path)
0.25 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.25 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.25 pathlib.py(326):     if sep not in pattern:
0.25 pathlib.py(327):         name = path.name
0.25 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.25 pathlib.py(317):     path = PurePath(path)
0.25 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.25 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.25 pathlib.py(326):     if sep not in pattern:
0.25 pathlib.py(327):         name = path.name
0.25 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.25 pathlib.py(317):     path = PurePath(path)
0.25 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.25 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.25 pathlib.py(326):     if sep not in pattern:
0.25 pathlib.py(327):         name = path.name
0.25 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.25 pathlib.py(317):     path = PurePath(path)
0.25 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.25 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.25 pathlib.py(326):     if sep not in pattern:
0.25 pathlib.py(327):         name = path.name
0.25 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.25 pathlib.py(317):     path = PurePath(path)
0.25 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.25 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.25 pathlib.py(326):     if sep not in pattern:
0.25 pathlib.py(329):         name = str(path)
0.25 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.25 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.25 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.25 __init__.py(958):         try:
0.25 __init__.py(959):             return self._inicache[name]
0.25 __init__.py(960):         except KeyError:
0.25 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.25 __init__.py(965):         try:
0.25 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.25 __init__.py(969):         value = self._get_override_ini_value(name)
0.25 __init__.py(1010):         value = None
0.25 __init__.py(1014):         for ini_config in self._override_ini:
0.25 __init__.py(1022):         return value
0.25 __init__.py(970):         if value is None:
0.25 __init__.py(971):             try:
0.25 __init__.py(972):                 value = self.inicfg[name]
0.25 __init__.py(973):             except KeyError:
0.25 __init__.py(974):                 if default is not None:
0.25 __init__.py(975):                     return default
0.25 __init__.py(962):             return val
0.28 __init__.py(575):             mod = sys.modules[importspec]
0.28 __init__.py(576):             self.register(mod, modname)
0.28 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.28 __init__.py(324):         ret = super().register(plugin, name)
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(286):             opts = {}
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.28 __init__.py(775):             self._opt2dest[name] = opt.dest
0.28 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.28 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.28 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.28 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.28 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.28 __init__.py(775):             self._opt2dest[name] = opt.dest
0.28 __init__.py(774):         for name in opt._short_opts + opt._long_opts:
0.28 __init__.py(777):         if hasattr(opt, "default") and opt.dest:
0.28 __init__.py(778):             if not hasattr(self.option, opt.dest):
0.28 __init__.py(779):                 setattr(self.option, opt.dest, opt.default)
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(286):             opts = {}
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(325):         if ret:
0.28 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.28 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.28 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.28 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.28 __init__.py(331):                 self.consider_module(plugin)
0.28 __init__.py(524):         self._import_plugin_specs(getattr(mod, "pytest_plugins", []))
0.28 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.28 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.28 __init__.py(588):         if isinstance(specs, str):
0.28 __init__.py(590):         if not isinstance(specs, (list, tuple)):
0.28 __init__.py(595):         return list(specs)
0.28 __init__.py(528):         for import_spec in plugins:
0.28 __init__.py(332):         return ret
0.28 __init__.py(476):         while i < n:
0.28 __init__.py(477):             opt = args[i]
0.28 __init__.py(478):             i += 1
0.28 __init__.py(479):             if isinstance(opt, str):
0.28 __init__.py(480):                 if opt == "-p":
0.28 __init__.py(486):                 elif opt.startswith("-p"):
0.28 __init__.py(476):         while i < n:
0.28 __init__.py(477):             opt = args[i]
0.28 __init__.py(478):             i += 1
0.28 __init__.py(479):             if isinstance(opt, str):
0.28 __init__.py(480):                 if opt == "-p":
0.28 __init__.py(486):                 elif opt.startswith("-p"):
0.28 __init__.py(476):         while i < n:
0.28 __init__.py(477):             opt = args[i]
0.28 __init__.py(478):             i += 1
0.28 __init__.py(479):             if isinstance(opt, str):
0.28 __init__.py(480):                 if opt == "-p":
0.28 __init__.py(486):                 elif opt.startswith("-p"):
0.28 __init__.py(476):         while i < n:
0.28 __init__.py(871):         if not os.environ.get("PYTEST_DISABLE_PLUGIN_AUTOLOAD"):
0.28 __init__.py(874):             self.pluginmanager.load_setuptools_entrypoints("pytest11")
0.28 __init__.py(875):         self.pluginmanager.consider_env()
0.28 __init__.py(521):         self._import_plugin_specs(os.environ.get("PYTEST_PLUGINS"))
0.28 __init__.py(527):         plugins = _get_plugin_specs_as_list(spec)
0.28 __init__.py(587):     if specs is not None and not isinstance(specs, types.ModuleType):
0.28 __init__.py(596):     return []
0.28 __init__.py(528):         for import_spec in plugins:
0.28 __init__.py(876):         self.known_args_namespace = ns = self._parser.parse_known_args(
0.28 __init__.py(877):             args, namespace=copy.copy(self.option)
0.28 __init__.py(876):         self.known_args_namespace = ns = self._parser.parse_known_args(
0.28 __init__.py(879):         if self.known_args_namespace.confcutdir is None and self.inifile:
0.28 __init__.py(880):             confcutdir = py.path.local(self.inifile).dirname
0.28 __init__.py(881):             self.known_args_namespace.confcutdir = confcutdir
0.28 __init__.py(882):         try:
0.28 __init__.py(883):             self.hook.pytest_load_initial_conftests(
0.28 __init__.py(884):                 early_config=self, args=args, parser=self._parser
0.28 __init__.py(883):             self.hook.pytest_load_initial_conftests(
0.28 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.28 __init__.py(324):         ret = super().register(plugin, name)
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(274):         if name == "pytest_plugins":
0.28 __init__.py(277):         method = getattr(plugin, name)
0.28 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.28 __init__.py(281):         if not inspect.isroutine(method):
0.28 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.28 __init__.py(287):         if opts is not None:
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.28 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.28 __init__.py(294):         return opts
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(271):         if not name.startswith("pytest_"):
0.28 __init__.py(272):             return
0.28 __init__.py(325):         if ret:
0.28 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.28 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.28 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.28 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.28 __init__.py(332):         return ret
0.28 __init__.py(697):         self._cleanup.append(func)
0.29 __init__.py(930):         self.hook.pytest_cmdline_preparse(config=self, args=args)
0.29 __init__.py(931):         self._parser.after_preparse = True
0.29 __init__.py(932):         try:
0.29 __init__.py(933):             args = self._parser.parse_setoption(
0.29 __init__.py(934):                 args, self.option, namespace=self.option
0.29 __init__.py(933):             args = self._parser.parse_setoption(
0.29 __init__.py(936):             if not args:
0.29 __init__.py(941):             self.args = args
0.29 __init__.py(740):         return self
0.29 __init__.py(77):             try:
0.29 __init__.py(78):                 return config.hook.pytest_cmdline_main(config=config)
0.29 __init__.py(958):         try:
0.29 __init__.py(959):             return self._inicache[name]
0.29 __init__.py(960):         except KeyError:
0.29 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.29 __init__.py(965):         try:
0.29 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.29 __init__.py(969):         value = self._get_override_ini_value(name)
0.29 __init__.py(1010):         value = None
0.29 __init__.py(1014):         for ini_config in self._override_ini:
0.29 __init__.py(1022):         return value
0.29 __init__.py(970):         if value is None:
0.29 __init__.py(971):             try:
0.29 __init__.py(972):                 value = self.inicfg[name]
0.29 __init__.py(979):         if type == "pathlist":
0.29 __init__.py(985):         elif type == "args":
0.29 __init__.py(986):             return shlex.split(value)
0.29 __init__.py(962):             return val
0.29 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.29 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.29 __init__.py(324):         ret = super().register(plugin, name)
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(274):         if name == "pytest_plugins":
0.29 __init__.py(277):         method = getattr(plugin, name)
0.29 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.29 __init__.py(281):         if not inspect.isroutine(method):
0.29 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.29 __init__.py(287):         if opts is not None:
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(294):         return opts
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(274):         if name == "pytest_plugins":
0.29 __init__.py(277):         method = getattr(plugin, name)
0.29 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.29 __init__.py(281):         if not inspect.isroutine(method):
0.29 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.29 __init__.py(287):         if opts is not None:
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(294):         return opts
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(274):         if name == "pytest_plugins":
0.29 __init__.py(277):         method = getattr(plugin, name)
0.29 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.29 __init__.py(281):         if not inspect.isroutine(method):
0.29 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.29 __init__.py(287):         if opts is not None:
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(294):         return opts
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(325):         if ret:
0.29 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.29 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.29 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.29 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.29 __init__.py(332):         return ret
0.29 __init__.py(700):         assert not self._configured
0.29 __init__.py(701):         self._configured = True
0.29 __init__.py(702):         with warnings.catch_warnings():
0.29 __init__.py(703):             warnings.simplefilter("default")
0.29 __init__.py(704):             self.hook.pytest_configure.call_historic(kwargs=dict(config=self))
0.29 __init__.py(958):         try:
0.29 __init__.py(959):             return self._inicache[name]
0.29 __init__.py(960):         except KeyError:
0.29 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.29 __init__.py(965):         try:
0.29 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.29 __init__.py(969):         value = self._get_override_ini_value(name)
0.29 __init__.py(1010):         value = None
0.29 __init__.py(1014):         for ini_config in self._override_ini:
0.29 __init__.py(1022):         return value
0.29 __init__.py(970):         if value is None:
0.29 __init__.py(971):             try:
0.29 __init__.py(972):                 value = self.inicfg[name]
0.29 __init__.py(973):             except KeyError:
0.29 __init__.py(974):                 if default is not None:
0.29 __init__.py(975):                     return default
0.29 __init__.py(962):             return val
0.29 pathlib.py(290):     assert not isinstance(input, Path), "would break on py2"
0.29 pathlib.py(291):     root = Path(root)
0.29 pathlib.py(292):     input = expanduser(input)
0.29 pathlib.py(293):     input = expandvars(input)
0.29 pathlib.py(294):     if isabs(input):
0.29 pathlib.py(297):         return root.joinpath(input)
0.29 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.29 __init__.py(1034):         try:
0.29 __init__.py(1035):             val = getattr(self.option, name)
0.29 __init__.py(1036):             if val is None and skip:
0.29 __init__.py(1038):             return val
0.29 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.29 __init__.py(1034):         try:
0.29 __init__.py(1035):             val = getattr(self.option, name)
0.29 __init__.py(1036):             if val is None and skip:
0.29 __init__.py(1038):             return val
0.29 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.29 __init__.py(1034):         try:
0.29 __init__.py(1035):             val = getattr(self.option, name)
0.29 __init__.py(1036):             if val is None and skip:
0.29 __init__.py(1038):             return val
0.29 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.29 __init__.py(324):         ret = super().register(plugin, name)
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(272):             return
0.29 __init__.py(271):         if not name.startswith("pytest_"):
0.29 __init__.py(274):         if name == "pytest_plugins":
0.29 __init__.py(277):         method = getattr(plugin, name)
0.29 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.29 __init__.py(281):         if not inspect.isroutine(method):
0.29 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.29 __init__.py(286):             opts = {}
0.29 __init__.py(287):         if opts is not None:
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.29 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.29 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(325):         if ret:
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.30 __init__.py(332):         return ret
0.30 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.30 __init__.py(324):         ret = super().register(plugin, name)
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(325):         if ret:
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.30 __init__.py(332):         return ret
0.30 __init__.py(1050):         return self.getoption(name)
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(979):         if type == "pathlist":
0.30 __init__.py(985):         elif type == "args":
0.30 __init__.py(987):         elif type == "linelist":
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.30 __init__.py(962):             return val
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(1050):         return self.getoption(name)
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.30 __init__.py(324):         ret = super().register(plugin, name)
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(325):         if ret:
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.30 __init__.py(332):         return ret
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(1050):         return self.getoption(name)
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(1050):         return self.getoption(name)
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.30 __init__.py(1111):     tw = py.io.TerminalWriter(*args, **kwargs)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(329):         name = str(path)
0.30 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.30 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(329):         name = str(path)
0.30 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.30 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(327):         name = path.name
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 pathlib.py(317):     path = PurePath(path)
0.30 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.30 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.30 pathlib.py(326):     if sep not in pattern:
0.30 pathlib.py(329):         name = str(path)
0.30 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.30 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.30 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.30 __init__.py(1112):     if config.option.color == "yes":
0.30 __init__.py(1114):     if config.option.color == "no":
0.30 __init__.py(1116):     return tw
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.30 __init__.py(324):         ret = super().register(plugin, name)
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(286):             opts = {}
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(325):         if ret:
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.30 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.30 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.30 __init__.py(332):         return ret
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(976):                 if type is None:
0.30 __init__.py(977):                     return ""
0.30 __init__.py(962):             return val
0.30 __init__.py(345):         config.addinivalue_line(
0.30 __init__.py(346):             "markers",
0.30 __init__.py(347):             "tryfirst: mark a hook implementation function such that the "
0.30 __init__.py(345):         config.addinivalue_line(
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(350):         config.addinivalue_line(
0.30 __init__.py(351):             "markers",
0.30 __init__.py(352):             "trylast: mark a hook implementation function such that the "
0.30 __init__.py(350):         config.addinivalue_line(
0.30 __init__.py(949):         x = self.getini(name)
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(950):         assert isinstance(x, list)
0.30 __init__.py(951):         x.append(line)  # modifies the cached list inline
0.30 __init__.py(355):         self._configured = True
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(1111):     tw = py.io.TerminalWriter(*args, **kwargs)
0.30 __init__.py(1112):     if config.option.color == "yes":
0.30 __init__.py(1114):     if config.option.color == "no":
0.30 __init__.py(1116):     return tw
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(976):                 if type is None:
0.30 __init__.py(977):                     return ""
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(976):                 if type is None:
0.30 __init__.py(977):                     return ""
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(976):                 if type is None:
0.30 __init__.py(977):                     return ""
0.30 __init__.py(962):             return val
0.30 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.30 __init__.py(1034):         try:
0.30 __init__.py(1035):             val = getattr(self.option, name)
0.30 __init__.py(1036):             if val is None and skip:
0.30 __init__.py(1038):             return val
0.30 __init__.py(958):         try:
0.30 __init__.py(959):             return self._inicache[name]
0.30 __init__.py(960):         except KeyError:
0.30 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.30 __init__.py(965):         try:
0.30 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.30 __init__.py(969):         value = self._get_override_ini_value(name)
0.30 __init__.py(1010):         value = None
0.30 __init__.py(1014):         for ini_config in self._override_ini:
0.30 __init__.py(1022):         return value
0.30 __init__.py(970):         if value is None:
0.30 __init__.py(971):             try:
0.30 __init__.py(972):                 value = self.inicfg[name]
0.30 __init__.py(973):             except KeyError:
0.30 __init__.py(974):                 if default is not None:
0.30 __init__.py(975):                     return default
0.30 __init__.py(962):             return val
0.30 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.30 __init__.py(324):         ret = super().register(plugin, name)
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(272):             return
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.30 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.30 __init__.py(294):         return opts
0.30 __init__.py(271):         if not name.startswith("pytest_"):
0.30 __init__.py(274):         if name == "pytest_plugins":
0.30 __init__.py(277):         method = getattr(plugin, name)
0.30 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.30 __init__.py(281):         if not inspect.isroutine(method):
0.30 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.30 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(325):         if ret:
0.31 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.31 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.31 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.31 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.31 __init__.py(332):         return ret
0.31 __init__.py(958):         try:
0.31 __init__.py(959):             return self._inicache[name]
0.31 __init__.py(960):         except KeyError:
0.31 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.31 __init__.py(965):         try:
0.31 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.31 __init__.py(969):         value = self._get_override_ini_value(name)
0.31 __init__.py(1010):         value = None
0.31 __init__.py(1014):         for ini_config in self._override_ini:
0.31 __init__.py(1022):         return value
0.31 __init__.py(970):         if value is None:
0.31 __init__.py(971):             try:
0.31 __init__.py(972):                 value = self.inicfg[name]
0.31 __init__.py(973):             except KeyError:
0.31 __init__.py(974):                 if default is not None:
0.31 __init__.py(975):                     return default
0.31 __init__.py(962):             return val
0.31 __init__.py(314):         if name in _pytest.deprecated.DEPRECATED_EXTERNAL_PLUGINS:
0.31 __init__.py(324):         ret = super().register(plugin, name)
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(286):             opts = {}
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(286):             opts = {}
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(274):         if name == "pytest_plugins":
0.31 __init__.py(277):         method = getattr(plugin, name)
0.31 __init__.py(278):         opts = super().parse_hookimpl_opts(plugin, name)
0.31 __init__.py(281):         if not inspect.isroutine(method):
0.31 __init__.py(285):         if opts is None and name.startswith("pytest_"):
0.31 __init__.py(286):             opts = {}
0.31 __init__.py(287):         if opts is not None:
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(290):             known_marks = {m.name for m in getattr(method, "pytestmark", [])}
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(293):                 opts.setdefault(name, hasattr(method, name) or name in known_marks)
0.31 __init__.py(292):             for name in ("tryfirst", "trylast", "optionalhook", "hookwrapper"):
0.31 __init__.py(294):         return opts
0.31 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.31 __init__.py(401):         if self._noconftest:
0.31 __init__.py(404):         if path.isfile():
0.31 __init__.py(407):             directory = path
0.31 __init__.py(409):         directory = unique_path(directory)
0.31 pathlib.py(346):     return type(path)(normcase(str(path.realpath())))
0.31 __init__.py(414):         clist = []
0.31 __init__.py(415):         for parent in directory.parts():
0.31 __init__.py(416):             if self._confcutdir and self._confcutdir.relto(parent):
0.31 __init__.py(417):                 continue
0.31 __init__.py(415):         for parent in directory.parts():
0.31 __init__.py(416):             if self._confcutdir and self._confcutdir.relto(parent):
0.31 __init__.py(418):             conftestpath = parent.join("conftest.py")
0.31 __init__.py(419):             if conftestpath.isfile():
0.31 __init__.py(415):         for parent in directory.parts():
0.31 __init__.py(422):         self._dirpath2confmods[directory] = clist
0.31 __init__.py(423):         return clist
0.31 __init__.py(271):         if not name.startswith("pytest_"):
0.31 __init__.py(272):             return
0.31 __init__.py(325):         if ret:
0.31 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.31 __init__.py(327):                 kwargs=dict(plugin=plugin, manager=self)
0.31 __init__.py(326):             self.hook.pytest_plugin_registered.call_historic(
0.31 __init__.py(330):             if isinstance(plugin, types.ModuleType):
0.31 __init__.py(332):         return ret
============================= test session starts ==============================
platform linux -- Python 3.9.23, pytest-5.1.3.dev14+g73c5b7f4b, py-1.11.0, pluggy-0.13.1
0.31 __init__.py(958):         try:
0.31 __init__.py(959):             return self._inicache[name]
0.31 __init__.py(960):         except KeyError:
0.31 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.31 __init__.py(965):         try:
0.31 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.31 __init__.py(969):         value = self._get_override_ini_value(name)
0.31 __init__.py(1010):         value = None
0.31 __init__.py(1014):         for ini_config in self._override_ini:
0.31 __init__.py(1022):         return value
0.31 __init__.py(970):         if value is None:
0.31 __init__.py(971):             try:
0.31 __init__.py(972):                 value = self.inicfg[name]
0.31 __init__.py(979):         if type == "pathlist":
0.31 __init__.py(985):         elif type == "args":
0.31 __init__.py(986):             return shlex.split(value)
0.31 __init__.py(962):             return val
0.31 __init__.py(958):         try:
0.31 __init__.py(959):             return self._inicache[name]
rootdir: /testbed, inifile: tox.ini
0.31 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.31 __init__.py(1034):         try:
0.31 __init__.py(1035):             val = getattr(self.option, name)
0.31 __init__.py(1036):             if val is None and skip:
0.31 __init__.py(1038):             return val
0.31 __init__.py(958):         try:
0.31 __init__.py(959):             return self._inicache[name]
0.31 __init__.py(960):         except KeyError:
0.31 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.31 __init__.py(965):         try:
0.31 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.31 __init__.py(969):         value = self._get_override_ini_value(name)
0.31 __init__.py(1010):         value = None
0.31 __init__.py(1014):         for ini_config in self._override_ini:
0.31 __init__.py(1022):         return value
0.31 __init__.py(970):         if value is None:
0.31 __init__.py(971):             try:
0.31 __init__.py(972):                 value = self.inicfg[name]
0.31 __init__.py(979):         if type == "pathlist":
0.31 __init__.py(985):         elif type == "args":
0.31 __init__.py(987):         elif type == "linelist":
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(988):             return [t for t in map(lambda x: x.strip(), value.split("\n")) if t]
0.31 __init__.py(962):             return val
0.31 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.31 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.31 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.31 __init__.py(1034):         try:
0.31 __init__.py(1035):             val = getattr(self.option, name)
0.31 __init__.py(1036):             if val is None and skip:
0.31 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
collected 1 item
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(958):         try:
0.36 __init__.py(959):             return self._inicache[name]
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(958):         try:
0.36 __init__.py(959):             return self._inicache[name]
0.36 __init__.py(958):         try:
0.36 __init__.py(959):             return self._inicache[name]
0.36 __init__.py(960):         except KeyError:
0.36 __init__.py(961):             self._inicache[name] = val = self._getini(name)
0.36 __init__.py(965):         try:
0.36 __init__.py(966):             description, type, default = self._parser._inidict[name]
0.36 __init__.py(969):         value = self._get_override_ini_value(name)
0.36 __init__.py(1010):         value = None
0.36 __init__.py(1014):         for ini_config in self._override_ini:
0.36 __init__.py(1022):         return value
0.36 __init__.py(970):         if value is None:
0.36 __init__.py(971):             try:
0.36 __init__.py(972):                 value = self.inicfg[name]
0.36 __init__.py(973):             except KeyError:
0.36 __init__.py(974):                 if default is not None:
0.36 __init__.py(975):                     return default
0.36 __init__.py(962):             return val
0.36 pathlib.py(317):     path = PurePath(path)
0.36 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.36 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.36 pathlib.py(326):     if sep not in pattern:
0.36 pathlib.py(327):         name = path.name
0.36 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.36 pathlib.py(317):     path = PurePath(path)
0.36 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.36 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.36 pathlib.py(326):     if sep not in pattern:
0.36 pathlib.py(327):         name = path.name
0.36 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.36 pathlib.py(317):     path = PurePath(path)
0.36 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.36 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.36 pathlib.py(326):     if sep not in pattern:
0.36 pathlib.py(327):         name = path.name
0.36 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.36 pathlib.py(317):     path = PurePath(path)
0.36 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.36 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.36 pathlib.py(326):     if sep not in pattern:
0.36 pathlib.py(327):         name = path.name
0.36 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.36 pathlib.py(317):     path = PurePath(path)
0.36 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.36 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.36 pathlib.py(326):     if sep not in pattern:
0.36 pathlib.py(329):         name = str(path)
0.36 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.36 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.36 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)

testing/test_coverup_pytest-dev__pytest-5840.py 0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.37 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.37 __init__.py(1034):         try:
0.37 __init__.py(1035):             val = getattr(self.option, name)
0.37 __init__.py(1036):             if val is None and skip:
0.37 __init__.py(1038):             return val
0.37 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.37 __init__.py(1034):         try:
0.37 __init__.py(1035):             val = getattr(self.option, name)
0.37 __init__.py(1036):             if val is None and skip:
0.37 __init__.py(1038):             return val
0.37 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.37 __init__.py(1034):         try:
0.37 __init__.py(1035):             val = getattr(self.option, name)
0.37 __init__.py(1036):             if val is None and skip:
0.37 __init__.py(1038):             return val
0.39 __init__.py(1050):         return self.getoption(name)
0.39 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.39 __init__.py(1034):         try:
0.39 __init__.py(1035):             val = getattr(self.option, name)
0.39 __init__.py(1036):             if val is None and skip:
0.39 __init__.py(1038):             return val
F0.39 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.39 __init__.py(1034):         try:
0.39 __init__.py(1035):             val = getattr(self.option, name)
0.39 __init__.py(1036):             if val is None and skip:
0.39 __init__.py(1038):             return val
                        [100%]0.40 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.40 __init__.py(1034):         try:
0.40 __init__.py(1035):             val = getattr(self.option, name)
0.40 __init__.py(1036):             if val is None and skip:
0.40 __init__.py(1038):             return val
0.40 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.40 __init__.py(1034):         try:
0.40 __init__.py(1035):             val = getattr(self.option, name)
0.40 __init__.py(1036):             if val is None and skip:
0.40 __init__.py(1038):             return val


=================================== FAILURES ===================================
____________________ test_importerror_due_to_lowercase_path ____________________

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f5ce1717b50>

    def test_importerror_due_to_lowercase_path(monkeypatch):
        # Setup: Create a mock for the os.path.normcase to simulate the bug
        def mock_normcase(path):
            return path.lower()  # Simulate the bug by converting path to lowercase
    
        monkeypatch.setattr(os.path, 'normcase', mock_normcase)
    
        # Simulate the directory structure and path
        mixed_case_path = "C:\\Azure\\KMS\\ComponentTest\\Python\\PIsys\\conftest.py"
        lower_case_path = mixed_case_path.lower()
    
        # Simulate the ImportError with the path in lowercase
        try:
            # This is where the actual pytest collection would occur
            # For the purpose of this test, we simulate the ImportError
>           raise ImportError(f"ImportError while loading conftest '{lower_case_path}'.")
E           ImportError: ImportError while loading conftest 'c:\azure\kms\componenttest\python\pisys\conftest.py'.

testing/test_coverup_pytest-dev__pytest-5840.py:20: ImportError

During handling of the above exception, another exception occurred:

monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x7f5ce1717b50>

    def test_importerror_due_to_lowercase_path(monkeypatch):
        # Setup: Create a mock for the os.path.normcase to simulate the bug
        def mock_normcase(path):
            return path.lower()  # Simulate the bug by converting path to lowercase
    
        monkeypatch.setattr(os.path, 'normcase', mock_normcase)
    
        # Simulate the directory structure and path
        mixed_case_path = "C:\\Azure\\KMS\\ComponentTest\\Python\\PIsys\\conftest.py"
        lower_case_path = mixed_case_path.lower()
    
        # Simulate the ImportError with the path in lowercase
        try:
            # This is where the actual pytest collection would occur
            # For the purpose of this test, we simulate the ImportError
            raise ImportError(f"ImportError while loading conftest '{lower_case_path}'.")
        except ImportError as e:
            # Assert that the ImportError message contains the path in mixed case
>           assert mixed_case_path in str(e)  # Correct behavior: should match the original case
E           assert 'C:\\Azure\\KMS\\ComponentTest\\Python\\PIsys\\conftest.py' in "ImportError while loading conftest 'c:\\azure\\kms\\componenttest\\python\\pisys\\conftest.py'."
E            +  where "ImportError while loading conftest 'c:\\azure\\kms\\componenttest\\python\\pisys\\conftest.py'." = str(ImportError("ImportError while loading conftest 'c:\\azure\\kms\\componenttest\\python\\pisys\\conftest.py'."))

testing/test_coverup_pytest-dev__pytest-5840.py:23: AssertionError
----------------------------- Captured stdout call -----------------------------
0.36 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.36 __init__.py(1034):         try:
0.36 __init__.py(1035):             val = getattr(self.option, name)
0.36 __init__.py(1036):             if val is None and skip:
0.36 __init__.py(1038):             return val
0.40 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.40 __init__.py(1034):         try:
0.40 __init__.py(1035):             val = getattr(self.option, name)
0.40 __init__.py(1036):             if val is None and skip:
0.40 __init__.py(1038):             return val
0.40 __init__.py(958):         try:
0.40 __init__.py(959):             return self._inicache[name]
0.40 __init__.py(1050):         return self.getoption(name)
0.40 __init__.py(1033):         name = self._opt2dest.get(name, name)
0.40 __init__.py(1034):         try:
0.40 __init__.py(1035):             val = getattr(self.option, name)
0.40 __init__.py(1036):             if val is None and skip:
0.40 __init__.py(1038):             return val
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(329):         name = str(path)
0.40 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.40 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(329):         name = str(path)
0.40 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.40 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(329):         name = str(path)
0.40 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.40 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(329):         name = str(path)
0.40 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.40 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(327):         name = path.name
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 pathlib.py(317):     path = PurePath(path)
0.40 pathlib.py(318):     iswin32 = sys.platform.startswith("win")
0.40 pathlib.py(320):     if iswin32 and sep not in pattern and posix_sep in pattern:
0.40 pathlib.py(326):     if sep not in pattern:
0.40 pathlib.py(329):         name = str(path)
0.40 pathlib.py(330):         if path.is_absolute() and not os.path.isabs(pattern):
0.40 pathlib.py(331):             pattern = "*{}{}".format(os.sep, pattern)
0.40 pathlib.py(332):     return fnmatch.fnmatch(name, pattern)
0.40 __init__.py(758):         if self.invocation_dir != self.rootdir:
0.40 __init__.py(692):         return py.path.local(str(self.invocation_params.dir))
0.40 __init__.py(761):         return nodeid
=========================== short test summary info ============================
FAILED testing/test_coverup_pytest-dev__pytest-5840.py::test_importerror_due_to_lowercase_path
============================== 1 failed in 0.09s ===============================
0.40 __init__.py(707):         if self._configured:
0.40 __init__.py(708):             self._configured = False
0.40 __init__.py(709):             self.hook.pytest_unconfigure(config=self)
0.40 __init__.py(710):             self.hook.pytest_configure._call_history = []
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(712):             fin = self._cleanup.pop()
0.40 __init__.py(713):             fin()
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(712):             fin = self._cleanup.pop()
0.40 __init__.py(713):             fin()
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(712):             fin = self._cleanup.pop()
0.40 __init__.py(713):             fin()
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(712):             fin = self._cleanup.pop()
0.40 __init__.py(713):             fin()
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(80):                 config._ensure_unconfigure()
0.40 __init__.py(707):         if self._configured:
0.40 __init__.py(711):         while self._cleanup:
0.40 __init__.py(78):                 return config.hook.pytest_cmdline_main(config=config)
+ cat coverage.cover
{"/testbed/src/_pytest/pathlib.py": {"1": 1, "2": 1, "3": 1, "4": 1, "5": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "18": 1, "20": 1, "21": 1, "23": 0, "25": 1, "28": 1, "30": 1, "33": 1, "42": 1, "79": 1, "87": 1, "95": 1, "106": 1, "112": 1, "120": 1, "140": 1, "161": 1, "178": 1, "195": 1, "221": 1, "240": 1, "246": 1, "258": 1, "266": 1, "289": 1, "300": 1, "335": 1, "340": 1, "37": 0, "38": 0, "39": 0, "44": 0, "46": 0, "47": 0, "48": 0, "50": 0, "52": 0, "53": 0, "54": 0, "56": 0, "59": 0, "61": 0, "67": 0, "68": 0, "69": 0, "70": 0, "72": 0, "73": 0, "74": 0, "76": 0, "62": 0, "63": 0, "83": 0, "84": 0, "89": 0, "90": 0, "91": 0, "92": 0, "101": 0, "102": 0, "103": 0, "109": 0, "114": 0, "115": 0, "116": 0, "117": 0, "129": 0, "130": 0, "131": 0, "132": 0, "133": 0, "134": 0, "135": 0, "136": 0, "137": 0, "142": 0, "144": 0, "145": 0, "146": 0, "147": 0, "148": 0, "149": 0, "150": 0, "152": 0, "153": 0, "155": 0, "156": 0, "157": 0, "163": 0, "164": 0, "165": 0, "166": 0, "167": 0, "169": 0, "170": 0, "171": 0, "172": 0, "173": 0, "174": 0, "175": 0, "180": 0, "182": 0, "192": 0, "183": 0, "184": 0, "186": 0, "187": 0, "188": 0, "189": 0, "190": 0, "197": 0, "198": 0, "199": 0, "200": 0, "202": 0, "203": 0, "204": 0, "205": 0, "210": 0, "214": 0, "215": 0, "216": 0, "217": 0, "218": 0, "223": 0, "224": 0, "225": 0, "226": 0, "227": 0, "228": 0, "229": 0, "230": 0, "231": 0, "233": 0, "234": 0, "235": 0, "237": 0, "242": 0, "243": 0, "248": 0, "249": 0, "250": 0, "251": 0, "252": 0, "253": 0, "254": 0, "255": 0, "260": 0, "261": 0, "262": 0, "263": 0, "268": 0, "269": 0, "270": 0, "271": 0, "272": 0, "273": 0, "274": 0, "275": 0, "277": 0, "278": 0, "279": 0, "280": 0, "281": 0, "282": 0, "284": 0, "285": 0, "286": 0, "290": 1, "291": 1, "292": 1, "293": 1, "294": 1, "295": 0, "297": 1, "317": 225, "318": 225, "320": 225, "324": 0, "326": 225, "327": 182, "329": 43, "330": 43, "331": 43, "332": 225, "336": 0, "337": 0, "346": 4}}
{"/testbed/src/_pytest/config/__init__.py": {"2": 1, "3": 1, "4": 1, "5": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "18": 1, "20": 1, "21": 1, "22": 1, "23": 1, "24": 1, "25": 1, "26": 1, "27": 1, "28": 1, "29": 1, "30": 1, "31": 1, "32": 1, "33": 1, "34": 1, "36": 1, "37": 1, "40": 2, "47": 1, "88": 2, "92": 1, "103": 1, "115": 1, "123": 1, "150": 1, "151": 1, "154": 1, "173": 1, "185": 1, "216": 1, "229": 2, "579": 1, "599": 1, "606": 2, "611": 1, "614": 1, "626": 2, "1057": 1, "1066": 1, "1084": 1, "1106": 1, "1119": 1, "41": 1, "42": 0, "43": 0, "44": 0, "55": 1, "57": 1, "58": 1, "59": 1, "60": 0, "61": 0, "62": 0, "63": 0, "64": 0, "66": 0, "69": 0, "68": 0, "70": 0, "67": 0, "72": 0, "73": 0, "74": 0, "75": 0, "77": 1, "78": 2, "80": 1, "81": 0, "82": 0, "83": 0, "84": 0, "85": 0, "89": 1, "98": 0, "99": 0, "100": 0, "109": 0, "110": 0, "111": 0, "156": 1, "157": 2, "158": 1, "159": 2, "160": 1, "164": 1, "166": 1, "168": 30, "169": 29, "170": 1, "182": 0, "186": 1, "187": 1, "188": 1, "189": 0, "190": 0, "191": 0, "192": 0, "193": 0, "195": 1, "196": 1, "197": 1, "198": 1, "199": 0, "200": 0, "201": 0, "203": 0, "204": 1, "205": 0, "207": 0, "208": 2, "209": 1, "211": 0, "212": 0, "213": 0, "218": 0, "217": 0, "226": 0, "239": 1, "267": 1, "296": 1, "313": 1, "334": 1, "338": 1, "342": 1, "360": 1, "391": 1, "399": 1, "400": 1, "425": 1, "434": 1, "473": 1, "492": 1, "517": 1, "520": 1, "523": 1, "526": 1, "531": 1, "240": 1, "241": 1, "244": 1, "245": 1, "246": 1, "247": 1, "248": 1, "250": 1, "251": 1, "252": 1, "253": 0, "254": 0, "255": 0, "256": 0, "257": 0, "258": 0, "259": 0, "260": 0, "263": 1, "265": 1, "271": 1506, "272": 1346, "274": 160, "275": 0, "277": 160, "278": 160, "281": 160, "282": 0, "285": 160, "286": 110, "287": 160, "290": 320, "292": 800, "293": 640, "294": 160, "297": 64, "298": 64, "299": 41, "301": 41, "304": 62, "306": 31, "307": 31, "308": 31, "309": 31, "305": 31, "311": 64, "314": 41, "315": 0, "316": 0, "317": 0, "319": 0, "323": 0, "324": 41, "325": 41, "326": 82, "327": 41, "330": 41, "331": 31, "332": 41, "336": 0, "340": 0, "345": 2, "346": 1, "347": 1, "350": 2, "351": 1, "352": 1, "355": 1, "368": 1, "371": 1, "370": 1, "372": 0, "369": 1, "374": 1, "375": 1, "376": 1, "377": 1, "378": 2, "379": 1, "381": 1, "382": 1, "383": 0, "384": 1, "385": 1, "386": 1, "387": 1, "388": 1, "389": 0, "392": 1, "394": 1, "395": 0, "396": 0, "397": 0, "401": 2, "402": 0, "404": 2, "405": 1, "407": 1, "409": 2, "414": 2, "415": 7, "416": 5, "417": 2, "418": 3, "419": 3, "420": 1, "421": 1, "422": 2, "423": 2, "426": 0, "427": 0, "428": 0, "429": 0, "430": 0, "431": 0, "432": 0, "438": 1, "439": 1, "440": 1, "441": 1, "442": 1, "443": 1, "444": 1, "445": 1, "446": 1, "448": 1, "447": 1, "449": 0, "450": 0, "452": 0, "453": 0, "454": 0, "456": 1, "457": 1, "458": 1, "459": 1, "460": 0, "461": 0, "462": 0, "463": 0, "464": 1, "465": 1, "466": 1, "474": 2, "475": 2, "476": 9, "477": 7, "478": 7, "479": 7, "480": 7, "481": 1, "482": 1, "483": 0, "484": 0, "485": 1, "486": 6, "487": 0, "489": 0, "490": 1, "493": 1, "494": 0, "495": 0, "496": 0, "499": 0, "500": 0, "501": 0, "503": 0, "504": 0, "505": 0, "507": 1, "510": 1, "511": 0, "512": 1, "513": 1, "514": 0, "515": 1, "518": 1, "521": 1, "524": 32, "527": 33, "528": 33, "529": 0, "540": 30, "541": 0, "543": 30, "544": 30, "545": 0, "547": 30, "548": 30, "550": 30, "551": 1, "552": 1, "553": 0, "555": 30, "556": 30, "557": 0, "558": 0, "559": 0, "561": 0, "562": 0, "564": 0, "566": 0, "567": 0, "569": 0, "570": 0, "571": 0, "572": 0, "575": 30, "576": 30, "587": 33, "588": 32, "589": 0, "590": 32, "591": 0, "592": 0, "593": 0, "595": 32, "596": 1, "600": 1, "601": 1, "602": 1, "603": 1, "607": 1, "608": 0, "615": 1, "616": 0, "617": 0, "618": 0, "619": 0, "620": 0, "621": 0, "622": 0, "623": 0, "646": 2, "647": 1, "662": 1, "689": 1, "690": 1, "694": 1, "699": 1, "706": 1, "715": 1, "718": 1, "742": 1, "756": 1, "763": 1, "764": 1, "773": 1, "781": 1, "782": 1, "785": 1, "802": 1, "820": 1, "842": 1, "854": 1, "903": 1, "919": 1, "945": 1, "953": 1, "964": 1, "995": 1, "1009": 1, "1024": 1, "1048": 1, "1052": 1, "658": 1, "659": 1, "660": 1, "663": 1, "665": 1, "666": 0, "667": 0, "670": 1, "671": 1, "673": 1, "674": 2, "675": 1, "676": 1, "678": 1, "679": 1, "680": 1, "681": 1, "682": 1, "683": 1, "684": 1, "685": 1, "686": 1, "687": 1, "692": 6, "697": 2, "700": 1, "701": 1, "702": 1, "703": 1, "704": 1, "707": 2, "708": 1, "709": 1, "710": 1, "711": 6, "712": 4, "713": 4, "716": 0, "719": 1, "720": 1, "721": 0, "726": 0, "727": 0, "729": 0, "731": 0, "730": 0, "733": 0, "734": 0, "735": 0, "738": 0, "740": 1, "743": 0, "744": 0, "746": 0, "747": 0, "748": 0, "750": 0, "751": 0, "752": 0, "753": 0, "754": 0, "758": 1, "759": 0, "760": 0, "761": 1, "766": 0, "767": 0, "768": 0, "769": 0, "770": 0, "771": 0, "774": 185, "775": 105, "777": 80, "778": 41, "779": 39, "783": 1, "786": 2, "787": 1, "789": 2, "790": 1, "791": 1, "792": 1, "793": 1, "795": 1, "796": 1, "797": 1, "798": 1, "799": 1, "800": 1, "809": 1, "810": 1, "811": 1, "812": 1, "813": 1, "814": 0, "815": 0, "817": 1, "818": 1, "826": 1, "828": 1, "830": 0, "832": 14, "834": 12, "839": 1, "840": 0, "835": 72, "836": 0, "833": 0, "844": 1, "845": 1, "846": 2, "847": 1, "850": 1, "852": 1, "855": 1, "856": 1, "857": 1, "859": 0, "860": 0, "858": 0, "862": 1, "863": 1, "865": 1, "864": 1, "868": 1, "869": 1, "870": 1, "871": 1, "874": 1, "875": 1, "876": 2, "877": 1, "879": 1, "880": 1, "881": 1, "882": 1, "883": 2, "884": 1, "886": 0, "887": 0, "888": 0, "891": 0, "893": 0, "894": 0, "895": 0, "897": 0, "898": 0, "901": 0, "904": 1, "906": 1, "907": 1, "908": 1, "909": 0, "910": 0, "912": 0, "913": 0, "914": 0, "915": 0, "911": 0, "921": 2, "922": 1, "923": 0, "924": 1, "925": 2, "926": 1, "928": 1, "930": 1, "931": 1, "932": 1, "933": 2, "934": 1, "936": 1, "937": 0, "938": 0, "939": 0, "940": 0, "941": 1, "942": 0, "943": 0, "949": 9, "950": 9, "951": 9, "958": 72, "959": 72, "960": 22, "961": 22, "962": 22, "965": 22, "966": 22, "967": 0, "968": 0, "969": 22, "970": 22, "971": 22, "972": 22, "973": 15, "974": 15, "975": 11, "976": 4, "977": 4, "978": 0, "979": 7, "980": 0, "981": 0, "982": 0, "983": 0, "984": 0, "985": 7, "986": 5, "987": 2, "988": 32, "989": 0, "990": 0, "992": 0, "993": 0, "996": 0, "997": 0, "998": 0, "999": 0, "1000": 0, "1001": 0, "1002": 0, "1003": 0, "1004": 0, "1005": 0, "1006": 0, "1007": 0, "1010": 22, "1014": 22, "1015": 0, "1016": 0, "1017": 0, "1018": 0, "1020": 0, "1021": 0, "1022": 22, "1033": 43, "1034": 43, "1035": 43, "1036": 43, "1037": 0, "1038": 43, "1039": 0, "1040": 0, "1041": 0, "1042": 0, "1043": 0, "1045": 0, "1046": 0, "1050": 6, "1054": 0, "1058": 1, "1059": 1, "1060": 1, "1061": 1, "1063": 0, "1067": 1, "1068": 0, "1069": 0, "1070": 0, "1075": 0, "1076": 0, "1085": 0, "1087": 0, "1088": 0, "1089": 0, "1090": 0, "1091": 0, "1092": 0, "1093": 0, "1094": 0, "1095": 0, "1096": 0, "1097": 0, "1099": 0, "1100": 0, "1103": 0, "1111": 2, "1112": 2, "1113": 0, "1114": 2, "1115": 0, "1116": 2, "1128": 0, "1129": 0, "1130": 0, "1131": 0, "1132": 0, "1134": 0}}
+ git checkout 73c5b7f4b11a81e971f7d1bb18072e06a87060f4
Note: switching to '73c5b7f4b11a81e971f7d1bb18072e06a87060f4'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 73c5b7f4b Clarify docs by showing tox.ini considered before setup.cfg (#5839)
+ git apply /root/pre_state.patch
error: unrecognized input
