+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 29c126bb349526b5f1cd78facbe9f25906f18563
+ sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen
+ locale-gen
Generating locales (this might take a while)...
  en_US.UTF-8... done
Generation complete.
+ export LANG=en_US.UTF-8
+ LANG=en_US.UTF-8
+ export LANGUAGE=en_US:en
+ LANGUAGE=en_US:en
+ export LC_ALL=en_US.UTF-8
+ LC_ALL=en_US.UTF-8
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 29c126bb349526b5f1cd78facbe9f25906f18563
Author: Carlton Gibson <carlton.gibson@noumenal.es>
Date:   Tue Jan 7 11:52:09 2020 +0100

    Fixed #31124 -- Fixed setting of get_FOO_display() when overriding inherited choices.
    
    Regression in 2d38eb0ab9f78d68c083a5b78b1eca39027b279a

diff --git a/django/db/models/fields/__init__.py b/django/db/models/fields/__init__.py
index 1a55d3d417..6bd95f542c 100644
--- a/django/db/models/fields/__init__.py
+++ b/django/db/models/fields/__init__.py
@@ -764,7 +764,11 @@ class Field(RegisterLookupMixin):
             if not getattr(cls, self.attname, None):
                 setattr(cls, self.attname, self.descriptor_class(self))
         if self.choices is not None:
-            if not hasattr(cls, 'get_%s_display' % self.name):
+            # Don't override a get_FOO_display() method defined explicitly on
+            # this class, but don't check methods derived from inheritance, to
+            # allow overriding inherited choices. For more complex inheritance
+            # structures users should override contribute_to_class().
+            if 'get_%s_display' % self.name not in cls.__dict__:
                 setattr(
                     cls,
                     'get_%s_display' % self.name,
diff --git a/docs/ref/models/instances.txt b/docs/ref/models/instances.txt
index 1524ad2fcd..6adcb979ba 100644
--- a/docs/ref/models/instances.txt
+++ b/docs/ref/models/instances.txt
@@ -834,6 +834,15 @@ Note that in the case of identical date values, these methods will use the
 primary key as a tie-breaker. This guarantees that no records are skipped or
 duplicated. That also means you cannot use those methods on unsaved objects.
 
+.. admonition:: Overriding extra instance methods
+
+    In most cases overriding or inheriting ``get_FOO_display()``,
+    ``get_next_by_FOO()``, and ``get_previous_by_FOO()` should work as
+    expected. Since they are added by the metaclass however, it is not
+    practical to account for all possible inheritance structures. In more
+    complex cases you should override ``Field.contribute_to_class()`` to set
+    the methods you need.
+
 Other attributes
 ================
 
diff --git a/docs/releases/3.0.3.txt b/docs/releases/3.0.3.txt
index c2cac9203d..2726e2d3ab 100644
--- a/docs/releases/3.0.3.txt
+++ b/docs/releases/3.0.3.txt
@@ -31,3 +31,7 @@ Bugfixes
   :class:`~django.contrib.postgres.aggregates.ArrayAgg` and
   :class:`~django.contrib.postgres.aggregates.StringAgg` with ``filter``
   argument when used in a ``Subquery`` (:ticket:`31097`).
+
+* Fixed a regression in Django 2.2.7 that caused
+  :meth:`~django.db.models.Model.get_FOO_display` to work incorrectly when
+  overriding inherited choices (:ticket:`31124`).
diff --git a/tests/model_fields/tests.py b/tests/model_fields/tests.py
index a3b805409c..b97c99d42d 100644
--- a/tests/model_fields/tests.py
+++ b/tests/model_fields/tests.py
@@ -178,6 +178,19 @@ class GetFieldDisplayTests(SimpleTestCase):
         f = FooBar(foo_bar=1)
         self.assertEqual(f.get_foo_bar_display(), 'something')
 
+    def test_overriding_inherited_FIELD_display(self):
+        class Base(models.Model):
+            foo = models.CharField(max_length=254, choices=[('A', 'Base A')])
+
+            class Meta:
+                abstract = True
+
+        class Child(Base):
+            foo = models.CharField(max_length=254, choices=[('A', 'Child A'), ('B', 'Child B')])
+
+        self.assertEqual(Child(foo='A').get_foo_display(), 'Child A')
+        self.assertEqual(Child(foo='B').get_foo_display(), 'Child B')
+
     def test_iterator_choices(self):
         """
         get_choices() works with Iterators.
+ git diff 29c126bb349526b5f1cd78facbe9f25906f18563
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
Requirement already satisfied: asgiref>=3.2 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.1) (3.4.1)
Requirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.1) (2025.2)
Requirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.1) (0.4.4)
Requirement already satisfied: typing-extensions in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from asgiref>=3.2->Django==3.1) (4.1.1)
Installing collected packages: Django
  Attempting uninstall: Django
    Found existing installation: Django 3.1
    Uninstalling Django-3.1:
      Successfully uninstalled Django-3.1
  Running setup.py develop for Django
Successfully installed Django-3.1
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
+ git apply -v -
Checking patch tests/test_coverup_django__django-12325.py...
Applied patch tests/test_coverup_django__django-12325.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(django/db/models/base\.py|django/db/models/options\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_coverup_django__django-12325
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(django/db/models/base\\.py|django/db/models/options\\.py)']
0.35 base.py(1): import copy
0.35 base.py(2): import inspect
0.35 base.py(3): import warnings
0.35 base.py(4): from functools import partialmethod
0.35 base.py(5): from itertools import chain
0.35 base.py(7): from django.apps import apps
0.35 base.py(8): from django.conf import settings
0.35 base.py(9): from django.core import checks
0.35 base.py(10): from django.core.exceptions import (
0.35 base.py(14): from django.db import (
0.35 base.py(18): from django.db.models import (
0.35 base.py(21): from django.db.models.constants import LOOKUP_SEP
0.35 base.py(22): from django.db.models.constraints import CheckConstraint, UniqueConstraint
0.35 base.py(23): from django.db.models.deletion import CASCADE, Collector
0.35 base.py(24): from django.db.models.fields.related import (
0.36 base.py(27): from django.db.models.functions import Coalesce
0.36 base.py(28): from django.db.models.manager import Manager
0.36 base.py(29): from django.db.models.options import Options
0.36 options.py(1): import bisect
0.36 options.py(2): import copy
0.36 options.py(3): import inspect
0.36 options.py(4): from collections import defaultdict
0.36 options.py(6): from django.apps import apps
0.36 options.py(7): from django.conf import settings
0.36 options.py(8): from django.core.exceptions import FieldDoesNotExist, ImproperlyConfigured
0.36 options.py(9): from django.db import connections
0.36 options.py(10): from django.db.models import Manager
0.36 options.py(11): from django.db.models.fields import AutoField
0.36 options.py(12): from django.db.models.fields.proxy import OrderWrt
0.36 options.py(13): from django.db.models.query_utils import PathInfo
0.36 options.py(14): from django.utils.datastructures import ImmutableList, OrderedSet
0.36 options.py(15): from django.utils.functional import cached_property
0.36 options.py(16): from django.utils.text import camel_case_to_spaces, format_lazy
0.36 options.py(17): from django.utils.translation import override
0.36 options.py(19): PROXY_PARENTS = object()
0.36 options.py(21): EMPTY_RELATION_TREE = ()
0.36 options.py(24):     "The return type of '%s' should never be mutated. If you want to manipulate this list "
0.36 options.py(35):     'indexes', 'constraints',
0.36 options.py(39): def normalize_together(option_together):
0.36 options.py(61): def make_immutable_fields_list(name, data):
0.36 options.py(65): class Options:
0.36 options.py(65): class Options:
0.36 options.py(67):         'fields', 'many_to_many', 'concrete_fields', 'local_concrete_fields',
0.36 options.py(68):         '_forward_fields_map', 'managers', 'managers_map', 'base_manager',
0.36 options.py(69):         'default_manager',
0.36 options.py(71):     REVERSE_PROPERTIES = {'related_objects', 'fields_map', '_relation_tree'}
0.36 options.py(73):     default_apps = apps
0.36 options.py(75):     def __init__(self, meta, app_label=None):
0.36 options.py(132):     @property
0.36 options.py(136):     @property
0.36 options.py(140):     @property
0.36 options.py(145):     @property
0.36 options.py(149):     def contribute_to_class(self, cls, name):
0.36 options.py(210):     def _format_names_with_class(self, cls, objs):
0.36 options.py(222):     def _prepare(self, model):
0.36 options.py(262):     def add_manager(self, manager):
0.36 options.py(266):     def add_field(self, field, private=False):
0.36 options.py(296):     def setup_pk(self, field):
0.36 options.py(301):     def setup_proxy(self, target):
0.36 options.py(310):     def __repr__(self):
0.36 options.py(313):     def __str__(self):
0.36 options.py(316):     def can_migrate(self, connection):
0.36 options.py(332):     @property
0.36 options.py(338):     @property
0.36 options.py(363):     @cached_property
0.36 options.py(383):     @cached_property
0.36 options.py(387):     @cached_property
0.36 options.py(415):     @cached_property
0.36 options.py(439):     @cached_property
0.36 options.py(473):     @cached_property
0.36 options.py(486):     @cached_property
0.36 options.py(499):     @cached_property
0.36 options.py(513):     @cached_property
0.36 options.py(530):     @cached_property
0.36 options.py(545):     @cached_property
0.36 options.py(560):     def get_field(self, field_name):
0.36 options.py(585):     def get_base_chain(self, model):
0.36 options.py(602):     def get_parent_list(self):
0.36 options.py(613):     def get_ancestor_link(self, ancestor):
0.36 options.py(633):     def get_path_to_parent(self, parent):
0.36 options.py(663):     def get_path_from_parent(self, parent):
0.36 options.py(685):     def _populate_directed_relation_graph(self):
0.36 options.py(721):     @cached_property
0.36 options.py(725):     def _expire_cache(self, forward=True, reverse=True):
0.36 options.py(738):     def get_fields(self, include_parents=True, include_hidden=False):
0.36 options.py(753):                     seen_models=None):
0.36 options.py(836):     @cached_property
0.36 options.py(846):     @cached_property
0.36 base.py(30): from django.db.models.query import Q
0.36 base.py(31): from django.db.models.signals import (
0.36 base.py(34): from django.db.models.utils import make_model_tuple
0.36 base.py(35): from django.utils.encoding import force_str
0.36 base.py(36): from django.utils.hashable import make_hashable
0.36 base.py(37): from django.utils.text import capfirst, get_text_list
0.36 base.py(38): from django.utils.translation import gettext_lazy as _
0.36 base.py(39): from django.utils.version import get_version
0.36 base.py(42): class Deferred:
0.36 base.py(42): class Deferred:
0.36 base.py(43):     def __repr__(self):
0.36 base.py(46):     def __str__(self):
0.36 base.py(50): DEFERRED = Deferred()
0.36 base.py(53): def subclass_exception(name, bases, module, attached_to):
0.36 base.py(67): def _has_contribute_to_class(value):
0.36 base.py(72): class ModelBase(type):
0.36 base.py(72): class ModelBase(type):
0.36 base.py(73):     """Metaclass for all models."""
0.36 base.py(74):     def __new__(cls, name, bases, attrs, **kwargs):
0.36 base.py(324):     def add_to_class(cls, name, value):
0.36 base.py(330):     def _prepare(cls):
0.36 base.py(376):     @property
0.36 base.py(380):     @property
0.36 base.py(385): class ModelStateFieldsCacheDescriptor:
0.36 base.py(385): class ModelStateFieldsCacheDescriptor:
0.36 base.py(386):     def __get__(self, instance, cls=None):
0.36 base.py(393): class ModelState:
0.36 base.py(393): class ModelState:
0.36 base.py(394):     """Store model instance state."""
0.36 base.py(395):     db = None
0.36 base.py(400):     adding = True
0.36 base.py(401):     fields_cache = ModelStateFieldsCacheDescriptor()
0.36 base.py(404): class Model(metaclass=ModelBase):
0.36 base.py(404): class Model(metaclass=ModelBase):
0.36 base.py(406):     def __init__(self, *args, **kwargs):
0.36 base.py(505):     @classmethod
0.36 base.py(518):     def __repr__(self):
0.36 base.py(521):     def __str__(self):
0.36 base.py(524):     def __eq__(self, other):
0.36 base.py(534):     def __hash__(self):
0.36 base.py(539):     def __reduce__(self):
0.36 base.py(545):     def __getstate__(self):
0.36 base.py(549):     def __setstate__(self, state):
0.36 base.py(567):     def _get_pk_val(self, meta=None):
0.36 base.py(571):     def _set_pk_val(self, value):
0.36 base.py(577):     pk = property(_get_pk_val, _set_pk_val)
0.36 base.py(579):     def get_deferred_fields(self):
0.36 base.py(588):     def refresh_from_db(self, using=None, fields=None):
0.36 base.py(649):     def serializable_value(self, field_name):
0.36 base.py(667):              update_fields=None):
0.36 base.py(751):     save.alters_data = True
0.36 base.py(754):                   force_update=False, using=None, update_fields=None):
0.36 base.py(802):     save_base.alters_data = True
0.36 base.py(804):     def _save_parents(self, cls, using, update_fields):
0.36 base.py(833):                     force_update=False, using=None, update_fields=None):
0.36 base.py(896):     def _do_update(self, base_qs, using, pk_val, values, update_fields, forced_update):
0.36 base.py(923):     def _do_insert(self, manager, using, fields, returning_fields, raw):
0.36 base.py(933):     def delete(self, using=None, keep_parents=False):
0.36 base.py(944):     delete.alters_data = True
0.36 base.py(946):     def _get_FIELD_display(self, field):
0.36 base.py(952):     def _get_next_or_previous_by_FIELD(self, field, is_next, **kwargs):
0.36 base.py(968):     def _get_next_or_previous_in_order(self, is_next):
0.36 base.py(983):     def prepare_database_save(self, field):
0.36 base.py(988):     def clean(self):
0.36 base.py(997):     def validate_unique(self, exclude=None):
0.36 base.py(1013):     def _get_unique_checks(self, exclude=None):
0.36 base.py(1072):     def _perform_unique_checks(self, unique_checks):
0.36 base.py(1117):     def _perform_date_checks(self, date_checks):
0.36 base.py(1146):     def date_error_message(self, lookup_type, field_name, unique_for):
0.36 base.py(1163):     def unique_error_message(self, model_class, unique_check):
0.36 base.py(1193):     def full_clean(self, exclude=None, validate_unique=True):
0.36 base.py(1229):     def clean_fields(self, exclude=None):
0.36 base.py(1254):     @classmethod
0.36 base.py(1285):     @classmethod
0.36 base.py(1312):     @classmethod
0.36 base.py(1325):     @classmethod
0.36 base.py(1333):     @classmethod
0.36 base.py(1343):     @classmethod
0.36 base.py(1375):     @classmethod
0.36 base.py(1392):     @classmethod
0.36 base.py(1449):     @classmethod
0.36 base.py(1474):     @classmethod
0.36 base.py(1498):     @classmethod
0.36 base.py(1518):     @classmethod
0.36 base.py(1532):     @classmethod
0.36 base.py(1559):     @classmethod
0.36 base.py(1586):     @classmethod
0.36 base.py(1615):     @classmethod
0.36 base.py(1665):     @classmethod
0.36 base.py(1765):     @classmethod
0.36 base.py(1838):     @classmethod
0.36 base.py(75):         super_new = super().__new__
0.36 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.36 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.36 base.py(80):         if not parents:
0.36 base.py(81):             return super_new(cls, name, bases, attrs)
0.36 base.py(1871): def method_set_order(self, ordered_obj, id_list, using=None):
0.36 base.py(1881): def method_get_order(self, ordered_obj):
0.36 base.py(1888): def make_foreign_order_accessors(model, related_model):
0.36 base.py(1905): def model_unpickle(model_id):
0.36 base.py(1915): model_unpickle.__safe_for_unpickle__ = True
Testing against Django installed in '/testbed/django'
0.57 base.py(75):         super_new = super().__new__
0.57 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.57 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.57 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.57 base.py(80):         if not parents:
0.57 base.py(84):         module = attrs.pop('__module__')
0.57 base.py(85):         new_attrs = {'__module__': module}
0.57 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.57 base.py(87):         if classcell is not None:
0.57 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.57 base.py(93):         contributable_attrs = {}
0.57 base.py(94):         for obj_name, obj in list(attrs.items()):
0.57 base.py(95):             if _has_contribute_to_class(obj):
0.57 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(96):                 contributable_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(96):                 contributable_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(96):                 contributable_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.58 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.58 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.58 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.58 base.py(105):         app_label = None
0.58 base.py(108):         app_config = apps.get_containing_app_config(module)
0.58 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.58 base.py(111):             if app_config is None:
0.58 base.py(120):                 app_label = app_config.label
0.58 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.58 options.py(76):         self._get_fields_cache = {}
0.58 options.py(77):         self.local_fields = []
0.58 options.py(78):         self.local_many_to_many = []
0.58 options.py(79):         self.private_fields = []
0.58 options.py(80):         self.local_managers = []
0.58 options.py(81):         self.base_manager_name = None
0.58 options.py(82):         self.default_manager_name = None
0.58 options.py(83):         self.model_name = None
0.58 options.py(84):         self.verbose_name = None
0.58 options.py(85):         self.verbose_name_plural = None
0.58 options.py(86):         self.db_table = ''
0.58 options.py(87):         self.ordering = []
0.58 options.py(88):         self._ordering_clash = False
0.58 options.py(89):         self.indexes = []
0.58 options.py(90):         self.constraints = []
0.58 options.py(91):         self.unique_together = []
0.58 options.py(92):         self.index_together = []
0.58 options.py(93):         self.select_on_save = False
0.58 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.58 options.py(95):         self.permissions = []
0.58 options.py(96):         self.object_name = None
0.58 options.py(97):         self.app_label = app_label
0.58 options.py(98):         self.get_latest_by = None
0.58 options.py(99):         self.order_with_respect_to = None
0.58 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.58 options.py(101):         self.required_db_features = []
0.58 options.py(102):         self.required_db_vendor = None
0.58 options.py(103):         self.meta = meta
0.58 options.py(104):         self.pk = None
0.58 options.py(105):         self.auto_field = None
0.58 options.py(106):         self.abstract = False
0.58 options.py(107):         self.managed = True
0.58 options.py(108):         self.proxy = False
0.58 options.py(114):         self.proxy_for_model = None
0.58 options.py(118):         self.concrete_model = None
0.58 options.py(119):         self.swappable = None
0.58 options.py(120):         self.parents = {}
0.58 options.py(121):         self.auto_created = False
0.58 options.py(125):         self.related_fkey_lookups = []
0.58 options.py(128):         self.apps = self.default_apps
0.58 options.py(130):         self.default_related_name = None
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(150):         from django.db import connection
0.58 options.py(151):         from django.db.backends.utils import truncate_name
0.58 options.py(153):         cls._meta = self
0.58 options.py(154):         self.model = cls
0.58 options.py(156):         self.object_name = cls.__name__
0.58 options.py(157):         self.model_name = self.object_name.lower()
0.58 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.58 options.py(162):         self.original_attrs = {}
0.58 options.py(165):         if self.meta:
0.58 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.58 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.58 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.58 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.58 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.58 options.py(45):     try:
0.58 options.py(46):         if not option_together:
0.58 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.58 options.py(50):         first_element = option_together[0]
0.58 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.58 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.58 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.58 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.58 options.py(182):             self.index_together = normalize_together(self.index_together)
0.58 options.py(45):     try:
0.58 options.py(46):         if not option_together:
0.58 options.py(47):             return ()
0.58 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.58 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.58 options.py(187):                     objs = getattr(self, attr_name, [])
0.58 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.58 options.py(212):         new_objs = []
0.58 options.py(213):         for obj in objs:
0.58 options.py(220):         return new_objs
0.58 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.58 options.py(187):                     objs = getattr(self, attr_name, [])
0.58 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.58 options.py(212):         new_objs = []
0.58 options.py(213):         for obj in objs:
0.58 options.py(220):         return new_objs
0.58 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.58 options.py(192):             if self.verbose_name_plural is None:
0.58 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.58 options.py(199):             if meta_attrs != {}:
0.58 options.py(203):         del self.meta
0.58 options.py(206):         if not self.db_table:
0.58 base.py(123):         if not abstract:
0.58 base.py(124):             new_class.add_to_class(
0.58 base.py(125):                 'DoesNotExist',
0.58 base.py(126):                 subclass_exception(
0.58 base.py(127):                     'DoesNotExist',
0.58 base.py(128):                     tuple(
0.58 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(130):                     ) or (ObjectDoesNotExist,),
0.58 base.py(131):                     module,
0.58 base.py(132):                     attached_to=new_class))
0.58 base.py(61):     return type(name, bases, {
0.58 base.py(62):         '__module__': module,
0.58 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(328):             setattr(cls, name, value)
0.58 base.py(133):             new_class.add_to_class(
0.58 base.py(134):                 'MultipleObjectsReturned',
0.58 base.py(135):                 subclass_exception(
0.58 base.py(136):                     'MultipleObjectsReturned',
0.58 base.py(137):                     tuple(
0.58 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.58 base.py(139):                     ) or (MultipleObjectsReturned,),
0.58 base.py(140):                     module,
0.58 base.py(141):                     attached_to=new_class))
0.58 base.py(61):     return type(name, bases, {
0.58 base.py(62):         '__module__': module,
0.58 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(328):             setattr(cls, name, value)
0.58 base.py(142):             if base_meta and not base_meta.abstract:
0.58 base.py(151):         is_proxy = new_class._meta.proxy
0.58 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.58 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.58 base.py(161):             new_class.add_to_class(obj_name, obj)
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(271):         if private:
0.58 options.py(273):         elif field.is_relation and field.many_to_many:
0.58 options.py(276):             bisect.insort(self.local_fields, field)
0.58 options.py(277):             self.setup_pk(field)
0.58 options.py(297):         if not self.pk and field.primary_key:
0.58 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.58 options.py(294):             self._expire_cache(reverse=False)
0.58 options.py(728):         if forward:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(732):         if reverse and not self.abstract:
0.58 options.py(736):         self._get_fields_cache = {}
0.58 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.58 base.py(161):             new_class.add_to_class(obj_name, obj)
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(271):         if private:
0.58 options.py(273):         elif field.is_relation and field.many_to_many:
0.58 options.py(276):             bisect.insort(self.local_fields, field)
0.58 options.py(277):             self.setup_pk(field)
0.58 options.py(297):         if not self.pk and field.primary_key:
0.58 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.58 options.py(294):             self._expire_cache(reverse=False)
0.58 options.py(728):         if forward:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(732):         if reverse and not self.abstract:
0.58 options.py(736):         self._get_fields_cache = {}
0.58 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.58 base.py(161):             new_class.add_to_class(obj_name, obj)
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(263):         self.local_managers.append(manager)
0.58 options.py(264):         self._expire_cache()
0.58 options.py(728):         if forward:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(732):         if reverse and not self.abstract:
0.58 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.58 options.py(734):                 if cache_key in self.__dict__:
0.58 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.58 options.py(734):                 if cache_key in self.__dict__:
0.58 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.58 options.py(734):                 if cache_key in self.__dict__:
0.58 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.58 options.py(736):         self._get_fields_cache = {}
0.58 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.58 base.py(164):         new_fields = chain(
0.58 base.py(165):             new_class._meta.local_fields,
0.58 base.py(166):             new_class._meta.local_many_to_many,
0.58 base.py(167):             new_class._meta.private_fields
0.58 base.py(169):         field_names = {f.name for f in new_fields}
0.58 base.py(169):         field_names = {f.name for f in new_fields}
0.58 base.py(169):         field_names = {f.name for f in new_fields}
0.58 base.py(169):         field_names = {f.name for f in new_fields}
0.58 base.py(172):         if is_proxy:
0.58 base.py(192):             new_class._meta.concrete_model = new_class
0.58 base.py(195):         parent_links = {}
0.58 base.py(196):         for base in reversed([new_class] + parents):
0.58 base.py(198):             if not hasattr(base, '_meta'):
0.58 base.py(199):                 continue
0.58 base.py(196):         for base in reversed([new_class] + parents):
0.58 base.py(198):             if not hasattr(base, '_meta'):
0.58 base.py(201):             if base != new_class and not base._meta.abstract:
0.58 base.py(204):             for field in base._meta.local_fields:
0.58 base.py(205):                 if isinstance(field, OneToOneField):
0.58 base.py(204):             for field in base._meta.local_fields:
0.58 base.py(205):                 if isinstance(field, OneToOneField):
0.58 base.py(204):             for field in base._meta.local_fields:
0.58 base.py(196):         for base in reversed([new_class] + parents):
0.58 base.py(210):         inherited_attributes = set()
0.58 base.py(212):         for base in new_class.mro():
0.58 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.58 base.py(216):                 inherited_attributes.update(base.__dict__)
0.58 base.py(217):                 continue
0.58 base.py(212):         for base in new_class.mro():
0.58 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.58 base.py(216):                 inherited_attributes.update(base.__dict__)
0.58 base.py(217):                 continue
0.58 base.py(212):         for base in new_class.mro():
0.58 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.58 base.py(216):                 inherited_attributes.update(base.__dict__)
0.58 base.py(217):                 continue
0.58 base.py(212):         for base in new_class.mro():
0.58 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.58 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.58 base.py(312):         if abstract:
0.58 base.py(320):         new_class._prepare()
0.58 base.py(332):         opts = cls._meta
0.58 base.py(333):         opts._prepare(cls)
0.58 options.py(223):         if self.order_with_respect_to:
0.58 options.py(239):             self.order_with_respect_to = None
0.58 options.py(241):         if self.pk is None:
0.58 options.py(242):             if self.parents:
0.58 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.58 options.py(260):                 model.add_to_class('id', auto)
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(271):         if private:
0.58 options.py(273):         elif field.is_relation and field.many_to_many:
0.58 options.py(276):             bisect.insort(self.local_fields, field)
0.58 options.py(277):             self.setup_pk(field)
0.58 options.py(297):         if not self.pk and field.primary_key:
0.58 options.py(298):             self.pk = field
0.58 options.py(299):             field.serialize = False
0.58 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.58 options.py(294):             self._expire_cache(reverse=False)
0.58 options.py(728):         if forward:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(730):                 if cache_key in self.__dict__:
0.58 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.58 options.py(732):         if reverse and not self.abstract:
0.58 options.py(736):         self._get_fields_cache = {}
0.58 base.py(335):         if opts.order_with_respect_to:
0.58 base.py(350):         if cls.__doc__ is None:
0.58 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.58 options.py(456):         def is_not_an_m2m_field(f):
0.58 options.py(459):         def is_not_a_generic_relation(f):
0.58 options.py(462):         def is_not_a_generic_foreign_key(f):
0.58 options.py(467):         return make_immutable_fields_list(
0.58 options.py(468):             "fields",
0.58 options.py(469):             (f for f in self._get_fields(reverse=False)
0.58 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.58 options.py(773):         topmost_call = seen_models is None
0.58 options.py(774):         if topmost_call:
0.58 options.py(775):             seen_models = set()
0.58 options.py(776):         seen_models.add(self.model)
0.58 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.58 options.py(781):         try:
0.58 options.py(784):             return self._get_fields_cache[cache_key]
0.58 options.py(785):         except KeyError:
0.58 options.py(786):             pass
0.58 options.py(788):         fields = []
0.58 options.py(791):         if include_parents is not False:
0.58 options.py(792):             for parent in self.parents:
0.58 options.py(806):         if reverse and not self.proxy:
0.58 options.py(817):         if forward:
0.58 options.py(818):             fields += self.local_fields
0.58 options.py(819):             fields += self.local_many_to_many
0.58 options.py(825):             if topmost_call:
0.58 options.py(826):                 fields += self.private_fields
0.58 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.58 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.58 options.py(833):         self._get_fields_cache[cache_key] = fields
0.58 options.py(834):         return fields
0.58 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.58 options.py(469):             (f for f in self._get_fields(reverse=False)
0.58 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.58 options.py(457):             return not (f.is_relation and f.many_to_many)
0.58 options.py(460):             return not (f.is_relation and f.one_to_many)
0.58 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.58 options.py(469):             (f for f in self._get_fields(reverse=False)
0.58 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.58 options.py(457):             return not (f.is_relation and f.many_to_many)
0.58 options.py(460):             return not (f.is_relation and f.one_to_many)
0.58 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.58 options.py(469):             (f for f in self._get_fields(reverse=False)
0.58 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.58 options.py(457):             return not (f.is_relation and f.many_to_many)
0.58 options.py(460):             return not (f.is_relation and f.one_to_many)
0.58 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.58 options.py(469):             (f for f in self._get_fields(reverse=False)
0.58 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.58 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.58 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.58 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.58 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.58 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.58 base.py(354):         if get_absolute_url_override:
0.58 base.py(357):         if not opts.managers:
0.58 options.py(365):         managers = []
0.58 options.py(366):         seen_managers = set()
0.58 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.58 options.py(368):         for depth, base in enumerate(bases):
0.58 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.58 options.py(369):             for manager in base._meta.local_managers:
0.58 options.py(370):                 if manager.name in seen_managers:
0.58 options.py(373):                 manager = copy.copy(manager)
0.58 options.py(374):                 manager.model = self.model
0.58 options.py(375):                 seen_managers.add(manager.name)
0.58 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.58 options.py(369):             for manager in base._meta.local_managers:
0.58 options.py(368):         for depth, base in enumerate(bases):
0.58 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.58 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.58 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.58 options.py(378):         return make_immutable_fields_list(
0.58 options.py(379):             "managers",
0.58 options.py(380):             (m[2] for m in sorted(managers)),
0.58 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.58 options.py(380):             (m[2] for m in sorted(managers)),
0.58 options.py(380):             (m[2] for m in sorted(managers)),
0.58 base.py(370):         for index in cls._meta.indexes:
0.58 base.py(374):         class_prepared.send(sender=cls)
0.58 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.58 base.py(322):         return new_class
0.58 base.py(75):         super_new = super().__new__
0.58 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.58 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.58 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.58 base.py(80):         if not parents:
0.58 base.py(84):         module = attrs.pop('__module__')
0.58 base.py(85):         new_attrs = {'__module__': module}
0.58 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.58 base.py(87):         if classcell is not None:
0.58 base.py(88):             new_attrs['__classcell__'] = classcell
0.58 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.58 base.py(93):         contributable_attrs = {}
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(96):                 contributable_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(96):                 contributable_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(95):             if _has_contribute_to_class(obj):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(98):                 new_attrs[obj_name] = obj
0.58 base.py(94):         for obj_name, obj in list(attrs.items()):
0.58 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.58 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.58 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.58 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.58 base.py(105):         app_label = None
0.58 base.py(108):         app_config = apps.get_containing_app_config(module)
0.58 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.58 base.py(111):             if app_config is None:
0.58 base.py(120):                 app_label = app_config.label
0.58 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.58 options.py(76):         self._get_fields_cache = {}
0.58 options.py(77):         self.local_fields = []
0.58 options.py(78):         self.local_many_to_many = []
0.58 options.py(79):         self.private_fields = []
0.58 options.py(80):         self.local_managers = []
0.58 options.py(81):         self.base_manager_name = None
0.58 options.py(82):         self.default_manager_name = None
0.58 options.py(83):         self.model_name = None
0.58 options.py(84):         self.verbose_name = None
0.58 options.py(85):         self.verbose_name_plural = None
0.58 options.py(86):         self.db_table = ''
0.58 options.py(87):         self.ordering = []
0.58 options.py(88):         self._ordering_clash = False
0.58 options.py(89):         self.indexes = []
0.58 options.py(90):         self.constraints = []
0.58 options.py(91):         self.unique_together = []
0.58 options.py(92):         self.index_together = []
0.58 options.py(93):         self.select_on_save = False
0.58 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.58 options.py(95):         self.permissions = []
0.58 options.py(96):         self.object_name = None
0.58 options.py(97):         self.app_label = app_label
0.58 options.py(98):         self.get_latest_by = None
0.58 options.py(99):         self.order_with_respect_to = None
0.58 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.58 options.py(101):         self.required_db_features = []
0.58 options.py(102):         self.required_db_vendor = None
0.58 options.py(103):         self.meta = meta
0.58 options.py(104):         self.pk = None
0.58 options.py(105):         self.auto_field = None
0.58 options.py(106):         self.abstract = False
0.58 options.py(107):         self.managed = True
0.58 options.py(108):         self.proxy = False
0.58 options.py(114):         self.proxy_for_model = None
0.58 options.py(118):         self.concrete_model = None
0.58 options.py(119):         self.swappable = None
0.58 options.py(120):         self.parents = {}
0.58 options.py(121):         self.auto_created = False
0.58 options.py(125):         self.related_fkey_lookups = []
0.58 options.py(128):         self.apps = self.default_apps
0.58 options.py(130):         self.default_related_name = None
0.58 base.py(325):         if _has_contribute_to_class(value):
0.58 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.58 base.py(326):             value.contribute_to_class(cls, name)
0.58 options.py(150):         from django.db import connection
0.58 options.py(151):         from django.db.backends.utils import truncate_name
0.58 options.py(153):         cls._meta = self
0.58 options.py(154):         self.model = cls
0.58 options.py(156):         self.object_name = cls.__name__
0.58 options.py(157):         self.model_name = self.object_name.lower()
0.58 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.58 options.py(162):         self.original_attrs = {}
0.58 options.py(165):         if self.meta:
0.58 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(171):                 if name.startswith('_'):
0.58 options.py(172):                     del meta_attrs[name]
0.58 options.py(167):             for name in self.meta.__dict__:
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.58 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(174):                 if attr_name in meta_attrs:
0.58 options.py(177):                 elif hasattr(self.meta, attr_name):
0.58 options.py(173):             for attr_name in DEFAULT_NAMES:
0.58 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.58 options.py(45):     try:
0.58 options.py(46):         if not option_together:
0.58 options.py(47):             return ()
0.58 options.py(182):             self.index_together = normalize_together(self.index_together)
0.58 options.py(45):     try:
0.58 options.py(46):         if not option_together:
0.58 options.py(47):             return ()
0.58 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.58 options.py(192):             if self.verbose_name_plural is None:
0.58 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.58 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.58 options.py(199):             if meta_attrs != {}:
0.58 options.py(203):         del self.meta
0.58 options.py(206):         if not self.db_table:
0.58 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.58 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.62 base.py(123):         if not abstract:
0.62 base.py(151):         is_proxy = new_class._meta.proxy
0.62 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(294):             self._expire_cache(reverse=False)
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(294):             self._expire_cache(reverse=False)
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(164):         new_fields = chain(
0.62 base.py(165):             new_class._meta.local_fields,
0.62 base.py(166):             new_class._meta.local_many_to_many,
0.62 base.py(167):             new_class._meta.private_fields
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(172):         if is_proxy:
0.62 base.py(192):             new_class._meta.concrete_model = new_class
0.62 base.py(195):         parent_links = {}
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(198):             if not hasattr(base, '_meta'):
0.62 base.py(199):                 continue
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(198):             if not hasattr(base, '_meta'):
0.62 base.py(201):             if base != new_class and not base._meta.abstract:
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(205):                 if isinstance(field, OneToOneField):
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(205):                 if isinstance(field, OneToOneField):
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(210):         inherited_attributes = set()
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.62 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.62 base.py(312):         if abstract:
0.62 base.py(316):             attr_meta.abstract = False
0.62 base.py(317):             new_class.Meta = attr_meta
0.62 base.py(318):             return new_class
0.62 base.py(75):         super_new = super().__new__
0.62 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.62 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.62 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.62 base.py(80):         if not parents:
0.62 base.py(84):         module = attrs.pop('__module__')
0.62 base.py(85):         new_attrs = {'__module__': module}
0.62 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.62 base.py(87):         if classcell is not None:
0.62 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.62 base.py(93):         contributable_attrs = {}
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(98):                 new_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(98):                 new_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(96):                 contributable_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(96):                 contributable_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(96):                 contributable_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(96):                 contributable_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(98):                 new_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(95):             if _has_contribute_to_class(obj):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(98):                 new_attrs[obj_name] = obj
0.62 base.py(94):         for obj_name, obj in list(attrs.items()):
0.62 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.62 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.62 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.62 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.62 base.py(105):         app_label = None
0.62 base.py(108):         app_config = apps.get_containing_app_config(module)
0.62 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.62 base.py(111):             if app_config is None:
0.62 base.py(120):                 app_label = app_config.label
0.62 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.62 options.py(76):         self._get_fields_cache = {}
0.62 options.py(77):         self.local_fields = []
0.62 options.py(78):         self.local_many_to_many = []
0.62 options.py(79):         self.private_fields = []
0.62 options.py(80):         self.local_managers = []
0.62 options.py(81):         self.base_manager_name = None
0.62 options.py(82):         self.default_manager_name = None
0.62 options.py(83):         self.model_name = None
0.62 options.py(84):         self.verbose_name = None
0.62 options.py(85):         self.verbose_name_plural = None
0.62 options.py(86):         self.db_table = ''
0.62 options.py(87):         self.ordering = []
0.62 options.py(88):         self._ordering_clash = False
0.62 options.py(89):         self.indexes = []
0.62 options.py(90):         self.constraints = []
0.62 options.py(91):         self.unique_together = []
0.62 options.py(92):         self.index_together = []
0.62 options.py(93):         self.select_on_save = False
0.62 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.62 options.py(95):         self.permissions = []
0.62 options.py(96):         self.object_name = None
0.62 options.py(97):         self.app_label = app_label
0.62 options.py(98):         self.get_latest_by = None
0.62 options.py(99):         self.order_with_respect_to = None
0.62 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.62 options.py(101):         self.required_db_features = []
0.62 options.py(102):         self.required_db_vendor = None
0.62 options.py(103):         self.meta = meta
0.62 options.py(104):         self.pk = None
0.62 options.py(105):         self.auto_field = None
0.62 options.py(106):         self.abstract = False
0.62 options.py(107):         self.managed = True
0.62 options.py(108):         self.proxy = False
0.62 options.py(114):         self.proxy_for_model = None
0.62 options.py(118):         self.concrete_model = None
0.62 options.py(119):         self.swappable = None
0.62 options.py(120):         self.parents = {}
0.62 options.py(121):         self.auto_created = False
0.62 options.py(125):         self.related_fkey_lookups = []
0.62 options.py(128):         self.apps = self.default_apps
0.62 options.py(130):         self.default_related_name = None
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(150):         from django.db import connection
0.62 options.py(151):         from django.db.backends.utils import truncate_name
0.62 options.py(153):         cls._meta = self
0.62 options.py(154):         self.model = cls
0.62 options.py(156):         self.object_name = cls.__name__
0.62 options.py(157):         self.model_name = self.object_name.lower()
0.62 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.62 options.py(162):         self.original_attrs = {}
0.62 options.py(165):         if self.meta:
0.62 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(172):                     del meta_attrs[name]
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(172):                     del meta_attrs[name]
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(172):                     del meta_attrs[name]
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(171):                 if name.startswith('_'):
0.62 options.py(172):                     del meta_attrs[name]
0.62 options.py(167):             for name in self.meta.__dict__:
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.62 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.62 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.62 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.62 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(174):                 if attr_name in meta_attrs:
0.62 options.py(177):                 elif hasattr(self.meta, attr_name):
0.62 options.py(173):             for attr_name in DEFAULT_NAMES:
0.62 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.62 options.py(45):     try:
0.62 options.py(46):         if not option_together:
0.62 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.62 options.py(50):         first_element = option_together[0]
0.62 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.62 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.62 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.62 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.62 options.py(182):             self.index_together = normalize_together(self.index_together)
0.62 options.py(45):     try:
0.62 options.py(46):         if not option_together:
0.62 options.py(47):             return ()
0.62 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.62 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.62 options.py(187):                     objs = getattr(self, attr_name, [])
0.62 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.62 options.py(212):         new_objs = []
0.62 options.py(213):         for obj in objs:
0.62 options.py(220):         return new_objs
0.62 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.62 options.py(187):                     objs = getattr(self, attr_name, [])
0.62 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.62 options.py(212):         new_objs = []
0.62 options.py(213):         for obj in objs:
0.62 options.py(220):         return new_objs
0.62 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.62 options.py(192):             if self.verbose_name_plural is None:
0.62 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.62 options.py(199):             if meta_attrs != {}:
0.62 options.py(203):         del self.meta
0.62 options.py(206):         if not self.db_table:
0.62 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.62 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.62 base.py(123):         if not abstract:
0.62 base.py(124):             new_class.add_to_class(
0.62 base.py(125):                 'DoesNotExist',
0.62 base.py(126):                 subclass_exception(
0.62 base.py(127):                     'DoesNotExist',
0.62 base.py(128):                     tuple(
0.62 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(130):                     ) or (ObjectDoesNotExist,),
0.62 base.py(131):                     module,
0.62 base.py(132):                     attached_to=new_class))
0.62 base.py(61):     return type(name, bases, {
0.62 base.py(62):         '__module__': module,
0.62 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(328):             setattr(cls, name, value)
0.62 base.py(133):             new_class.add_to_class(
0.62 base.py(134):                 'MultipleObjectsReturned',
0.62 base.py(135):                 subclass_exception(
0.62 base.py(136):                     'MultipleObjectsReturned',
0.62 base.py(137):                     tuple(
0.62 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.62 base.py(139):                     ) or (MultipleObjectsReturned,),
0.62 base.py(140):                     module,
0.62 base.py(141):                     attached_to=new_class))
0.62 base.py(61):     return type(name, bases, {
0.62 base.py(62):         '__module__': module,
0.62 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(328):             setattr(cls, name, value)
0.62 base.py(142):             if base_meta and not base_meta.abstract:
0.62 base.py(151):         is_proxy = new_class._meta.proxy
0.62 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(294):             self._expire_cache(reverse=False)
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(288):             try:
0.62 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.62 options.py(728):         if forward:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 options.py(292):             self._expire_cache()
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(294):             self._expire_cache(reverse=False)
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(161):             new_class.add_to_class(obj_name, obj)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(263):         self.local_managers.append(manager)
0.62 options.py(264):         self._expire_cache()
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(734):                 if cache_key in self.__dict__:
0.62 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.62 base.py(164):         new_fields = chain(
0.62 base.py(165):             new_class._meta.local_fields,
0.62 base.py(166):             new_class._meta.local_many_to_many,
0.62 base.py(167):             new_class._meta.private_fields
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(169):         field_names = {f.name for f in new_fields}
0.62 base.py(172):         if is_proxy:
0.62 base.py(192):             new_class._meta.concrete_model = new_class
0.62 base.py(195):         parent_links = {}
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(198):             if not hasattr(base, '_meta'):
0.62 base.py(199):                 continue
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(198):             if not hasattr(base, '_meta'):
0.62 base.py(201):             if base != new_class and not base._meta.abstract:
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(205):                 if isinstance(field, OneToOneField):
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(205):                 if isinstance(field, OneToOneField):
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(205):                 if isinstance(field, OneToOneField):
0.62 base.py(204):             for field in base._meta.local_fields:
0.62 base.py(196):         for base in reversed([new_class] + parents):
0.62 base.py(210):         inherited_attributes = set()
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.62 base.py(216):                 inherited_attributes.update(base.__dict__)
0.62 base.py(217):                 continue
0.62 base.py(212):         for base in new_class.mro():
0.62 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.62 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.62 base.py(312):         if abstract:
0.62 base.py(320):         new_class._prepare()
0.62 base.py(332):         opts = cls._meta
0.62 base.py(333):         opts._prepare(cls)
0.62 options.py(223):         if self.order_with_respect_to:
0.62 options.py(239):             self.order_with_respect_to = None
0.62 options.py(241):         if self.pk is None:
0.62 options.py(242):             if self.parents:
0.62 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.62 options.py(260):                 model.add_to_class('id', auto)
0.62 base.py(325):         if _has_contribute_to_class(value):
0.62 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.62 base.py(326):             value.contribute_to_class(cls, name)
0.62 options.py(271):         if private:
0.62 options.py(273):         elif field.is_relation and field.many_to_many:
0.62 options.py(276):             bisect.insort(self.local_fields, field)
0.62 options.py(277):             self.setup_pk(field)
0.62 options.py(297):         if not self.pk and field.primary_key:
0.62 options.py(298):             self.pk = field
0.62 options.py(299):             field.serialize = False
0.62 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.62 options.py(294):             self._expire_cache(reverse=False)
0.62 options.py(728):         if forward:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(730):                 if cache_key in self.__dict__:
0.62 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.62 options.py(732):         if reverse and not self.abstract:
0.62 options.py(736):         self._get_fields_cache = {}
0.62 base.py(335):         if opts.order_with_respect_to:
0.62 base.py(350):         if cls.__doc__ is None:
0.62 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.62 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.62 base.py(354):         if get_absolute_url_override:
0.62 base.py(357):         if not opts.managers:
0.62 options.py(365):         managers = []
0.62 options.py(366):         seen_managers = set()
0.62 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.62 options.py(368):         for depth, base in enumerate(bases):
0.62 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.62 options.py(369):             for manager in base._meta.local_managers:
0.62 options.py(370):                 if manager.name in seen_managers:
0.62 options.py(373):                 manager = copy.copy(manager)
0.62 options.py(374):                 manager.model = self.model
0.62 options.py(375):                 seen_managers.add(manager.name)
0.62 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.62 options.py(369):             for manager in base._meta.local_managers:
0.62 options.py(368):         for depth, base in enumerate(bases):
0.62 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.62 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.62 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.62 options.py(378):         return make_immutable_fields_list(
0.62 options.py(379):             "managers",
0.62 options.py(380):             (m[2] for m in sorted(managers)),
0.62 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.62 options.py(380):             (m[2] for m in sorted(managers)),
0.62 options.py(380):             (m[2] for m in sorted(managers)),
0.62 base.py(370):         for index in cls._meta.indexes:
0.62 base.py(374):         class_prepared.send(sender=cls)
0.62 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.62 options.py(347):         if self.swappable:
0.62 options.py(361):         return None
0.62 base.py(322):         return new_class
0.63 base.py(75):         super_new = super().__new__
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(80):         if not parents:
0.63 base.py(84):         module = attrs.pop('__module__')
0.63 base.py(85):         new_attrs = {'__module__': module}
0.63 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.63 base.py(87):         if classcell is not None:
0.63 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.63 base.py(93):         contributable_attrs = {}
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.63 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.63 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.63 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.63 base.py(105):         app_label = None
0.63 base.py(108):         app_config = apps.get_containing_app_config(module)
0.63 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.63 base.py(111):             if app_config is None:
0.63 base.py(120):                 app_label = app_config.label
0.63 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.63 options.py(76):         self._get_fields_cache = {}
0.63 options.py(77):         self.local_fields = []
0.63 options.py(78):         self.local_many_to_many = []
0.63 options.py(79):         self.private_fields = []
0.63 options.py(80):         self.local_managers = []
0.63 options.py(81):         self.base_manager_name = None
0.63 options.py(82):         self.default_manager_name = None
0.63 options.py(83):         self.model_name = None
0.63 options.py(84):         self.verbose_name = None
0.63 options.py(85):         self.verbose_name_plural = None
0.63 options.py(86):         self.db_table = ''
0.63 options.py(87):         self.ordering = []
0.63 options.py(88):         self._ordering_clash = False
0.63 options.py(89):         self.indexes = []
0.63 options.py(90):         self.constraints = []
0.63 options.py(91):         self.unique_together = []
0.63 options.py(92):         self.index_together = []
0.63 options.py(93):         self.select_on_save = False
0.63 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.63 options.py(95):         self.permissions = []
0.63 options.py(96):         self.object_name = None
0.63 options.py(97):         self.app_label = app_label
0.63 options.py(98):         self.get_latest_by = None
0.63 options.py(99):         self.order_with_respect_to = None
0.63 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.63 options.py(101):         self.required_db_features = []
0.63 options.py(102):         self.required_db_vendor = None
0.63 options.py(103):         self.meta = meta
0.63 options.py(104):         self.pk = None
0.63 options.py(105):         self.auto_field = None
0.63 options.py(106):         self.abstract = False
0.63 options.py(107):         self.managed = True
0.63 options.py(108):         self.proxy = False
0.63 options.py(114):         self.proxy_for_model = None
0.63 options.py(118):         self.concrete_model = None
0.63 options.py(119):         self.swappable = None
0.63 options.py(120):         self.parents = {}
0.63 options.py(121):         self.auto_created = False
0.63 options.py(125):         self.related_fkey_lookups = []
0.63 options.py(128):         self.apps = self.default_apps
0.63 options.py(130):         self.default_related_name = None
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(150):         from django.db import connection
0.63 options.py(151):         from django.db.backends.utils import truncate_name
0.63 options.py(153):         cls._meta = self
0.63 options.py(154):         self.model = cls
0.63 options.py(156):         self.object_name = cls.__name__
0.63 options.py(157):         self.model_name = self.object_name.lower()
0.63 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.63 options.py(162):         self.original_attrs = {}
0.63 options.py(165):         if self.meta:
0.63 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(47):             return ()
0.63 options.py(182):             self.index_together = normalize_together(self.index_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(47):             return ()
0.63 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(187):                     objs = getattr(self, attr_name, [])
0.63 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.63 options.py(212):         new_objs = []
0.63 options.py(213):         for obj in objs:
0.63 options.py(220):         return new_objs
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(187):                     objs = getattr(self, attr_name, [])
0.63 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.63 options.py(212):         new_objs = []
0.63 options.py(213):         for obj in objs:
0.63 options.py(220):         return new_objs
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(192):             if self.verbose_name_plural is None:
0.63 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.63 options.py(199):             if meta_attrs != {}:
0.63 options.py(203):         del self.meta
0.63 options.py(206):         if not self.db_table:
0.63 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.63 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.63 base.py(123):         if not abstract:
0.63 base.py(124):             new_class.add_to_class(
0.63 base.py(125):                 'DoesNotExist',
0.63 base.py(126):                 subclass_exception(
0.63 base.py(127):                     'DoesNotExist',
0.63 base.py(128):                     tuple(
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(130):                     ) or (ObjectDoesNotExist,),
0.63 base.py(131):                     module,
0.63 base.py(132):                     attached_to=new_class))
0.63 base.py(61):     return type(name, bases, {
0.63 base.py(62):         '__module__': module,
0.63 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(328):             setattr(cls, name, value)
0.63 base.py(133):             new_class.add_to_class(
0.63 base.py(134):                 'MultipleObjectsReturned',
0.63 base.py(135):                 subclass_exception(
0.63 base.py(136):                     'MultipleObjectsReturned',
0.63 base.py(137):                     tuple(
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(139):                     ) or (MultipleObjectsReturned,),
0.63 base.py(140):                     module,
0.63 base.py(141):                     attached_to=new_class))
0.63 base.py(61):     return type(name, bases, {
0.63 base.py(62):         '__module__': module,
0.63 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(328):             setattr(cls, name, value)
0.63 base.py(142):             if base_meta and not base_meta.abstract:
0.63 base.py(151):         is_proxy = new_class._meta.proxy
0.63 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(294):             self._expire_cache(reverse=False)
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(288):             try:
0.63 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.63 options.py(728):         if forward:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(292):             self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(347):         if self.swappable:
0.63 options.py(361):         return None
0.63 base.py(75):         super_new = super().__new__
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(80):         if not parents:
0.63 base.py(84):         module = attrs.pop('__module__')
0.63 base.py(85):         new_attrs = {'__module__': module}
0.63 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.63 base.py(87):         if classcell is not None:
0.63 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.63 base.py(93):         contributable_attrs = {}
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.63 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.63 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.63 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.63 base.py(105):         app_label = None
0.63 base.py(108):         app_config = apps.get_containing_app_config(module)
0.63 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.63 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.63 options.py(76):         self._get_fields_cache = {}
0.63 options.py(77):         self.local_fields = []
0.63 options.py(78):         self.local_many_to_many = []
0.63 options.py(79):         self.private_fields = []
0.63 options.py(80):         self.local_managers = []
0.63 options.py(81):         self.base_manager_name = None
0.63 options.py(82):         self.default_manager_name = None
0.63 options.py(83):         self.model_name = None
0.63 options.py(84):         self.verbose_name = None
0.63 options.py(85):         self.verbose_name_plural = None
0.63 options.py(86):         self.db_table = ''
0.63 options.py(87):         self.ordering = []
0.63 options.py(88):         self._ordering_clash = False
0.63 options.py(89):         self.indexes = []
0.63 options.py(90):         self.constraints = []
0.63 options.py(91):         self.unique_together = []
0.63 options.py(92):         self.index_together = []
0.63 options.py(93):         self.select_on_save = False
0.63 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.63 options.py(95):         self.permissions = []
0.63 options.py(96):         self.object_name = None
0.63 options.py(97):         self.app_label = app_label
0.63 options.py(98):         self.get_latest_by = None
0.63 options.py(99):         self.order_with_respect_to = None
0.63 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.63 options.py(101):         self.required_db_features = []
0.63 options.py(102):         self.required_db_vendor = None
0.63 options.py(103):         self.meta = meta
0.63 options.py(104):         self.pk = None
0.63 options.py(105):         self.auto_field = None
0.63 options.py(106):         self.abstract = False
0.63 options.py(107):         self.managed = True
0.63 options.py(108):         self.proxy = False
0.63 options.py(114):         self.proxy_for_model = None
0.63 options.py(118):         self.concrete_model = None
0.63 options.py(119):         self.swappable = None
0.63 options.py(120):         self.parents = {}
0.63 options.py(121):         self.auto_created = False
0.63 options.py(125):         self.related_fkey_lookups = []
0.63 options.py(128):         self.apps = self.default_apps
0.63 options.py(130):         self.default_related_name = None
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(150):         from django.db import connection
0.63 options.py(151):         from django.db.backends.utils import truncate_name
0.63 options.py(153):         cls._meta = self
0.63 options.py(154):         self.model = cls
0.63 options.py(156):         self.object_name = cls.__name__
0.63 options.py(157):         self.model_name = self.object_name.lower()
0.63 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.63 options.py(162):         self.original_attrs = {}
0.63 options.py(165):         if self.meta:
0.63 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.63 options.py(50):         first_element = option_together[0]
0.63 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.63 options.py(52):             option_together = (option_together,)
0.63 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.63 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.63 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.63 options.py(182):             self.index_together = normalize_together(self.index_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(47):             return ()
0.63 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(187):                     objs = getattr(self, attr_name, [])
0.63 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.63 options.py(212):         new_objs = []
0.63 options.py(213):         for obj in objs:
0.63 options.py(220):         return new_objs
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(187):                     objs = getattr(self, attr_name, [])
0.63 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.63 options.py(212):         new_objs = []
0.63 options.py(213):         for obj in objs:
0.63 options.py(220):         return new_objs
0.63 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.63 options.py(192):             if self.verbose_name_plural is None:
0.63 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.63 options.py(199):             if meta_attrs != {}:
0.63 options.py(203):         del self.meta
0.63 options.py(206):         if not self.db_table:
0.63 base.py(123):         if not abstract:
0.63 base.py(124):             new_class.add_to_class(
0.63 base.py(125):                 'DoesNotExist',
0.63 base.py(126):                 subclass_exception(
0.63 base.py(127):                     'DoesNotExist',
0.63 base.py(128):                     tuple(
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(130):                     ) or (ObjectDoesNotExist,),
0.63 base.py(131):                     module,
0.63 base.py(132):                     attached_to=new_class))
0.63 base.py(61):     return type(name, bases, {
0.63 base.py(62):         '__module__': module,
0.63 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(328):             setattr(cls, name, value)
0.63 base.py(133):             new_class.add_to_class(
0.63 base.py(134):                 'MultipleObjectsReturned',
0.63 base.py(135):                 subclass_exception(
0.63 base.py(136):                     'MultipleObjectsReturned',
0.63 base.py(137):                     tuple(
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.63 base.py(139):                     ) or (MultipleObjectsReturned,),
0.63 base.py(140):                     module,
0.63 base.py(141):                     attached_to=new_class))
0.63 base.py(61):     return type(name, bases, {
0.63 base.py(62):         '__module__': module,
0.63 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(328):             setattr(cls, name, value)
0.63 base.py(142):             if base_meta and not base_meta.abstract:
0.63 base.py(151):         is_proxy = new_class._meta.proxy
0.63 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(288):             try:
0.63 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.63 options.py(728):         if forward:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(292):             self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(288):             try:
0.63 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.63 options.py(728):         if forward:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(292):             self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(164):         new_fields = chain(
0.63 base.py(165):             new_class._meta.local_fields,
0.63 base.py(166):             new_class._meta.local_many_to_many,
0.63 base.py(167):             new_class._meta.private_fields
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(172):         if is_proxy:
0.63 base.py(192):             new_class._meta.concrete_model = new_class
0.63 base.py(195):         parent_links = {}
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(199):                 continue
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(201):             if base != new_class and not base._meta.abstract:
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(205):                 if isinstance(field, OneToOneField):
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(205):                 if isinstance(field, OneToOneField):
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(210):         inherited_attributes = set()
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(312):         if abstract:
0.63 base.py(320):         new_class._prepare()
0.63 base.py(332):         opts = cls._meta
0.63 base.py(333):         opts._prepare(cls)
0.63 options.py(223):         if self.order_with_respect_to:
0.63 options.py(239):             self.order_with_respect_to = None
0.63 options.py(241):         if self.pk is None:
0.63 options.py(242):             if self.parents:
0.63 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.63 options.py(260):                 model.add_to_class('id', auto)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(298):             self.pk = field
0.63 options.py(299):             field.serialize = False
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(294):             self._expire_cache(reverse=False)
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(335):         if opts.order_with_respect_to:
0.63 base.py(350):         if cls.__doc__ is None:
0.63 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.63 options.py(456):         def is_not_an_m2m_field(f):
0.63 options.py(459):         def is_not_a_generic_relation(f):
0.63 options.py(462):         def is_not_a_generic_foreign_key(f):
0.63 options.py(467):         return make_immutable_fields_list(
0.63 options.py(468):             "fields",
0.63 options.py(469):             (f for f in self._get_fields(reverse=False)
0.63 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.63 options.py(773):         topmost_call = seen_models is None
0.63 options.py(774):         if topmost_call:
0.63 options.py(775):             seen_models = set()
0.63 options.py(776):         seen_models.add(self.model)
0.63 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.63 options.py(781):         try:
0.63 options.py(784):             return self._get_fields_cache[cache_key]
0.63 options.py(785):         except KeyError:
0.63 options.py(786):             pass
0.63 options.py(788):         fields = []
0.63 options.py(791):         if include_parents is not False:
0.63 options.py(792):             for parent in self.parents:
0.63 options.py(806):         if reverse and not self.proxy:
0.63 options.py(817):         if forward:
0.63 options.py(818):             fields += self.local_fields
0.63 options.py(819):             fields += self.local_many_to_many
0.63 options.py(825):             if topmost_call:
0.63 options.py(826):                 fields += self.private_fields
0.63 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.63 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.63 options.py(833):         self._get_fields_cache[cache_key] = fields
0.63 options.py(834):         return fields
0.63 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.63 options.py(469):             (f for f in self._get_fields(reverse=False)
0.63 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.63 options.py(457):             return not (f.is_relation and f.many_to_many)
0.63 options.py(460):             return not (f.is_relation and f.one_to_many)
0.63 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.63 options.py(469):             (f for f in self._get_fields(reverse=False)
0.63 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.63 options.py(457):             return not (f.is_relation and f.many_to_many)
0.63 options.py(460):             return not (f.is_relation and f.one_to_many)
0.63 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.63 options.py(469):             (f for f in self._get_fields(reverse=False)
0.63 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.63 options.py(457):             return not (f.is_relation and f.many_to_many)
0.63 options.py(460):             return not (f.is_relation and f.one_to_many)
0.63 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.63 options.py(469):             (f for f in self._get_fields(reverse=False)
0.63 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.63 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.63 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.63 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.63 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.63 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.63 base.py(354):         if get_absolute_url_override:
0.63 base.py(357):         if not opts.managers:
0.63 options.py(365):         managers = []
0.63 options.py(366):         seen_managers = set()
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(368):         for depth, base in enumerate(bases):
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(369):             for manager in base._meta.local_managers:
0.63 options.py(368):         for depth, base in enumerate(bases):
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(378):         return make_immutable_fields_list(
0.63 options.py(379):             "managers",
0.63 options.py(380):             (m[2] for m in sorted(managers)),
0.63 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.63 options.py(380):             (m[2] for m in sorted(managers)),
0.63 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.63 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.63 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.63 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.63 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.63 base.py(363):             manager = Manager()
0.63 base.py(364):             manager.auto_created = True
0.63 base.py(365):             cls.add_to_class('objects', manager)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(263):         self.local_managers.append(manager)
0.63 options.py(264):         self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(731):                     delattr(self, cache_key)
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(731):                     delattr(self, cache_key)
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(370):         for index in cls._meta.indexes:
0.63 base.py(374):         class_prepared.send(sender=cls)
0.63 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.63 base.py(322):         return new_class
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(263):         self.local_managers.append(manager)
0.63 options.py(264):         self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(164):         new_fields = chain(
0.63 base.py(165):             new_class._meta.local_fields,
0.63 base.py(166):             new_class._meta.local_many_to_many,
0.63 base.py(167):             new_class._meta.private_fields
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(172):         if is_proxy:
0.63 base.py(192):             new_class._meta.concrete_model = new_class
0.63 base.py(195):         parent_links = {}
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(199):                 continue
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(201):             if base != new_class and not base._meta.abstract:
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(205):                 if isinstance(field, OneToOneField):
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(210):         inherited_attributes = set()
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(312):         if abstract:
0.63 base.py(320):         new_class._prepare()
0.63 base.py(332):         opts = cls._meta
0.63 base.py(333):         opts._prepare(cls)
0.63 options.py(223):         if self.order_with_respect_to:
0.63 options.py(239):             self.order_with_respect_to = None
0.63 options.py(241):         if self.pk is None:
0.63 options.py(242):             if self.parents:
0.63 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.63 options.py(260):                 model.add_to_class('id', auto)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(298):             self.pk = field
0.63 options.py(299):             field.serialize = False
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(294):             self._expire_cache(reverse=False)
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(335):         if opts.order_with_respect_to:
0.63 base.py(350):         if cls.__doc__ is None:
0.63 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.63 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.63 base.py(354):         if get_absolute_url_override:
0.63 base.py(357):         if not opts.managers:
0.63 options.py(365):         managers = []
0.63 options.py(366):         seen_managers = set()
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(368):         for depth, base in enumerate(bases):
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(369):             for manager in base._meta.local_managers:
0.63 options.py(370):                 if manager.name in seen_managers:
0.63 options.py(373):                 manager = copy.copy(manager)
0.63 options.py(374):                 manager.model = self.model
0.63 options.py(375):                 seen_managers.add(manager.name)
0.63 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.63 options.py(369):             for manager in base._meta.local_managers:
0.63 options.py(368):         for depth, base in enumerate(bases):
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.63 options.py(378):         return make_immutable_fields_list(
0.63 options.py(379):             "managers",
0.63 options.py(380):             (m[2] for m in sorted(managers)),
0.63 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.63 options.py(380):             (m[2] for m in sorted(managers)),
0.63 options.py(380):             (m[2] for m in sorted(managers)),
0.63 base.py(370):         for index in cls._meta.indexes:
0.63 base.py(374):         class_prepared.send(sender=cls)
0.63 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.63 options.py(347):         if self.swappable:
0.63 options.py(361):         return None
0.63 base.py(322):         return new_class
0.63 base.py(75):         super_new = super().__new__
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(80):         if not parents:
0.63 base.py(84):         module = attrs.pop('__module__')
0.63 base.py(85):         new_attrs = {'__module__': module}
0.63 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.63 base.py(87):         if classcell is not None:
0.63 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.63 base.py(93):         contributable_attrs = {}
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.63 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.63 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.63 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.63 base.py(105):         app_label = None
0.63 base.py(108):         app_config = apps.get_containing_app_config(module)
0.63 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.63 base.py(111):             if app_config is None:
0.63 base.py(120):                 app_label = app_config.label
0.63 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.63 options.py(76):         self._get_fields_cache = {}
0.63 options.py(77):         self.local_fields = []
0.63 options.py(78):         self.local_many_to_many = []
0.63 options.py(79):         self.private_fields = []
0.63 options.py(80):         self.local_managers = []
0.63 options.py(81):         self.base_manager_name = None
0.63 options.py(82):         self.default_manager_name = None
0.63 options.py(83):         self.model_name = None
0.63 options.py(84):         self.verbose_name = None
0.63 options.py(85):         self.verbose_name_plural = None
0.63 options.py(86):         self.db_table = ''
0.63 options.py(87):         self.ordering = []
0.63 options.py(88):         self._ordering_clash = False
0.63 options.py(89):         self.indexes = []
0.63 options.py(90):         self.constraints = []
0.63 options.py(91):         self.unique_together = []
0.63 options.py(92):         self.index_together = []
0.63 options.py(93):         self.select_on_save = False
0.63 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.63 options.py(95):         self.permissions = []
0.63 options.py(96):         self.object_name = None
0.63 options.py(97):         self.app_label = app_label
0.63 options.py(98):         self.get_latest_by = None
0.63 options.py(99):         self.order_with_respect_to = None
0.63 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.63 options.py(101):         self.required_db_features = []
0.63 options.py(102):         self.required_db_vendor = None
0.63 options.py(103):         self.meta = meta
0.63 options.py(104):         self.pk = None
0.63 options.py(105):         self.auto_field = None
0.63 options.py(106):         self.abstract = False
0.63 options.py(107):         self.managed = True
0.63 options.py(108):         self.proxy = False
0.63 options.py(114):         self.proxy_for_model = None
0.63 options.py(118):         self.concrete_model = None
0.63 options.py(119):         self.swappable = None
0.63 options.py(120):         self.parents = {}
0.63 options.py(121):         self.auto_created = False
0.63 options.py(125):         self.related_fkey_lookups = []
0.63 options.py(128):         self.apps = self.default_apps
0.63 options.py(130):         self.default_related_name = None
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(150):         from django.db import connection
0.63 options.py(151):         from django.db.backends.utils import truncate_name
0.63 options.py(153):         cls._meta = self
0.63 options.py(154):         self.model = cls
0.63 options.py(156):         self.object_name = cls.__name__
0.63 options.py(157):         self.model_name = self.object_name.lower()
0.63 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.63 options.py(162):         self.original_attrs = {}
0.63 options.py(165):         if self.meta:
0.63 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(47):             return ()
0.63 options.py(182):             self.index_together = normalize_together(self.index_together)
0.63 options.py(45):     try:
0.63 options.py(46):         if not option_together:
0.63 options.py(47):             return ()
0.63 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.63 options.py(192):             if self.verbose_name_plural is None:
0.63 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.63 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.63 options.py(199):             if meta_attrs != {}:
0.63 options.py(203):         del self.meta
0.63 options.py(206):         if not self.db_table:
0.63 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.63 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.63 base.py(123):         if not abstract:
0.63 base.py(151):         is_proxy = new_class._meta.proxy
0.63 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(276):             bisect.insort(self.local_fields, field)
0.63 options.py(277):             self.setup_pk(field)
0.63 options.py(297):         if not self.pk and field.primary_key:
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(294):             self._expire_cache(reverse=False)
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(288):             try:
0.63 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.63 options.py(728):         if forward:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(292):             self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(161):             new_class.add_to_class(obj_name, obj)
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(271):         if private:
0.63 options.py(273):         elif field.is_relation and field.many_to_many:
0.63 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.63 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.63 options.py(288):             try:
0.63 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.63 options.py(728):         if forward:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(734):                 if cache_key in self.__dict__:
0.63 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 options.py(292):             self._expire_cache()
0.63 options.py(728):         if forward:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(730):                 if cache_key in self.__dict__:
0.63 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.63 options.py(732):         if reverse and not self.abstract:
0.63 options.py(736):         self._get_fields_cache = {}
0.63 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.63 base.py(164):         new_fields = chain(
0.63 base.py(165):             new_class._meta.local_fields,
0.63 base.py(166):             new_class._meta.local_many_to_many,
0.63 base.py(167):             new_class._meta.private_fields
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(169):         field_names = {f.name for f in new_fields}
0.63 base.py(172):         if is_proxy:
0.63 base.py(192):             new_class._meta.concrete_model = new_class
0.63 base.py(195):         parent_links = {}
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(199):                 continue
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(198):             if not hasattr(base, '_meta'):
0.63 base.py(201):             if base != new_class and not base._meta.abstract:
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(205):                 if isinstance(field, OneToOneField):
0.63 base.py(204):             for field in base._meta.local_fields:
0.63 base.py(196):         for base in reversed([new_class] + parents):
0.63 base.py(210):         inherited_attributes = set()
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.63 base.py(216):                 inherited_attributes.update(base.__dict__)
0.63 base.py(217):                 continue
0.63 base.py(212):         for base in new_class.mro():
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.63 base.py(312):         if abstract:
0.63 base.py(316):             attr_meta.abstract = False
0.63 base.py(317):             new_class.Meta = attr_meta
0.63 base.py(318):             return new_class
0.63 base.py(75):         super_new = super().__new__
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.63 base.py(80):         if not parents:
0.63 base.py(84):         module = attrs.pop('__module__')
0.63 base.py(85):         new_attrs = {'__module__': module}
0.63 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.63 base.py(87):         if classcell is not None:
0.63 base.py(88):             new_attrs['__classcell__'] = classcell
0.63 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.63 base.py(93):         contributable_attrs = {}
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(96):                 contributable_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(95):             if _has_contribute_to_class(obj):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(98):                 new_attrs[obj_name] = obj
0.63 base.py(94):         for obj_name, obj in list(attrs.items()):
0.63 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.63 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.63 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.63 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.63 base.py(105):         app_label = None
0.63 base.py(108):         app_config = apps.get_containing_app_config(module)
0.63 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.63 base.py(111):             if app_config is None:
0.63 base.py(120):                 app_label = app_config.label
0.63 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.63 options.py(76):         self._get_fields_cache = {}
0.63 options.py(77):         self.local_fields = []
0.63 options.py(78):         self.local_many_to_many = []
0.63 options.py(79):         self.private_fields = []
0.63 options.py(80):         self.local_managers = []
0.63 options.py(81):         self.base_manager_name = None
0.63 options.py(82):         self.default_manager_name = None
0.63 options.py(83):         self.model_name = None
0.63 options.py(84):         self.verbose_name = None
0.63 options.py(85):         self.verbose_name_plural = None
0.63 options.py(86):         self.db_table = ''
0.63 options.py(87):         self.ordering = []
0.63 options.py(88):         self._ordering_clash = False
0.63 options.py(89):         self.indexes = []
0.63 options.py(90):         self.constraints = []
0.63 options.py(91):         self.unique_together = []
0.63 options.py(92):         self.index_together = []
0.63 options.py(93):         self.select_on_save = False
0.63 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.63 options.py(95):         self.permissions = []
0.63 options.py(96):         self.object_name = None
0.63 options.py(97):         self.app_label = app_label
0.63 options.py(98):         self.get_latest_by = None
0.63 options.py(99):         self.order_with_respect_to = None
0.63 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.63 options.py(101):         self.required_db_features = []
0.63 options.py(102):         self.required_db_vendor = None
0.63 options.py(103):         self.meta = meta
0.63 options.py(104):         self.pk = None
0.63 options.py(105):         self.auto_field = None
0.63 options.py(106):         self.abstract = False
0.63 options.py(107):         self.managed = True
0.63 options.py(108):         self.proxy = False
0.63 options.py(114):         self.proxy_for_model = None
0.63 options.py(118):         self.concrete_model = None
0.63 options.py(119):         self.swappable = None
0.63 options.py(120):         self.parents = {}
0.63 options.py(121):         self.auto_created = False
0.63 options.py(125):         self.related_fkey_lookups = []
0.63 options.py(128):         self.apps = self.default_apps
0.63 options.py(130):         self.default_related_name = None
0.63 base.py(325):         if _has_contribute_to_class(value):
0.63 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.63 base.py(326):             value.contribute_to_class(cls, name)
0.63 options.py(150):         from django.db import connection
0.63 options.py(151):         from django.db.backends.utils import truncate_name
0.63 options.py(153):         cls._meta = self
0.63 options.py(154):         self.model = cls
0.63 options.py(156):         self.object_name = cls.__name__
0.63 options.py(157):         self.model_name = self.object_name.lower()
0.63 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.63 options.py(162):         self.original_attrs = {}
0.63 options.py(165):         if self.meta:
0.63 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(171):                 if name.startswith('_'):
0.63 options.py(172):                     del meta_attrs[name]
0.63 options.py(167):             for name in self.meta.__dict__:
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.63 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.63 options.py(173):             for attr_name in DEFAULT_NAMES:
0.63 options.py(174):                 if attr_name in meta_attrs:
0.63 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(182):             self.index_together = normalize_together(self.index_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.64 options.py(192):             if self.verbose_name_plural is None:
0.64 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.64 options.py(199):             if meta_attrs != {}:
0.64 options.py(203):         del self.meta
0.64 options.py(206):         if not self.db_table:
0.64 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.64 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.64 base.py(123):         if not abstract:
0.64 base.py(151):         is_proxy = new_class._meta.proxy
0.64 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(263):         self.local_managers.append(manager)
0.64 options.py(264):         self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(164):         new_fields = chain(
0.64 base.py(165):             new_class._meta.local_fields,
0.64 base.py(166):             new_class._meta.local_many_to_many,
0.64 base.py(167):             new_class._meta.private_fields
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(172):         if is_proxy:
0.64 base.py(192):             new_class._meta.concrete_model = new_class
0.64 base.py(195):         parent_links = {}
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(210):         inherited_attributes = set()
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(219):             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
0.64 base.py(220):             if not base._meta.abstract:
0.64 base.py(270):                 base_parents = base._meta.parents.copy()
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(287):                 new_class._meta.parents.update(base_parents)
0.64 base.py(291):             for field in base._meta.private_fields:
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(219):             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
0.64 base.py(220):             if not base._meta.abstract:
0.64 base.py(270):                 base_parents = base._meta.parents.copy()
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(287):                 new_class._meta.parents.update(base_parents)
0.64 base.py(291):             for field in base._meta.private_fields:
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(312):         if abstract:
0.64 base.py(316):             attr_meta.abstract = False
0.64 base.py(317):             new_class.Meta = attr_meta
0.64 base.py(318):             return new_class
0.64 base.py(75):         super_new = super().__new__
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(80):         if not parents:
0.64 base.py(84):         module = attrs.pop('__module__')
0.64 base.py(85):         new_attrs = {'__module__': module}
0.64 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.64 base.py(87):         if classcell is not None:
0.64 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.64 base.py(93):         contributable_attrs = {}
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(98):                 new_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(98):                 new_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.64 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.64 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.64 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.64 base.py(105):         app_label = None
0.64 base.py(108):         app_config = apps.get_containing_app_config(module)
0.64 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.64 base.py(111):             if app_config is None:
0.64 base.py(120):                 app_label = app_config.label
0.64 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.64 options.py(76):         self._get_fields_cache = {}
0.64 options.py(77):         self.local_fields = []
0.64 options.py(78):         self.local_many_to_many = []
0.64 options.py(79):         self.private_fields = []
0.64 options.py(80):         self.local_managers = []
0.64 options.py(81):         self.base_manager_name = None
0.64 options.py(82):         self.default_manager_name = None
0.64 options.py(83):         self.model_name = None
0.64 options.py(84):         self.verbose_name = None
0.64 options.py(85):         self.verbose_name_plural = None
0.64 options.py(86):         self.db_table = ''
0.64 options.py(87):         self.ordering = []
0.64 options.py(88):         self._ordering_clash = False
0.64 options.py(89):         self.indexes = []
0.64 options.py(90):         self.constraints = []
0.64 options.py(91):         self.unique_together = []
0.64 options.py(92):         self.index_together = []
0.64 options.py(93):         self.select_on_save = False
0.64 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.64 options.py(95):         self.permissions = []
0.64 options.py(96):         self.object_name = None
0.64 options.py(97):         self.app_label = app_label
0.64 options.py(98):         self.get_latest_by = None
0.64 options.py(99):         self.order_with_respect_to = None
0.64 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.64 options.py(101):         self.required_db_features = []
0.64 options.py(102):         self.required_db_vendor = None
0.64 options.py(103):         self.meta = meta
0.64 options.py(104):         self.pk = None
0.64 options.py(105):         self.auto_field = None
0.64 options.py(106):         self.abstract = False
0.64 options.py(107):         self.managed = True
0.64 options.py(108):         self.proxy = False
0.64 options.py(114):         self.proxy_for_model = None
0.64 options.py(118):         self.concrete_model = None
0.64 options.py(119):         self.swappable = None
0.64 options.py(120):         self.parents = {}
0.64 options.py(121):         self.auto_created = False
0.64 options.py(125):         self.related_fkey_lookups = []
0.64 options.py(128):         self.apps = self.default_apps
0.64 options.py(130):         self.default_related_name = None
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(150):         from django.db import connection
0.64 options.py(151):         from django.db.backends.utils import truncate_name
0.64 options.py(153):         cls._meta = self
0.64 options.py(154):         self.model = cls
0.64 options.py(156):         self.object_name = cls.__name__
0.64 options.py(157):         self.model_name = self.object_name.lower()
0.64 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.64 options.py(162):         self.original_attrs = {}
0.64 options.py(165):         if self.meta:
0.64 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.64 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.64 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.64 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(182):             self.index_together = normalize_together(self.index_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(192):             if self.verbose_name_plural is None:
0.64 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.64 options.py(199):             if meta_attrs != {}:
0.64 options.py(203):         del self.meta
0.64 options.py(206):         if not self.db_table:
0.64 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.64 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.64 base.py(123):         if not abstract:
0.64 base.py(124):             new_class.add_to_class(
0.64 base.py(125):                 'DoesNotExist',
0.64 base.py(126):                 subclass_exception(
0.64 base.py(127):                     'DoesNotExist',
0.64 base.py(128):                     tuple(
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(130):                     ) or (ObjectDoesNotExist,),
0.64 base.py(131):                     module,
0.64 base.py(132):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(133):             new_class.add_to_class(
0.64 base.py(134):                 'MultipleObjectsReturned',
0.64 base.py(135):                 subclass_exception(
0.64 base.py(136):                     'MultipleObjectsReturned',
0.64 base.py(137):                     tuple(
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(139):                     ) or (MultipleObjectsReturned,),
0.64 base.py(140):                     module,
0.64 base.py(141):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(142):             if base_meta and not base_meta.abstract:
0.64 base.py(151):         is_proxy = new_class._meta.proxy
0.64 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(164):         new_fields = chain(
0.64 base.py(165):             new_class._meta.local_fields,
0.64 base.py(166):             new_class._meta.local_many_to_many,
0.64 base.py(167):             new_class._meta.private_fields
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(172):         if is_proxy:
0.64 base.py(192):             new_class._meta.concrete_model = new_class
0.64 base.py(195):         parent_links = {}
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(210):         inherited_attributes = set()
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(219):             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
0.64 base.py(220):             if not base._meta.abstract:
0.64 base.py(270):                 base_parents = base._meta.parents.copy()
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(347):         if self.swappable:
0.64 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.64 options.py(349):             if swapped_for:
0.64 options.py(350):                 try:
0.64 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.64 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.64 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.64 options.py(361):         return None
0.64 base.py(75):         super_new = super().__new__
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(80):         if not parents:
0.64 base.py(84):         module = attrs.pop('__module__')
0.64 base.py(85):         new_attrs = {'__module__': module}
0.64 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.64 base.py(87):         if classcell is not None:
0.64 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.64 base.py(93):         contributable_attrs = {}
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(96):                 contributable_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(96):                 contributable_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.64 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.64 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.64 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.64 base.py(105):         app_label = None
0.64 base.py(108):         app_config = apps.get_containing_app_config(module)
0.64 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.64 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.64 options.py(76):         self._get_fields_cache = {}
0.64 options.py(77):         self.local_fields = []
0.64 options.py(78):         self.local_many_to_many = []
0.64 options.py(79):         self.private_fields = []
0.64 options.py(80):         self.local_managers = []
0.64 options.py(81):         self.base_manager_name = None
0.64 options.py(82):         self.default_manager_name = None
0.64 options.py(83):         self.model_name = None
0.64 options.py(84):         self.verbose_name = None
0.64 options.py(85):         self.verbose_name_plural = None
0.64 options.py(86):         self.db_table = ''
0.64 options.py(87):         self.ordering = []
0.64 options.py(88):         self._ordering_clash = False
0.64 options.py(89):         self.indexes = []
0.64 options.py(90):         self.constraints = []
0.64 options.py(91):         self.unique_together = []
0.64 options.py(92):         self.index_together = []
0.64 options.py(93):         self.select_on_save = False
0.64 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.64 options.py(95):         self.permissions = []
0.64 options.py(96):         self.object_name = None
0.64 options.py(97):         self.app_label = app_label
0.64 options.py(98):         self.get_latest_by = None
0.64 options.py(99):         self.order_with_respect_to = None
0.64 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.64 options.py(101):         self.required_db_features = []
0.64 options.py(102):         self.required_db_vendor = None
0.64 options.py(103):         self.meta = meta
0.64 options.py(104):         self.pk = None
0.64 options.py(105):         self.auto_field = None
0.64 options.py(106):         self.abstract = False
0.64 options.py(107):         self.managed = True
0.64 options.py(108):         self.proxy = False
0.64 options.py(114):         self.proxy_for_model = None
0.64 options.py(118):         self.concrete_model = None
0.64 options.py(119):         self.swappable = None
0.64 options.py(120):         self.parents = {}
0.64 options.py(121):         self.auto_created = False
0.64 options.py(125):         self.related_fkey_lookups = []
0.64 options.py(128):         self.apps = self.default_apps
0.64 options.py(130):         self.default_related_name = None
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(150):         from django.db import connection
0.64 options.py(151):         from django.db.backends.utils import truncate_name
0.64 options.py(153):         cls._meta = self
0.64 options.py(154):         self.model = cls
0.64 options.py(156):         self.object_name = cls.__name__
0.64 options.py(157):         self.model_name = self.object_name.lower()
0.64 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.64 options.py(162):         self.original_attrs = {}
0.64 options.py(165):         if self.meta:
0.64 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.64 options.py(50):         first_element = option_together[0]
0.64 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.64 options.py(52):             option_together = (option_together,)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(182):             self.index_together = normalize_together(self.index_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(192):             if self.verbose_name_plural is None:
0.64 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.64 options.py(199):             if meta_attrs != {}:
0.64 options.py(203):         del self.meta
0.64 options.py(206):         if not self.db_table:
0.64 base.py(123):         if not abstract:
0.64 base.py(124):             new_class.add_to_class(
0.64 base.py(125):                 'DoesNotExist',
0.64 base.py(126):                 subclass_exception(
0.64 base.py(127):                     'DoesNotExist',
0.64 base.py(128):                     tuple(
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(130):                     ) or (ObjectDoesNotExist,),
0.64 base.py(131):                     module,
0.64 base.py(132):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(133):             new_class.add_to_class(
0.64 base.py(134):                 'MultipleObjectsReturned',
0.64 base.py(135):                 subclass_exception(
0.64 base.py(136):                     'MultipleObjectsReturned',
0.64 base.py(137):                     tuple(
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(139):                     ) or (MultipleObjectsReturned,),
0.64 base.py(140):                     module,
0.64 base.py(141):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(142):             if base_meta and not base_meta.abstract:
0.64 base.py(151):         is_proxy = new_class._meta.proxy
0.64 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(164):         new_fields = chain(
0.64 base.py(165):             new_class._meta.local_fields,
0.64 base.py(166):             new_class._meta.local_many_to_many,
0.64 base.py(167):             new_class._meta.private_fields
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(172):         if is_proxy:
0.64 base.py(192):             new_class._meta.concrete_model = new_class
0.64 base.py(195):         parent_links = {}
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(199):                 continue
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(210):         inherited_attributes = set()
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(312):         if abstract:
0.64 base.py(320):         new_class._prepare()
0.64 base.py(332):         opts = cls._meta
0.64 base.py(333):         opts._prepare(cls)
0.64 options.py(223):         if self.order_with_respect_to:
0.64 options.py(239):             self.order_with_respect_to = None
0.64 options.py(241):         if self.pk is None:
0.64 options.py(242):             if self.parents:
0.64 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.64 options.py(260):                 model.add_to_class('id', auto)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(298):             self.pk = field
0.64 options.py(299):             field.serialize = False
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(294):             self._expire_cache(reverse=False)
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(335):         if opts.order_with_respect_to:
0.64 base.py(350):         if cls.__doc__ is None:
0.64 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.64 options.py(456):         def is_not_an_m2m_field(f):
0.64 options.py(459):         def is_not_a_generic_relation(f):
0.64 options.py(462):         def is_not_a_generic_foreign_key(f):
0.64 options.py(467):         return make_immutable_fields_list(
0.64 options.py(468):             "fields",
0.64 options.py(469):             (f for f in self._get_fields(reverse=False)
0.64 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.64 options.py(773):         topmost_call = seen_models is None
0.64 options.py(774):         if topmost_call:
0.64 options.py(775):             seen_models = set()
0.64 options.py(776):         seen_models.add(self.model)
0.64 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.64 options.py(781):         try:
0.64 options.py(784):             return self._get_fields_cache[cache_key]
0.64 options.py(785):         except KeyError:
0.64 options.py(786):             pass
0.64 options.py(788):         fields = []
0.64 options.py(791):         if include_parents is not False:
0.64 options.py(792):             for parent in self.parents:
0.64 options.py(806):         if reverse and not self.proxy:
0.64 options.py(817):         if forward:
0.64 options.py(818):             fields += self.local_fields
0.64 options.py(819):             fields += self.local_many_to_many
0.64 options.py(825):             if topmost_call:
0.64 options.py(826):                 fields += self.private_fields
0.64 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.64 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.64 options.py(833):         self._get_fields_cache[cache_key] = fields
0.64 options.py(834):         return fields
0.64 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.64 options.py(469):             (f for f in self._get_fields(reverse=False)
0.64 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.64 options.py(457):             return not (f.is_relation and f.many_to_many)
0.64 options.py(460):             return not (f.is_relation and f.one_to_many)
0.64 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.64 options.py(469):             (f for f in self._get_fields(reverse=False)
0.64 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.64 options.py(457):             return not (f.is_relation and f.many_to_many)
0.64 options.py(460):             return not (f.is_relation and f.one_to_many)
0.64 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.64 options.py(469):             (f for f in self._get_fields(reverse=False)
0.64 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.64 options.py(457):             return not (f.is_relation and f.many_to_many)
0.64 options.py(460):             return not (f.is_relation and f.one_to_many)
0.64 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.64 options.py(469):             (f for f in self._get_fields(reverse=False)
0.64 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.64 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.64 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.64 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.64 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.64 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.64 base.py(354):         if get_absolute_url_override:
0.64 base.py(357):         if not opts.managers:
0.64 options.py(365):         managers = []
0.64 options.py(366):         seen_managers = set()
0.64 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.64 options.py(368):         for depth, base in enumerate(bases):
0.64 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.64 options.py(369):             for manager in base._meta.local_managers:
0.64 options.py(368):         for depth, base in enumerate(bases):
0.64 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.64 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.64 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.64 options.py(378):         return make_immutable_fields_list(
0.64 options.py(379):             "managers",
0.64 options.py(380):             (m[2] for m in sorted(managers)),
0.64 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.64 options.py(380):             (m[2] for m in sorted(managers)),
0.64 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.64 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.64 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.64 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.64 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.64 base.py(363):             manager = Manager()
0.64 base.py(364):             manager.auto_created = True
0.64 base.py(365):             cls.add_to_class('objects', manager)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(263):         self.local_managers.append(manager)
0.64 options.py(264):         self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(731):                     delattr(self, cache_key)
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(731):                     delattr(self, cache_key)
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(370):         for index in cls._meta.indexes:
0.64 base.py(374):         class_prepared.send(sender=cls)
0.64 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.64 base.py(322):         return new_class
0.64 base.py(281):                         if field.one_to_one:
0.64 base.py(273):                 for field in parent_fields:
0.64 base.py(274):                     if (field.name not in field_names and
0.64 base.py(275):                             field.name not in new_class.__dict__ and
0.64 base.py(276):                             field.name not in inherited_attributes):
0.64 base.py(277):                         new_field = copy.deepcopy(field)
0.64 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(347):         if self.swappable:
0.64 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.64 options.py(349):             if swapped_for:
0.64 options.py(350):                 try:
0.64 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.64 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.64 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.64 options.py(361):         return None
0.64 base.py(75):         super_new = super().__new__
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.64 base.py(80):         if not parents:
0.64 base.py(84):         module = attrs.pop('__module__')
0.64 base.py(85):         new_attrs = {'__module__': module}
0.64 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.64 base.py(87):         if classcell is not None:
0.64 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.64 base.py(93):         contributable_attrs = {}
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(96):                 contributable_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(95):             if _has_contribute_to_class(obj):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(96):                 contributable_attrs[obj_name] = obj
0.64 base.py(94):         for obj_name, obj in list(attrs.items()):
0.64 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.64 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.64 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.64 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.64 base.py(105):         app_label = None
0.64 base.py(108):         app_config = apps.get_containing_app_config(module)
0.64 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.64 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.64 options.py(76):         self._get_fields_cache = {}
0.64 options.py(77):         self.local_fields = []
0.64 options.py(78):         self.local_many_to_many = []
0.64 options.py(79):         self.private_fields = []
0.64 options.py(80):         self.local_managers = []
0.64 options.py(81):         self.base_manager_name = None
0.64 options.py(82):         self.default_manager_name = None
0.64 options.py(83):         self.model_name = None
0.64 options.py(84):         self.verbose_name = None
0.64 options.py(85):         self.verbose_name_plural = None
0.64 options.py(86):         self.db_table = ''
0.64 options.py(87):         self.ordering = []
0.64 options.py(88):         self._ordering_clash = False
0.64 options.py(89):         self.indexes = []
0.64 options.py(90):         self.constraints = []
0.64 options.py(91):         self.unique_together = []
0.64 options.py(92):         self.index_together = []
0.64 options.py(93):         self.select_on_save = False
0.64 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.64 options.py(95):         self.permissions = []
0.64 options.py(96):         self.object_name = None
0.64 options.py(97):         self.app_label = app_label
0.64 options.py(98):         self.get_latest_by = None
0.64 options.py(99):         self.order_with_respect_to = None
0.64 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.64 options.py(101):         self.required_db_features = []
0.64 options.py(102):         self.required_db_vendor = None
0.64 options.py(103):         self.meta = meta
0.64 options.py(104):         self.pk = None
0.64 options.py(105):         self.auto_field = None
0.64 options.py(106):         self.abstract = False
0.64 options.py(107):         self.managed = True
0.64 options.py(108):         self.proxy = False
0.64 options.py(114):         self.proxy_for_model = None
0.64 options.py(118):         self.concrete_model = None
0.64 options.py(119):         self.swappable = None
0.64 options.py(120):         self.parents = {}
0.64 options.py(121):         self.auto_created = False
0.64 options.py(125):         self.related_fkey_lookups = []
0.64 options.py(128):         self.apps = self.default_apps
0.64 options.py(130):         self.default_related_name = None
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(150):         from django.db import connection
0.64 options.py(151):         from django.db.backends.utils import truncate_name
0.64 options.py(153):         cls._meta = self
0.64 options.py(154):         self.model = cls
0.64 options.py(156):         self.object_name = cls.__name__
0.64 options.py(157):         self.model_name = self.object_name.lower()
0.64 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.64 options.py(162):         self.original_attrs = {}
0.64 options.py(165):         if self.meta:
0.64 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(171):                 if name.startswith('_'):
0.64 options.py(172):                     del meta_attrs[name]
0.64 options.py(167):             for name in self.meta.__dict__:
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.64 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(174):                 if attr_name in meta_attrs:
0.64 options.py(177):                 elif hasattr(self.meta, attr_name):
0.64 options.py(173):             for attr_name in DEFAULT_NAMES:
0.64 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.64 options.py(50):         first_element = option_together[0]
0.64 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.64 options.py(52):             option_together = (option_together,)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.64 options.py(182):             self.index_together = normalize_together(self.index_together)
0.64 options.py(45):     try:
0.64 options.py(46):         if not option_together:
0.64 options.py(47):             return ()
0.64 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(187):                     objs = getattr(self, attr_name, [])
0.64 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.64 options.py(212):         new_objs = []
0.64 options.py(213):         for obj in objs:
0.64 options.py(220):         return new_objs
0.64 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.64 options.py(192):             if self.verbose_name_plural is None:
0.64 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.64 options.py(199):             if meta_attrs != {}:
0.64 options.py(203):         del self.meta
0.64 options.py(206):         if not self.db_table:
0.64 base.py(123):         if not abstract:
0.64 base.py(124):             new_class.add_to_class(
0.64 base.py(125):                 'DoesNotExist',
0.64 base.py(126):                 subclass_exception(
0.64 base.py(127):                     'DoesNotExist',
0.64 base.py(128):                     tuple(
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(130):                     ) or (ObjectDoesNotExist,),
0.64 base.py(131):                     module,
0.64 base.py(132):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(133):             new_class.add_to_class(
0.64 base.py(134):                 'MultipleObjectsReturned',
0.64 base.py(135):                 subclass_exception(
0.64 base.py(136):                     'MultipleObjectsReturned',
0.64 base.py(137):                     tuple(
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.64 base.py(139):                     ) or (MultipleObjectsReturned,),
0.64 base.py(140):                     module,
0.64 base.py(141):                     attached_to=new_class))
0.64 base.py(61):     return type(name, bases, {
0.64 base.py(62):         '__module__': module,
0.64 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(328):             setattr(cls, name, value)
0.64 base.py(142):             if base_meta and not base_meta.abstract:
0.64 base.py(151):         is_proxy = new_class._meta.proxy
0.64 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(161):             new_class.add_to_class(obj_name, obj)
0.64 base.py(325):         if _has_contribute_to_class(value):
0.64 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.64 base.py(326):             value.contribute_to_class(cls, name)
0.64 options.py(271):         if private:
0.64 options.py(273):         elif field.is_relation and field.many_to_many:
0.64 options.py(276):             bisect.insort(self.local_fields, field)
0.64 options.py(277):             self.setup_pk(field)
0.64 options.py(297):         if not self.pk and field.primary_key:
0.64 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.64 options.py(288):             try:
0.64 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.64 options.py(728):         if forward:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 options.py(292):             self._expire_cache()
0.64 options.py(728):         if forward:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(730):                 if cache_key in self.__dict__:
0.64 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.64 options.py(732):         if reverse and not self.abstract:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(734):                 if cache_key in self.__dict__:
0.64 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.64 options.py(736):         self._get_fields_cache = {}
0.64 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.64 base.py(164):         new_fields = chain(
0.64 base.py(165):             new_class._meta.local_fields,
0.64 base.py(166):             new_class._meta.local_many_to_many,
0.64 base.py(167):             new_class._meta.private_fields
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(169):         field_names = {f.name for f in new_fields}
0.64 base.py(172):         if is_proxy:
0.64 base.py(192):             new_class._meta.concrete_model = new_class
0.64 base.py(195):         parent_links = {}
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(199):                 continue
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(198):             if not hasattr(base, '_meta'):
0.64 base.py(201):             if base != new_class and not base._meta.abstract:
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(205):                 if isinstance(field, OneToOneField):
0.64 base.py(204):             for field in base._meta.local_fields:
0.64 base.py(196):         for base in reversed([new_class] + parents):
0.64 base.py(210):         inherited_attributes = set()
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.64 base.py(216):                 inherited_attributes.update(base.__dict__)
0.64 base.py(217):                 continue
0.64 base.py(212):         for base in new_class.mro():
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.64 base.py(312):         if abstract:
0.64 base.py(320):         new_class._prepare()
0.64 base.py(332):         opts = cls._meta
0.64 base.py(333):         opts._prepare(cls)
0.64 options.py(223):         if self.order_with_respect_to:
0.64 options.py(239):             self.order_with_respect_to = None
0.64 options.py(241):         if self.pk is None:
0.64 options.py(242):             if self.parents:
0.64 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.65 options.py(260):                 model.add_to_class('id', auto)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(298):             self.pk = field
0.65 options.py(299):             field.serialize = False
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(335):         if opts.order_with_respect_to:
0.65 base.py(350):         if cls.__doc__ is None:
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 options.py(456):         def is_not_an_m2m_field(f):
0.65 options.py(459):         def is_not_a_generic_relation(f):
0.65 options.py(462):         def is_not_a_generic_foreign_key(f):
0.65 options.py(467):         return make_immutable_fields_list(
0.65 options.py(468):             "fields",
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.65 options.py(773):         topmost_call = seen_models is None
0.65 options.py(774):         if topmost_call:
0.65 options.py(775):             seen_models = set()
0.65 options.py(776):         seen_models.add(self.model)
0.65 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.65 options.py(781):         try:
0.65 options.py(784):             return self._get_fields_cache[cache_key]
0.65 options.py(785):         except KeyError:
0.65 options.py(786):             pass
0.65 options.py(788):         fields = []
0.65 options.py(791):         if include_parents is not False:
0.65 options.py(792):             for parent in self.parents:
0.65 options.py(806):         if reverse and not self.proxy:
0.65 options.py(817):         if forward:
0.65 options.py(818):             fields += self.local_fields
0.65 options.py(819):             fields += self.local_many_to_many
0.65 options.py(825):             if topmost_call:
0.65 options.py(826):                 fields += self.private_fields
0.65 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(833):         self._get_fields_cache[cache_key] = fields
0.65 options.py(834):         return fields
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 base.py(354):         if get_absolute_url_override:
0.65 base.py(357):         if not opts.managers:
0.65 options.py(365):         managers = []
0.65 options.py(366):         seen_managers = set()
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(378):         return make_immutable_fields_list(
0.65 options.py(379):             "managers",
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.65 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.65 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.65 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.65 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.65 base.py(363):             manager = Manager()
0.65 base.py(364):             manager.auto_created = True
0.65 base.py(365):             cls.add_to_class('objects', manager)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(263):         self.local_managers.append(manager)
0.65 options.py(264):         self._expire_cache()
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(731):                     delattr(self, cache_key)
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(731):                     delattr(self, cache_key)
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(370):         for index in cls._meta.indexes:
0.65 base.py(374):         class_prepared.send(sender=cls)
0.65 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.65 base.py(322):         return new_class
0.65 base.py(281):                         if field.one_to_one:
0.65 base.py(273):                 for field in parent_fields:
0.65 base.py(287):                 new_class._meta.parents.update(base_parents)
0.65 base.py(291):             for field in base._meta.private_fields:
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(312):         if abstract:
0.65 base.py(320):         new_class._prepare()
0.65 base.py(332):         opts = cls._meta
0.65 base.py(333):         opts._prepare(cls)
0.65 options.py(223):         if self.order_with_respect_to:
0.65 options.py(239):             self.order_with_respect_to = None
0.65 options.py(241):         if self.pk is None:
0.65 options.py(242):             if self.parents:
0.65 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.65 options.py(260):                 model.add_to_class('id', auto)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(298):             self.pk = field
0.65 options.py(299):             field.serialize = False
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(335):         if opts.order_with_respect_to:
0.65 base.py(350):         if cls.__doc__ is None:
0.65 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 base.py(354):         if get_absolute_url_override:
0.65 base.py(357):         if not opts.managers:
0.65 options.py(365):         managers = []
0.65 options.py(366):         seen_managers = set()
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(370):                 if manager.name in seen_managers:
0.65 options.py(373):                 manager = copy.copy(manager)
0.65 options.py(374):                 manager.model = self.model
0.65 options.py(375):                 seen_managers.add(manager.name)
0.65 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(378):         return make_immutable_fields_list(
0.65 options.py(379):             "managers",
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 base.py(370):         for index in cls._meta.indexes:
0.65 base.py(374):         class_prepared.send(sender=cls)
0.65 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.65 options.py(347):         if self.swappable:
0.65 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.65 options.py(349):             if swapped_for:
0.65 options.py(350):                 try:
0.65 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.65 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 options.py(361):         return None
0.65 options.py(347):         if self.swappable:
0.65 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.65 options.py(349):             if swapped_for:
0.65 options.py(350):                 try:
0.65 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.65 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 options.py(361):         return None
0.65 base.py(322):         return new_class
0.65 base.py(75):         super_new = super().__new__
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(80):         if not parents:
0.65 base.py(84):         module = attrs.pop('__module__')
0.65 base.py(85):         new_attrs = {'__module__': module}
0.65 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.65 base.py(87):         if classcell is not None:
0.65 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.65 base.py(93):         contributable_attrs = {}
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.65 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.65 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.65 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.65 base.py(105):         app_label = None
0.65 base.py(108):         app_config = apps.get_containing_app_config(module)
0.65 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.65 base.py(111):             if app_config is None:
0.65 base.py(120):                 app_label = app_config.label
0.65 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.65 options.py(76):         self._get_fields_cache = {}
0.65 options.py(77):         self.local_fields = []
0.65 options.py(78):         self.local_many_to_many = []
0.65 options.py(79):         self.private_fields = []
0.65 options.py(80):         self.local_managers = []
0.65 options.py(81):         self.base_manager_name = None
0.65 options.py(82):         self.default_manager_name = None
0.65 options.py(83):         self.model_name = None
0.65 options.py(84):         self.verbose_name = None
0.65 options.py(85):         self.verbose_name_plural = None
0.65 options.py(86):         self.db_table = ''
0.65 options.py(87):         self.ordering = []
0.65 options.py(88):         self._ordering_clash = False
0.65 options.py(89):         self.indexes = []
0.65 options.py(90):         self.constraints = []
0.65 options.py(91):         self.unique_together = []
0.65 options.py(92):         self.index_together = []
0.65 options.py(93):         self.select_on_save = False
0.65 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.65 options.py(95):         self.permissions = []
0.65 options.py(96):         self.object_name = None
0.65 options.py(97):         self.app_label = app_label
0.65 options.py(98):         self.get_latest_by = None
0.65 options.py(99):         self.order_with_respect_to = None
0.65 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.65 options.py(101):         self.required_db_features = []
0.65 options.py(102):         self.required_db_vendor = None
0.65 options.py(103):         self.meta = meta
0.65 options.py(104):         self.pk = None
0.65 options.py(105):         self.auto_field = None
0.65 options.py(106):         self.abstract = False
0.65 options.py(107):         self.managed = True
0.65 options.py(108):         self.proxy = False
0.65 options.py(114):         self.proxy_for_model = None
0.65 options.py(118):         self.concrete_model = None
0.65 options.py(119):         self.swappable = None
0.65 options.py(120):         self.parents = {}
0.65 options.py(121):         self.auto_created = False
0.65 options.py(125):         self.related_fkey_lookups = []
0.65 options.py(128):         self.apps = self.default_apps
0.65 options.py(130):         self.default_related_name = None
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(150):         from django.db import connection
0.65 options.py(151):         from django.db.backends.utils import truncate_name
0.65 options.py(153):         cls._meta = self
0.65 options.py(154):         self.model = cls
0.65 options.py(156):         self.object_name = cls.__name__
0.65 options.py(157):         self.model_name = self.object_name.lower()
0.65 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.65 options.py(162):         self.original_attrs = {}
0.65 options.py(165):         if self.meta:
0.65 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(182):             self.index_together = normalize_together(self.index_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(187):                     objs = getattr(self, attr_name, [])
0.65 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.65 options.py(212):         new_objs = []
0.65 options.py(213):         for obj in objs:
0.65 options.py(220):         return new_objs
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(187):                     objs = getattr(self, attr_name, [])
0.65 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.65 options.py(212):         new_objs = []
0.65 options.py(213):         for obj in objs:
0.65 options.py(220):         return new_objs
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(192):             if self.verbose_name_plural is None:
0.65 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.65 options.py(199):             if meta_attrs != {}:
0.65 options.py(203):         del self.meta
0.65 options.py(206):         if not self.db_table:
0.65 base.py(123):         if not abstract:
0.65 base.py(124):             new_class.add_to_class(
0.65 base.py(125):                 'DoesNotExist',
0.65 base.py(126):                 subclass_exception(
0.65 base.py(127):                     'DoesNotExist',
0.65 base.py(128):                     tuple(
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(130):                     ) or (ObjectDoesNotExist,),
0.65 base.py(131):                     module,
0.65 base.py(132):                     attached_to=new_class))
0.65 base.py(61):     return type(name, bases, {
0.65 base.py(62):         '__module__': module,
0.65 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(328):             setattr(cls, name, value)
0.65 base.py(133):             new_class.add_to_class(
0.65 base.py(134):                 'MultipleObjectsReturned',
0.65 base.py(135):                 subclass_exception(
0.65 base.py(136):                     'MultipleObjectsReturned',
0.65 base.py(137):                     tuple(
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(139):                     ) or (MultipleObjectsReturned,),
0.65 base.py(140):                     module,
0.65 base.py(141):                     attached_to=new_class))
0.65 base.py(61):     return type(name, bases, {
0.65 base.py(62):         '__module__': module,
0.65 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(328):             setattr(cls, name, value)
0.65 base.py(142):             if base_meta and not base_meta.abstract:
0.65 base.py(151):         is_proxy = new_class._meta.proxy
0.65 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(263):         self.local_managers.append(manager)
0.65 options.py(264):         self._expire_cache()
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(164):         new_fields = chain(
0.65 base.py(165):             new_class._meta.local_fields,
0.65 base.py(166):             new_class._meta.local_many_to_many,
0.65 base.py(167):             new_class._meta.private_fields
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(172):         if is_proxy:
0.65 base.py(192):             new_class._meta.concrete_model = new_class
0.65 base.py(195):         parent_links = {}
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(199):                 continue
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(201):             if base != new_class and not base._meta.abstract:
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(210):         inherited_attributes = set()
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(312):         if abstract:
0.65 base.py(320):         new_class._prepare()
0.65 base.py(332):         opts = cls._meta
0.65 base.py(333):         opts._prepare(cls)
0.65 options.py(223):         if self.order_with_respect_to:
0.65 options.py(239):             self.order_with_respect_to = None
0.65 options.py(241):         if self.pk is None:
0.65 options.py(242):             if self.parents:
0.65 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.65 options.py(260):                 model.add_to_class('id', auto)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(298):             self.pk = field
0.65 options.py(299):             field.serialize = False
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(335):         if opts.order_with_respect_to:
0.65 base.py(350):         if cls.__doc__ is None:
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 options.py(456):         def is_not_an_m2m_field(f):
0.65 options.py(459):         def is_not_a_generic_relation(f):
0.65 options.py(462):         def is_not_a_generic_foreign_key(f):
0.65 options.py(467):         return make_immutable_fields_list(
0.65 options.py(468):             "fields",
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.65 options.py(773):         topmost_call = seen_models is None
0.65 options.py(774):         if topmost_call:
0.65 options.py(775):             seen_models = set()
0.65 options.py(776):         seen_models.add(self.model)
0.65 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.65 options.py(781):         try:
0.65 options.py(784):             return self._get_fields_cache[cache_key]
0.65 options.py(785):         except KeyError:
0.65 options.py(786):             pass
0.65 options.py(788):         fields = []
0.65 options.py(791):         if include_parents is not False:
0.65 options.py(792):             for parent in self.parents:
0.65 options.py(806):         if reverse and not self.proxy:
0.65 options.py(817):         if forward:
0.65 options.py(818):             fields += self.local_fields
0.65 options.py(819):             fields += self.local_many_to_many
0.65 options.py(825):             if topmost_call:
0.65 options.py(826):                 fields += self.private_fields
0.65 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(833):         self._get_fields_cache[cache_key] = fields
0.65 options.py(834):         return fields
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.65 options.py(457):             return not (f.is_relation and f.many_to_many)
0.65 options.py(460):             return not (f.is_relation and f.one_to_many)
0.65 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.65 options.py(469):             (f for f in self._get_fields(reverse=False)
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.65 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 base.py(354):         if get_absolute_url_override:
0.65 base.py(357):         if not opts.managers:
0.65 options.py(365):         managers = []
0.65 options.py(366):         seen_managers = set()
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(370):                 if manager.name in seen_managers:
0.65 options.py(373):                 manager = copy.copy(manager)
0.65 options.py(374):                 manager.model = self.model
0.65 options.py(375):                 seen_managers.add(manager.name)
0.65 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(378):         return make_immutable_fields_list(
0.65 options.py(379):             "managers",
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 base.py(370):         for index in cls._meta.indexes:
0.65 base.py(374):         class_prepared.send(sender=cls)
0.65 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.65 base.py(322):         return new_class
0.65 base.py(75):         super_new = super().__new__
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(80):         if not parents:
0.65 base.py(84):         module = attrs.pop('__module__')
0.65 base.py(85):         new_attrs = {'__module__': module}
0.65 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.65 base.py(87):         if classcell is not None:
0.65 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.65 base.py(93):         contributable_attrs = {}
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.65 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.65 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.65 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.65 base.py(105):         app_label = None
0.65 base.py(108):         app_config = apps.get_containing_app_config(module)
0.65 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.65 base.py(111):             if app_config is None:
0.65 base.py(120):                 app_label = app_config.label
0.65 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.65 options.py(76):         self._get_fields_cache = {}
0.65 options.py(77):         self.local_fields = []
0.65 options.py(78):         self.local_many_to_many = []
0.65 options.py(79):         self.private_fields = []
0.65 options.py(80):         self.local_managers = []
0.65 options.py(81):         self.base_manager_name = None
0.65 options.py(82):         self.default_manager_name = None
0.65 options.py(83):         self.model_name = None
0.65 options.py(84):         self.verbose_name = None
0.65 options.py(85):         self.verbose_name_plural = None
0.65 options.py(86):         self.db_table = ''
0.65 options.py(87):         self.ordering = []
0.65 options.py(88):         self._ordering_clash = False
0.65 options.py(89):         self.indexes = []
0.65 options.py(90):         self.constraints = []
0.65 options.py(91):         self.unique_together = []
0.65 options.py(92):         self.index_together = []
0.65 options.py(93):         self.select_on_save = False
0.65 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.65 options.py(95):         self.permissions = []
0.65 options.py(96):         self.object_name = None
0.65 options.py(97):         self.app_label = app_label
0.65 options.py(98):         self.get_latest_by = None
0.65 options.py(99):         self.order_with_respect_to = None
0.65 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.65 options.py(101):         self.required_db_features = []
0.65 options.py(102):         self.required_db_vendor = None
0.65 options.py(103):         self.meta = meta
0.65 options.py(104):         self.pk = None
0.65 options.py(105):         self.auto_field = None
0.65 options.py(106):         self.abstract = False
0.65 options.py(107):         self.managed = True
0.65 options.py(108):         self.proxy = False
0.65 options.py(114):         self.proxy_for_model = None
0.65 options.py(118):         self.concrete_model = None
0.65 options.py(119):         self.swappable = None
0.65 options.py(120):         self.parents = {}
0.65 options.py(121):         self.auto_created = False
0.65 options.py(125):         self.related_fkey_lookups = []
0.65 options.py(128):         self.apps = self.default_apps
0.65 options.py(130):         self.default_related_name = None
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(150):         from django.db import connection
0.65 options.py(151):         from django.db.backends.utils import truncate_name
0.65 options.py(153):         cls._meta = self
0.65 options.py(154):         self.model = cls
0.65 options.py(156):         self.object_name = cls.__name__
0.65 options.py(157):         self.model_name = self.object_name.lower()
0.65 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.65 options.py(162):         self.original_attrs = {}
0.65 options.py(165):         if self.meta:
0.65 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(182):             self.index_together = normalize_together(self.index_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.65 options.py(192):             if self.verbose_name_plural is None:
0.65 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.65 options.py(199):             if meta_attrs != {}:
0.65 options.py(203):         del self.meta
0.65 options.py(206):         if not self.db_table:
0.65 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.65 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.65 base.py(123):         if not abstract:
0.65 base.py(151):         is_proxy = new_class._meta.proxy
0.65 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(298):             self.pk = field
0.65 options.py(299):             field.serialize = False
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(263):         self.local_managers.append(manager)
0.65 options.py(264):         self._expire_cache()
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(164):         new_fields = chain(
0.65 base.py(165):             new_class._meta.local_fields,
0.65 base.py(166):             new_class._meta.local_many_to_many,
0.65 base.py(167):             new_class._meta.private_fields
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(172):         if is_proxy:
0.65 base.py(192):             new_class._meta.concrete_model = new_class
0.65 base.py(195):         parent_links = {}
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(199):                 continue
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(201):             if base != new_class and not base._meta.abstract:
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(210):         inherited_attributes = set()
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(312):         if abstract:
0.65 base.py(316):             attr_meta.abstract = False
0.65 base.py(317):             new_class.Meta = attr_meta
0.65 base.py(318):             return new_class
0.65 base.py(75):         super_new = super().__new__
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.65 base.py(80):         if not parents:
0.65 base.py(84):         module = attrs.pop('__module__')
0.65 base.py(85):         new_attrs = {'__module__': module}
0.65 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.65 base.py(87):         if classcell is not None:
0.65 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.65 base.py(93):         contributable_attrs = {}
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(96):                 contributable_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(95):             if _has_contribute_to_class(obj):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(98):                 new_attrs[obj_name] = obj
0.65 base.py(94):         for obj_name, obj in list(attrs.items()):
0.65 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.65 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.65 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.65 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.65 base.py(105):         app_label = None
0.65 base.py(108):         app_config = apps.get_containing_app_config(module)
0.65 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.65 base.py(111):             if app_config is None:
0.65 base.py(120):                 app_label = app_config.label
0.65 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.65 options.py(76):         self._get_fields_cache = {}
0.65 options.py(77):         self.local_fields = []
0.65 options.py(78):         self.local_many_to_many = []
0.65 options.py(79):         self.private_fields = []
0.65 options.py(80):         self.local_managers = []
0.65 options.py(81):         self.base_manager_name = None
0.65 options.py(82):         self.default_manager_name = None
0.65 options.py(83):         self.model_name = None
0.65 options.py(84):         self.verbose_name = None
0.65 options.py(85):         self.verbose_name_plural = None
0.65 options.py(86):         self.db_table = ''
0.65 options.py(87):         self.ordering = []
0.65 options.py(88):         self._ordering_clash = False
0.65 options.py(89):         self.indexes = []
0.65 options.py(90):         self.constraints = []
0.65 options.py(91):         self.unique_together = []
0.65 options.py(92):         self.index_together = []
0.65 options.py(93):         self.select_on_save = False
0.65 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.65 options.py(95):         self.permissions = []
0.65 options.py(96):         self.object_name = None
0.65 options.py(97):         self.app_label = app_label
0.65 options.py(98):         self.get_latest_by = None
0.65 options.py(99):         self.order_with_respect_to = None
0.65 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.65 options.py(101):         self.required_db_features = []
0.65 options.py(102):         self.required_db_vendor = None
0.65 options.py(103):         self.meta = meta
0.65 options.py(104):         self.pk = None
0.65 options.py(105):         self.auto_field = None
0.65 options.py(106):         self.abstract = False
0.65 options.py(107):         self.managed = True
0.65 options.py(108):         self.proxy = False
0.65 options.py(114):         self.proxy_for_model = None
0.65 options.py(118):         self.concrete_model = None
0.65 options.py(119):         self.swappable = None
0.65 options.py(120):         self.parents = {}
0.65 options.py(121):         self.auto_created = False
0.65 options.py(125):         self.related_fkey_lookups = []
0.65 options.py(128):         self.apps = self.default_apps
0.65 options.py(130):         self.default_related_name = None
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(150):         from django.db import connection
0.65 options.py(151):         from django.db.backends.utils import truncate_name
0.65 options.py(153):         cls._meta = self
0.65 options.py(154):         self.model = cls
0.65 options.py(156):         self.object_name = cls.__name__
0.65 options.py(157):         self.model_name = self.object_name.lower()
0.65 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.65 options.py(162):         self.original_attrs = {}
0.65 options.py(165):         if self.meta:
0.65 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(171):                 if name.startswith('_'):
0.65 options.py(172):                     del meta_attrs[name]
0.65 options.py(167):             for name in self.meta.__dict__:
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.65 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.65 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.65 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(178):                     setattr(self, attr_name, getattr(self.meta, attr_name))
0.65 options.py(179):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(174):                 if attr_name in meta_attrs:
0.65 options.py(177):                 elif hasattr(self.meta, attr_name):
0.65 options.py(173):             for attr_name in DEFAULT_NAMES:
0.65 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(182):             self.index_together = normalize_together(self.index_together)
0.65 options.py(45):     try:
0.65 options.py(46):         if not option_together:
0.65 options.py(47):             return ()
0.65 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(187):                     objs = getattr(self, attr_name, [])
0.65 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.65 options.py(212):         new_objs = []
0.65 options.py(213):         for obj in objs:
0.65 options.py(220):         return new_objs
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(187):                     objs = getattr(self, attr_name, [])
0.65 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.65 options.py(212):         new_objs = []
0.65 options.py(213):         for obj in objs:
0.65 options.py(220):         return new_objs
0.65 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.65 options.py(192):             if self.verbose_name_plural is None:
0.65 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.65 options.py(199):             if meta_attrs != {}:
0.65 options.py(203):         del self.meta
0.65 options.py(206):         if not self.db_table:
0.65 base.py(123):         if not abstract:
0.65 base.py(124):             new_class.add_to_class(
0.65 base.py(125):                 'DoesNotExist',
0.65 base.py(126):                 subclass_exception(
0.65 base.py(127):                     'DoesNotExist',
0.65 base.py(128):                     tuple(
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(130):                     ) or (ObjectDoesNotExist,),
0.65 base.py(131):                     module,
0.65 base.py(132):                     attached_to=new_class))
0.65 base.py(61):     return type(name, bases, {
0.65 base.py(62):         '__module__': module,
0.65 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(328):             setattr(cls, name, value)
0.65 base.py(133):             new_class.add_to_class(
0.65 base.py(134):                 'MultipleObjectsReturned',
0.65 base.py(135):                 subclass_exception(
0.65 base.py(136):                     'MultipleObjectsReturned',
0.65 base.py(137):                     tuple(
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.65 base.py(139):                     ) or (MultipleObjectsReturned,),
0.65 base.py(140):                     module,
0.65 base.py(141):                     attached_to=new_class))
0.65 base.py(61):     return type(name, bases, {
0.65 base.py(62):         '__module__': module,
0.65 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(328):             setattr(cls, name, value)
0.65 base.py(142):             if base_meta and not base_meta.abstract:
0.65 base.py(151):         is_proxy = new_class._meta.proxy
0.65 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(161):             new_class.add_to_class(obj_name, obj)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(263):         self.local_managers.append(manager)
0.65 options.py(264):         self._expire_cache()
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(734):                 if cache_key in self.__dict__:
0.65 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.65 base.py(164):         new_fields = chain(
0.65 base.py(165):             new_class._meta.local_fields,
0.65 base.py(166):             new_class._meta.local_many_to_many,
0.65 base.py(167):             new_class._meta.private_fields
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(169):         field_names = {f.name for f in new_fields}
0.65 base.py(172):         if is_proxy:
0.65 base.py(192):             new_class._meta.concrete_model = new_class
0.65 base.py(195):         parent_links = {}
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(201):             if base != new_class and not base._meta.abstract:
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(205):                 if isinstance(field, OneToOneField):
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(198):             if not hasattr(base, '_meta'):
0.65 base.py(201):             if base != new_class and not base._meta.abstract:
0.65 base.py(204):             for field in base._meta.local_fields:
0.65 base.py(196):         for base in reversed([new_class] + parents):
0.65 base.py(210):         inherited_attributes = set()
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(219):             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
0.65 base.py(220):             if not base._meta.abstract:
0.65 base.py(270):                 base_parents = base._meta.parents.copy()
0.65 base.py(273):                 for field in parent_fields:
0.65 base.py(274):                     if (field.name not in field_names and
0.65 base.py(275):                             field.name not in new_class.__dict__ and
0.65 base.py(276):                             field.name not in inherited_attributes):
0.65 base.py(277):                         new_field = copy.deepcopy(field)
0.65 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(298):             self.pk = field
0.65 options.py(299):             field.serialize = False
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(281):                         if field.one_to_one:
0.65 base.py(273):                 for field in parent_fields:
0.65 base.py(274):                     if (field.name not in field_names and
0.65 base.py(275):                             field.name not in new_class.__dict__ and
0.65 base.py(276):                             field.name not in inherited_attributes):
0.65 base.py(277):                         new_field = copy.deepcopy(field)
0.65 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(281):                         if field.one_to_one:
0.65 base.py(273):                 for field in parent_fields:
0.65 base.py(274):                     if (field.name not in field_names and
0.65 base.py(275):                             field.name not in new_class.__dict__ and
0.65 base.py(276):                             field.name not in inherited_attributes):
0.65 base.py(277):                         new_field = copy.deepcopy(field)
0.65 base.py(278):                         new_class.add_to_class(field.name, new_field)
0.65 base.py(325):         if _has_contribute_to_class(value):
0.65 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.65 base.py(326):             value.contribute_to_class(cls, name)
0.65 options.py(271):         if private:
0.65 options.py(273):         elif field.is_relation and field.many_to_many:
0.65 options.py(276):             bisect.insort(self.local_fields, field)
0.65 options.py(277):             self.setup_pk(field)
0.65 options.py(297):         if not self.pk and field.primary_key:
0.65 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.65 options.py(294):             self._expire_cache(reverse=False)
0.65 options.py(728):         if forward:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(730):                 if cache_key in self.__dict__:
0.65 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.65 options.py(732):         if reverse and not self.abstract:
0.65 options.py(736):         self._get_fields_cache = {}
0.65 base.py(281):                         if field.one_to_one:
0.65 base.py(273):                 for field in parent_fields:
0.65 base.py(287):                 new_class._meta.parents.update(base_parents)
0.65 base.py(291):             for field in base._meta.private_fields:
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.65 base.py(216):                 inherited_attributes.update(base.__dict__)
0.65 base.py(217):                 continue
0.65 base.py(212):         for base in new_class.mro():
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.65 base.py(312):         if abstract:
0.65 base.py(320):         new_class._prepare()
0.65 base.py(332):         opts = cls._meta
0.65 base.py(333):         opts._prepare(cls)
0.65 options.py(223):         if self.order_with_respect_to:
0.65 options.py(239):             self.order_with_respect_to = None
0.65 options.py(241):         if self.pk is None:
0.65 base.py(335):         if opts.order_with_respect_to:
0.65 base.py(350):         if cls.__doc__ is None:
0.65 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.65 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.65 base.py(354):         if get_absolute_url_override:
0.65 base.py(357):         if not opts.managers:
0.65 options.py(365):         managers = []
0.65 options.py(366):         seen_managers = set()
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(370):                 if manager.name in seen_managers:
0.65 options.py(373):                 manager = copy.copy(manager)
0.65 options.py(374):                 manager.model = self.model
0.65 options.py(375):                 seen_managers.add(manager.name)
0.65 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(370):                 if manager.name in seen_managers:
0.65 options.py(371):                     continue
0.65 options.py(369):             for manager in base._meta.local_managers:
0.65 options.py(368):         for depth, base in enumerate(bases):
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.65 options.py(378):         return make_immutable_fields_list(
0.65 options.py(379):             "managers",
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 options.py(380):             (m[2] for m in sorted(managers)),
0.65 base.py(370):         for index in cls._meta.indexes:
0.65 base.py(374):         class_prepared.send(sender=cls)
0.65 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.65 base.py(322):         return new_class
0.66 base.py(75):         super_new = super().__new__
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(80):         if not parents:
0.66 base.py(84):         module = attrs.pop('__module__')
0.66 base.py(85):         new_attrs = {'__module__': module}
0.66 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.66 base.py(87):         if classcell is not None:
0.66 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.66 base.py(93):         contributable_attrs = {}
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(96):                 contributable_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.66 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.66 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.66 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.66 base.py(105):         app_label = None
0.66 base.py(108):         app_config = apps.get_containing_app_config(module)
0.66 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.66 base.py(111):             if app_config is None:
0.66 base.py(120):                 app_label = app_config.label
0.66 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.66 options.py(76):         self._get_fields_cache = {}
0.66 options.py(77):         self.local_fields = []
0.66 options.py(78):         self.local_many_to_many = []
0.66 options.py(79):         self.private_fields = []
0.66 options.py(80):         self.local_managers = []
0.66 options.py(81):         self.base_manager_name = None
0.66 options.py(82):         self.default_manager_name = None
0.66 options.py(83):         self.model_name = None
0.66 options.py(84):         self.verbose_name = None
0.66 options.py(85):         self.verbose_name_plural = None
0.66 options.py(86):         self.db_table = ''
0.66 options.py(87):         self.ordering = []
0.66 options.py(88):         self._ordering_clash = False
0.66 options.py(89):         self.indexes = []
0.66 options.py(90):         self.constraints = []
0.66 options.py(91):         self.unique_together = []
0.66 options.py(92):         self.index_together = []
0.66 options.py(93):         self.select_on_save = False
0.66 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.66 options.py(95):         self.permissions = []
0.66 options.py(96):         self.object_name = None
0.66 options.py(97):         self.app_label = app_label
0.66 options.py(98):         self.get_latest_by = None
0.66 options.py(99):         self.order_with_respect_to = None
0.66 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.66 options.py(101):         self.required_db_features = []
0.66 options.py(102):         self.required_db_vendor = None
0.66 options.py(103):         self.meta = meta
0.66 options.py(104):         self.pk = None
0.66 options.py(105):         self.auto_field = None
0.66 options.py(106):         self.abstract = False
0.66 options.py(107):         self.managed = True
0.66 options.py(108):         self.proxy = False
0.66 options.py(114):         self.proxy_for_model = None
0.66 options.py(118):         self.concrete_model = None
0.66 options.py(119):         self.swappable = None
0.66 options.py(120):         self.parents = {}
0.66 options.py(121):         self.auto_created = False
0.66 options.py(125):         self.related_fkey_lookups = []
0.66 options.py(128):         self.apps = self.default_apps
0.66 options.py(130):         self.default_related_name = None
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(150):         from django.db import connection
0.66 options.py(151):         from django.db.backends.utils import truncate_name
0.66 options.py(153):         cls._meta = self
0.66 options.py(154):         self.model = cls
0.66 options.py(156):         self.object_name = cls.__name__
0.66 options.py(157):         self.model_name = self.object_name.lower()
0.66 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.66 options.py(162):         self.original_attrs = {}
0.66 options.py(165):         if self.meta:
0.66 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(172):                     del meta_attrs[name]
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(172):                     del meta_attrs[name]
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(172):                     del meta_attrs[name]
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(171):                 if name.startswith('_'):
0.66 options.py(172):                     del meta_attrs[name]
0.66 options.py(167):             for name in self.meta.__dict__:
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.66 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.66 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.66 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.66 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(174):                 if attr_name in meta_attrs:
0.66 options.py(177):                 elif hasattr(self.meta, attr_name):
0.66 options.py(173):             for attr_name in DEFAULT_NAMES:
0.66 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.66 options.py(45):     try:
0.66 options.py(46):         if not option_together:
0.66 options.py(47):             return ()
0.66 options.py(182):             self.index_together = normalize_together(self.index_together)
0.66 options.py(45):     try:
0.66 options.py(46):         if not option_together:
0.66 options.py(47):             return ()
0.66 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.66 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.66 options.py(187):                     objs = getattr(self, attr_name, [])
0.66 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.66 options.py(212):         new_objs = []
0.66 options.py(213):         for obj in objs:
0.66 options.py(220):         return new_objs
0.66 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.66 options.py(187):                     objs = getattr(self, attr_name, [])
0.66 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.66 options.py(212):         new_objs = []
0.66 options.py(213):         for obj in objs:
0.66 options.py(220):         return new_objs
0.66 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.66 options.py(192):             if self.verbose_name_plural is None:
0.66 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.66 options.py(199):             if meta_attrs != {}:
0.66 options.py(203):         del self.meta
0.66 options.py(206):         if not self.db_table:
0.66 base.py(123):         if not abstract:
0.66 base.py(124):             new_class.add_to_class(
0.66 base.py(125):                 'DoesNotExist',
0.66 base.py(126):                 subclass_exception(
0.66 base.py(127):                     'DoesNotExist',
0.66 base.py(128):                     tuple(
0.66 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(130):                     ) or (ObjectDoesNotExist,),
0.66 base.py(131):                     module,
0.66 base.py(132):                     attached_to=new_class))
0.66 base.py(61):     return type(name, bases, {
0.66 base.py(62):         '__module__': module,
0.66 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(328):             setattr(cls, name, value)
0.66 base.py(133):             new_class.add_to_class(
0.66 base.py(134):                 'MultipleObjectsReturned',
0.66 base.py(135):                 subclass_exception(
0.66 base.py(136):                     'MultipleObjectsReturned',
0.66 base.py(137):                     tuple(
0.66 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.66 base.py(139):                     ) or (MultipleObjectsReturned,),
0.66 base.py(140):                     module,
0.66 base.py(141):                     attached_to=new_class))
0.66 base.py(61):     return type(name, bases, {
0.66 base.py(62):         '__module__': module,
0.66 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(328):             setattr(cls, name, value)
0.66 base.py(142):             if base_meta and not base_meta.abstract:
0.66 base.py(151):         is_proxy = new_class._meta.proxy
0.66 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(288):             try:
0.66 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.66 options.py(290):             except AttributeError:
0.66 options.py(291):                 pass
0.66 options.py(292):             self._expire_cache()
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(288):             try:
0.66 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.66 options.py(728):         if forward:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 options.py(292):             self._expire_cache()
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(161):             new_class.add_to_class(obj_name, obj)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(263):         self.local_managers.append(manager)
0.66 options.py(264):         self._expire_cache()
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(734):                 if cache_key in self.__dict__:
0.66 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.66 base.py(164):         new_fields = chain(
0.66 base.py(165):             new_class._meta.local_fields,
0.66 base.py(166):             new_class._meta.local_many_to_many,
0.66 base.py(167):             new_class._meta.private_fields
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(169):         field_names = {f.name for f in new_fields}
0.66 base.py(172):         if is_proxy:
0.66 base.py(192):             new_class._meta.concrete_model = new_class
0.66 base.py(195):         parent_links = {}
0.66 base.py(196):         for base in reversed([new_class] + parents):
0.66 base.py(198):             if not hasattr(base, '_meta'):
0.66 base.py(199):                 continue
0.66 base.py(196):         for base in reversed([new_class] + parents):
0.66 base.py(198):             if not hasattr(base, '_meta'):
0.66 base.py(201):             if base != new_class and not base._meta.abstract:
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(205):                 if isinstance(field, OneToOneField):
0.66 base.py(204):             for field in base._meta.local_fields:
0.66 base.py(196):         for base in reversed([new_class] + parents):
0.66 base.py(210):         inherited_attributes = set()
0.66 base.py(212):         for base in new_class.mro():
0.66 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.66 base.py(216):                 inherited_attributes.update(base.__dict__)
0.66 base.py(217):                 continue
0.66 base.py(212):         for base in new_class.mro():
0.66 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.66 base.py(216):                 inherited_attributes.update(base.__dict__)
0.66 base.py(217):                 continue
0.66 base.py(212):         for base in new_class.mro():
0.66 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.66 base.py(216):                 inherited_attributes.update(base.__dict__)
0.66 base.py(217):                 continue
0.66 base.py(212):         for base in new_class.mro():
0.66 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.66 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.66 base.py(312):         if abstract:
0.66 base.py(320):         new_class._prepare()
0.66 base.py(332):         opts = cls._meta
0.66 base.py(333):         opts._prepare(cls)
0.66 options.py(223):         if self.order_with_respect_to:
0.66 options.py(239):             self.order_with_respect_to = None
0.66 options.py(241):         if self.pk is None:
0.66 options.py(242):             if self.parents:
0.66 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.66 options.py(260):                 model.add_to_class('id', auto)
0.66 base.py(325):         if _has_contribute_to_class(value):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(326):             value.contribute_to_class(cls, name)
0.66 options.py(271):         if private:
0.66 options.py(273):         elif field.is_relation and field.many_to_many:
0.66 options.py(276):             bisect.insort(self.local_fields, field)
0.66 options.py(277):             self.setup_pk(field)
0.66 options.py(297):         if not self.pk and field.primary_key:
0.66 options.py(298):             self.pk = field
0.66 options.py(299):             field.serialize = False
0.66 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.66 options.py(294):             self._expire_cache(reverse=False)
0.66 options.py(728):         if forward:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(730):                 if cache_key in self.__dict__:
0.66 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.66 options.py(732):         if reverse and not self.abstract:
0.66 options.py(736):         self._get_fields_cache = {}
0.66 base.py(335):         if opts.order_with_respect_to:
0.66 base.py(350):         if cls.__doc__ is None:
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 options.py(456):         def is_not_an_m2m_field(f):
0.66 options.py(459):         def is_not_a_generic_relation(f):
0.66 options.py(462):         def is_not_a_generic_foreign_key(f):
0.66 options.py(467):         return make_immutable_fields_list(
0.66 options.py(468):             "fields",
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.66 options.py(773):         topmost_call = seen_models is None
0.66 options.py(774):         if topmost_call:
0.66 options.py(775):             seen_models = set()
0.66 options.py(776):         seen_models.add(self.model)
0.66 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.66 options.py(781):         try:
0.66 options.py(784):             return self._get_fields_cache[cache_key]
0.66 options.py(785):         except KeyError:
0.66 options.py(786):             pass
0.66 options.py(788):         fields = []
0.66 options.py(791):         if include_parents is not False:
0.66 options.py(792):             for parent in self.parents:
0.66 options.py(806):         if reverse and not self.proxy:
0.66 options.py(817):         if forward:
0.66 options.py(818):             fields += self.local_fields
0.66 options.py(819):             fields += self.local_many_to_many
0.66 options.py(825):             if topmost_call:
0.66 options.py(826):                 fields += self.private_fields
0.66 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.66 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.66 options.py(833):         self._get_fields_cache[cache_key] = fields
0.66 options.py(834):         return fields
0.66 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.66 options.py(457):             return not (f.is_relation and f.many_to_many)
0.66 options.py(460):             return not (f.is_relation and f.one_to_many)
0.66 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.66 options.py(469):             (f for f in self._get_fields(reverse=False)
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.66 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.66 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.66 base.py(354):         if get_absolute_url_override:
0.66 base.py(357):         if not opts.managers:
0.66 options.py(365):         managers = []
0.66 options.py(366):         seen_managers = set()
0.66 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.66 options.py(368):         for depth, base in enumerate(bases):
0.66 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.66 options.py(369):             for manager in base._meta.local_managers:
0.66 options.py(370):                 if manager.name in seen_managers:
0.66 options.py(373):                 manager = copy.copy(manager)
0.66 options.py(374):                 manager.model = self.model
0.66 options.py(375):                 seen_managers.add(manager.name)
0.66 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.66 options.py(369):             for manager in base._meta.local_managers:
0.66 options.py(368):         for depth, base in enumerate(bases):
0.66 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.66 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.66 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.66 options.py(378):         return make_immutable_fields_list(
0.66 options.py(379):             "managers",
0.66 options.py(380):             (m[2] for m in sorted(managers)),
0.66 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.66 options.py(380):             (m[2] for m in sorted(managers)),
0.66 options.py(380):             (m[2] for m in sorted(managers)),
0.66 base.py(370):         for index in cls._meta.indexes:
0.66 base.py(374):         class_prepared.send(sender=cls)
0.66 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.66 options.py(347):         if self.swappable:
0.66 options.py(361):         return None
0.66 options.py(347):         if self.swappable:
0.66 options.py(361):         return None
0.66 base.py(322):         return new_class
0.66 base.py(75):         super_new = super().__new__
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.66 base.py(80):         if not parents:
0.66 base.py(84):         module = attrs.pop('__module__')
0.66 base.py(85):         new_attrs = {'__module__': module}
0.66 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.66 base.py(87):         if classcell is not None:
0.66 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.66 base.py(93):         contributable_attrs = {}
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(95):             if _has_contribute_to_class(obj):
0.66 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.66 base.py(98):                 new_attrs[obj_name] = obj
0.66 base.py(94):         for obj_name, obj in list(attrs.items()):
0.66 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.66 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.66 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.66 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.66 base.py(105):         app_label = None
0.66 base.py(108):         app_config = apps.get_containing_app_config(module)
0.66 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.66 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.66 options.py(76):         self._get_fields_cache = {}
0.66 options.py(77):         self.local_fields = []
0.67 options.py(78):         self.local_many_to_many = []
0.67 options.py(79):         self.private_fields = []
0.67 options.py(80):         self.local_managers = []
0.67 options.py(81):         self.base_manager_name = None
0.67 options.py(82):         self.default_manager_name = None
0.67 options.py(83):         self.model_name = None
0.67 options.py(84):         self.verbose_name = None
0.67 options.py(85):         self.verbose_name_plural = None
0.67 options.py(86):         self.db_table = ''
0.67 options.py(87):         self.ordering = []
0.67 options.py(88):         self._ordering_clash = False
0.67 options.py(89):         self.indexes = []
0.67 options.py(90):         self.constraints = []
0.67 options.py(91):         self.unique_together = []
0.67 options.py(92):         self.index_together = []
0.67 options.py(93):         self.select_on_save = False
0.67 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.67 options.py(95):         self.permissions = []
0.67 options.py(96):         self.object_name = None
0.67 options.py(97):         self.app_label = app_label
0.67 options.py(98):         self.get_latest_by = None
0.67 options.py(99):         self.order_with_respect_to = None
0.67 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.67 options.py(101):         self.required_db_features = []
0.67 options.py(102):         self.required_db_vendor = None
0.67 options.py(103):         self.meta = meta
0.67 options.py(104):         self.pk = None
0.67 options.py(105):         self.auto_field = None
0.67 options.py(106):         self.abstract = False
0.67 options.py(107):         self.managed = True
0.67 options.py(108):         self.proxy = False
0.67 options.py(114):         self.proxy_for_model = None
0.67 options.py(118):         self.concrete_model = None
0.67 options.py(119):         self.swappable = None
0.67 options.py(120):         self.parents = {}
0.67 options.py(121):         self.auto_created = False
0.67 options.py(125):         self.related_fkey_lookups = []
0.67 options.py(128):         self.apps = self.default_apps
0.67 options.py(130):         self.default_related_name = None
0.67 base.py(325):         if _has_contribute_to_class(value):
0.67 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.67 base.py(326):             value.contribute_to_class(cls, name)
0.67 options.py(150):         from django.db import connection
0.67 options.py(151):         from django.db.backends.utils import truncate_name
0.67 options.py(153):         cls._meta = self
0.67 options.py(154):         self.model = cls
0.67 options.py(156):         self.object_name = cls.__name__
0.67 options.py(157):         self.model_name = self.object_name.lower()
0.67 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.67 options.py(162):         self.original_attrs = {}
0.67 options.py(165):         if self.meta:
0.67 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(171):                 if name.startswith('_'):
0.67 options.py(172):                     del meta_attrs[name]
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(171):                 if name.startswith('_'):
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(171):                 if name.startswith('_'):
0.67 options.py(172):                     del meta_attrs[name]
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(171):                 if name.startswith('_'):
0.67 options.py(172):                     del meta_attrs[name]
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(171):                 if name.startswith('_'):
0.67 options.py(172):                     del meta_attrs[name]
0.67 options.py(167):             for name in self.meta.__dict__:
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.67 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(174):                 if attr_name in meta_attrs:
0.67 options.py(177):                 elif hasattr(self.meta, attr_name):
0.67 options.py(173):             for attr_name in DEFAULT_NAMES:
0.67 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.67 options.py(45):     try:
0.67 options.py(46):         if not option_together:
0.67 options.py(47):             return ()
0.67 options.py(182):             self.index_together = normalize_together(self.index_together)
0.67 options.py(45):     try:
0.67 options.py(46):         if not option_together:
0.67 options.py(47):             return ()
0.67 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.67 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.67 options.py(187):                     objs = getattr(self, attr_name, [])
0.67 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.67 options.py(212):         new_objs = []
0.67 options.py(213):         for obj in objs:
0.67 options.py(220):         return new_objs
0.67 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.67 options.py(187):                     objs = getattr(self, attr_name, [])
0.67 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.67 options.py(212):         new_objs = []
0.67 options.py(213):         for obj in objs:
0.67 options.py(220):         return new_objs
0.67 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.67 options.py(192):             if self.verbose_name_plural is None:
0.67 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.67 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.67 options.py(199):             if meta_attrs != {}:
0.67 options.py(203):         del self.meta
0.67 options.py(206):         if not self.db_table:
0.67 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.67 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.67 base.py(123):         if not abstract:
0.67 base.py(124):             new_class.add_to_class(
0.67 base.py(125):                 'DoesNotExist',
0.67 base.py(126):                 subclass_exception(
0.67 base.py(127):                     'DoesNotExist',
0.67 base.py(128):                     tuple(
0.67 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(130):                     ) or (ObjectDoesNotExist,),
0.67 base.py(131):                     module,
0.67 base.py(132):                     attached_to=new_class))
0.67 base.py(61):     return type(name, bases, {
0.67 base.py(62):         '__module__': module,
0.67 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.67 base.py(325):         if _has_contribute_to_class(value):
0.67 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.67 base.py(328):             setattr(cls, name, value)
0.67 base.py(133):             new_class.add_to_class(
0.67 base.py(134):                 'MultipleObjectsReturned',
0.67 base.py(135):                 subclass_exception(
0.67 base.py(136):                     'MultipleObjectsReturned',
0.67 base.py(137):                     tuple(
0.67 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.67 base.py(139):                     ) or (MultipleObjectsReturned,),
0.67 base.py(140):                     module,
0.67 base.py(141):                     attached_to=new_class))
0.67 base.py(61):     return type(name, bases, {
0.67 base.py(62):         '__module__': module,
0.67 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.67 base.py(325):         if _has_contribute_to_class(value):
0.67 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.67 base.py(328):             setattr(cls, name, value)
0.67 base.py(142):             if base_meta and not base_meta.abstract:
0.67 base.py(151):         is_proxy = new_class._meta.proxy
0.67 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.67 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.67 base.py(164):         new_fields = chain(
0.67 base.py(165):             new_class._meta.local_fields,
0.67 base.py(166):             new_class._meta.local_many_to_many,
0.67 base.py(167):             new_class._meta.private_fields
0.67 base.py(169):         field_names = {f.name for f in new_fields}
0.67 base.py(169):         field_names = {f.name for f in new_fields}
0.67 base.py(172):         if is_proxy:
0.67 base.py(192):             new_class._meta.concrete_model = new_class
0.67 base.py(195):         parent_links = {}
0.67 base.py(196):         for base in reversed([new_class] + parents):
0.67 base.py(198):             if not hasattr(base, '_meta'):
0.67 base.py(199):                 continue
0.67 base.py(196):         for base in reversed([new_class] + parents):
0.67 base.py(198):             if not hasattr(base, '_meta'):
0.67 base.py(201):             if base != new_class and not base._meta.abstract:
0.67 base.py(204):             for field in base._meta.local_fields:
0.67 base.py(196):         for base in reversed([new_class] + parents):
0.67 base.py(210):         inherited_attributes = set()
0.67 base.py(212):         for base in new_class.mro():
0.67 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.67 base.py(216):                 inherited_attributes.update(base.__dict__)
0.67 base.py(217):                 continue
0.67 base.py(212):         for base in new_class.mro():
0.67 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.67 base.py(216):                 inherited_attributes.update(base.__dict__)
0.67 base.py(217):                 continue
0.67 base.py(212):         for base in new_class.mro():
0.67 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.67 base.py(216):                 inherited_attributes.update(base.__dict__)
0.67 base.py(217):                 continue
0.67 base.py(212):         for base in new_class.mro():
0.67 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.67 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.67 base.py(312):         if abstract:
0.67 base.py(320):         new_class._prepare()
0.67 base.py(332):         opts = cls._meta
0.67 base.py(333):         opts._prepare(cls)
0.67 options.py(223):         if self.order_with_respect_to:
0.67 options.py(239):             self.order_with_respect_to = None
0.67 options.py(241):         if self.pk is None:
0.67 options.py(242):             if self.parents:
0.67 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.67 options.py(260):                 model.add_to_class('id', auto)
0.67 base.py(325):         if _has_contribute_to_class(value):
0.67 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.67 base.py(326):             value.contribute_to_class(cls, name)
0.67 options.py(271):         if private:
0.67 options.py(273):         elif field.is_relation and field.many_to_many:
0.67 options.py(276):             bisect.insort(self.local_fields, field)
0.67 options.py(277):             self.setup_pk(field)
0.67 options.py(297):         if not self.pk and field.primary_key:
0.67 options.py(298):             self.pk = field
0.67 options.py(299):             field.serialize = False
0.67 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.67 options.py(294):             self._expire_cache(reverse=False)
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 base.py(335):         if opts.order_with_respect_to:
0.67 base.py(350):         if cls.__doc__ is None:
0.67 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.67 options.py(456):         def is_not_an_m2m_field(f):
0.67 options.py(459):         def is_not_a_generic_relation(f):
0.67 options.py(462):         def is_not_a_generic_foreign_key(f):
0.67 options.py(467):         return make_immutable_fields_list(
0.67 options.py(468):             "fields",
0.67 options.py(469):             (f for f in self._get_fields(reverse=False)
0.67 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.67 options.py(773):         topmost_call = seen_models is None
0.67 options.py(774):         if topmost_call:
0.67 options.py(775):             seen_models = set()
0.67 options.py(776):         seen_models.add(self.model)
0.67 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.67 options.py(781):         try:
0.67 options.py(784):             return self._get_fields_cache[cache_key]
0.67 options.py(785):         except KeyError:
0.67 options.py(786):             pass
0.67 options.py(788):         fields = []
0.67 options.py(791):         if include_parents is not False:
0.67 options.py(792):             for parent in self.parents:
0.67 options.py(806):         if reverse and not self.proxy:
0.67 options.py(817):         if forward:
0.67 options.py(818):             fields += self.local_fields
0.67 options.py(819):             fields += self.local_many_to_many
0.67 options.py(825):             if topmost_call:
0.67 options.py(826):                 fields += self.private_fields
0.67 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.67 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.67 options.py(833):         self._get_fields_cache[cache_key] = fields
0.67 options.py(834):         return fields
0.67 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.67 options.py(469):             (f for f in self._get_fields(reverse=False)
0.67 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.67 options.py(457):             return not (f.is_relation and f.many_to_many)
0.67 options.py(460):             return not (f.is_relation and f.one_to_many)
0.67 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.67 options.py(469):             (f for f in self._get_fields(reverse=False)
0.67 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.67 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.67 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.67 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.67 base.py(354):         if get_absolute_url_override:
0.67 base.py(357):         if not opts.managers:
0.67 options.py(365):         managers = []
0.67 options.py(366):         seen_managers = set()
0.67 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.67 options.py(368):         for depth, base in enumerate(bases):
0.67 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.67 options.py(369):             for manager in base._meta.local_managers:
0.67 options.py(368):         for depth, base in enumerate(bases):
0.67 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.67 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.67 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.67 options.py(378):         return make_immutable_fields_list(
0.67 options.py(379):             "managers",
0.67 options.py(380):             (m[2] for m in sorted(managers)),
0.67 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.67 options.py(380):             (m[2] for m in sorted(managers)),
0.67 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.67 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.67 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.67 base.py(363):             manager = Manager()
0.67 base.py(364):             manager.auto_created = True
0.67 base.py(365):             cls.add_to_class('objects', manager)
0.67 base.py(325):         if _has_contribute_to_class(value):
0.67 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.67 base.py(326):             value.contribute_to_class(cls, name)
0.67 options.py(263):         self.local_managers.append(manager)
0.67 options.py(264):         self._expire_cache()
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 base.py(370):         for index in cls._meta.indexes:
0.67 base.py(374):         class_prepared.send(sender=cls)
0.67 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.67 options.py(349):             if swapped_for:
0.67 options.py(350):                 try:
0.67 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.67 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.67 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 options.py(347):         if self.swappable:
0.67 options.py(361):         return None
0.67 options.py(728):         if forward:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(731):                     delattr(self, cache_key)
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(730):                 if cache_key in self.__dict__:
0.67 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.67 options.py(732):         if reverse and not self.abstract:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(734):                 if cache_key in self.__dict__:
0.67 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.67 options.py(736):         self._get_fields_cache = {}
0.67 base.py(322):         return new_class
Skipping setup of unused database(s): other.
0.69 base.py(75):         super_new = super().__new__
0.69 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.69 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.69 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.69 base.py(80):         if not parents:
0.69 base.py(84):         module = attrs.pop('__module__')
0.69 base.py(85):         new_attrs = {'__module__': module}
0.69 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.69 base.py(87):         if classcell is not None:
0.69 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.69 base.py(93):         contributable_attrs = {}
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(95):             if _has_contribute_to_class(obj):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(98):                 new_attrs[obj_name] = obj
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(95):             if _has_contribute_to_class(obj):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(96):                 contributable_attrs[obj_name] = obj
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(95):             if _has_contribute_to_class(obj):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(96):                 contributable_attrs[obj_name] = obj
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(95):             if _has_contribute_to_class(obj):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(96):                 contributable_attrs[obj_name] = obj
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(95):             if _has_contribute_to_class(obj):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(98):                 new_attrs[obj_name] = obj
0.69 base.py(94):         for obj_name, obj in list(attrs.items()):
0.69 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.69 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.69 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.69 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.69 base.py(105):         app_label = None
0.69 base.py(108):         app_config = apps.get_containing_app_config(module)
0.69 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.69 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.69 options.py(76):         self._get_fields_cache = {}
0.69 options.py(77):         self.local_fields = []
0.69 options.py(78):         self.local_many_to_many = []
0.69 options.py(79):         self.private_fields = []
0.69 options.py(80):         self.local_managers = []
0.69 options.py(81):         self.base_manager_name = None
0.69 options.py(82):         self.default_manager_name = None
0.69 options.py(83):         self.model_name = None
0.69 options.py(84):         self.verbose_name = None
0.69 options.py(85):         self.verbose_name_plural = None
0.69 options.py(86):         self.db_table = ''
0.69 options.py(87):         self.ordering = []
0.69 options.py(88):         self._ordering_clash = False
0.69 options.py(89):         self.indexes = []
0.69 options.py(90):         self.constraints = []
0.69 options.py(91):         self.unique_together = []
0.69 options.py(92):         self.index_together = []
0.69 options.py(93):         self.select_on_save = False
0.69 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.69 options.py(95):         self.permissions = []
0.69 options.py(96):         self.object_name = None
0.69 options.py(97):         self.app_label = app_label
0.69 options.py(98):         self.get_latest_by = None
0.69 options.py(99):         self.order_with_respect_to = None
0.69 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.69 options.py(101):         self.required_db_features = []
0.69 options.py(102):         self.required_db_vendor = None
0.69 options.py(103):         self.meta = meta
0.69 options.py(104):         self.pk = None
0.69 options.py(105):         self.auto_field = None
0.69 options.py(106):         self.abstract = False
0.69 options.py(107):         self.managed = True
0.69 options.py(108):         self.proxy = False
0.69 options.py(114):         self.proxy_for_model = None
0.69 options.py(118):         self.concrete_model = None
0.69 options.py(119):         self.swappable = None
0.69 options.py(120):         self.parents = {}
0.69 options.py(121):         self.auto_created = False
0.69 options.py(125):         self.related_fkey_lookups = []
0.69 options.py(128):         self.apps = self.default_apps
0.69 options.py(130):         self.default_related_name = None
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(150):         from django.db import connection
0.69 options.py(151):         from django.db.backends.utils import truncate_name
0.69 options.py(153):         cls._meta = self
0.69 options.py(154):         self.model = cls
0.69 options.py(156):         self.object_name = cls.__name__
0.69 options.py(157):         self.model_name = self.object_name.lower()
0.69 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.69 options.py(162):         self.original_attrs = {}
0.69 options.py(165):         if self.meta:
0.69 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(172):                     del meta_attrs[name]
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(172):                     del meta_attrs[name]
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(172):                     del meta_attrs[name]
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(171):                 if name.startswith('_'):
0.69 options.py(172):                     del meta_attrs[name]
0.69 options.py(167):             for name in self.meta.__dict__:
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.69 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.69 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.69 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(174):                 if attr_name in meta_attrs:
0.69 options.py(177):                 elif hasattr(self.meta, attr_name):
0.69 options.py(173):             for attr_name in DEFAULT_NAMES:
0.69 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.69 options.py(45):     try:
0.69 options.py(46):         if not option_together:
0.69 options.py(47):             return ()
0.69 options.py(182):             self.index_together = normalize_together(self.index_together)
0.69 options.py(45):     try:
0.69 options.py(46):         if not option_together:
0.69 options.py(47):             return ()
0.69 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.69 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.69 options.py(187):                     objs = getattr(self, attr_name, [])
0.69 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.69 options.py(212):         new_objs = []
0.69 options.py(213):         for obj in objs:
0.69 options.py(220):         return new_objs
0.69 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.69 options.py(187):                     objs = getattr(self, attr_name, [])
0.69 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.69 options.py(212):         new_objs = []
0.69 options.py(213):         for obj in objs:
0.69 options.py(220):         return new_objs
0.69 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.69 options.py(192):             if self.verbose_name_plural is None:
0.69 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.69 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.69 options.py(199):             if meta_attrs != {}:
0.69 options.py(203):         del self.meta
0.69 options.py(206):         if not self.db_table:
0.69 base.py(123):         if not abstract:
0.69 base.py(124):             new_class.add_to_class(
0.69 base.py(125):                 'DoesNotExist',
0.69 base.py(126):                 subclass_exception(
0.69 base.py(127):                     'DoesNotExist',
0.69 base.py(128):                     tuple(
0.69 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(130):                     ) or (ObjectDoesNotExist,),
0.69 base.py(131):                     module,
0.69 base.py(132):                     attached_to=new_class))
0.69 base.py(61):     return type(name, bases, {
0.69 base.py(62):         '__module__': module,
0.69 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(328):             setattr(cls, name, value)
0.69 base.py(133):             new_class.add_to_class(
0.69 base.py(134):                 'MultipleObjectsReturned',
0.69 base.py(135):                 subclass_exception(
0.69 base.py(136):                     'MultipleObjectsReturned',
0.69 base.py(137):                     tuple(
0.69 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.69 base.py(139):                     ) or (MultipleObjectsReturned,),
0.69 base.py(140):                     module,
0.69 base.py(141):                     attached_to=new_class))
0.69 base.py(61):     return type(name, bases, {
0.69 base.py(62):         '__module__': module,
0.69 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(328):             setattr(cls, name, value)
0.69 base.py(142):             if base_meta and not base_meta.abstract:
0.69 base.py(151):         is_proxy = new_class._meta.proxy
0.69 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.69 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.69 base.py(161):             new_class.add_to_class(obj_name, obj)
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(271):         if private:
0.69 options.py(273):         elif field.is_relation and field.many_to_many:
0.69 options.py(276):             bisect.insort(self.local_fields, field)
0.69 options.py(277):             self.setup_pk(field)
0.69 options.py(297):         if not self.pk and field.primary_key:
0.69 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.69 options.py(294):             self._expire_cache(reverse=False)
0.69 options.py(728):         if forward:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(732):         if reverse and not self.abstract:
0.69 options.py(736):         self._get_fields_cache = {}
0.69 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.69 base.py(161):             new_class.add_to_class(obj_name, obj)
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(271):         if private:
0.69 options.py(273):         elif field.is_relation and field.many_to_many:
0.69 options.py(276):             bisect.insort(self.local_fields, field)
0.69 options.py(277):             self.setup_pk(field)
0.69 options.py(297):         if not self.pk and field.primary_key:
0.69 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.69 options.py(294):             self._expire_cache(reverse=False)
0.69 options.py(728):         if forward:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(732):         if reverse and not self.abstract:
0.69 options.py(736):         self._get_fields_cache = {}
0.69 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.69 base.py(161):             new_class.add_to_class(obj_name, obj)
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(271):         if private:
0.69 options.py(273):         elif field.is_relation and field.many_to_many:
0.69 options.py(276):             bisect.insort(self.local_fields, field)
0.69 options.py(277):             self.setup_pk(field)
0.69 options.py(297):         if not self.pk and field.primary_key:
0.69 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.69 options.py(294):             self._expire_cache(reverse=False)
0.69 options.py(728):         if forward:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(732):         if reverse and not self.abstract:
0.69 options.py(736):         self._get_fields_cache = {}
0.69 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.69 base.py(164):         new_fields = chain(
0.69 base.py(165):             new_class._meta.local_fields,
0.69 base.py(166):             new_class._meta.local_many_to_many,
0.69 base.py(167):             new_class._meta.private_fields
0.69 base.py(169):         field_names = {f.name for f in new_fields}
0.69 base.py(169):         field_names = {f.name for f in new_fields}
0.69 base.py(169):         field_names = {f.name for f in new_fields}
0.69 base.py(169):         field_names = {f.name for f in new_fields}
0.69 base.py(169):         field_names = {f.name for f in new_fields}
0.69 base.py(172):         if is_proxy:
0.69 base.py(192):             new_class._meta.concrete_model = new_class
0.69 base.py(195):         parent_links = {}
0.69 base.py(196):         for base in reversed([new_class] + parents):
0.69 base.py(198):             if not hasattr(base, '_meta'):
0.69 base.py(199):                 continue
0.69 base.py(196):         for base in reversed([new_class] + parents):
0.69 base.py(198):             if not hasattr(base, '_meta'):
0.69 base.py(201):             if base != new_class and not base._meta.abstract:
0.69 base.py(204):             for field in base._meta.local_fields:
0.69 base.py(205):                 if isinstance(field, OneToOneField):
0.69 base.py(204):             for field in base._meta.local_fields:
0.69 base.py(205):                 if isinstance(field, OneToOneField):
0.69 base.py(204):             for field in base._meta.local_fields:
0.69 base.py(205):                 if isinstance(field, OneToOneField):
0.69 base.py(204):             for field in base._meta.local_fields:
0.69 base.py(196):         for base in reversed([new_class] + parents):
0.69 base.py(210):         inherited_attributes = set()
0.69 base.py(212):         for base in new_class.mro():
0.69 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.69 base.py(216):                 inherited_attributes.update(base.__dict__)
0.69 base.py(217):                 continue
0.69 base.py(212):         for base in new_class.mro():
0.69 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.69 base.py(216):                 inherited_attributes.update(base.__dict__)
0.69 base.py(217):                 continue
0.69 base.py(212):         for base in new_class.mro():
0.69 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.69 base.py(216):                 inherited_attributes.update(base.__dict__)
0.69 base.py(217):                 continue
0.69 base.py(212):         for base in new_class.mro():
0.69 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.69 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.69 base.py(312):         if abstract:
0.69 base.py(320):         new_class._prepare()
0.69 base.py(332):         opts = cls._meta
0.69 base.py(333):         opts._prepare(cls)
0.69 options.py(223):         if self.order_with_respect_to:
0.69 options.py(239):             self.order_with_respect_to = None
0.69 options.py(241):         if self.pk is None:
0.69 options.py(242):             if self.parents:
0.69 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.69 options.py(260):                 model.add_to_class('id', auto)
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(271):         if private:
0.69 options.py(273):         elif field.is_relation and field.many_to_many:
0.69 options.py(276):             bisect.insort(self.local_fields, field)
0.69 options.py(277):             self.setup_pk(field)
0.69 options.py(297):         if not self.pk and field.primary_key:
0.69 options.py(298):             self.pk = field
0.69 options.py(299):             field.serialize = False
0.69 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.69 options.py(294):             self._expire_cache(reverse=False)
0.69 options.py(728):         if forward:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(732):         if reverse and not self.abstract:
0.69 options.py(736):         self._get_fields_cache = {}
0.69 base.py(335):         if opts.order_with_respect_to:
0.69 base.py(350):         if cls.__doc__ is None:
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 options.py(456):         def is_not_an_m2m_field(f):
0.69 options.py(459):         def is_not_a_generic_relation(f):
0.69 options.py(462):         def is_not_a_generic_foreign_key(f):
0.69 options.py(467):         return make_immutable_fields_list(
0.69 options.py(468):             "fields",
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.69 options.py(773):         topmost_call = seen_models is None
0.69 options.py(774):         if topmost_call:
0.69 options.py(775):             seen_models = set()
0.69 options.py(776):         seen_models.add(self.model)
0.69 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.69 options.py(781):         try:
0.69 options.py(784):             return self._get_fields_cache[cache_key]
0.69 options.py(785):         except KeyError:
0.69 options.py(786):             pass
0.69 options.py(788):         fields = []
0.69 options.py(791):         if include_parents is not False:
0.69 options.py(792):             for parent in self.parents:
0.69 options.py(806):         if reverse and not self.proxy:
0.69 options.py(817):         if forward:
0.69 options.py(818):             fields += self.local_fields
0.69 options.py(819):             fields += self.local_many_to_many
0.69 options.py(825):             if topmost_call:
0.69 options.py(826):                 fields += self.private_fields
0.69 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.69 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.69 options.py(833):         self._get_fields_cache[cache_key] = fields
0.69 options.py(834):         return fields
0.69 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.69 options.py(457):             return not (f.is_relation and f.many_to_many)
0.69 options.py(460):             return not (f.is_relation and f.one_to_many)
0.69 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.69 options.py(457):             return not (f.is_relation and f.many_to_many)
0.69 options.py(460):             return not (f.is_relation and f.one_to_many)
0.69 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.69 options.py(457):             return not (f.is_relation and f.many_to_many)
0.69 options.py(460):             return not (f.is_relation and f.one_to_many)
0.69 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.69 options.py(457):             return not (f.is_relation and f.many_to_many)
0.69 options.py(460):             return not (f.is_relation and f.one_to_many)
0.69 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.69 options.py(469):             (f for f in self._get_fields(reverse=False)
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.69 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.69 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.69 base.py(354):         if get_absolute_url_override:
0.69 base.py(357):         if not opts.managers:
0.69 options.py(365):         managers = []
0.69 options.py(366):         seen_managers = set()
0.69 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.69 options.py(368):         for depth, base in enumerate(bases):
0.69 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.69 options.py(369):             for manager in base._meta.local_managers:
0.69 options.py(368):         for depth, base in enumerate(bases):
0.69 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.69 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.69 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.69 options.py(378):         return make_immutable_fields_list(
0.69 options.py(379):             "managers",
0.69 options.py(380):             (m[2] for m in sorted(managers)),
0.69 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.69 options.py(380):             (m[2] for m in sorted(managers)),
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.69 base.py(363):             manager = Manager()
0.69 base.py(364):             manager.auto_created = True
0.69 base.py(365):             cls.add_to_class('objects', manager)
0.69 base.py(325):         if _has_contribute_to_class(value):
0.69 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.69 base.py(326):             value.contribute_to_class(cls, name)
0.69 options.py(263):         self.local_managers.append(manager)
0.69 options.py(264):         self._expire_cache()
0.69 options.py(728):         if forward:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(731):                     delattr(self, cache_key)
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(731):                     delattr(self, cache_key)
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(730):                 if cache_key in self.__dict__:
0.69 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.69 options.py(732):         if reverse and not self.abstract:
0.69 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.69 options.py(734):                 if cache_key in self.__dict__:
0.69 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.69 options.py(734):                 if cache_key in self.__dict__:
0.69 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.69 options.py(734):                 if cache_key in self.__dict__:
0.69 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.69 options.py(736):         self._get_fields_cache = {}
0.69 base.py(370):         for index in cls._meta.indexes:
0.69 base.py(374):         class_prepared.send(sender=cls)
0.69 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.69 base.py(322):         return new_class
Operations to perform:
  Synchronize unmigrated apps: auth, contenttypes, messages, sessions, staticfiles
  Apply all migrations: admin, sites
0.69 options.py(347):         if self.swappable:
0.69 options.py(361):         return None
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.70 options.py(50):         first_element = option_together[0]
0.70 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(347):         if self.swappable:
0.70 options.py(361):         return None
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(347):         if self.swappable:
0.70 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.70 options.py(349):             if swapped_for:
0.70 options.py(350):                 try:
0.70 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.70 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.70 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.70 options.py(361):         return None
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(347):         if self.swappable:
0.70 options.py(361):         return None
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(371):                     continue
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(347):         if self.swappable:
0.70 options.py(361):         return None
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.70 options.py(50):         first_element = option_together[0]
0.70 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 base.py(75):         super_new = super().__new__
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(80):         if not parents:
0.70 base.py(84):         module = attrs.pop('__module__')
0.70 base.py(85):         new_attrs = {'__module__': module}
0.70 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.70 base.py(87):         if classcell is not None:
0.70 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.70 base.py(93):         contributable_attrs = {}
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.70 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.70 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.70 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.70 base.py(105):         app_label = None
0.70 base.py(108):         app_config = apps.get_containing_app_config(module)
0.70 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.70 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.70 options.py(76):         self._get_fields_cache = {}
0.70 options.py(77):         self.local_fields = []
0.70 options.py(78):         self.local_many_to_many = []
0.70 options.py(79):         self.private_fields = []
0.70 options.py(80):         self.local_managers = []
0.70 options.py(81):         self.base_manager_name = None
0.70 options.py(82):         self.default_manager_name = None
0.70 options.py(83):         self.model_name = None
0.70 options.py(84):         self.verbose_name = None
0.70 options.py(85):         self.verbose_name_plural = None
0.70 options.py(86):         self.db_table = ''
0.70 options.py(87):         self.ordering = []
0.70 options.py(88):         self._ordering_clash = False
0.70 options.py(89):         self.indexes = []
0.70 options.py(90):         self.constraints = []
0.70 options.py(91):         self.unique_together = []
0.70 options.py(92):         self.index_together = []
0.70 options.py(93):         self.select_on_save = False
0.70 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.70 options.py(95):         self.permissions = []
0.70 options.py(96):         self.object_name = None
0.70 options.py(97):         self.app_label = app_label
0.70 options.py(98):         self.get_latest_by = None
0.70 options.py(99):         self.order_with_respect_to = None
0.70 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.70 options.py(101):         self.required_db_features = []
0.70 options.py(102):         self.required_db_vendor = None
0.70 options.py(103):         self.meta = meta
0.70 options.py(104):         self.pk = None
0.70 options.py(105):         self.auto_field = None
0.70 options.py(106):         self.abstract = False
0.70 options.py(107):         self.managed = True
0.70 options.py(108):         self.proxy = False
0.70 options.py(114):         self.proxy_for_model = None
0.70 options.py(118):         self.concrete_model = None
0.70 options.py(119):         self.swappable = None
0.70 options.py(120):         self.parents = {}
0.70 options.py(121):         self.auto_created = False
0.70 options.py(125):         self.related_fkey_lookups = []
0.70 options.py(128):         self.apps = self.default_apps
0.70 options.py(130):         self.default_related_name = None
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(150):         from django.db import connection
0.70 options.py(151):         from django.db.backends.utils import truncate_name
0.70 options.py(153):         cls._meta = self
0.70 options.py(154):         self.model = cls
0.70 options.py(156):         self.object_name = cls.__name__
0.70 options.py(157):         self.model_name = self.object_name.lower()
0.70 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.70 options.py(162):         self.original_attrs = {}
0.70 options.py(165):         if self.meta:
0.70 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(47):             return ()
0.70 options.py(182):             self.index_together = normalize_together(self.index_together)
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(47):             return ()
0.70 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(187):                     objs = getattr(self, attr_name, [])
0.70 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.70 options.py(212):         new_objs = []
0.70 options.py(213):         for obj in objs:
0.70 options.py(220):         return new_objs
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(187):                     objs = getattr(self, attr_name, [])
0.70 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.70 options.py(212):         new_objs = []
0.70 options.py(213):         for obj in objs:
0.70 options.py(220):         return new_objs
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(192):             if self.verbose_name_plural is None:
0.70 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.70 options.py(199):             if meta_attrs != {}:
0.70 options.py(203):         del self.meta
0.70 options.py(206):         if not self.db_table:
0.70 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.70 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.70 base.py(123):         if not abstract:
0.70 base.py(124):             new_class.add_to_class(
0.70 base.py(125):                 'DoesNotExist',
0.70 base.py(126):                 subclass_exception(
0.70 base.py(127):                     'DoesNotExist',
0.70 base.py(128):                     tuple(
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(130):                     ) or (ObjectDoesNotExist,),
0.70 base.py(131):                     module,
0.70 base.py(132):                     attached_to=new_class))
0.70 base.py(61):     return type(name, bases, {
0.70 base.py(62):         '__module__': module,
0.70 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(328):             setattr(cls, name, value)
0.70 base.py(133):             new_class.add_to_class(
0.70 base.py(134):                 'MultipleObjectsReturned',
0.70 base.py(135):                 subclass_exception(
0.70 base.py(136):                     'MultipleObjectsReturned',
0.70 base.py(137):                     tuple(
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(139):                     ) or (MultipleObjectsReturned,),
0.70 base.py(140):                     module,
0.70 base.py(141):                     attached_to=new_class))
0.70 base.py(61):     return type(name, bases, {
0.70 base.py(62):         '__module__': module,
0.70 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(328):             setattr(cls, name, value)
0.70 base.py(142):             if base_meta and not base_meta.abstract:
0.70 base.py(151):         is_proxy = new_class._meta.proxy
0.70 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(271):         if private:
0.70 options.py(273):         elif field.is_relation and field.many_to_many:
0.70 options.py(276):             bisect.insort(self.local_fields, field)
0.70 options.py(277):             self.setup_pk(field)
0.70 options.py(297):         if not self.pk and field.primary_key:
0.70 options.py(298):             self.pk = field
0.70 options.py(299):             field.serialize = False
0.70 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.70 options.py(294):             self._expire_cache(reverse=False)
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(271):         if private:
0.70 options.py(273):         elif field.is_relation and field.many_to_many:
0.70 options.py(276):             bisect.insort(self.local_fields, field)
0.70 options.py(277):             self.setup_pk(field)
0.70 options.py(297):         if not self.pk and field.primary_key:
0.70 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.70 options.py(294):             self._expire_cache(reverse=False)
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(271):         if private:
0.70 options.py(273):         elif field.is_relation and field.many_to_many:
0.70 options.py(276):             bisect.insort(self.local_fields, field)
0.70 options.py(277):             self.setup_pk(field)
0.70 options.py(297):         if not self.pk and field.primary_key:
0.70 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.70 options.py(294):             self._expire_cache(reverse=False)
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(263):         self.local_managers.append(manager)
0.70 options.py(264):         self._expire_cache()
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(164):         new_fields = chain(
0.70 base.py(165):             new_class._meta.local_fields,
0.70 base.py(166):             new_class._meta.local_many_to_many,
0.70 base.py(167):             new_class._meta.private_fields
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(172):         if is_proxy:
0.70 base.py(192):             new_class._meta.concrete_model = new_class
0.70 base.py(195):         parent_links = {}
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(198):             if not hasattr(base, '_meta'):
0.70 base.py(199):                 continue
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(198):             if not hasattr(base, '_meta'):
0.70 base.py(201):             if base != new_class and not base._meta.abstract:
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(205):                 if isinstance(field, OneToOneField):
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(205):                 if isinstance(field, OneToOneField):
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(205):                 if isinstance(field, OneToOneField):
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(210):         inherited_attributes = set()
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.70 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.70 base.py(312):         if abstract:
0.70 base.py(320):         new_class._prepare()
0.70 base.py(332):         opts = cls._meta
0.70 base.py(333):         opts._prepare(cls)
0.70 options.py(223):         if self.order_with_respect_to:
0.70 options.py(239):             self.order_with_respect_to = None
0.70 options.py(241):         if self.pk is None:
0.70 base.py(335):         if opts.order_with_respect_to:
0.70 base.py(350):         if cls.__doc__ is None:
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 options.py(456):         def is_not_an_m2m_field(f):
0.70 options.py(459):         def is_not_a_generic_relation(f):
0.70 options.py(462):         def is_not_a_generic_foreign_key(f):
0.70 options.py(467):         return make_immutable_fields_list(
0.70 options.py(468):             "fields",
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.70 options.py(773):         topmost_call = seen_models is None
0.70 options.py(774):         if topmost_call:
0.70 options.py(775):             seen_models = set()
0.70 options.py(776):         seen_models.add(self.model)
0.70 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.70 options.py(781):         try:
0.70 options.py(784):             return self._get_fields_cache[cache_key]
0.70 options.py(785):         except KeyError:
0.70 options.py(786):             pass
0.70 options.py(788):         fields = []
0.70 options.py(791):         if include_parents is not False:
0.70 options.py(792):             for parent in self.parents:
0.70 options.py(806):         if reverse and not self.proxy:
0.70 options.py(817):         if forward:
0.70 options.py(818):             fields += self.local_fields
0.70 options.py(819):             fields += self.local_many_to_many
0.70 options.py(825):             if topmost_call:
0.70 options.py(826):                 fields += self.private_fields
0.70 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(833):         self._get_fields_cache[cache_key] = fields
0.70 options.py(834):         return fields
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.70 options.py(457):             return not (f.is_relation and f.many_to_many)
0.70 options.py(460):             return not (f.is_relation and f.one_to_many)
0.70 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.70 options.py(457):             return not (f.is_relation and f.many_to_many)
0.70 options.py(460):             return not (f.is_relation and f.one_to_many)
0.70 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.70 options.py(457):             return not (f.is_relation and f.many_to_many)
0.70 options.py(460):             return not (f.is_relation and f.one_to_many)
0.70 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.70 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.70 base.py(354):         if get_absolute_url_override:
0.70 base.py(357):         if not opts.managers:
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 base.py(370):         for index in cls._meta.indexes:
0.70 base.py(374):         class_prepared.send(sender=cls)
0.70 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.70 base.py(322):         return new_class
0.70 base.py(75):         super_new = super().__new__
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(80):         if not parents:
0.70 base.py(84):         module = attrs.pop('__module__')
0.70 base.py(85):         new_attrs = {'__module__': module}
0.70 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.70 base.py(87):         if classcell is not None:
0.70 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.70 base.py(93):         contributable_attrs = {}
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.70 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.70 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.70 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.70 base.py(105):         app_label = None
0.70 base.py(108):         app_config = apps.get_containing_app_config(module)
0.70 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.70 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.70 options.py(76):         self._get_fields_cache = {}
0.70 options.py(77):         self.local_fields = []
0.70 options.py(78):         self.local_many_to_many = []
0.70 options.py(79):         self.private_fields = []
0.70 options.py(80):         self.local_managers = []
0.70 options.py(81):         self.base_manager_name = None
0.70 options.py(82):         self.default_manager_name = None
0.70 options.py(83):         self.model_name = None
0.70 options.py(84):         self.verbose_name = None
0.70 options.py(85):         self.verbose_name_plural = None
0.70 options.py(86):         self.db_table = ''
0.70 options.py(87):         self.ordering = []
0.70 options.py(88):         self._ordering_clash = False
0.70 options.py(89):         self.indexes = []
0.70 options.py(90):         self.constraints = []
0.70 options.py(91):         self.unique_together = []
0.70 options.py(92):         self.index_together = []
0.70 options.py(93):         self.select_on_save = False
0.70 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.70 options.py(95):         self.permissions = []
0.70 options.py(96):         self.object_name = None
0.70 options.py(97):         self.app_label = app_label
0.70 options.py(98):         self.get_latest_by = None
0.70 options.py(99):         self.order_with_respect_to = None
0.70 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.70 options.py(101):         self.required_db_features = []
0.70 options.py(102):         self.required_db_vendor = None
0.70 options.py(103):         self.meta = meta
0.70 options.py(104):         self.pk = None
0.70 options.py(105):         self.auto_field = None
0.70 options.py(106):         self.abstract = False
0.70 options.py(107):         self.managed = True
0.70 options.py(108):         self.proxy = False
0.70 options.py(114):         self.proxy_for_model = None
0.70 options.py(118):         self.concrete_model = None
0.70 options.py(119):         self.swappable = None
0.70 options.py(120):         self.parents = {}
0.70 options.py(121):         self.auto_created = False
0.70 options.py(125):         self.related_fkey_lookups = []
0.70 options.py(128):         self.apps = self.default_apps
0.70 options.py(130):         self.default_related_name = None
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(150):         from django.db import connection
0.70 options.py(151):         from django.db.backends.utils import truncate_name
0.70 options.py(153):         cls._meta = self
0.70 options.py(154):         self.model = cls
0.70 options.py(156):         self.object_name = cls.__name__
0.70 options.py(157):         self.model_name = self.object_name.lower()
0.70 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.70 options.py(162):         self.original_attrs = {}
0.70 options.py(165):         if self.meta:
0.70 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(177):                 elif hasattr(self.meta, attr_name):
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(174):                 if attr_name in meta_attrs:
0.70 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.70 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.70 options.py(173):             for attr_name in DEFAULT_NAMES:
0.70 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(47):             return ()
0.70 options.py(182):             self.index_together = normalize_together(self.index_together)
0.70 options.py(45):     try:
0.70 options.py(46):         if not option_together:
0.70 options.py(47):             return ()
0.70 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(187):                     objs = getattr(self, attr_name, [])
0.70 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.70 options.py(212):         new_objs = []
0.70 options.py(213):         for obj in objs:
0.70 options.py(220):         return new_objs
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(187):                     objs = getattr(self, attr_name, [])
0.70 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.70 options.py(212):         new_objs = []
0.70 options.py(213):         for obj in objs:
0.70 options.py(220):         return new_objs
0.70 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.70 options.py(192):             if self.verbose_name_plural is None:
0.70 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.70 options.py(199):             if meta_attrs != {}:
0.70 options.py(203):         del self.meta
0.70 options.py(206):         if not self.db_table:
0.70 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.70 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.70 base.py(123):         if not abstract:
0.70 base.py(124):             new_class.add_to_class(
0.70 base.py(125):                 'DoesNotExist',
0.70 base.py(126):                 subclass_exception(
0.70 base.py(127):                     'DoesNotExist',
0.70 base.py(128):                     tuple(
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(130):                     ) or (ObjectDoesNotExist,),
0.70 base.py(131):                     module,
0.70 base.py(132):                     attached_to=new_class))
0.70 base.py(61):     return type(name, bases, {
0.70 base.py(62):         '__module__': module,
0.70 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(328):             setattr(cls, name, value)
0.70 base.py(133):             new_class.add_to_class(
0.70 base.py(134):                 'MultipleObjectsReturned',
0.70 base.py(135):                 subclass_exception(
0.70 base.py(136):                     'MultipleObjectsReturned',
0.70 base.py(137):                     tuple(
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.70 base.py(139):                     ) or (MultipleObjectsReturned,),
0.70 base.py(140):                     module,
0.70 base.py(141):                     attached_to=new_class))
0.70 base.py(61):     return type(name, bases, {
0.70 base.py(62):         '__module__': module,
0.70 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(328):             setattr(cls, name, value)
0.70 base.py(142):             if base_meta and not base_meta.abstract:
0.70 base.py(151):         is_proxy = new_class._meta.proxy
0.70 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(271):         if private:
0.70 options.py(273):         elif field.is_relation and field.many_to_many:
0.70 options.py(276):             bisect.insort(self.local_fields, field)
0.70 options.py(277):             self.setup_pk(field)
0.70 options.py(297):         if not self.pk and field.primary_key:
0.70 options.py(298):             self.pk = field
0.70 options.py(299):             field.serialize = False
0.70 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.70 options.py(294):             self._expire_cache(reverse=False)
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(271):         if private:
0.70 options.py(273):         elif field.is_relation and field.many_to_many:
0.70 options.py(276):             bisect.insort(self.local_fields, field)
0.70 options.py(277):             self.setup_pk(field)
0.70 options.py(297):         if not self.pk and field.primary_key:
0.70 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.70 options.py(294):             self._expire_cache(reverse=False)
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(161):             new_class.add_to_class(obj_name, obj)
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(263):         self.local_managers.append(manager)
0.70 options.py(264):         self._expire_cache()
0.70 options.py(728):         if forward:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(730):                 if cache_key in self.__dict__:
0.70 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.70 options.py(732):         if reverse and not self.abstract:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(734):                 if cache_key in self.__dict__:
0.70 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.70 options.py(736):         self._get_fields_cache = {}
0.70 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.70 base.py(164):         new_fields = chain(
0.70 base.py(165):             new_class._meta.local_fields,
0.70 base.py(166):             new_class._meta.local_many_to_many,
0.70 base.py(167):             new_class._meta.private_fields
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(169):         field_names = {f.name for f in new_fields}
0.70 base.py(172):         if is_proxy:
0.70 base.py(192):             new_class._meta.concrete_model = new_class
0.70 base.py(195):         parent_links = {}
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(198):             if not hasattr(base, '_meta'):
0.70 base.py(199):                 continue
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(198):             if not hasattr(base, '_meta'):
0.70 base.py(201):             if base != new_class and not base._meta.abstract:
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(205):                 if isinstance(field, OneToOneField):
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(205):                 if isinstance(field, OneToOneField):
0.70 base.py(204):             for field in base._meta.local_fields:
0.70 base.py(196):         for base in reversed([new_class] + parents):
0.70 base.py(210):         inherited_attributes = set()
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.70 base.py(216):                 inherited_attributes.update(base.__dict__)
0.70 base.py(217):                 continue
0.70 base.py(212):         for base in new_class.mro():
0.70 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.70 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.70 base.py(312):         if abstract:
0.70 base.py(320):         new_class._prepare()
0.70 base.py(332):         opts = cls._meta
0.70 base.py(333):         opts._prepare(cls)
0.70 options.py(223):         if self.order_with_respect_to:
0.70 options.py(239):             self.order_with_respect_to = None
0.70 options.py(241):         if self.pk is None:
0.70 base.py(335):         if opts.order_with_respect_to:
0.70 base.py(350):         if cls.__doc__ is None:
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 options.py(456):         def is_not_an_m2m_field(f):
0.70 options.py(459):         def is_not_a_generic_relation(f):
0.70 options.py(462):         def is_not_a_generic_foreign_key(f):
0.70 options.py(467):         return make_immutable_fields_list(
0.70 options.py(468):             "fields",
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.70 options.py(773):         topmost_call = seen_models is None
0.70 options.py(774):         if topmost_call:
0.70 options.py(775):             seen_models = set()
0.70 options.py(776):         seen_models.add(self.model)
0.70 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.70 options.py(781):         try:
0.70 options.py(784):             return self._get_fields_cache[cache_key]
0.70 options.py(785):         except KeyError:
0.70 options.py(786):             pass
0.70 options.py(788):         fields = []
0.70 options.py(791):         if include_parents is not False:
0.70 options.py(792):             for parent in self.parents:
0.70 options.py(806):         if reverse and not self.proxy:
0.70 options.py(817):         if forward:
0.70 options.py(818):             fields += self.local_fields
0.70 options.py(819):             fields += self.local_many_to_many
0.70 options.py(825):             if topmost_call:
0.70 options.py(826):                 fields += self.private_fields
0.70 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(833):         self._get_fields_cache[cache_key] = fields
0.70 options.py(834):         return fields
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.70 options.py(457):             return not (f.is_relation and f.many_to_many)
0.70 options.py(460):             return not (f.is_relation and f.one_to_many)
0.70 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.70 options.py(457):             return not (f.is_relation and f.many_to_many)
0.70 options.py(460):             return not (f.is_relation and f.one_to_many)
0.70 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.70 options.py(469):             (f for f in self._get_fields(reverse=False)
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.70 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.70 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.70 base.py(354):         if get_absolute_url_override:
0.70 base.py(357):         if not opts.managers:
0.70 options.py(365):         managers = []
0.70 options.py(366):         seen_managers = set()
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(370):                 if manager.name in seen_managers:
0.70 options.py(373):                 manager = copy.copy(manager)
0.70 options.py(374):                 manager.model = self.model
0.70 options.py(375):                 seen_managers.add(manager.name)
0.70 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.70 options.py(369):             for manager in base._meta.local_managers:
0.70 options.py(368):         for depth, base in enumerate(bases):
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.70 options.py(378):         return make_immutable_fields_list(
0.70 options.py(379):             "managers",
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 options.py(380):             (m[2] for m in sorted(managers)),
0.70 base.py(370):         for index in cls._meta.indexes:
0.70 base.py(374):         class_prepared.send(sender=cls)
0.70 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.70 base.py(322):         return new_class
0.70 base.py(75):         super_new = super().__new__
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.70 base.py(80):         if not parents:
0.70 base.py(84):         module = attrs.pop('__module__')
0.70 base.py(85):         new_attrs = {'__module__': module}
0.70 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.70 base.py(87):         if classcell is not None:
0.70 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.70 base.py(93):         contributable_attrs = {}
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(95):             if _has_contribute_to_class(obj):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(96):                 contributable_attrs[obj_name] = obj
0.70 base.py(94):         for obj_name, obj in list(attrs.items()):
0.70 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.70 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.70 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.70 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.70 base.py(105):         app_label = None
0.70 base.py(108):         app_config = apps.get_containing_app_config(module)
0.70 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.70 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.70 options.py(76):         self._get_fields_cache = {}
0.70 options.py(77):         self.local_fields = []
0.70 options.py(78):         self.local_many_to_many = []
0.70 options.py(79):         self.private_fields = []
0.70 options.py(80):         self.local_managers = []
0.70 options.py(81):         self.base_manager_name = None
0.70 options.py(82):         self.default_manager_name = None
0.70 options.py(83):         self.model_name = None
0.70 options.py(84):         self.verbose_name = None
0.70 options.py(85):         self.verbose_name_plural = None
0.70 options.py(86):         self.db_table = ''
0.70 options.py(87):         self.ordering = []
0.70 options.py(88):         self._ordering_clash = False
0.70 options.py(89):         self.indexes = []
0.70 options.py(90):         self.constraints = []
0.70 options.py(91):         self.unique_together = []
0.70 options.py(92):         self.index_together = []
0.70 options.py(93):         self.select_on_save = False
0.70 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.70 options.py(95):         self.permissions = []
0.70 options.py(96):         self.object_name = None
0.70 options.py(97):         self.app_label = app_label
0.70 options.py(98):         self.get_latest_by = None
0.70 options.py(99):         self.order_with_respect_to = None
0.70 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.70 options.py(101):         self.required_db_features = []
0.70 options.py(102):         self.required_db_vendor = None
0.70 options.py(103):         self.meta = meta
0.70 options.py(104):         self.pk = None
0.70 options.py(105):         self.auto_field = None
0.70 options.py(106):         self.abstract = False
0.70 options.py(107):         self.managed = True
0.70 options.py(108):         self.proxy = False
0.70 options.py(114):         self.proxy_for_model = None
0.70 options.py(118):         self.concrete_model = None
0.70 options.py(119):         self.swappable = None
0.70 options.py(120):         self.parents = {}
0.70 options.py(121):         self.auto_created = False
0.70 options.py(125):         self.related_fkey_lookups = []
0.70 options.py(128):         self.apps = self.default_apps
0.70 options.py(130):         self.default_related_name = None
0.70 base.py(325):         if _has_contribute_to_class(value):
0.70 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.70 base.py(326):             value.contribute_to_class(cls, name)
0.70 options.py(150):         from django.db import connection
0.70 options.py(151):         from django.db.backends.utils import truncate_name
0.70 options.py(153):         cls._meta = self
0.70 options.py(154):         self.model = cls
0.70 options.py(156):         self.object_name = cls.__name__
0.70 options.py(157):         self.model_name = self.object_name.lower()
0.70 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.70 options.py(162):         self.original_attrs = {}
0.70 options.py(165):         if self.meta:
0.70 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.70 options.py(172):                     del meta_attrs[name]
0.70 options.py(167):             for name in self.meta.__dict__:
0.70 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(182):             self.index_together = normalize_together(self.index_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(192):             if self.verbose_name_plural is None:
0.71 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.71 options.py(199):             if meta_attrs != {}:
0.71 options.py(203):         del self.meta
0.71 options.py(206):         if not self.db_table:
0.71 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.71 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.71 base.py(123):         if not abstract:
0.71 base.py(124):             new_class.add_to_class(
0.71 base.py(125):                 'DoesNotExist',
0.71 base.py(126):                 subclass_exception(
0.71 base.py(127):                     'DoesNotExist',
0.71 base.py(128):                     tuple(
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(130):                     ) or (ObjectDoesNotExist,),
0.71 base.py(131):                     module,
0.71 base.py(132):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(133):             new_class.add_to_class(
0.71 base.py(134):                 'MultipleObjectsReturned',
0.71 base.py(135):                 subclass_exception(
0.71 base.py(136):                     'MultipleObjectsReturned',
0.71 base.py(137):                     tuple(
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(139):                     ) or (MultipleObjectsReturned,),
0.71 base.py(140):                     module,
0.71 base.py(141):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(142):             if base_meta and not base_meta.abstract:
0.71 base.py(151):         is_proxy = new_class._meta.proxy
0.71 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(298):             self.pk = field
0.71 options.py(299):             field.serialize = False
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(263):         self.local_managers.append(manager)
0.71 options.py(264):         self._expire_cache()
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(164):         new_fields = chain(
0.71 base.py(165):             new_class._meta.local_fields,
0.71 base.py(166):             new_class._meta.local_many_to_many,
0.71 base.py(167):             new_class._meta.private_fields
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(172):         if is_proxy:
0.71 base.py(192):             new_class._meta.concrete_model = new_class
0.71 base.py(195):         parent_links = {}
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(199):                 continue
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(201):             if base != new_class and not base._meta.abstract:
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(210):         inherited_attributes = set()
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(312):         if abstract:
0.71 base.py(320):         new_class._prepare()
0.71 base.py(332):         opts = cls._meta
0.71 base.py(333):         opts._prepare(cls)
0.71 options.py(223):         if self.order_with_respect_to:
0.71 options.py(239):             self.order_with_respect_to = None
0.71 options.py(241):         if self.pk is None:
0.71 base.py(335):         if opts.order_with_respect_to:
0.71 base.py(350):         if cls.__doc__ is None:
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 options.py(456):         def is_not_an_m2m_field(f):
0.71 options.py(459):         def is_not_a_generic_relation(f):
0.71 options.py(462):         def is_not_a_generic_foreign_key(f):
0.71 options.py(467):         return make_immutable_fields_list(
0.71 options.py(468):             "fields",
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.71 options.py(773):         topmost_call = seen_models is None
0.71 options.py(774):         if topmost_call:
0.71 options.py(775):             seen_models = set()
0.71 options.py(776):         seen_models.add(self.model)
0.71 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.71 options.py(781):         try:
0.71 options.py(784):             return self._get_fields_cache[cache_key]
0.71 options.py(785):         except KeyError:
0.71 options.py(786):             pass
0.71 options.py(788):         fields = []
0.71 options.py(791):         if include_parents is not False:
0.71 options.py(792):             for parent in self.parents:
0.71 options.py(806):         if reverse and not self.proxy:
0.71 options.py(817):         if forward:
0.71 options.py(818):             fields += self.local_fields
0.71 options.py(819):             fields += self.local_many_to_many
0.71 options.py(825):             if topmost_call:
0.71 options.py(826):                 fields += self.private_fields
0.71 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(833):         self._get_fields_cache[cache_key] = fields
0.71 options.py(834):         return fields
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.71 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.71 base.py(354):         if get_absolute_url_override:
0.71 base.py(357):         if not opts.managers:
0.71 options.py(365):         managers = []
0.71 options.py(366):         seen_managers = set()
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(370):                 if manager.name in seen_managers:
0.71 options.py(373):                 manager = copy.copy(manager)
0.71 options.py(374):                 manager.model = self.model
0.71 options.py(375):                 seen_managers.add(manager.name)
0.71 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(378):         return make_immutable_fields_list(
0.71 options.py(379):             "managers",
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 base.py(370):         for index in cls._meta.indexes:
0.71 base.py(374):         class_prepared.send(sender=cls)
0.71 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.71 base.py(322):         return new_class
0.71 base.py(75):         super_new = super().__new__
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(80):         if not parents:
0.71 base.py(84):         module = attrs.pop('__module__')
0.71 base.py(85):         new_attrs = {'__module__': module}
0.71 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.71 base.py(87):         if classcell is not None:
0.71 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.71 base.py(93):         contributable_attrs = {}
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.71 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.71 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.71 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.71 base.py(105):         app_label = None
0.71 base.py(108):         app_config = apps.get_containing_app_config(module)
0.71 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.71 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.71 options.py(76):         self._get_fields_cache = {}
0.71 options.py(77):         self.local_fields = []
0.71 options.py(78):         self.local_many_to_many = []
0.71 options.py(79):         self.private_fields = []
0.71 options.py(80):         self.local_managers = []
0.71 options.py(81):         self.base_manager_name = None
0.71 options.py(82):         self.default_manager_name = None
0.71 options.py(83):         self.model_name = None
0.71 options.py(84):         self.verbose_name = None
0.71 options.py(85):         self.verbose_name_plural = None
0.71 options.py(86):         self.db_table = ''
0.71 options.py(87):         self.ordering = []
0.71 options.py(88):         self._ordering_clash = False
0.71 options.py(89):         self.indexes = []
0.71 options.py(90):         self.constraints = []
0.71 options.py(91):         self.unique_together = []
0.71 options.py(92):         self.index_together = []
0.71 options.py(93):         self.select_on_save = False
0.71 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.71 options.py(95):         self.permissions = []
0.71 options.py(96):         self.object_name = None
0.71 options.py(97):         self.app_label = app_label
0.71 options.py(98):         self.get_latest_by = None
0.71 options.py(99):         self.order_with_respect_to = None
0.71 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.71 options.py(101):         self.required_db_features = []
0.71 options.py(102):         self.required_db_vendor = None
0.71 options.py(103):         self.meta = meta
0.71 options.py(104):         self.pk = None
0.71 options.py(105):         self.auto_field = None
0.71 options.py(106):         self.abstract = False
0.71 options.py(107):         self.managed = True
0.71 options.py(108):         self.proxy = False
0.71 options.py(114):         self.proxy_for_model = None
0.71 options.py(118):         self.concrete_model = None
0.71 options.py(119):         self.swappable = None
0.71 options.py(120):         self.parents = {}
0.71 options.py(121):         self.auto_created = False
0.71 options.py(125):         self.related_fkey_lookups = []
0.71 options.py(128):         self.apps = self.default_apps
0.71 options.py(130):         self.default_related_name = None
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(150):         from django.db import connection
0.71 options.py(151):         from django.db.backends.utils import truncate_name
0.71 options.py(153):         cls._meta = self
0.71 options.py(154):         self.model = cls
0.71 options.py(156):         self.object_name = cls.__name__
0.71 options.py(157):         self.model_name = self.object_name.lower()
0.71 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.71 options.py(162):         self.original_attrs = {}
0.71 options.py(165):         if self.meta:
0.71 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(182):             self.index_together = normalize_together(self.index_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(192):             if self.verbose_name_plural is None:
0.71 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.71 options.py(199):             if meta_attrs != {}:
0.71 options.py(203):         del self.meta
0.71 options.py(206):         if not self.db_table:
0.71 base.py(123):         if not abstract:
0.71 base.py(124):             new_class.add_to_class(
0.71 base.py(125):                 'DoesNotExist',
0.71 base.py(126):                 subclass_exception(
0.71 base.py(127):                     'DoesNotExist',
0.71 base.py(128):                     tuple(
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(130):                     ) or (ObjectDoesNotExist,),
0.71 base.py(131):                     module,
0.71 base.py(132):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(133):             new_class.add_to_class(
0.71 base.py(134):                 'MultipleObjectsReturned',
0.71 base.py(135):                 subclass_exception(
0.71 base.py(136):                     'MultipleObjectsReturned',
0.71 base.py(137):                     tuple(
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(139):                     ) or (MultipleObjectsReturned,),
0.71 base.py(140):                     module,
0.71 base.py(141):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(142):             if base_meta and not base_meta.abstract:
0.71 base.py(151):         is_proxy = new_class._meta.proxy
0.71 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(298):             self.pk = field
0.71 options.py(299):             field.serialize = False
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(263):         self.local_managers.append(manager)
0.71 options.py(264):         self._expire_cache()
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(164):         new_fields = chain(
0.71 base.py(165):             new_class._meta.local_fields,
0.71 base.py(166):             new_class._meta.local_many_to_many,
0.71 base.py(167):             new_class._meta.private_fields
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(172):         if is_proxy:
0.71 base.py(192):             new_class._meta.concrete_model = new_class
0.71 base.py(195):         parent_links = {}
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(199):                 continue
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(201):             if base != new_class and not base._meta.abstract:
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(210):         inherited_attributes = set()
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(312):         if abstract:
0.71 base.py(320):         new_class._prepare()
0.71 base.py(332):         opts = cls._meta
0.71 base.py(333):         opts._prepare(cls)
0.71 options.py(223):         if self.order_with_respect_to:
0.71 options.py(239):             self.order_with_respect_to = None
0.71 options.py(241):         if self.pk is None:
0.71 base.py(335):         if opts.order_with_respect_to:
0.71 base.py(350):         if cls.__doc__ is None:
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 options.py(456):         def is_not_an_m2m_field(f):
0.71 options.py(459):         def is_not_a_generic_relation(f):
0.71 options.py(462):         def is_not_a_generic_foreign_key(f):
0.71 options.py(467):         return make_immutable_fields_list(
0.71 options.py(468):             "fields",
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.71 options.py(773):         topmost_call = seen_models is None
0.71 options.py(774):         if topmost_call:
0.71 options.py(775):             seen_models = set()
0.71 options.py(776):         seen_models.add(self.model)
0.71 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.71 options.py(781):         try:
0.71 options.py(784):             return self._get_fields_cache[cache_key]
0.71 options.py(785):         except KeyError:
0.71 options.py(786):             pass
0.71 options.py(788):         fields = []
0.71 options.py(791):         if include_parents is not False:
0.71 options.py(792):             for parent in self.parents:
0.71 options.py(806):         if reverse and not self.proxy:
0.71 options.py(817):         if forward:
0.71 options.py(818):             fields += self.local_fields
0.71 options.py(819):             fields += self.local_many_to_many
0.71 options.py(825):             if topmost_call:
0.71 options.py(826):                 fields += self.private_fields
0.71 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(833):         self._get_fields_cache[cache_key] = fields
0.71 options.py(834):         return fields
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.71 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.71 base.py(354):         if get_absolute_url_override:
0.71 base.py(357):         if not opts.managers:
0.71 options.py(365):         managers = []
0.71 options.py(366):         seen_managers = set()
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(370):                 if manager.name in seen_managers:
0.71 options.py(373):                 manager = copy.copy(manager)
0.71 options.py(374):                 manager.model = self.model
0.71 options.py(375):                 seen_managers.add(manager.name)
0.71 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(378):         return make_immutable_fields_list(
0.71 options.py(379):             "managers",
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 base.py(370):         for index in cls._meta.indexes:
0.71 base.py(374):         class_prepared.send(sender=cls)
0.71 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.71 base.py(322):         return new_class
0.71 base.py(75):         super_new = super().__new__
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.71 base.py(80):         if not parents:
0.71 base.py(84):         module = attrs.pop('__module__')
0.71 base.py(85):         new_attrs = {'__module__': module}
0.71 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.71 base.py(87):         if classcell is not None:
0.71 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.71 base.py(93):         contributable_attrs = {}
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(95):             if _has_contribute_to_class(obj):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(96):                 contributable_attrs[obj_name] = obj
0.71 base.py(94):         for obj_name, obj in list(attrs.items()):
0.71 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.71 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.71 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.71 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.71 base.py(105):         app_label = None
0.71 base.py(108):         app_config = apps.get_containing_app_config(module)
0.71 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.71 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.71 options.py(76):         self._get_fields_cache = {}
0.71 options.py(77):         self.local_fields = []
0.71 options.py(78):         self.local_many_to_many = []
0.71 options.py(79):         self.private_fields = []
0.71 options.py(80):         self.local_managers = []
0.71 options.py(81):         self.base_manager_name = None
0.71 options.py(82):         self.default_manager_name = None
0.71 options.py(83):         self.model_name = None
0.71 options.py(84):         self.verbose_name = None
0.71 options.py(85):         self.verbose_name_plural = None
0.71 options.py(86):         self.db_table = ''
0.71 options.py(87):         self.ordering = []
0.71 options.py(88):         self._ordering_clash = False
0.71 options.py(89):         self.indexes = []
0.71 options.py(90):         self.constraints = []
0.71 options.py(91):         self.unique_together = []
0.71 options.py(92):         self.index_together = []
0.71 options.py(93):         self.select_on_save = False
0.71 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.71 options.py(95):         self.permissions = []
0.71 options.py(96):         self.object_name = None
0.71 options.py(97):         self.app_label = app_label
0.71 options.py(98):         self.get_latest_by = None
0.71 options.py(99):         self.order_with_respect_to = None
0.71 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.71 options.py(101):         self.required_db_features = []
0.71 options.py(102):         self.required_db_vendor = None
0.71 options.py(103):         self.meta = meta
0.71 options.py(104):         self.pk = None
0.71 options.py(105):         self.auto_field = None
0.71 options.py(106):         self.abstract = False
0.71 options.py(107):         self.managed = True
0.71 options.py(108):         self.proxy = False
0.71 options.py(114):         self.proxy_for_model = None
0.71 options.py(118):         self.concrete_model = None
0.71 options.py(119):         self.swappable = None
0.71 options.py(120):         self.parents = {}
0.71 options.py(121):         self.auto_created = False
0.71 options.py(125):         self.related_fkey_lookups = []
0.71 options.py(128):         self.apps = self.default_apps
0.71 options.py(130):         self.default_related_name = None
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(150):         from django.db import connection
0.71 options.py(151):         from django.db.backends.utils import truncate_name
0.71 options.py(153):         cls._meta = self
0.71 options.py(154):         self.model = cls
0.71 options.py(156):         self.object_name = cls.__name__
0.71 options.py(157):         self.model_name = self.object_name.lower()
0.71 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.71 options.py(162):         self.original_attrs = {}
0.71 options.py(165):         if self.meta:
0.71 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(171):                 if name.startswith('_'):
0.71 options.py(172):                     del meta_attrs[name]
0.71 options.py(167):             for name in self.meta.__dict__:
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(177):                 elif hasattr(self.meta, attr_name):
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(174):                 if attr_name in meta_attrs:
0.71 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.71 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.71 options.py(173):             for attr_name in DEFAULT_NAMES:
0.71 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(182):             self.index_together = normalize_together(self.index_together)
0.71 options.py(45):     try:
0.71 options.py(46):         if not option_together:
0.71 options.py(47):             return ()
0.71 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(187):                     objs = getattr(self, attr_name, [])
0.71 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.71 options.py(212):         new_objs = []
0.71 options.py(213):         for obj in objs:
0.71 options.py(220):         return new_objs
0.71 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.71 options.py(192):             if self.verbose_name_plural is None:
0.71 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.71 options.py(199):             if meta_attrs != {}:
0.71 options.py(203):         del self.meta
0.71 options.py(206):         if not self.db_table:
0.71 base.py(123):         if not abstract:
0.71 base.py(124):             new_class.add_to_class(
0.71 base.py(125):                 'DoesNotExist',
0.71 base.py(126):                 subclass_exception(
0.71 base.py(127):                     'DoesNotExist',
0.71 base.py(128):                     tuple(
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(130):                     ) or (ObjectDoesNotExist,),
0.71 base.py(131):                     module,
0.71 base.py(132):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(133):             new_class.add_to_class(
0.71 base.py(134):                 'MultipleObjectsReturned',
0.71 base.py(135):                 subclass_exception(
0.71 base.py(136):                     'MultipleObjectsReturned',
0.71 base.py(137):                     tuple(
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.71 base.py(139):                     ) or (MultipleObjectsReturned,),
0.71 base.py(140):                     module,
0.71 base.py(141):                     attached_to=new_class))
0.71 base.py(61):     return type(name, bases, {
0.71 base.py(62):         '__module__': module,
0.71 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(328):             setattr(cls, name, value)
0.71 base.py(142):             if base_meta and not base_meta.abstract:
0.71 base.py(151):         is_proxy = new_class._meta.proxy
0.71 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(298):             self.pk = field
0.71 options.py(299):             field.serialize = False
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(271):         if private:
0.71 options.py(273):         elif field.is_relation and field.many_to_many:
0.71 options.py(276):             bisect.insort(self.local_fields, field)
0.71 options.py(277):             self.setup_pk(field)
0.71 options.py(297):         if not self.pk and field.primary_key:
0.71 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.71 options.py(294):             self._expire_cache(reverse=False)
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(161):             new_class.add_to_class(obj_name, obj)
0.71 base.py(325):         if _has_contribute_to_class(value):
0.71 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.71 base.py(326):             value.contribute_to_class(cls, name)
0.71 options.py(263):         self.local_managers.append(manager)
0.71 options.py(264):         self._expire_cache()
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.71 base.py(164):         new_fields = chain(
0.71 base.py(165):             new_class._meta.local_fields,
0.71 base.py(166):             new_class._meta.local_many_to_many,
0.71 base.py(167):             new_class._meta.private_fields
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(169):         field_names = {f.name for f in new_fields}
0.71 base.py(172):         if is_proxy:
0.71 base.py(192):             new_class._meta.concrete_model = new_class
0.71 base.py(195):         parent_links = {}
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(199):                 continue
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(198):             if not hasattr(base, '_meta'):
0.71 base.py(201):             if base != new_class and not base._meta.abstract:
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(205):                 if isinstance(field, OneToOneField):
0.71 base.py(204):             for field in base._meta.local_fields:
0.71 base.py(196):         for base in reversed([new_class] + parents):
0.71 base.py(210):         inherited_attributes = set()
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.71 base.py(216):                 inherited_attributes.update(base.__dict__)
0.71 base.py(217):                 continue
0.71 base.py(212):         for base in new_class.mro():
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.71 base.py(312):         if abstract:
0.71 base.py(320):         new_class._prepare()
0.71 base.py(332):         opts = cls._meta
0.71 base.py(333):         opts._prepare(cls)
0.71 options.py(223):         if self.order_with_respect_to:
0.71 options.py(239):             self.order_with_respect_to = None
0.71 options.py(241):         if self.pk is None:
0.71 base.py(335):         if opts.order_with_respect_to:
0.71 base.py(350):         if cls.__doc__ is None:
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 options.py(456):         def is_not_an_m2m_field(f):
0.71 options.py(459):         def is_not_a_generic_relation(f):
0.71 options.py(462):         def is_not_a_generic_foreign_key(f):
0.71 options.py(467):         return make_immutable_fields_list(
0.71 options.py(468):             "fields",
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.71 options.py(773):         topmost_call = seen_models is None
0.71 options.py(774):         if topmost_call:
0.71 options.py(775):             seen_models = set()
0.71 options.py(776):         seen_models.add(self.model)
0.71 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.71 options.py(781):         try:
0.71 options.py(784):             return self._get_fields_cache[cache_key]
0.71 options.py(785):         except KeyError:
0.71 options.py(786):             pass
0.71 options.py(788):         fields = []
0.71 options.py(791):         if include_parents is not False:
0.71 options.py(792):             for parent in self.parents:
0.71 options.py(806):         if reverse and not self.proxy:
0.71 options.py(817):         if forward:
0.71 options.py(818):             fields += self.local_fields
0.71 options.py(819):             fields += self.local_many_to_many
0.71 options.py(825):             if topmost_call:
0.71 options.py(826):                 fields += self.private_fields
0.71 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(833):         self._get_fields_cache[cache_key] = fields
0.71 options.py(834):         return fields
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.71 options.py(457):             return not (f.is_relation and f.many_to_many)
0.71 options.py(460):             return not (f.is_relation and f.one_to_many)
0.71 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.71 options.py(469):             (f for f in self._get_fields(reverse=False)
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.71 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.71 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.71 base.py(354):         if get_absolute_url_override:
0.71 base.py(357):         if not opts.managers:
0.71 options.py(365):         managers = []
0.71 options.py(366):         seen_managers = set()
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(370):                 if manager.name in seen_managers:
0.71 options.py(373):                 manager = copy.copy(manager)
0.71 options.py(374):                 manager.model = self.model
0.71 options.py(375):                 seen_managers.add(manager.name)
0.71 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.71 options.py(369):             for manager in base._meta.local_managers:
0.71 options.py(368):         for depth, base in enumerate(bases):
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.71 options.py(378):         return make_immutable_fields_list(
0.71 options.py(379):             "managers",
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 options.py(380):             (m[2] for m in sorted(managers)),
0.71 base.py(370):         for index in cls._meta.indexes:
0.71 base.py(374):         class_prepared.send(sender=cls)
0.71 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.71 base.py(322):         return new_class
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 options.py(347):         if self.swappable:
0.71 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.71 options.py(349):             if swapped_for:
0.71 options.py(350):                 try:
0.71 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.71 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.71 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.71 options.py(361):         return None
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(728):         if forward:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(731):                     delattr(self, cache_key)
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(730):                 if cache_key in self.__dict__:
0.71 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.71 options.py(732):         if reverse and not self.abstract:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(734):                 if cache_key in self.__dict__:
0.71 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.71 options.py(736):         self._get_fields_cache = {}
Synchronizing apps without migrations:
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(347):         if self.swappable:
0.71 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.71 options.py(349):             if swapped_for:
0.71 options.py(350):                 try:
0.71 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.71 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.71 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.71 options.py(361):         return None
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
  Creating tables...
0.71 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.71 options.py(347):         if self.swappable:
0.71 options.py(361):         return None
0.71 options.py(323):         if isinstance(connection, str):
0.71 options.py(325):         if self.required_db_vendor:
0.71 options.py(327):         if self.required_db_features:
0.71 options.py(330):         return True
    Creating table django_content_type
0.71 options.py(564):         try:
0.71 options.py(567):             return self._forward_fields_map[field_name]
0.71 options.py(532):         res = {}
0.71 options.py(533):         fields = self._get_fields(reverse=False)
0.71 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.71 options.py(773):         topmost_call = seen_models is None
0.71 options.py(774):         if topmost_call:
0.71 options.py(775):             seen_models = set()
0.71 options.py(776):         seen_models.add(self.model)
0.71 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.71 options.py(781):         try:
0.71 options.py(784):             return self._get_fields_cache[cache_key]
0.71 options.py(785):         except KeyError:
0.71 options.py(786):             pass
0.71 options.py(788):         fields = []
0.71 options.py(791):         if include_parents is not False:
0.71 options.py(792):             for parent in self.parents:
0.71 options.py(806):         if reverse and not self.proxy:
0.71 options.py(817):         if forward:
0.71 options.py(818):             fields += self.local_fields
0.71 options.py(819):             fields += self.local_many_to_many
0.71 options.py(825):             if topmost_call:
0.71 options.py(826):                 fields += self.private_fields
0.71 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.71 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.71 options.py(833):         self._get_fields_cache[cache_key] = fields
0.71 options.py(834):         return fields
0.71 options.py(534):         for field in fields:
0.71 options.py(535):             res[field.name] = field
0.71 options.py(539):             try:
0.71 options.py(540):                 res[field.attname] = field
0.71 options.py(534):         for field in fields:
0.71 options.py(535):             res[field.name] = field
0.71 options.py(539):             try:
0.71 options.py(540):                 res[field.attname] = field
0.71 options.py(534):         for field in fields:
0.71 options.py(535):             res[field.name] = field
0.71 options.py(539):             try:
0.71 options.py(540):                 res[field.attname] = field
0.71 options.py(534):         for field in fields:
0.71 options.py(543):         return res
0.71 options.py(564):         try:
0.71 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(323):         if isinstance(connection, str):
0.72 options.py(325):         if self.required_db_vendor:
0.72 options.py(327):         if self.required_db_features:
0.72 options.py(330):         return True
    Creating table auth_permission
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(323):         if isinstance(connection, str):
0.72 options.py(325):         if self.required_db_vendor:
0.72 options.py(327):         if self.required_db_features:
0.72 options.py(330):         return True
    Creating table auth_group
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.72 options.py(347):         if self.swappable:
0.72 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.72 options.py(349):             if swapped_for:
0.72 options.py(350):                 try:
0.72 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.72 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.72 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.72 options.py(361):         return None
0.72 options.py(323):         if isinstance(connection, str):
0.72 options.py(325):         if self.required_db_vendor:
0.72 options.py(327):         if self.required_db_features:
0.72 options.py(330):         return True
    Creating table auth_user
0.72 options.py(347):         if self.swappable:
0.72 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.72 options.py(349):             if swapped_for:
0.72 options.py(350):                 try:
0.72 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.72 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.72 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.72 options.py(361):         return None
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(532):         res = {}
0.72 options.py(533):         fields = self._get_fields(reverse=False)
0.72 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.72 options.py(773):         topmost_call = seen_models is None
0.72 options.py(774):         if topmost_call:
0.72 options.py(775):             seen_models = set()
0.72 options.py(776):         seen_models.add(self.model)
0.72 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.72 options.py(781):         try:
0.72 options.py(784):             return self._get_fields_cache[cache_key]
0.72 options.py(785):         except KeyError:
0.72 options.py(786):             pass
0.72 options.py(788):         fields = []
0.72 options.py(791):         if include_parents is not False:
0.72 options.py(792):             for parent in self.parents:
0.72 options.py(806):         if reverse and not self.proxy:
0.72 options.py(817):         if forward:
0.72 options.py(818):             fields += self.local_fields
0.72 options.py(819):             fields += self.local_many_to_many
0.72 options.py(825):             if topmost_call:
0.72 options.py(826):                 fields += self.private_fields
0.72 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.72 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.72 options.py(833):         self._get_fields_cache[cache_key] = fields
0.72 options.py(834):         return fields
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(535):             res[field.name] = field
0.72 options.py(539):             try:
0.72 options.py(540):                 res[field.attname] = field
0.72 options.py(534):         for field in fields:
0.72 options.py(543):         return res
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(564):         try:
0.72 options.py(567):             return self._forward_fields_map[field_name]
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
0.72 options.py(323):         if isinstance(connection, str):
0.72 options.py(325):         if self.required_db_vendor:
0.72 options.py(327):         if self.required_db_features:
0.72 options.py(330):         return True
    Creating table django_session
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
    Running deferred SQL...
Running migrations:
0.72 options.py(347):         if self.swappable:
0.72 options.py(361):         return None
  Applying admin.0001_initial...0.73 options.py(748):         if include_parents is False:
0.73 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(792):             for parent in self.parents:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(810):             all_fields = self._relation_tree
0.73 options.py(723):         return self._populate_directed_relation_graph()
0.73 options.py(692):         related_objects_graph = defaultdict(list)
0.73 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.73 options.py(349):             if swapped_for:
0.73 options.py(350):                 try:
0.73 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.73 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(695):         for model in all_models:
0.73 options.py(696):             opts = model._meta
0.73 options.py(699):             if opts.abstract:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(705):             for f in fields_with_relations:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(695):         for model in all_models:
0.73 options.py(696):             opts = model._meta
0.73 options.py(699):             if opts.abstract:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(705):             for f in fields_with_relations:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(695):         for model in all_models:
0.73 options.py(696):             opts = model._meta
0.73 options.py(699):             if opts.abstract:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(705):             for f in fields_with_relations:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(695):         for model in all_models:
0.73 options.py(696):             opts = model._meta
0.73 options.py(699):             if opts.abstract:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(705):             for f in fields_with_relations:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(695):         for model in all_models:
0.73 options.py(696):             opts = model._meta
0.73 options.py(699):             if opts.abstract:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(705):             for f in fields_with_relations:
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(703):                 if f.is_relation and f.related_model is not None
0.73 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.73 options.py(695):         for model in all_models:
0.73 options.py(709):         for model in all_models:
0.73 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.73 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.73 options.py(709):         for model in all_models:
0.73 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.73 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.73 options.py(709):         for model in all_models:
0.73 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.73 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.73 options.py(709):         for model in all_models:
0.73 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.73 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.73 options.py(709):         for model in all_models:
0.73 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.73 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.73 options.py(709):         for model in all_models:
0.73 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
0.73 options.py(811):             for field in all_fields:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(748):         if include_parents is False:
0.73 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(792):             for parent in self.parents:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(810):             all_fields = self._relation_tree
0.73 options.py(811):             for field in all_fields:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(735):                     delattr(self, cache_key)
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(735):                     delattr(self, cache_key)
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(735):                     delattr(self, cache_key)
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(75):         super_new = super().__new__
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(80):         if not parents:
0.73 base.py(84):         module = attrs.pop('__module__')
0.73 base.py(85):         new_attrs = {'__module__': module}
0.73 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.73 base.py(87):         if classcell is not None:
0.73 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.73 base.py(93):         contributable_attrs = {}
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.73 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.73 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.73 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.73 base.py(105):         app_label = None
0.73 base.py(108):         app_config = apps.get_containing_app_config(module)
0.73 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.73 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.73 options.py(76):         self._get_fields_cache = {}
0.73 options.py(77):         self.local_fields = []
0.73 options.py(78):         self.local_many_to_many = []
0.73 options.py(79):         self.private_fields = []
0.73 options.py(80):         self.local_managers = []
0.73 options.py(81):         self.base_manager_name = None
0.73 options.py(82):         self.default_manager_name = None
0.73 options.py(83):         self.model_name = None
0.73 options.py(84):         self.verbose_name = None
0.73 options.py(85):         self.verbose_name_plural = None
0.73 options.py(86):         self.db_table = ''
0.73 options.py(87):         self.ordering = []
0.73 options.py(88):         self._ordering_clash = False
0.73 options.py(89):         self.indexes = []
0.73 options.py(90):         self.constraints = []
0.73 options.py(91):         self.unique_together = []
0.73 options.py(92):         self.index_together = []
0.73 options.py(93):         self.select_on_save = False
0.73 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.73 options.py(95):         self.permissions = []
0.73 options.py(96):         self.object_name = None
0.73 options.py(97):         self.app_label = app_label
0.73 options.py(98):         self.get_latest_by = None
0.73 options.py(99):         self.order_with_respect_to = None
0.73 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.73 options.py(101):         self.required_db_features = []
0.73 options.py(102):         self.required_db_vendor = None
0.73 options.py(103):         self.meta = meta
0.73 options.py(104):         self.pk = None
0.73 options.py(105):         self.auto_field = None
0.73 options.py(106):         self.abstract = False
0.73 options.py(107):         self.managed = True
0.73 options.py(108):         self.proxy = False
0.73 options.py(114):         self.proxy_for_model = None
0.73 options.py(118):         self.concrete_model = None
0.73 options.py(119):         self.swappable = None
0.73 options.py(120):         self.parents = {}
0.73 options.py(121):         self.auto_created = False
0.73 options.py(125):         self.related_fkey_lookups = []
0.73 options.py(128):         self.apps = self.default_apps
0.73 options.py(130):         self.default_related_name = None
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(150):         from django.db import connection
0.73 options.py(151):         from django.db.backends.utils import truncate_name
0.73 options.py(153):         cls._meta = self
0.73 options.py(154):         self.model = cls
0.73 options.py(156):         self.object_name = cls.__name__
0.73 options.py(157):         self.model_name = self.object_name.lower()
0.73 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.73 options.py(162):         self.original_attrs = {}
0.73 options.py(165):         if self.meta:
0.73 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.73 options.py(45):     try:
0.73 options.py(46):         if not option_together:
0.73 options.py(47):             return ()
0.73 options.py(182):             self.index_together = normalize_together(self.index_together)
0.73 options.py(45):     try:
0.73 options.py(46):         if not option_together:
0.73 options.py(47):             return ()
0.73 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(187):                     objs = getattr(self, attr_name, [])
0.73 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.73 options.py(212):         new_objs = []
0.73 options.py(213):         for obj in objs:
0.73 options.py(220):         return new_objs
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(187):                     objs = getattr(self, attr_name, [])
0.73 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.73 options.py(212):         new_objs = []
0.73 options.py(213):         for obj in objs:
0.73 options.py(220):         return new_objs
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(192):             if self.verbose_name_plural is None:
0.73 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.73 options.py(199):             if meta_attrs != {}:
0.73 options.py(203):         del self.meta
0.73 options.py(206):         if not self.db_table:
0.73 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.73 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.73 base.py(123):         if not abstract:
0.73 base.py(124):             new_class.add_to_class(
0.73 base.py(125):                 'DoesNotExist',
0.73 base.py(126):                 subclass_exception(
0.73 base.py(127):                     'DoesNotExist',
0.73 base.py(128):                     tuple(
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(130):                     ) or (ObjectDoesNotExist,),
0.73 base.py(131):                     module,
0.73 base.py(132):                     attached_to=new_class))
0.73 base.py(61):     return type(name, bases, {
0.73 base.py(62):         '__module__': module,
0.73 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(328):             setattr(cls, name, value)
0.73 base.py(133):             new_class.add_to_class(
0.73 base.py(134):                 'MultipleObjectsReturned',
0.73 base.py(135):                 subclass_exception(
0.73 base.py(136):                     'MultipleObjectsReturned',
0.73 base.py(137):                     tuple(
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(139):                     ) or (MultipleObjectsReturned,),
0.73 base.py(140):                     module,
0.73 base.py(141):                     attached_to=new_class))
0.73 base.py(61):     return type(name, bases, {
0.73 base.py(62):         '__module__': module,
0.73 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(328):             setattr(cls, name, value)
0.73 base.py(142):             if base_meta and not base_meta.abstract:
0.73 base.py(151):         is_proxy = new_class._meta.proxy
0.73 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(298):             self.pk = field
0.73 options.py(299):             field.serialize = False
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(263):         self.local_managers.append(manager)
0.73 options.py(264):         self._expire_cache()
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(164):         new_fields = chain(
0.73 base.py(165):             new_class._meta.local_fields,
0.73 base.py(166):             new_class._meta.local_many_to_many,
0.73 base.py(167):             new_class._meta.private_fields
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(172):         if is_proxy:
0.73 base.py(192):             new_class._meta.concrete_model = new_class
0.73 base.py(195):         parent_links = {}
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(198):             if not hasattr(base, '_meta'):
0.73 base.py(199):                 continue
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(198):             if not hasattr(base, '_meta'):
0.73 base.py(201):             if base != new_class and not base._meta.abstract:
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(210):         inherited_attributes = set()
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.73 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.73 base.py(312):         if abstract:
0.73 base.py(320):         new_class._prepare()
0.73 base.py(332):         opts = cls._meta
0.73 base.py(333):         opts._prepare(cls)
0.73 options.py(223):         if self.order_with_respect_to:
0.73 options.py(239):             self.order_with_respect_to = None
0.73 options.py(241):         if self.pk is None:
0.73 base.py(335):         if opts.order_with_respect_to:
0.73 base.py(350):         if cls.__doc__ is None:
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 options.py(456):         def is_not_an_m2m_field(f):
0.73 options.py(459):         def is_not_a_generic_relation(f):
0.73 options.py(462):         def is_not_a_generic_foreign_key(f):
0.73 options.py(467):         return make_immutable_fields_list(
0.73 options.py(468):             "fields",
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(792):             for parent in self.parents:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 base.py(354):         if get_absolute_url_override:
0.73 base.py(357):         if not opts.managers:
0.73 options.py(365):         managers = []
0.73 options.py(366):         seen_managers = set()
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(368):         for depth, base in enumerate(bases):
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(369):             for manager in base._meta.local_managers:
0.73 options.py(370):                 if manager.name in seen_managers:
0.73 options.py(373):                 manager = copy.copy(manager)
0.73 options.py(374):                 manager.model = self.model
0.73 options.py(375):                 seen_managers.add(manager.name)
0.73 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.73 options.py(369):             for manager in base._meta.local_managers:
0.73 options.py(368):         for depth, base in enumerate(bases):
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(378):         return make_immutable_fields_list(
0.73 options.py(379):             "managers",
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 base.py(370):         for index in cls._meta.indexes:
0.73 base.py(374):         class_prepared.send(sender=cls)
0.73 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.73 base.py(322):         return new_class
0.73 base.py(75):         super_new = super().__new__
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.73 base.py(80):         if not parents:
0.73 base.py(84):         module = attrs.pop('__module__')
0.73 base.py(85):         new_attrs = {'__module__': module}
0.73 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.73 base.py(87):         if classcell is not None:
0.73 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.73 base.py(93):         contributable_attrs = {}
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(95):             if _has_contribute_to_class(obj):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(96):                 contributable_attrs[obj_name] = obj
0.73 base.py(94):         for obj_name, obj in list(attrs.items()):
0.73 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.73 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.73 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.73 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.73 base.py(105):         app_label = None
0.73 base.py(108):         app_config = apps.get_containing_app_config(module)
0.73 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.73 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.73 options.py(76):         self._get_fields_cache = {}
0.73 options.py(77):         self.local_fields = []
0.73 options.py(78):         self.local_many_to_many = []
0.73 options.py(79):         self.private_fields = []
0.73 options.py(80):         self.local_managers = []
0.73 options.py(81):         self.base_manager_name = None
0.73 options.py(82):         self.default_manager_name = None
0.73 options.py(83):         self.model_name = None
0.73 options.py(84):         self.verbose_name = None
0.73 options.py(85):         self.verbose_name_plural = None
0.73 options.py(86):         self.db_table = ''
0.73 options.py(87):         self.ordering = []
0.73 options.py(88):         self._ordering_clash = False
0.73 options.py(89):         self.indexes = []
0.73 options.py(90):         self.constraints = []
0.73 options.py(91):         self.unique_together = []
0.73 options.py(92):         self.index_together = []
0.73 options.py(93):         self.select_on_save = False
0.73 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.73 options.py(95):         self.permissions = []
0.73 options.py(96):         self.object_name = None
0.73 options.py(97):         self.app_label = app_label
0.73 options.py(98):         self.get_latest_by = None
0.73 options.py(99):         self.order_with_respect_to = None
0.73 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.73 options.py(101):         self.required_db_features = []
0.73 options.py(102):         self.required_db_vendor = None
0.73 options.py(103):         self.meta = meta
0.73 options.py(104):         self.pk = None
0.73 options.py(105):         self.auto_field = None
0.73 options.py(106):         self.abstract = False
0.73 options.py(107):         self.managed = True
0.73 options.py(108):         self.proxy = False
0.73 options.py(114):         self.proxy_for_model = None
0.73 options.py(118):         self.concrete_model = None
0.73 options.py(119):         self.swappable = None
0.73 options.py(120):         self.parents = {}
0.73 options.py(121):         self.auto_created = False
0.73 options.py(125):         self.related_fkey_lookups = []
0.73 options.py(128):         self.apps = self.default_apps
0.73 options.py(130):         self.default_related_name = None
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(150):         from django.db import connection
0.73 options.py(151):         from django.db.backends.utils import truncate_name
0.73 options.py(153):         cls._meta = self
0.73 options.py(154):         self.model = cls
0.73 options.py(156):         self.object_name = cls.__name__
0.73 options.py(157):         self.model_name = self.object_name.lower()
0.73 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.73 options.py(162):         self.original_attrs = {}
0.73 options.py(165):         if self.meta:
0.73 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(171):                 if name.startswith('_'):
0.73 options.py(172):                     del meta_attrs[name]
0.73 options.py(167):             for name in self.meta.__dict__:
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(177):                 elif hasattr(self.meta, attr_name):
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(174):                 if attr_name in meta_attrs:
0.73 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.73 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.73 options.py(173):             for attr_name in DEFAULT_NAMES:
0.73 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.73 options.py(45):     try:
0.73 options.py(46):         if not option_together:
0.73 options.py(47):             return ()
0.73 options.py(182):             self.index_together = normalize_together(self.index_together)
0.73 options.py(45):     try:
0.73 options.py(46):         if not option_together:
0.73 options.py(47):             return ()
0.73 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(187):                     objs = getattr(self, attr_name, [])
0.73 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.73 options.py(212):         new_objs = []
0.73 options.py(213):         for obj in objs:
0.73 options.py(220):         return new_objs
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(187):                     objs = getattr(self, attr_name, [])
0.73 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.73 options.py(212):         new_objs = []
0.73 options.py(213):         for obj in objs:
0.73 options.py(220):         return new_objs
0.73 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.73 options.py(192):             if self.verbose_name_plural is None:
0.73 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.73 options.py(199):             if meta_attrs != {}:
0.73 options.py(203):         del self.meta
0.73 options.py(206):         if not self.db_table:
0.73 base.py(123):         if not abstract:
0.73 base.py(124):             new_class.add_to_class(
0.73 base.py(125):                 'DoesNotExist',
0.73 base.py(126):                 subclass_exception(
0.73 base.py(127):                     'DoesNotExist',
0.73 base.py(128):                     tuple(
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(130):                     ) or (ObjectDoesNotExist,),
0.73 base.py(131):                     module,
0.73 base.py(132):                     attached_to=new_class))
0.73 base.py(61):     return type(name, bases, {
0.73 base.py(62):         '__module__': module,
0.73 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(328):             setattr(cls, name, value)
0.73 base.py(133):             new_class.add_to_class(
0.73 base.py(134):                 'MultipleObjectsReturned',
0.73 base.py(135):                 subclass_exception(
0.73 base.py(136):                     'MultipleObjectsReturned',
0.73 base.py(137):                     tuple(
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.73 base.py(139):                     ) or (MultipleObjectsReturned,),
0.73 base.py(140):                     module,
0.73 base.py(141):                     attached_to=new_class))
0.73 base.py(61):     return type(name, bases, {
0.73 base.py(62):         '__module__': module,
0.73 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(328):             setattr(cls, name, value)
0.73 base.py(142):             if base_meta and not base_meta.abstract:
0.73 base.py(151):         is_proxy = new_class._meta.proxy
0.73 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(298):             self.pk = field
0.73 options.py(299):             field.serialize = False
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(271):         if private:
0.73 options.py(273):         elif field.is_relation and field.many_to_many:
0.73 options.py(276):             bisect.insort(self.local_fields, field)
0.73 options.py(277):             self.setup_pk(field)
0.73 options.py(297):         if not self.pk and field.primary_key:
0.73 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.73 options.py(294):             self._expire_cache(reverse=False)
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(161):             new_class.add_to_class(obj_name, obj)
0.73 base.py(325):         if _has_contribute_to_class(value):
0.73 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.73 base.py(326):             value.contribute_to_class(cls, name)
0.73 options.py(263):         self.local_managers.append(manager)
0.73 options.py(264):         self._expire_cache()
0.73 options.py(728):         if forward:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(730):                 if cache_key in self.__dict__:
0.73 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.73 options.py(732):         if reverse and not self.abstract:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(734):                 if cache_key in self.__dict__:
0.73 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.73 options.py(736):         self._get_fields_cache = {}
0.73 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.73 base.py(164):         new_fields = chain(
0.73 base.py(165):             new_class._meta.local_fields,
0.73 base.py(166):             new_class._meta.local_many_to_many,
0.73 base.py(167):             new_class._meta.private_fields
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(169):         field_names = {f.name for f in new_fields}
0.73 base.py(172):         if is_proxy:
0.73 base.py(192):             new_class._meta.concrete_model = new_class
0.73 base.py(195):         parent_links = {}
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(198):             if not hasattr(base, '_meta'):
0.73 base.py(199):                 continue
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(198):             if not hasattr(base, '_meta'):
0.73 base.py(201):             if base != new_class and not base._meta.abstract:
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(205):                 if isinstance(field, OneToOneField):
0.73 base.py(204):             for field in base._meta.local_fields:
0.73 base.py(196):         for base in reversed([new_class] + parents):
0.73 base.py(210):         inherited_attributes = set()
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.73 base.py(216):                 inherited_attributes.update(base.__dict__)
0.73 base.py(217):                 continue
0.73 base.py(212):         for base in new_class.mro():
0.73 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.73 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.73 base.py(312):         if abstract:
0.73 base.py(320):         new_class._prepare()
0.73 base.py(332):         opts = cls._meta
0.73 base.py(333):         opts._prepare(cls)
0.73 options.py(223):         if self.order_with_respect_to:
0.73 options.py(239):             self.order_with_respect_to = None
0.73 options.py(241):         if self.pk is None:
0.73 base.py(335):         if opts.order_with_respect_to:
0.73 base.py(350):         if cls.__doc__ is None:
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 options.py(456):         def is_not_an_m2m_field(f):
0.73 options.py(459):         def is_not_a_generic_relation(f):
0.73 options.py(462):         def is_not_a_generic_foreign_key(f):
0.73 options.py(467):         return make_immutable_fields_list(
0.73 options.py(468):             "fields",
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.73 options.py(773):         topmost_call = seen_models is None
0.73 options.py(774):         if topmost_call:
0.73 options.py(775):             seen_models = set()
0.73 options.py(776):         seen_models.add(self.model)
0.73 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.73 options.py(781):         try:
0.73 options.py(784):             return self._get_fields_cache[cache_key]
0.73 options.py(785):         except KeyError:
0.73 options.py(786):             pass
0.73 options.py(788):         fields = []
0.73 options.py(791):         if include_parents is not False:
0.73 options.py(792):             for parent in self.parents:
0.73 options.py(806):         if reverse and not self.proxy:
0.73 options.py(817):         if forward:
0.73 options.py(818):             fields += self.local_fields
0.73 options.py(819):             fields += self.local_many_to_many
0.73 options.py(825):             if topmost_call:
0.73 options.py(826):                 fields += self.private_fields
0.73 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(833):         self._get_fields_cache[cache_key] = fields
0.73 options.py(834):         return fields
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.73 options.py(457):             return not (f.is_relation and f.many_to_many)
0.73 options.py(460):             return not (f.is_relation and f.one_to_many)
0.73 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.73 options.py(469):             (f for f in self._get_fields(reverse=False)
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.73 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 base.py(354):         if get_absolute_url_override:
0.73 base.py(357):         if not opts.managers:
0.73 options.py(365):         managers = []
0.73 options.py(366):         seen_managers = set()
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(368):         for depth, base in enumerate(bases):
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(369):             for manager in base._meta.local_managers:
0.73 options.py(370):                 if manager.name in seen_managers:
0.73 options.py(373):                 manager = copy.copy(manager)
0.73 options.py(374):                 manager.model = self.model
0.73 options.py(375):                 seen_managers.add(manager.name)
0.73 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.73 options.py(369):             for manager in base._meta.local_managers:
0.73 options.py(368):         for depth, base in enumerate(bases):
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.73 options.py(378):         return make_immutable_fields_list(
0.73 options.py(379):             "managers",
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 options.py(380):             (m[2] for m in sorted(managers)),
0.73 base.py(370):         for index in cls._meta.indexes:
0.73 base.py(374):         class_prepared.send(sender=cls)
0.73 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.73 base.py(322):         return new_class
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.73 options.py(349):             if swapped_for:
0.73 options.py(350):                 try:
0.73 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.73 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.73 options.py(349):             if swapped_for:
0.73 options.py(350):                 try:
0.73 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.73 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 options.py(361):         return None
0.73 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(361):         return None
0.73 options.py(347):         if self.swappable:
0.73 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.73 options.py(349):             if swapped_for:
0.73 options.py(350):                 try:
0.73 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.73 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.73 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.73 options.py(361):         return None
0.73 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.74 base.py(75):         super_new = super().__new__
0.74 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.74 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.74 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.74 base.py(80):         if not parents:
0.74 base.py(84):         module = attrs.pop('__module__')
0.74 base.py(85):         new_attrs = {'__module__': module}
0.74 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.74 base.py(87):         if classcell is not None:
0.74 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.74 base.py(93):         contributable_attrs = {}
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(95):             if _has_contribute_to_class(obj):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(96):                 contributable_attrs[obj_name] = obj
0.74 base.py(94):         for obj_name, obj in list(attrs.items()):
0.74 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.74 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.74 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.74 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.74 base.py(105):         app_label = None
0.74 base.py(108):         app_config = apps.get_containing_app_config(module)
0.74 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.74 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.74 options.py(76):         self._get_fields_cache = {}
0.74 options.py(77):         self.local_fields = []
0.74 options.py(78):         self.local_many_to_many = []
0.74 options.py(79):         self.private_fields = []
0.74 options.py(80):         self.local_managers = []
0.74 options.py(81):         self.base_manager_name = None
0.74 options.py(82):         self.default_manager_name = None
0.74 options.py(83):         self.model_name = None
0.74 options.py(84):         self.verbose_name = None
0.74 options.py(85):         self.verbose_name_plural = None
0.74 options.py(86):         self.db_table = ''
0.74 options.py(87):         self.ordering = []
0.74 options.py(88):         self._ordering_clash = False
0.74 options.py(89):         self.indexes = []
0.74 options.py(90):         self.constraints = []
0.74 options.py(91):         self.unique_together = []
0.74 options.py(92):         self.index_together = []
0.74 options.py(93):         self.select_on_save = False
0.74 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.74 options.py(95):         self.permissions = []
0.74 options.py(96):         self.object_name = None
0.74 options.py(97):         self.app_label = app_label
0.74 options.py(98):         self.get_latest_by = None
0.74 options.py(99):         self.order_with_respect_to = None
0.74 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.74 options.py(101):         self.required_db_features = []
0.74 options.py(102):         self.required_db_vendor = None
0.74 options.py(103):         self.meta = meta
0.74 options.py(104):         self.pk = None
0.74 options.py(105):         self.auto_field = None
0.74 options.py(106):         self.abstract = False
0.74 options.py(107):         self.managed = True
0.74 options.py(108):         self.proxy = False
0.74 options.py(114):         self.proxy_for_model = None
0.74 options.py(118):         self.concrete_model = None
0.74 options.py(119):         self.swappable = None
0.74 options.py(120):         self.parents = {}
0.74 options.py(121):         self.auto_created = False
0.74 options.py(125):         self.related_fkey_lookups = []
0.74 options.py(128):         self.apps = self.default_apps
0.74 options.py(130):         self.default_related_name = None
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(150):         from django.db import connection
0.74 options.py(151):         from django.db.backends.utils import truncate_name
0.74 options.py(153):         cls._meta = self
0.74 options.py(154):         self.model = cls
0.74 options.py(156):         self.object_name = cls.__name__
0.74 options.py(157):         self.model_name = self.object_name.lower()
0.74 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.74 options.py(162):         self.original_attrs = {}
0.74 options.py(165):         if self.meta:
0.74 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(172):                     del meta_attrs[name]
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(172):                     del meta_attrs[name]
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(172):                     del meta_attrs[name]
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(171):                 if name.startswith('_'):
0.74 options.py(172):                     del meta_attrs[name]
0.74 options.py(167):             for name in self.meta.__dict__:
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(177):                 elif hasattr(self.meta, attr_name):
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(174):                 if attr_name in meta_attrs:
0.74 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.74 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.74 options.py(173):             for attr_name in DEFAULT_NAMES:
0.74 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.74 options.py(45):     try:
0.74 options.py(46):         if not option_together:
0.74 options.py(47):             return ()
0.74 options.py(182):             self.index_together = normalize_together(self.index_together)
0.74 options.py(45):     try:
0.74 options.py(46):         if not option_together:
0.74 options.py(47):             return ()
0.74 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.74 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.74 options.py(187):                     objs = getattr(self, attr_name, [])
0.74 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.74 options.py(212):         new_objs = []
0.74 options.py(213):         for obj in objs:
0.74 options.py(220):         return new_objs
0.74 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.74 options.py(187):                     objs = getattr(self, attr_name, [])
0.74 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.74 options.py(212):         new_objs = []
0.74 options.py(213):         for obj in objs:
0.74 options.py(220):         return new_objs
0.74 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.74 options.py(192):             if self.verbose_name_plural is None:
0.74 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.74 options.py(199):             if meta_attrs != {}:
0.74 options.py(203):         del self.meta
0.74 options.py(206):         if not self.db_table:
0.74 base.py(123):         if not abstract:
0.74 base.py(124):             new_class.add_to_class(
0.74 base.py(125):                 'DoesNotExist',
0.74 base.py(126):                 subclass_exception(
0.74 base.py(127):                     'DoesNotExist',
0.74 base.py(128):                     tuple(
0.74 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(130):                     ) or (ObjectDoesNotExist,),
0.74 base.py(131):                     module,
0.74 base.py(132):                     attached_to=new_class))
0.74 base.py(61):     return type(name, bases, {
0.74 base.py(62):         '__module__': module,
0.74 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(328):             setattr(cls, name, value)
0.74 base.py(133):             new_class.add_to_class(
0.74 base.py(134):                 'MultipleObjectsReturned',
0.74 base.py(135):                 subclass_exception(
0.74 base.py(136):                     'MultipleObjectsReturned',
0.74 base.py(137):                     tuple(
0.74 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.74 base.py(139):                     ) or (MultipleObjectsReturned,),
0.74 base.py(140):                     module,
0.74 base.py(141):                     attached_to=new_class))
0.74 base.py(61):     return type(name, bases, {
0.74 base.py(62):         '__module__': module,
0.74 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(328):             setattr(cls, name, value)
0.74 base.py(142):             if base_meta and not base_meta.abstract:
0.74 base.py(151):         is_proxy = new_class._meta.proxy
0.74 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(298):             self.pk = field
0.74 options.py(299):             field.serialize = False
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(294):             self._expire_cache(reverse=False)
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(288):             try:
0.74 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.74 options.py(290):             except AttributeError:
0.74 options.py(291):                 pass
0.74 options.py(292):             self._expire_cache()
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(271):         if private:
0.74 options.py(273):         elif field.is_relation and field.many_to_many:
0.74 options.py(276):             bisect.insort(self.local_fields, field)
0.74 options.py(277):             self.setup_pk(field)
0.74 options.py(297):         if not self.pk and field.primary_key:
0.74 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.74 options.py(288):             try:
0.74 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.74 options.py(290):             except AttributeError:
0.74 options.py(291):                 pass
0.74 options.py(292):             self._expire_cache()
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(161):             new_class.add_to_class(obj_name, obj)
0.74 base.py(325):         if _has_contribute_to_class(value):
0.74 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.74 base.py(326):             value.contribute_to_class(cls, name)
0.74 options.py(263):         self.local_managers.append(manager)
0.74 options.py(264):         self._expire_cache()
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.74 base.py(164):         new_fields = chain(
0.74 base.py(165):             new_class._meta.local_fields,
0.74 base.py(166):             new_class._meta.local_many_to_many,
0.74 base.py(167):             new_class._meta.private_fields
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(169):         field_names = {f.name for f in new_fields}
0.74 base.py(172):         if is_proxy:
0.74 base.py(192):             new_class._meta.concrete_model = new_class
0.74 base.py(195):         parent_links = {}
0.74 base.py(196):         for base in reversed([new_class] + parents):
0.74 base.py(198):             if not hasattr(base, '_meta'):
0.74 base.py(199):                 continue
0.74 base.py(196):         for base in reversed([new_class] + parents):
0.74 base.py(198):             if not hasattr(base, '_meta'):
0.74 base.py(201):             if base != new_class and not base._meta.abstract:
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(205):                 if isinstance(field, OneToOneField):
0.74 base.py(204):             for field in base._meta.local_fields:
0.74 base.py(196):         for base in reversed([new_class] + parents):
0.74 base.py(210):         inherited_attributes = set()
0.74 base.py(212):         for base in new_class.mro():
0.74 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.74 base.py(216):                 inherited_attributes.update(base.__dict__)
0.74 base.py(217):                 continue
0.74 base.py(212):         for base in new_class.mro():
0.74 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.74 base.py(216):                 inherited_attributes.update(base.__dict__)
0.74 base.py(217):                 continue
0.74 base.py(212):         for base in new_class.mro():
0.74 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.74 base.py(216):                 inherited_attributes.update(base.__dict__)
0.74 base.py(217):                 continue
0.74 base.py(212):         for base in new_class.mro():
0.74 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.74 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.74 base.py(312):         if abstract:
0.74 base.py(320):         new_class._prepare()
0.74 base.py(332):         opts = cls._meta
0.74 base.py(333):         opts._prepare(cls)
0.74 options.py(223):         if self.order_with_respect_to:
0.74 options.py(239):             self.order_with_respect_to = None
0.74 options.py(241):         if self.pk is None:
0.74 base.py(335):         if opts.order_with_respect_to:
0.74 base.py(350):         if cls.__doc__ is None:
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 options.py(456):         def is_not_an_m2m_field(f):
0.74 options.py(459):         def is_not_a_generic_relation(f):
0.74 options.py(462):         def is_not_a_generic_foreign_key(f):
0.74 options.py(467):         return make_immutable_fields_list(
0.74 options.py(468):             "fields",
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.74 options.py(773):         topmost_call = seen_models is None
0.74 options.py(774):         if topmost_call:
0.74 options.py(775):             seen_models = set()
0.74 options.py(776):         seen_models.add(self.model)
0.74 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.74 options.py(781):         try:
0.74 options.py(784):             return self._get_fields_cache[cache_key]
0.74 options.py(785):         except KeyError:
0.74 options.py(786):             pass
0.74 options.py(788):         fields = []
0.74 options.py(791):         if include_parents is not False:
0.74 options.py(792):             for parent in self.parents:
0.74 options.py(806):         if reverse and not self.proxy:
0.74 options.py(817):         if forward:
0.74 options.py(818):             fields += self.local_fields
0.74 options.py(819):             fields += self.local_many_to_many
0.74 options.py(825):             if topmost_call:
0.74 options.py(826):                 fields += self.private_fields
0.74 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(833):         self._get_fields_cache[cache_key] = fields
0.74 options.py(834):         return fields
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.74 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.74 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.74 base.py(354):         if get_absolute_url_override:
0.74 base.py(357):         if not opts.managers:
0.74 options.py(365):         managers = []
0.74 options.py(366):         seen_managers = set()
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(368):         for depth, base in enumerate(bases):
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(369):             for manager in base._meta.local_managers:
0.74 options.py(370):                 if manager.name in seen_managers:
0.74 options.py(373):                 manager = copy.copy(manager)
0.74 options.py(374):                 manager.model = self.model
0.74 options.py(375):                 seen_managers.add(manager.name)
0.74 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.74 options.py(369):             for manager in base._meta.local_managers:
0.74 options.py(368):         for depth, base in enumerate(bases):
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(378):         return make_immutable_fields_list(
0.74 options.py(379):             "managers",
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 base.py(370):         for index in cls._meta.indexes:
0.74 base.py(374):         class_prepared.send(sender=cls)
0.74 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 base.py(322):         return new_class
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(347):         if self.swappable:
0.74 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.74 options.py(349):             if swapped_for:
0.74 options.py(350):                 try:
0.74 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.74 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.74 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(728):         if forward:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(731):                     delattr(self, cache_key)
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(730):                 if cache_key in self.__dict__:
0.74 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.74 options.py(732):         if reverse and not self.abstract:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(734):                 if cache_key in self.__dict__:
0.74 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.74 options.py(736):         self._get_fields_cache = {}
0.74 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(323):         if isinstance(connection, str):
0.74 options.py(324):             connection = connections[connection]
0.74 options.py(325):         if self.required_db_vendor:
0.74 options.py(327):         if self.required_db_features:
0.74 options.py(330):         return True
0.74 options.py(564):         try:
0.74 options.py(567):             return self._forward_fields_map[field_name]
0.74 options.py(532):         res = {}
0.74 options.py(533):         fields = self._get_fields(reverse=False)
0.74 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.74 options.py(773):         topmost_call = seen_models is None
0.74 options.py(774):         if topmost_call:
0.74 options.py(775):             seen_models = set()
0.74 options.py(776):         seen_models.add(self.model)
0.74 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.74 options.py(781):         try:
0.74 options.py(784):             return self._get_fields_cache[cache_key]
0.74 options.py(785):         except KeyError:
0.74 options.py(786):             pass
0.74 options.py(788):         fields = []
0.74 options.py(791):         if include_parents is not False:
0.74 options.py(792):             for parent in self.parents:
0.74 options.py(806):         if reverse and not self.proxy:
0.74 options.py(817):         if forward:
0.74 options.py(818):             fields += self.local_fields
0.74 options.py(819):             fields += self.local_many_to_many
0.74 options.py(825):             if topmost_call:
0.74 options.py(826):                 fields += self.private_fields
0.74 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(833):         self._get_fields_cache[cache_key] = fields
0.74 options.py(834):         return fields
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(543):         return res
0.74 options.py(564):         try:
0.74 options.py(567):             return self._forward_fields_map[field_name]
0.74 options.py(564):         try:
0.74 options.py(567):             return self._forward_fields_map[field_name]
0.74 options.py(532):         res = {}
0.74 options.py(533):         fields = self._get_fields(reverse=False)
0.74 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.74 options.py(773):         topmost_call = seen_models is None
0.74 options.py(774):         if topmost_call:
0.74 options.py(775):             seen_models = set()
0.74 options.py(776):         seen_models.add(self.model)
0.74 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.74 options.py(781):         try:
0.74 options.py(784):             return self._get_fields_cache[cache_key]
0.74 options.py(785):         except KeyError:
0.74 options.py(786):             pass
0.74 options.py(788):         fields = []
0.74 options.py(791):         if include_parents is not False:
0.74 options.py(792):             for parent in self.parents:
0.74 options.py(806):         if reverse and not self.proxy:
0.74 options.py(817):         if forward:
0.74 options.py(818):             fields += self.local_fields
0.74 options.py(819):             fields += self.local_many_to_many
0.74 options.py(825):             if topmost_call:
0.74 options.py(826):                 fields += self.private_fields
0.74 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(833):         self._get_fields_cache[cache_key] = fields
0.74 options.py(834):         return fields
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(535):             res[field.name] = field
0.74 options.py(539):             try:
0.74 options.py(540):                 res[field.attname] = field
0.74 options.py(534):         for field in fields:
0.74 options.py(543):         return res
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(347):         if self.swappable:
0.74 options.py(361):         return None
0.74 options.py(385):         return {manager.name: manager for manager in self.managers}
0.74 options.py(365):         managers = []
0.74 options.py(366):         seen_managers = set()
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(368):         for depth, base in enumerate(bases):
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(369):             for manager in base._meta.local_managers:
0.74 options.py(370):                 if manager.name in seen_managers:
0.74 options.py(373):                 manager = copy.copy(manager)
0.74 options.py(374):                 manager.model = self.model
0.74 options.py(375):                 seen_managers.add(manager.name)
0.74 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.74 options.py(369):             for manager in base._meta.local_managers:
0.74 options.py(368):         for depth, base in enumerate(bases):
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.74 options.py(378):         return make_immutable_fields_list(
0.74 options.py(379):             "managers",
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 options.py(380):             (m[2] for m in sorted(managers)),
0.74 options.py(385):         return {manager.name: manager for manager in self.managers}
0.74 options.py(385):         return {manager.name: manager for manager in self.managers}
0.74 base.py(408):         cls = self.__class__
0.74 base.py(409):         opts = self._meta
0.74 base.py(410):         _setattr = setattr
0.74 base.py(411):         _DEFERRED = DEFERRED
0.74 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.74 base.py(416):         self._state = ModelState()
0.74 base.py(422):         if len(args) > len(opts.concrete_fields):
0.74 options.py(482):         return make_immutable_fields_list(
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 options.py(456):         def is_not_an_m2m_field(f):
0.74 options.py(459):         def is_not_a_generic_relation(f):
0.74 options.py(462):         def is_not_a_generic_foreign_key(f):
0.74 options.py(467):         return make_immutable_fields_list(
0.74 options.py(468):             "fields",
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.74 options.py(773):         topmost_call = seen_models is None
0.74 options.py(774):         if topmost_call:
0.74 options.py(775):             seen_models = set()
0.74 options.py(776):         seen_models.add(self.model)
0.74 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.74 options.py(781):         try:
0.74 options.py(784):             return self._get_fields_cache[cache_key]
0.74 options.py(785):         except KeyError:
0.74 options.py(786):             pass
0.74 options.py(788):         fields = []
0.74 options.py(791):         if include_parents is not False:
0.74 options.py(792):             for parent in self.parents:
0.74 options.py(806):         if reverse and not self.proxy:
0.74 options.py(817):         if forward:
0.74 options.py(818):             fields += self.local_fields
0.74 options.py(819):             fields += self.local_many_to_many
0.74 options.py(825):             if topmost_call:
0.74 options.py(826):                 fields += self.private_fields
0.74 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(833):         self._get_fields_cache[cache_key] = fields
0.74 options.py(834):         return fields
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.74 options.py(457):             return not (f.is_relation and f.many_to_many)
0.74 options.py(460):             return not (f.is_relation and f.one_to_many)
0.74 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.74 options.py(469):             (f for f in self._get_fields(reverse=False)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.74 base.py(426):         if not kwargs:
0.74 base.py(438):             fields_iter = iter(opts.fields)
0.74 base.py(439):             for val, field in zip(args, fields_iter):
0.74 base.py(448):         for field in fields_iter:
0.74 base.py(449):             is_related_object = False
0.74 base.py(451):             if field.attname not in kwargs and field.column is None:
0.74 base.py(453):             if kwargs:
0.74 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.74 base.py(466):                     try:
0.74 base.py(467):                         val = kwargs.pop(field.attname)
0.74 base.py(468):                     except KeyError:
0.74 base.py(473):                         val = field.get_default()
0.74 base.py(477):             if is_related_object:
0.74 base.py(485):                 if val is not _DEFERRED:
0.74 base.py(486):                     _setattr(self, field.attname, val)
0.74 base.py(448):         for field in fields_iter:
0.74 base.py(449):             is_related_object = False
0.74 base.py(451):             if field.attname not in kwargs and field.column is None:
0.74 base.py(453):             if kwargs:
0.74 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.74 base.py(466):                     try:
0.74 base.py(467):                         val = kwargs.pop(field.attname)
0.74 base.py(477):             if is_related_object:
0.74 base.py(485):                 if val is not _DEFERRED:
0.74 base.py(486):                     _setattr(self, field.attname, val)
0.74 base.py(448):         for field in fields_iter:
0.74 base.py(449):             is_related_object = False
0.74 base.py(451):             if field.attname not in kwargs and field.column is None:
0.74 base.py(453):             if kwargs:
0.74 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.74 base.py(466):                     try:
0.74 base.py(467):                         val = kwargs.pop(field.attname)
0.74 base.py(477):             if is_related_object:
0.74 base.py(485):                 if val is not _DEFERRED:
0.74 base.py(486):                     _setattr(self, field.attname, val)
0.74 base.py(448):         for field in fields_iter:
0.74 base.py(449):             is_related_object = False
0.74 base.py(451):             if field.attname not in kwargs and field.column is None:
0.74 base.py(453):             if kwargs:
0.74 base.py(475):                 val = field.get_default()
0.74 base.py(477):             if is_related_object:
0.74 base.py(485):                 if val is not _DEFERRED:
0.74 base.py(486):                     _setattr(self, field.attname, val)
0.74 base.py(448):         for field in fields_iter:
0.74 base.py(488):         if kwargs:
0.74 base.py(502):         super().__init__()
0.74 base.py(503):         post_init.send(sender=cls, instance=self)
0.74 base.py(679):         for field in self._meta.concrete_fields:
0.74 base.py(682):             if field.is_relation and field.is_cached(self):
0.74 base.py(679):         for field in self._meta.concrete_fields:
0.74 base.py(682):             if field.is_relation and field.is_cached(self):
0.74 base.py(679):         for field in self._meta.concrete_fields:
0.74 base.py(682):             if field.is_relation and field.is_cached(self):
0.74 base.py(679):         for field in self._meta.concrete_fields:
0.74 base.py(682):             if field.is_relation and field.is_cached(self):
0.74 base.py(679):         for field in self._meta.concrete_fields:
0.74 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.74 base.py(710):         if force_insert and (force_update or update_fields):
0.74 base.py(713):         deferred_fields = self.get_deferred_fields()
0.74 base.py(583):         return {
0.74 base.py(584):             f.attname for f in self._meta.concrete_fields
0.74 base.py(583):         return {
0.74 base.py(584):             f.attname for f in self._meta.concrete_fields
0.74 base.py(585):             if f.attname not in self.__dict__
0.74 base.py(583):         return {
0.74 base.py(584):             f.attname for f in self._meta.concrete_fields
0.74 base.py(585):             if f.attname not in self.__dict__
0.74 base.py(583):         return {
0.74 base.py(584):             f.attname for f in self._meta.concrete_fields
0.74 base.py(585):             if f.attname not in self.__dict__
0.74 base.py(583):         return {
0.74 base.py(584):             f.attname for f in self._meta.concrete_fields
0.74 base.py(585):             if f.attname not in self.__dict__
0.74 base.py(583):         return {
0.74 base.py(714):         if update_fields is not None:
0.74 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.74 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.74 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.74 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.74 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.74 base.py(766):         assert update_fields is None or update_fields
0.74 base.py(767):         cls = origin = self.__class__
0.74 base.py(769):         if cls._meta.proxy:
0.74 base.py(771):         meta = cls._meta
0.74 base.py(772):         if not meta.auto_created:
0.74 base.py(773):             pre_save.send(
0.74 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.74 base.py(775):                 update_fields=update_fields,
0.74 base.py(778):         if meta.parents:
0.74 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.74 base.py(782):         with context_manager:
0.74 base.py(783):             parent_inserted = False
0.74 base.py(784):             if not raw:
0.74 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.74 base.py(806):         meta = cls._meta
0.74 base.py(807):         inserted = False
0.74 base.py(808):         for parent, field in meta.parents.items():
0.74 base.py(830):         return inserted
0.74 base.py(786):             updated = self._save_table(
0.74 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.74 base.py(788):                 force_update, using, update_fields,
0.74 base.py(838):         meta = cls._meta
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 options.py(495):         return make_immutable_fields_list(
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.74 base.py(841):         if update_fields:
0.74 base.py(845):         pk_val = self._get_pk_val(meta)
0.74 base.py(568):         meta = meta or self._meta
0.74 base.py(569):         return getattr(self, meta.pk.attname)
0.74 base.py(846):         if pk_val is None:
0.74 base.py(847):             pk_val = meta.pk.get_pk_value_on_save(self)
0.74 base.py(848):             setattr(self, meta.pk.attname, pk_val)
0.74 base.py(849):         pk_set = pk_val is not None
0.74 base.py(850):         if not pk_set and (force_update or update_fields):
0.74 base.py(852):         updated = False
0.74 base.py(855):             not raw and
0.74 base.py(856):             not force_insert and
0.74 base.py(863):         if pk_set and not force_insert:
0.74 base.py(874):         if not updated:
0.74 base.py(875):             if meta.order_with_respect_to:
0.74 base.py(886):             fields = meta.local_concrete_fields
0.74 base.py(887):             if not pk_set:
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.74 base.py(890):             returning_fields = meta.db_returning_fields
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.74 options.py(773):         topmost_call = seen_models is None
0.74 options.py(774):         if topmost_call:
0.74 options.py(775):             seen_models = set()
0.74 options.py(776):         seen_models.add(self.model)
0.74 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.74 options.py(781):         try:
0.74 options.py(784):             return self._get_fields_cache[cache_key]
0.74 options.py(785):         except KeyError:
0.74 options.py(786):             pass
0.74 options.py(788):         fields = []
0.74 options.py(791):         if include_parents is not False:
0.74 options.py(792):             for parent in self.parents:
0.74 options.py(806):         if reverse and not self.proxy:
0.74 options.py(817):         if forward:
0.74 options.py(818):             fields += self.local_fields
0.74 options.py(819):             fields += self.local_many_to_many
0.74 options.py(825):             if topmost_call:
0.74 options.py(826):                 fields += self.private_fields
0.74 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.74 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.74 options.py(833):         self._get_fields_cache[cache_key] = fields
0.74 options.py(834):         return fields
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 options.py(854):             if getattr(field, 'db_returning', False)
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 options.py(854):             if getattr(field, 'db_returning', False)
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 options.py(854):             if getattr(field, 'db_returning', False)
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 options.py(854):             if getattr(field, 'db_returning', False)
0.74 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.74 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.74 base.py(378):         return cls._meta.base_manager
0.74 options.py(389):         base_manager_name = self.base_manager_name
0.74 options.py(390):         if not base_manager_name:
0.74 options.py(392):             for parent in self.model.mro()[1:]:
0.74 options.py(393):                 if hasattr(parent, '_meta'):
0.74 options.py(392):             for parent in self.model.mro()[1:]:
0.74 options.py(393):                 if hasattr(parent, '_meta'):
0.74 options.py(392):             for parent in self.model.mro()[1:]:
0.74 options.py(398):         if base_manager_name:
0.74 options.py(409):         manager = Manager()
0.74 options.py(410):         manager.name = '_base_manager'
0.74 options.py(411):         manager.model = self.model
0.74 options.py(412):         manager.auto_created = True
0.74 options.py(413):         return manager
0.74 base.py(928):         return manager._insert(
0.74 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.74 base.py(930):             using=using, raw=raw,
0.75 base.py(892):             for result, field in zip(results, returning_fields):
0.75 base.py(893):                 setattr(self, field.attname, result)
0.75 base.py(892):             for result, field in zip(results, returning_fields):
0.75 base.py(894):         return updated
0.75 base.py(791):         self._state.db = using
0.75 base.py(793):         self._state.adding = False
0.75 base.py(796):         if not meta.auto_created:
0.75 base.py(797):             post_save.send(
0.75 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.75 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
 OK
  Applying admin.0002_logentry_remove_auto_add...0.75 options.py(748):         if include_parents is False:
0.75 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(792):             for parent in self.parents:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(810):             all_fields = self._relation_tree
0.75 options.py(723):         return self._populate_directed_relation_graph()
0.75 options.py(692):         related_objects_graph = defaultdict(list)
0.75 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
0.75 options.py(347):         if self.swappable:
0.75 options.py(361):         return None
0.75 options.py(347):         if self.swappable:
0.75 options.py(361):         return None
0.75 options.py(347):         if self.swappable:
0.75 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.75 options.py(349):             if swapped_for:
0.75 options.py(350):                 try:
0.75 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.75 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.75 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.75 options.py(361):         return None
0.75 options.py(347):         if self.swappable:
0.75 options.py(361):         return None
0.75 options.py(347):         if self.swappable:
0.75 options.py(361):         return None
0.75 options.py(347):         if self.swappable:
0.75 options.py(361):         return None
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(696):             opts = model._meta
0.75 options.py(699):             if opts.abstract:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.75 options.py(776):         seen_models.add(self.model)
0.75 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.75 options.py(781):         try:
0.75 options.py(784):             return self._get_fields_cache[cache_key]
0.75 options.py(785):         except KeyError:
0.75 options.py(786):             pass
0.75 options.py(788):         fields = []
0.75 options.py(791):         if include_parents is not False:
0.75 options.py(806):         if reverse and not self.proxy:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.75 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(703):                 if f.is_relation and f.related_model is not None
0.75 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.75 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.75 options.py(705):             for f in fields_with_relations:
0.75 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.75 options.py(695):         for model in all_models:
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.75 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.75 options.py(709):         for model in all_models:
0.75 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
0.75 options.py(811):             for field in all_fields:
0.75 options.py(817):         if forward:
0.75 options.py(818):             fields += self.local_fields
0.75 options.py(819):             fields += self.local_many_to_many
0.75 options.py(825):             if topmost_call:
0.75 options.py(826):                 fields += self.private_fields
0.75 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.75 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.75 options.py(833):         self._get_fields_cache[cache_key] = fields
0.75 options.py(834):         return fields
0.75 options.py(748):         if include_parents is False:
0.75 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.75 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.75 options.py(773):         topmost_call = seen_models is None
0.75 options.py(774):         if topmost_call:
0.75 options.py(775):             seen_models = set()
0.76 options.py(776):         seen_models.add(self.model)
0.76 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.76 options.py(781):         try:
0.76 options.py(784):             return self._get_fields_cache[cache_key]
0.76 options.py(785):         except KeyError:
0.76 options.py(786):             pass
0.76 options.py(788):         fields = []
0.76 options.py(791):         if include_parents is not False:
0.76 options.py(792):             for parent in self.parents:
0.76 options.py(806):         if reverse and not self.proxy:
0.76 options.py(810):             all_fields = self._relation_tree
0.76 options.py(811):             for field in all_fields:
0.76 options.py(814):                 if include_hidden or not field.remote_field.hidden:
0.76 options.py(815):                     fields.append(field.remote_field)
0.76 options.py(811):             for field in all_fields:
0.76 options.py(817):         if forward:
0.76 options.py(818):             fields += self.local_fields
0.76 options.py(819):             fields += self.local_many_to_many
0.76 options.py(825):             if topmost_call:
0.76 options.py(826):                 fields += self.private_fields
0.76 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(833):         self._get_fields_cache[cache_key] = fields
0.76 options.py(834):         return fields
0.76 options.py(748):         if include_parents is False:
0.76 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.76 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.76 options.py(773):         topmost_call = seen_models is None
0.76 options.py(774):         if topmost_call:
0.76 options.py(775):             seen_models = set()
0.76 options.py(776):         seen_models.add(self.model)
0.76 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.76 options.py(781):         try:
0.76 options.py(784):             return self._get_fields_cache[cache_key]
0.76 options.py(785):         except KeyError:
0.76 options.py(786):             pass
0.76 options.py(788):         fields = []
0.76 options.py(791):         if include_parents is not False:
0.76 options.py(792):             for parent in self.parents:
0.76 options.py(806):         if reverse and not self.proxy:
0.76 options.py(810):             all_fields = self._relation_tree
0.76 options.py(811):             for field in all_fields:
0.76 options.py(814):                 if include_hidden or not field.remote_field.hidden:
0.76 options.py(815):                     fields.append(field.remote_field)
0.76 options.py(811):             for field in all_fields:
0.76 options.py(817):         if forward:
0.76 options.py(818):             fields += self.local_fields
0.76 options.py(819):             fields += self.local_many_to_many
0.76 options.py(825):             if topmost_call:
0.76 options.py(826):                 fields += self.private_fields
0.76 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(833):         self._get_fields_cache[cache_key] = fields
0.76 options.py(834):         return fields
0.76 options.py(347):         if self.swappable:
0.76 options.py(361):         return None
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(735):                     delattr(self, cache_key)
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 options.py(347):         if self.swappable:
0.76 options.py(361):         return None
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(735):                     delattr(self, cache_key)
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 options.py(347):         if self.swappable:
0.76 options.py(361):         return None
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(735):                     delattr(self, cache_key)
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(75):         super_new = super().__new__
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(80):         if not parents:
0.76 base.py(84):         module = attrs.pop('__module__')
0.76 base.py(85):         new_attrs = {'__module__': module}
0.76 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.76 base.py(87):         if classcell is not None:
0.76 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.76 base.py(93):         contributable_attrs = {}
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.76 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.76 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.76 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.76 base.py(105):         app_label = None
0.76 base.py(108):         app_config = apps.get_containing_app_config(module)
0.76 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.76 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.76 options.py(76):         self._get_fields_cache = {}
0.76 options.py(77):         self.local_fields = []
0.76 options.py(78):         self.local_many_to_many = []
0.76 options.py(79):         self.private_fields = []
0.76 options.py(80):         self.local_managers = []
0.76 options.py(81):         self.base_manager_name = None
0.76 options.py(82):         self.default_manager_name = None
0.76 options.py(83):         self.model_name = None
0.76 options.py(84):         self.verbose_name = None
0.76 options.py(85):         self.verbose_name_plural = None
0.76 options.py(86):         self.db_table = ''
0.76 options.py(87):         self.ordering = []
0.76 options.py(88):         self._ordering_clash = False
0.76 options.py(89):         self.indexes = []
0.76 options.py(90):         self.constraints = []
0.76 options.py(91):         self.unique_together = []
0.76 options.py(92):         self.index_together = []
0.76 options.py(93):         self.select_on_save = False
0.76 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.76 options.py(95):         self.permissions = []
0.76 options.py(96):         self.object_name = None
0.76 options.py(97):         self.app_label = app_label
0.76 options.py(98):         self.get_latest_by = None
0.76 options.py(99):         self.order_with_respect_to = None
0.76 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.76 options.py(101):         self.required_db_features = []
0.76 options.py(102):         self.required_db_vendor = None
0.76 options.py(103):         self.meta = meta
0.76 options.py(104):         self.pk = None
0.76 options.py(105):         self.auto_field = None
0.76 options.py(106):         self.abstract = False
0.76 options.py(107):         self.managed = True
0.76 options.py(108):         self.proxy = False
0.76 options.py(114):         self.proxy_for_model = None
0.76 options.py(118):         self.concrete_model = None
0.76 options.py(119):         self.swappable = None
0.76 options.py(120):         self.parents = {}
0.76 options.py(121):         self.auto_created = False
0.76 options.py(125):         self.related_fkey_lookups = []
0.76 options.py(128):         self.apps = self.default_apps
0.76 options.py(130):         self.default_related_name = None
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(150):         from django.db import connection
0.76 options.py(151):         from django.db.backends.utils import truncate_name
0.76 options.py(153):         cls._meta = self
0.76 options.py(154):         self.model = cls
0.76 options.py(156):         self.object_name = cls.__name__
0.76 options.py(157):         self.model_name = self.object_name.lower()
0.76 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.76 options.py(162):         self.original_attrs = {}
0.76 options.py(165):         if self.meta:
0.76 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(182):             self.index_together = normalize_together(self.index_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(192):             if self.verbose_name_plural is None:
0.76 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.76 options.py(199):             if meta_attrs != {}:
0.76 options.py(203):         del self.meta
0.76 options.py(206):         if not self.db_table:
0.76 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.76 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.76 base.py(123):         if not abstract:
0.76 base.py(124):             new_class.add_to_class(
0.76 base.py(125):                 'DoesNotExist',
0.76 base.py(126):                 subclass_exception(
0.76 base.py(127):                     'DoesNotExist',
0.76 base.py(128):                     tuple(
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(130):                     ) or (ObjectDoesNotExist,),
0.76 base.py(131):                     module,
0.76 base.py(132):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(133):             new_class.add_to_class(
0.76 base.py(134):                 'MultipleObjectsReturned',
0.76 base.py(135):                 subclass_exception(
0.76 base.py(136):                     'MultipleObjectsReturned',
0.76 base.py(137):                     tuple(
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(139):                     ) or (MultipleObjectsReturned,),
0.76 base.py(140):                     module,
0.76 base.py(141):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(142):             if base_meta and not base_meta.abstract:
0.76 base.py(151):         is_proxy = new_class._meta.proxy
0.76 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(298):             self.pk = field
0.76 options.py(299):             field.serialize = False
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(263):         self.local_managers.append(manager)
0.76 options.py(264):         self._expire_cache()
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(164):         new_fields = chain(
0.76 base.py(165):             new_class._meta.local_fields,
0.76 base.py(166):             new_class._meta.local_many_to_many,
0.76 base.py(167):             new_class._meta.private_fields
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(172):         if is_proxy:
0.76 base.py(192):             new_class._meta.concrete_model = new_class
0.76 base.py(195):         parent_links = {}
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(198):             if not hasattr(base, '_meta'):
0.76 base.py(199):                 continue
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(198):             if not hasattr(base, '_meta'):
0.76 base.py(201):             if base != new_class and not base._meta.abstract:
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(210):         inherited_attributes = set()
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.76 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.76 base.py(312):         if abstract:
0.76 base.py(320):         new_class._prepare()
0.76 base.py(332):         opts = cls._meta
0.76 base.py(333):         opts._prepare(cls)
0.76 options.py(223):         if self.order_with_respect_to:
0.76 options.py(239):             self.order_with_respect_to = None
0.76 options.py(241):         if self.pk is None:
0.76 base.py(335):         if opts.order_with_respect_to:
0.76 base.py(350):         if cls.__doc__ is None:
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 options.py(456):         def is_not_an_m2m_field(f):
0.76 options.py(459):         def is_not_a_generic_relation(f):
0.76 options.py(462):         def is_not_a_generic_foreign_key(f):
0.76 options.py(467):         return make_immutable_fields_list(
0.76 options.py(468):             "fields",
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.76 options.py(773):         topmost_call = seen_models is None
0.76 options.py(774):         if topmost_call:
0.76 options.py(775):             seen_models = set()
0.76 options.py(776):         seen_models.add(self.model)
0.76 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.76 options.py(781):         try:
0.76 options.py(784):             return self._get_fields_cache[cache_key]
0.76 options.py(785):         except KeyError:
0.76 options.py(786):             pass
0.76 options.py(788):         fields = []
0.76 options.py(791):         if include_parents is not False:
0.76 options.py(792):             for parent in self.parents:
0.76 options.py(806):         if reverse and not self.proxy:
0.76 options.py(817):         if forward:
0.76 options.py(818):             fields += self.local_fields
0.76 options.py(819):             fields += self.local_many_to_many
0.76 options.py(825):             if topmost_call:
0.76 options.py(826):                 fields += self.private_fields
0.76 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(833):         self._get_fields_cache[cache_key] = fields
0.76 options.py(834):         return fields
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.76 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.76 base.py(354):         if get_absolute_url_override:
0.76 base.py(357):         if not opts.managers:
0.76 options.py(365):         managers = []
0.76 options.py(366):         seen_managers = set()
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(368):         for depth, base in enumerate(bases):
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(369):             for manager in base._meta.local_managers:
0.76 options.py(370):                 if manager.name in seen_managers:
0.76 options.py(373):                 manager = copy.copy(manager)
0.76 options.py(374):                 manager.model = self.model
0.76 options.py(375):                 seen_managers.add(manager.name)
0.76 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.76 options.py(369):             for manager in base._meta.local_managers:
0.76 options.py(368):         for depth, base in enumerate(bases):
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(378):         return make_immutable_fields_list(
0.76 options.py(379):             "managers",
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 base.py(370):         for index in cls._meta.indexes:
0.76 base.py(374):         class_prepared.send(sender=cls)
0.76 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.76 base.py(322):         return new_class
0.76 base.py(75):         super_new = super().__new__
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(80):         if not parents:
0.76 base.py(84):         module = attrs.pop('__module__')
0.76 base.py(85):         new_attrs = {'__module__': module}
0.76 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.76 base.py(87):         if classcell is not None:
0.76 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.76 base.py(93):         contributable_attrs = {}
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.76 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.76 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.76 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.76 base.py(105):         app_label = None
0.76 base.py(108):         app_config = apps.get_containing_app_config(module)
0.76 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.76 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.76 options.py(76):         self._get_fields_cache = {}
0.76 options.py(77):         self.local_fields = []
0.76 options.py(78):         self.local_many_to_many = []
0.76 options.py(79):         self.private_fields = []
0.76 options.py(80):         self.local_managers = []
0.76 options.py(81):         self.base_manager_name = None
0.76 options.py(82):         self.default_manager_name = None
0.76 options.py(83):         self.model_name = None
0.76 options.py(84):         self.verbose_name = None
0.76 options.py(85):         self.verbose_name_plural = None
0.76 options.py(86):         self.db_table = ''
0.76 options.py(87):         self.ordering = []
0.76 options.py(88):         self._ordering_clash = False
0.76 options.py(89):         self.indexes = []
0.76 options.py(90):         self.constraints = []
0.76 options.py(91):         self.unique_together = []
0.76 options.py(92):         self.index_together = []
0.76 options.py(93):         self.select_on_save = False
0.76 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.76 options.py(95):         self.permissions = []
0.76 options.py(96):         self.object_name = None
0.76 options.py(97):         self.app_label = app_label
0.76 options.py(98):         self.get_latest_by = None
0.76 options.py(99):         self.order_with_respect_to = None
0.76 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.76 options.py(101):         self.required_db_features = []
0.76 options.py(102):         self.required_db_vendor = None
0.76 options.py(103):         self.meta = meta
0.76 options.py(104):         self.pk = None
0.76 options.py(105):         self.auto_field = None
0.76 options.py(106):         self.abstract = False
0.76 options.py(107):         self.managed = True
0.76 options.py(108):         self.proxy = False
0.76 options.py(114):         self.proxy_for_model = None
0.76 options.py(118):         self.concrete_model = None
0.76 options.py(119):         self.swappable = None
0.76 options.py(120):         self.parents = {}
0.76 options.py(121):         self.auto_created = False
0.76 options.py(125):         self.related_fkey_lookups = []
0.76 options.py(128):         self.apps = self.default_apps
0.76 options.py(130):         self.default_related_name = None
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(150):         from django.db import connection
0.76 options.py(151):         from django.db.backends.utils import truncate_name
0.76 options.py(153):         cls._meta = self
0.76 options.py(154):         self.model = cls
0.76 options.py(156):         self.object_name = cls.__name__
0.76 options.py(157):         self.model_name = self.object_name.lower()
0.76 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.76 options.py(162):         self.original_attrs = {}
0.76 options.py(165):         if self.meta:
0.76 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(182):             self.index_together = normalize_together(self.index_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(192):             if self.verbose_name_plural is None:
0.76 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.76 options.py(199):             if meta_attrs != {}:
0.76 options.py(203):         del self.meta
0.76 options.py(206):         if not self.db_table:
0.76 base.py(123):         if not abstract:
0.76 base.py(124):             new_class.add_to_class(
0.76 base.py(125):                 'DoesNotExist',
0.76 base.py(126):                 subclass_exception(
0.76 base.py(127):                     'DoesNotExist',
0.76 base.py(128):                     tuple(
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(130):                     ) or (ObjectDoesNotExist,),
0.76 base.py(131):                     module,
0.76 base.py(132):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(133):             new_class.add_to_class(
0.76 base.py(134):                 'MultipleObjectsReturned',
0.76 base.py(135):                 subclass_exception(
0.76 base.py(136):                     'MultipleObjectsReturned',
0.76 base.py(137):                     tuple(
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(139):                     ) or (MultipleObjectsReturned,),
0.76 base.py(140):                     module,
0.76 base.py(141):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(142):             if base_meta and not base_meta.abstract:
0.76 base.py(151):         is_proxy = new_class._meta.proxy
0.76 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(298):             self.pk = field
0.76 options.py(299):             field.serialize = False
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(271):         if private:
0.76 options.py(273):         elif field.is_relation and field.many_to_many:
0.76 options.py(276):             bisect.insort(self.local_fields, field)
0.76 options.py(277):             self.setup_pk(field)
0.76 options.py(297):         if not self.pk and field.primary_key:
0.76 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.76 options.py(294):             self._expire_cache(reverse=False)
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(263):         self.local_managers.append(manager)
0.76 options.py(264):         self._expire_cache()
0.76 options.py(728):         if forward:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(730):                 if cache_key in self.__dict__:
0.76 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.76 options.py(732):         if reverse and not self.abstract:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(734):                 if cache_key in self.__dict__:
0.76 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.76 options.py(736):         self._get_fields_cache = {}
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(164):         new_fields = chain(
0.76 base.py(165):             new_class._meta.local_fields,
0.76 base.py(166):             new_class._meta.local_many_to_many,
0.76 base.py(167):             new_class._meta.private_fields
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(169):         field_names = {f.name for f in new_fields}
0.76 base.py(172):         if is_proxy:
0.76 base.py(192):             new_class._meta.concrete_model = new_class
0.76 base.py(195):         parent_links = {}
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(198):             if not hasattr(base, '_meta'):
0.76 base.py(199):                 continue
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(198):             if not hasattr(base, '_meta'):
0.76 base.py(201):             if base != new_class and not base._meta.abstract:
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(205):                 if isinstance(field, OneToOneField):
0.76 base.py(204):             for field in base._meta.local_fields:
0.76 base.py(196):         for base in reversed([new_class] + parents):
0.76 base.py(210):         inherited_attributes = set()
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.76 base.py(216):                 inherited_attributes.update(base.__dict__)
0.76 base.py(217):                 continue
0.76 base.py(212):         for base in new_class.mro():
0.76 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.76 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.76 base.py(312):         if abstract:
0.76 base.py(320):         new_class._prepare()
0.76 base.py(332):         opts = cls._meta
0.76 base.py(333):         opts._prepare(cls)
0.76 options.py(223):         if self.order_with_respect_to:
0.76 options.py(239):             self.order_with_respect_to = None
0.76 options.py(241):         if self.pk is None:
0.76 base.py(335):         if opts.order_with_respect_to:
0.76 base.py(350):         if cls.__doc__ is None:
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 options.py(456):         def is_not_an_m2m_field(f):
0.76 options.py(459):         def is_not_a_generic_relation(f):
0.76 options.py(462):         def is_not_a_generic_foreign_key(f):
0.76 options.py(467):         return make_immutable_fields_list(
0.76 options.py(468):             "fields",
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.76 options.py(773):         topmost_call = seen_models is None
0.76 options.py(774):         if topmost_call:
0.76 options.py(775):             seen_models = set()
0.76 options.py(776):         seen_models.add(self.model)
0.76 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.76 options.py(781):         try:
0.76 options.py(784):             return self._get_fields_cache[cache_key]
0.76 options.py(785):         except KeyError:
0.76 options.py(786):             pass
0.76 options.py(788):         fields = []
0.76 options.py(791):         if include_parents is not False:
0.76 options.py(792):             for parent in self.parents:
0.76 options.py(806):         if reverse and not self.proxy:
0.76 options.py(817):         if forward:
0.76 options.py(818):             fields += self.local_fields
0.76 options.py(819):             fields += self.local_many_to_many
0.76 options.py(825):             if topmost_call:
0.76 options.py(826):                 fields += self.private_fields
0.76 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(833):         self._get_fields_cache[cache_key] = fields
0.76 options.py(834):         return fields
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.76 options.py(457):             return not (f.is_relation and f.many_to_many)
0.76 options.py(460):             return not (f.is_relation and f.one_to_many)
0.76 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.76 options.py(469):             (f for f in self._get_fields(reverse=False)
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.76 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.76 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.76 base.py(354):         if get_absolute_url_override:
0.76 base.py(357):         if not opts.managers:
0.76 options.py(365):         managers = []
0.76 options.py(366):         seen_managers = set()
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(368):         for depth, base in enumerate(bases):
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(369):             for manager in base._meta.local_managers:
0.76 options.py(370):                 if manager.name in seen_managers:
0.76 options.py(373):                 manager = copy.copy(manager)
0.76 options.py(374):                 manager.model = self.model
0.76 options.py(375):                 seen_managers.add(manager.name)
0.76 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.76 options.py(369):             for manager in base._meta.local_managers:
0.76 options.py(368):         for depth, base in enumerate(bases):
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.76 options.py(378):         return make_immutable_fields_list(
0.76 options.py(379):             "managers",
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 options.py(380):             (m[2] for m in sorted(managers)),
0.76 base.py(370):         for index in cls._meta.indexes:
0.76 base.py(374):         class_prepared.send(sender=cls)
0.76 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.76 base.py(322):         return new_class
0.76 base.py(75):         super_new = super().__new__
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.76 base.py(80):         if not parents:
0.76 base.py(84):         module = attrs.pop('__module__')
0.76 base.py(85):         new_attrs = {'__module__': module}
0.76 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.76 base.py(87):         if classcell is not None:
0.76 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.76 base.py(93):         contributable_attrs = {}
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(95):             if _has_contribute_to_class(obj):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(96):                 contributable_attrs[obj_name] = obj
0.76 base.py(94):         for obj_name, obj in list(attrs.items()):
0.76 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.76 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.76 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.76 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.76 base.py(105):         app_label = None
0.76 base.py(108):         app_config = apps.get_containing_app_config(module)
0.76 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.76 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.76 options.py(76):         self._get_fields_cache = {}
0.76 options.py(77):         self.local_fields = []
0.76 options.py(78):         self.local_many_to_many = []
0.76 options.py(79):         self.private_fields = []
0.76 options.py(80):         self.local_managers = []
0.76 options.py(81):         self.base_manager_name = None
0.76 options.py(82):         self.default_manager_name = None
0.76 options.py(83):         self.model_name = None
0.76 options.py(84):         self.verbose_name = None
0.76 options.py(85):         self.verbose_name_plural = None
0.76 options.py(86):         self.db_table = ''
0.76 options.py(87):         self.ordering = []
0.76 options.py(88):         self._ordering_clash = False
0.76 options.py(89):         self.indexes = []
0.76 options.py(90):         self.constraints = []
0.76 options.py(91):         self.unique_together = []
0.76 options.py(92):         self.index_together = []
0.76 options.py(93):         self.select_on_save = False
0.76 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.76 options.py(95):         self.permissions = []
0.76 options.py(96):         self.object_name = None
0.76 options.py(97):         self.app_label = app_label
0.76 options.py(98):         self.get_latest_by = None
0.76 options.py(99):         self.order_with_respect_to = None
0.76 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.76 options.py(101):         self.required_db_features = []
0.76 options.py(102):         self.required_db_vendor = None
0.76 options.py(103):         self.meta = meta
0.76 options.py(104):         self.pk = None
0.76 options.py(105):         self.auto_field = None
0.76 options.py(106):         self.abstract = False
0.76 options.py(107):         self.managed = True
0.76 options.py(108):         self.proxy = False
0.76 options.py(114):         self.proxy_for_model = None
0.76 options.py(118):         self.concrete_model = None
0.76 options.py(119):         self.swappable = None
0.76 options.py(120):         self.parents = {}
0.76 options.py(121):         self.auto_created = False
0.76 options.py(125):         self.related_fkey_lookups = []
0.76 options.py(128):         self.apps = self.default_apps
0.76 options.py(130):         self.default_related_name = None
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.76 options.py(150):         from django.db import connection
0.76 options.py(151):         from django.db.backends.utils import truncate_name
0.76 options.py(153):         cls._meta = self
0.76 options.py(154):         self.model = cls
0.76 options.py(156):         self.object_name = cls.__name__
0.76 options.py(157):         self.model_name = self.object_name.lower()
0.76 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.76 options.py(162):         self.original_attrs = {}
0.76 options.py(165):         if self.meta:
0.76 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(171):                 if name.startswith('_'):
0.76 options.py(172):                     del meta_attrs[name]
0.76 options.py(167):             for name in self.meta.__dict__:
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(177):                 elif hasattr(self.meta, attr_name):
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(174):                 if attr_name in meta_attrs:
0.76 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.76 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.76 options.py(173):             for attr_name in DEFAULT_NAMES:
0.76 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(182):             self.index_together = normalize_together(self.index_together)
0.76 options.py(45):     try:
0.76 options.py(46):         if not option_together:
0.76 options.py(47):             return ()
0.76 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(187):                     objs = getattr(self, attr_name, [])
0.76 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.76 options.py(212):         new_objs = []
0.76 options.py(213):         for obj in objs:
0.76 options.py(220):         return new_objs
0.76 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.76 options.py(192):             if self.verbose_name_plural is None:
0.76 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.76 options.py(199):             if meta_attrs != {}:
0.76 options.py(203):         del self.meta
0.76 options.py(206):         if not self.db_table:
0.76 base.py(123):         if not abstract:
0.76 base.py(124):             new_class.add_to_class(
0.76 base.py(125):                 'DoesNotExist',
0.76 base.py(126):                 subclass_exception(
0.76 base.py(127):                     'DoesNotExist',
0.76 base.py(128):                     tuple(
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(130):                     ) or (ObjectDoesNotExist,),
0.76 base.py(131):                     module,
0.76 base.py(132):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(133):             new_class.add_to_class(
0.76 base.py(134):                 'MultipleObjectsReturned',
0.76 base.py(135):                 subclass_exception(
0.76 base.py(136):                     'MultipleObjectsReturned',
0.76 base.py(137):                     tuple(
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.76 base.py(139):                     ) or (MultipleObjectsReturned,),
0.76 base.py(140):                     module,
0.76 base.py(141):                     attached_to=new_class))
0.76 base.py(61):     return type(name, bases, {
0.76 base.py(62):         '__module__': module,
0.76 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(328):             setattr(cls, name, value)
0.76 base.py(142):             if base_meta and not base_meta.abstract:
0.76 base.py(151):         is_proxy = new_class._meta.proxy
0.76 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.76 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.76 base.py(161):             new_class.add_to_class(obj_name, obj)
0.76 base.py(325):         if _has_contribute_to_class(value):
0.76 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.76 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(298):             self.pk = field
0.77 options.py(299):             field.serialize = False
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(288):             try:
0.77 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.77 options.py(290):             except AttributeError:
0.77 options.py(291):                 pass
0.77 options.py(292):             self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(288):             try:
0.77 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.77 options.py(290):             except AttributeError:
0.77 options.py(291):                 pass
0.77 options.py(292):             self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(263):         self.local_managers.append(manager)
0.77 options.py(264):         self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(164):         new_fields = chain(
0.77 base.py(165):             new_class._meta.local_fields,
0.77 base.py(166):             new_class._meta.local_many_to_many,
0.77 base.py(167):             new_class._meta.private_fields
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(172):         if is_proxy:
0.77 base.py(192):             new_class._meta.concrete_model = new_class
0.77 base.py(195):         parent_links = {}
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(198):             if not hasattr(base, '_meta'):
0.77 base.py(199):                 continue
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(198):             if not hasattr(base, '_meta'):
0.77 base.py(201):             if base != new_class and not base._meta.abstract:
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(210):         inherited_attributes = set()
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.77 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.77 base.py(312):         if abstract:
0.77 base.py(320):         new_class._prepare()
0.77 base.py(332):         opts = cls._meta
0.77 base.py(333):         opts._prepare(cls)
0.77 options.py(223):         if self.order_with_respect_to:
0.77 options.py(239):             self.order_with_respect_to = None
0.77 options.py(241):         if self.pk is None:
0.77 base.py(335):         if opts.order_with_respect_to:
0.77 base.py(350):         if cls.__doc__ is None:
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 options.py(456):         def is_not_an_m2m_field(f):
0.77 options.py(459):         def is_not_a_generic_relation(f):
0.77 options.py(462):         def is_not_a_generic_foreign_key(f):
0.77 options.py(467):         return make_immutable_fields_list(
0.77 options.py(468):             "fields",
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.77 options.py(773):         topmost_call = seen_models is None
0.77 options.py(774):         if topmost_call:
0.77 options.py(775):             seen_models = set()
0.77 options.py(776):         seen_models.add(self.model)
0.77 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.77 options.py(781):         try:
0.77 options.py(784):             return self._get_fields_cache[cache_key]
0.77 options.py(785):         except KeyError:
0.77 options.py(786):             pass
0.77 options.py(788):         fields = []
0.77 options.py(791):         if include_parents is not False:
0.77 options.py(792):             for parent in self.parents:
0.77 options.py(806):         if reverse and not self.proxy:
0.77 options.py(817):         if forward:
0.77 options.py(818):             fields += self.local_fields
0.77 options.py(819):             fields += self.local_many_to_many
0.77 options.py(825):             if topmost_call:
0.77 options.py(826):                 fields += self.private_fields
0.77 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(833):         self._get_fields_cache[cache_key] = fields
0.77 options.py(834):         return fields
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.77 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.77 base.py(354):         if get_absolute_url_override:
0.77 base.py(357):         if not opts.managers:
0.77 options.py(365):         managers = []
0.77 options.py(366):         seen_managers = set()
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(368):         for depth, base in enumerate(bases):
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(369):             for manager in base._meta.local_managers:
0.77 options.py(370):                 if manager.name in seen_managers:
0.77 options.py(373):                 manager = copy.copy(manager)
0.77 options.py(374):                 manager.model = self.model
0.77 options.py(375):                 seen_managers.add(manager.name)
0.77 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.77 options.py(369):             for manager in base._meta.local_managers:
0.77 options.py(368):         for depth, base in enumerate(bases):
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(378):         return make_immutable_fields_list(
0.77 options.py(379):             "managers",
0.77 options.py(380):             (m[2] for m in sorted(managers)),
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(380):             (m[2] for m in sorted(managers)),
0.77 options.py(380):             (m[2] for m in sorted(managers)),
0.77 base.py(370):         for index in cls._meta.indexes:
0.77 base.py(374):         class_prepared.send(sender=cls)
0.77 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 base.py(322):         return new_class
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(347):         if self.swappable:
0.77 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.77 options.py(349):             if swapped_for:
0.77 options.py(350):                 try:
0.77 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.77 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.77 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.77 options.py(347):         if self.swappable:
0.77 options.py(361):         return None
0.77 options.py(323):         if isinstance(connection, str):
0.77 options.py(324):             connection = connections[connection]
0.77 options.py(325):         if self.required_db_vendor:
0.77 options.py(327):         if self.required_db_features:
0.77 options.py(330):         return True
0.77 options.py(564):         try:
0.77 options.py(567):             return self._forward_fields_map[field_name]
0.77 options.py(532):         res = {}
0.77 options.py(533):         fields = self._get_fields(reverse=False)
0.77 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.77 options.py(773):         topmost_call = seen_models is None
0.77 options.py(774):         if topmost_call:
0.77 options.py(775):             seen_models = set()
0.77 options.py(776):         seen_models.add(self.model)
0.77 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.77 options.py(781):         try:
0.77 options.py(784):             return self._get_fields_cache[cache_key]
0.77 options.py(785):         except KeyError:
0.77 options.py(786):             pass
0.77 options.py(788):         fields = []
0.77 options.py(791):         if include_parents is not False:
0.77 options.py(792):             for parent in self.parents:
0.77 options.py(806):         if reverse and not self.proxy:
0.77 options.py(817):         if forward:
0.77 options.py(818):             fields += self.local_fields
0.77 options.py(819):             fields += self.local_many_to_many
0.77 options.py(825):             if topmost_call:
0.77 options.py(826):                 fields += self.private_fields
0.77 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(833):         self._get_fields_cache[cache_key] = fields
0.77 options.py(834):         return fields
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(543):         return res
0.77 options.py(564):         try:
0.77 options.py(567):             return self._forward_fields_map[field_name]
0.77 options.py(532):         res = {}
0.77 options.py(533):         fields = self._get_fields(reverse=False)
0.77 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.77 options.py(773):         topmost_call = seen_models is None
0.77 options.py(774):         if topmost_call:
0.77 options.py(775):             seen_models = set()
0.77 options.py(776):         seen_models.add(self.model)
0.77 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.77 options.py(781):         try:
0.77 options.py(784):             return self._get_fields_cache[cache_key]
0.77 options.py(785):         except KeyError:
0.77 options.py(786):             pass
0.77 options.py(788):         fields = []
0.77 options.py(791):         if include_parents is not False:
0.77 options.py(792):             for parent in self.parents:
0.77 options.py(806):         if reverse and not self.proxy:
0.77 options.py(817):         if forward:
0.77 options.py(818):             fields += self.local_fields
0.77 options.py(819):             fields += self.local_many_to_many
0.77 options.py(825):             if topmost_call:
0.77 options.py(826):                 fields += self.private_fields
0.77 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(833):         self._get_fields_cache[cache_key] = fields
0.77 options.py(834):         return fields
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(535):             res[field.name] = field
0.77 options.py(539):             try:
0.77 options.py(540):                 res[field.attname] = field
0.77 options.py(534):         for field in fields:
0.77 options.py(543):         return res
0.77 options.py(495):         return make_immutable_fields_list(
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.77 base.py(75):         super_new = super().__new__
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(80):         if not parents:
0.77 base.py(84):         module = attrs.pop('__module__')
0.77 base.py(85):         new_attrs = {'__module__': module}
0.77 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.77 base.py(87):         if classcell is not None:
0.77 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.77 base.py(93):         contributable_attrs = {}
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.77 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.77 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.77 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.77 base.py(105):         app_label = None
0.77 base.py(108):         app_config = apps.get_containing_app_config(module)
0.77 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.77 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.77 options.py(76):         self._get_fields_cache = {}
0.77 options.py(77):         self.local_fields = []
0.77 options.py(78):         self.local_many_to_many = []
0.77 options.py(79):         self.private_fields = []
0.77 options.py(80):         self.local_managers = []
0.77 options.py(81):         self.base_manager_name = None
0.77 options.py(82):         self.default_manager_name = None
0.77 options.py(83):         self.model_name = None
0.77 options.py(84):         self.verbose_name = None
0.77 options.py(85):         self.verbose_name_plural = None
0.77 options.py(86):         self.db_table = ''
0.77 options.py(87):         self.ordering = []
0.77 options.py(88):         self._ordering_clash = False
0.77 options.py(89):         self.indexes = []
0.77 options.py(90):         self.constraints = []
0.77 options.py(91):         self.unique_together = []
0.77 options.py(92):         self.index_together = []
0.77 options.py(93):         self.select_on_save = False
0.77 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.77 options.py(95):         self.permissions = []
0.77 options.py(96):         self.object_name = None
0.77 options.py(97):         self.app_label = app_label
0.77 options.py(98):         self.get_latest_by = None
0.77 options.py(99):         self.order_with_respect_to = None
0.77 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.77 options.py(101):         self.required_db_features = []
0.77 options.py(102):         self.required_db_vendor = None
0.77 options.py(103):         self.meta = meta
0.77 options.py(104):         self.pk = None
0.77 options.py(105):         self.auto_field = None
0.77 options.py(106):         self.abstract = False
0.77 options.py(107):         self.managed = True
0.77 options.py(108):         self.proxy = False
0.77 options.py(114):         self.proxy_for_model = None
0.77 options.py(118):         self.concrete_model = None
0.77 options.py(119):         self.swappable = None
0.77 options.py(120):         self.parents = {}
0.77 options.py(121):         self.auto_created = False
0.77 options.py(125):         self.related_fkey_lookups = []
0.77 options.py(128):         self.apps = self.default_apps
0.77 options.py(130):         self.default_related_name = None
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(150):         from django.db import connection
0.77 options.py(151):         from django.db.backends.utils import truncate_name
0.77 options.py(153):         cls._meta = self
0.77 options.py(154):         self.model = cls
0.77 options.py(156):         self.object_name = cls.__name__
0.77 options.py(157):         self.model_name = self.object_name.lower()
0.77 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.77 options.py(162):         self.original_attrs = {}
0.77 options.py(165):         if self.meta:
0.77 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.77 options.py(45):     try:
0.77 options.py(46):         if not option_together:
0.77 options.py(47):             return ()
0.77 options.py(182):             self.index_together = normalize_together(self.index_together)
0.77 options.py(45):     try:
0.77 options.py(46):         if not option_together:
0.77 options.py(47):             return ()
0.77 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(187):                     objs = getattr(self, attr_name, [])
0.77 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.77 options.py(212):         new_objs = []
0.77 options.py(213):         for obj in objs:
0.77 options.py(220):         return new_objs
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(187):                     objs = getattr(self, attr_name, [])
0.77 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.77 options.py(212):         new_objs = []
0.77 options.py(213):         for obj in objs:
0.77 options.py(220):         return new_objs
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(192):             if self.verbose_name_plural is None:
0.77 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.77 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.77 options.py(199):             if meta_attrs != {}:
0.77 options.py(203):         del self.meta
0.77 options.py(206):         if not self.db_table:
0.77 base.py(123):         if not abstract:
0.77 base.py(124):             new_class.add_to_class(
0.77 base.py(125):                 'DoesNotExist',
0.77 base.py(126):                 subclass_exception(
0.77 base.py(127):                     'DoesNotExist',
0.77 base.py(128):                     tuple(
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(130):                     ) or (ObjectDoesNotExist,),
0.77 base.py(131):                     module,
0.77 base.py(132):                     attached_to=new_class))
0.77 base.py(61):     return type(name, bases, {
0.77 base.py(62):         '__module__': module,
0.77 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(328):             setattr(cls, name, value)
0.77 base.py(133):             new_class.add_to_class(
0.77 base.py(134):                 'MultipleObjectsReturned',
0.77 base.py(135):                 subclass_exception(
0.77 base.py(136):                     'MultipleObjectsReturned',
0.77 base.py(137):                     tuple(
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(139):                     ) or (MultipleObjectsReturned,),
0.77 base.py(140):                     module,
0.77 base.py(141):                     attached_to=new_class))
0.77 base.py(61):     return type(name, bases, {
0.77 base.py(62):         '__module__': module,
0.77 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(328):             setattr(cls, name, value)
0.77 base.py(142):             if base_meta and not base_meta.abstract:
0.77 base.py(151):         is_proxy = new_class._meta.proxy
0.77 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(298):             self.pk = field
0.77 options.py(299):             field.serialize = False
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(288):             try:
0.77 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.77 options.py(728):         if forward:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(735):                     delattr(self, cache_key)
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(292):             self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(288):             try:
0.77 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.77 options.py(728):         if forward:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(735):                     delattr(self, cache_key)
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(292):             self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(164):         new_fields = chain(
0.77 base.py(165):             new_class._meta.local_fields,
0.77 base.py(166):             new_class._meta.local_many_to_many,
0.77 base.py(167):             new_class._meta.private_fields
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(169):         field_names = {f.name for f in new_fields}
0.77 base.py(172):         if is_proxy:
0.77 base.py(192):             new_class._meta.concrete_model = new_class
0.77 base.py(195):         parent_links = {}
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(198):             if not hasattr(base, '_meta'):
0.77 base.py(199):                 continue
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(198):             if not hasattr(base, '_meta'):
0.77 base.py(201):             if base != new_class and not base._meta.abstract:
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(205):                 if isinstance(field, OneToOneField):
0.77 base.py(204):             for field in base._meta.local_fields:
0.77 base.py(196):         for base in reversed([new_class] + parents):
0.77 base.py(210):         inherited_attributes = set()
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.77 base.py(216):                 inherited_attributes.update(base.__dict__)
0.77 base.py(217):                 continue
0.77 base.py(212):         for base in new_class.mro():
0.77 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.77 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.77 base.py(312):         if abstract:
0.77 base.py(320):         new_class._prepare()
0.77 base.py(332):         opts = cls._meta
0.77 base.py(333):         opts._prepare(cls)
0.77 options.py(223):         if self.order_with_respect_to:
0.77 options.py(239):             self.order_with_respect_to = None
0.77 options.py(241):         if self.pk is None:
0.77 base.py(335):         if opts.order_with_respect_to:
0.77 base.py(350):         if cls.__doc__ is None:
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 options.py(456):         def is_not_an_m2m_field(f):
0.77 options.py(459):         def is_not_a_generic_relation(f):
0.77 options.py(462):         def is_not_a_generic_foreign_key(f):
0.77 options.py(467):         return make_immutable_fields_list(
0.77 options.py(468):             "fields",
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.77 options.py(773):         topmost_call = seen_models is None
0.77 options.py(774):         if topmost_call:
0.77 options.py(775):             seen_models = set()
0.77 options.py(776):         seen_models.add(self.model)
0.77 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.77 options.py(781):         try:
0.77 options.py(784):             return self._get_fields_cache[cache_key]
0.77 options.py(785):         except KeyError:
0.77 options.py(786):             pass
0.77 options.py(788):         fields = []
0.77 options.py(791):         if include_parents is not False:
0.77 options.py(792):             for parent in self.parents:
0.77 options.py(806):         if reverse and not self.proxy:
0.77 options.py(817):         if forward:
0.77 options.py(818):             fields += self.local_fields
0.77 options.py(819):             fields += self.local_many_to_many
0.77 options.py(825):             if topmost_call:
0.77 options.py(826):                 fields += self.private_fields
0.77 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(833):         self._get_fields_cache[cache_key] = fields
0.77 options.py(834):         return fields
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.77 options.py(457):             return not (f.is_relation and f.many_to_many)
0.77 options.py(460):             return not (f.is_relation and f.one_to_many)
0.77 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.77 options.py(469):             (f for f in self._get_fields(reverse=False)
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.77 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.77 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.77 base.py(354):         if get_absolute_url_override:
0.77 base.py(357):         if not opts.managers:
0.77 options.py(365):         managers = []
0.77 options.py(366):         seen_managers = set()
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(368):         for depth, base in enumerate(bases):
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(369):             for manager in base._meta.local_managers:
0.77 options.py(368):         for depth, base in enumerate(bases):
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.77 options.py(378):         return make_immutable_fields_list(
0.77 options.py(379):             "managers",
0.77 options.py(380):             (m[2] for m in sorted(managers)),
0.77 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.77 options.py(380):             (m[2] for m in sorted(managers)),
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.77 base.py(363):             manager = Manager()
0.77 base.py(364):             manager.auto_created = True
0.77 base.py(365):             cls.add_to_class('objects', manager)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(263):         self.local_managers.append(manager)
0.77 options.py(264):         self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(731):                     delattr(self, cache_key)
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(370):         for index in cls._meta.indexes:
0.77 base.py(374):         class_prepared.send(sender=cls)
0.77 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.77 base.py(322):         return new_class
0.77 base.py(75):         super_new = super().__new__
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.77 base.py(80):         if not parents:
0.77 base.py(84):         module = attrs.pop('__module__')
0.77 base.py(85):         new_attrs = {'__module__': module}
0.77 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.77 base.py(87):         if classcell is not None:
0.77 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.77 base.py(93):         contributable_attrs = {}
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(95):             if _has_contribute_to_class(obj):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(96):                 contributable_attrs[obj_name] = obj
0.77 base.py(94):         for obj_name, obj in list(attrs.items()):
0.77 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.77 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.77 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.77 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.77 base.py(105):         app_label = None
0.77 base.py(108):         app_config = apps.get_containing_app_config(module)
0.77 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.77 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.77 options.py(76):         self._get_fields_cache = {}
0.77 options.py(77):         self.local_fields = []
0.77 options.py(78):         self.local_many_to_many = []
0.77 options.py(79):         self.private_fields = []
0.77 options.py(80):         self.local_managers = []
0.77 options.py(81):         self.base_manager_name = None
0.77 options.py(82):         self.default_manager_name = None
0.77 options.py(83):         self.model_name = None
0.77 options.py(84):         self.verbose_name = None
0.77 options.py(85):         self.verbose_name_plural = None
0.77 options.py(86):         self.db_table = ''
0.77 options.py(87):         self.ordering = []
0.77 options.py(88):         self._ordering_clash = False
0.77 options.py(89):         self.indexes = []
0.77 options.py(90):         self.constraints = []
0.77 options.py(91):         self.unique_together = []
0.77 options.py(92):         self.index_together = []
0.77 options.py(93):         self.select_on_save = False
0.77 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.77 options.py(95):         self.permissions = []
0.77 options.py(96):         self.object_name = None
0.77 options.py(97):         self.app_label = app_label
0.77 options.py(98):         self.get_latest_by = None
0.77 options.py(99):         self.order_with_respect_to = None
0.77 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.77 options.py(101):         self.required_db_features = []
0.77 options.py(102):         self.required_db_vendor = None
0.77 options.py(103):         self.meta = meta
0.77 options.py(104):         self.pk = None
0.77 options.py(105):         self.auto_field = None
0.77 options.py(106):         self.abstract = False
0.77 options.py(107):         self.managed = True
0.77 options.py(108):         self.proxy = False
0.77 options.py(114):         self.proxy_for_model = None
0.77 options.py(118):         self.concrete_model = None
0.77 options.py(119):         self.swappable = None
0.77 options.py(120):         self.parents = {}
0.77 options.py(121):         self.auto_created = False
0.77 options.py(125):         self.related_fkey_lookups = []
0.77 options.py(128):         self.apps = self.default_apps
0.77 options.py(130):         self.default_related_name = None
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(150):         from django.db import connection
0.77 options.py(151):         from django.db.backends.utils import truncate_name
0.77 options.py(153):         cls._meta = self
0.77 options.py(154):         self.model = cls
0.77 options.py(156):         self.object_name = cls.__name__
0.77 options.py(157):         self.model_name = self.object_name.lower()
0.77 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.77 options.py(162):         self.original_attrs = {}
0.77 options.py(165):         if self.meta:
0.77 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(171):                 if name.startswith('_'):
0.77 options.py(172):                     del meta_attrs[name]
0.77 options.py(167):             for name in self.meta.__dict__:
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(177):                 elif hasattr(self.meta, attr_name):
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(174):                 if attr_name in meta_attrs:
0.77 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.77 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.77 options.py(173):             for attr_name in DEFAULT_NAMES:
0.77 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.77 options.py(45):     try:
0.77 options.py(46):         if not option_together:
0.77 options.py(47):             return ()
0.77 options.py(182):             self.index_together = normalize_together(self.index_together)
0.77 options.py(45):     try:
0.77 options.py(46):         if not option_together:
0.77 options.py(47):             return ()
0.77 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(187):                     objs = getattr(self, attr_name, [])
0.77 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.77 options.py(212):         new_objs = []
0.77 options.py(213):         for obj in objs:
0.77 options.py(220):         return new_objs
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(187):                     objs = getattr(self, attr_name, [])
0.77 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.77 options.py(212):         new_objs = []
0.77 options.py(213):         for obj in objs:
0.77 options.py(220):         return new_objs
0.77 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.77 options.py(192):             if self.verbose_name_plural is None:
0.77 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.77 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.77 options.py(199):             if meta_attrs != {}:
0.77 options.py(203):         del self.meta
0.77 options.py(206):         if not self.db_table:
0.77 base.py(123):         if not abstract:
0.77 base.py(124):             new_class.add_to_class(
0.77 base.py(125):                 'DoesNotExist',
0.77 base.py(126):                 subclass_exception(
0.77 base.py(127):                     'DoesNotExist',
0.77 base.py(128):                     tuple(
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(130):                     ) or (ObjectDoesNotExist,),
0.77 base.py(131):                     module,
0.77 base.py(132):                     attached_to=new_class))
0.77 base.py(61):     return type(name, bases, {
0.77 base.py(62):         '__module__': module,
0.77 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(328):             setattr(cls, name, value)
0.77 base.py(133):             new_class.add_to_class(
0.77 base.py(134):                 'MultipleObjectsReturned',
0.77 base.py(135):                 subclass_exception(
0.77 base.py(136):                     'MultipleObjectsReturned',
0.77 base.py(137):                     tuple(
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.77 base.py(139):                     ) or (MultipleObjectsReturned,),
0.77 base.py(140):                     module,
0.77 base.py(141):                     attached_to=new_class))
0.77 base.py(61):     return type(name, bases, {
0.77 base.py(62):         '__module__': module,
0.77 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(328):             setattr(cls, name, value)
0.77 base.py(142):             if base_meta and not base_meta.abstract:
0.77 base.py(151):         is_proxy = new_class._meta.proxy
0.77 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(298):             self.pk = field
0.77 options.py(299):             field.serialize = False
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(294):             self._expire_cache(reverse=False)
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.77 options.py(277):             self.setup_pk(field)
0.77 options.py(297):         if not self.pk and field.primary_key:
0.77 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.77 options.py(288):             try:
0.77 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.77 options.py(728):         if forward:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 options.py(292):             self._expire_cache()
0.77 options.py(728):         if forward:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(730):                 if cache_key in self.__dict__:
0.77 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.77 options.py(732):         if reverse and not self.abstract:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(734):                 if cache_key in self.__dict__:
0.77 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.77 options.py(736):         self._get_fields_cache = {}
0.77 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.77 base.py(161):             new_class.add_to_class(obj_name, obj)
0.77 base.py(325):         if _has_contribute_to_class(value):
0.77 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.77 base.py(326):             value.contribute_to_class(cls, name)
0.77 options.py(271):         if private:
0.77 options.py(273):         elif field.is_relation and field.many_to_many:
0.77 options.py(276):             bisect.insort(self.local_fields, field)
0.78 options.py(277):             self.setup_pk(field)
0.78 options.py(297):         if not self.pk and field.primary_key:
0.78 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.78 options.py(288):             try:
0.78 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.78 options.py(728):         if forward:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 options.py(292):             self._expire_cache()
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.78 base.py(161):             new_class.add_to_class(obj_name, obj)
0.78 base.py(325):         if _has_contribute_to_class(value):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(326):             value.contribute_to_class(cls, name)
0.78 options.py(271):         if private:
0.78 options.py(273):         elif field.is_relation and field.many_to_many:
0.78 options.py(276):             bisect.insort(self.local_fields, field)
0.78 options.py(277):             self.setup_pk(field)
0.78 options.py(297):         if not self.pk and field.primary_key:
0.78 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.78 options.py(294):             self._expire_cache(reverse=False)
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.78 base.py(164):         new_fields = chain(
0.78 base.py(165):             new_class._meta.local_fields,
0.78 base.py(166):             new_class._meta.local_many_to_many,
0.78 base.py(167):             new_class._meta.private_fields
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(169):         field_names = {f.name for f in new_fields}
0.78 base.py(172):         if is_proxy:
0.78 base.py(192):             new_class._meta.concrete_model = new_class
0.78 base.py(195):         parent_links = {}
0.78 base.py(196):         for base in reversed([new_class] + parents):
0.78 base.py(198):             if not hasattr(base, '_meta'):
0.78 base.py(199):                 continue
0.78 base.py(196):         for base in reversed([new_class] + parents):
0.78 base.py(198):             if not hasattr(base, '_meta'):
0.78 base.py(201):             if base != new_class and not base._meta.abstract:
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(205):                 if isinstance(field, OneToOneField):
0.78 base.py(204):             for field in base._meta.local_fields:
0.78 base.py(196):         for base in reversed([new_class] + parents):
0.78 base.py(210):         inherited_attributes = set()
0.78 base.py(212):         for base in new_class.mro():
0.78 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.78 base.py(216):                 inherited_attributes.update(base.__dict__)
0.78 base.py(217):                 continue
0.78 base.py(212):         for base in new_class.mro():
0.78 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.78 base.py(216):                 inherited_attributes.update(base.__dict__)
0.78 base.py(217):                 continue
0.78 base.py(212):         for base in new_class.mro():
0.78 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.78 base.py(216):                 inherited_attributes.update(base.__dict__)
0.78 base.py(217):                 continue
0.78 base.py(212):         for base in new_class.mro():
0.78 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.78 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.78 base.py(312):         if abstract:
0.78 base.py(320):         new_class._prepare()
0.78 base.py(332):         opts = cls._meta
0.78 base.py(333):         opts._prepare(cls)
0.78 options.py(223):         if self.order_with_respect_to:
0.78 options.py(239):             self.order_with_respect_to = None
0.78 options.py(241):         if self.pk is None:
0.78 base.py(335):         if opts.order_with_respect_to:
0.78 base.py(350):         if cls.__doc__ is None:
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 options.py(456):         def is_not_an_m2m_field(f):
0.78 options.py(459):         def is_not_a_generic_relation(f):
0.78 options.py(462):         def is_not_a_generic_foreign_key(f):
0.78 options.py(467):         return make_immutable_fields_list(
0.78 options.py(468):             "fields",
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(792):             for parent in self.parents:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.78 options.py(457):             return not (f.is_relation and f.many_to_many)
0.78 options.py(460):             return not (f.is_relation and f.one_to_many)
0.78 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.78 options.py(469):             (f for f in self._get_fields(reverse=False)
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.78 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.78 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.78 base.py(354):         if get_absolute_url_override:
0.78 base.py(357):         if not opts.managers:
0.78 options.py(365):         managers = []
0.78 options.py(366):         seen_managers = set()
0.78 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.78 options.py(368):         for depth, base in enumerate(bases):
0.78 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.78 options.py(369):             for manager in base._meta.local_managers:
0.78 options.py(368):         for depth, base in enumerate(bases):
0.78 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.78 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.78 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.78 options.py(378):         return make_immutable_fields_list(
0.78 options.py(379):             "managers",
0.78 options.py(380):             (m[2] for m in sorted(managers)),
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(380):             (m[2] for m in sorted(managers)),
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.78 base.py(363):             manager = Manager()
0.78 base.py(364):             manager.auto_created = True
0.78 base.py(365):             cls.add_to_class('objects', manager)
0.78 base.py(325):         if _has_contribute_to_class(value):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(326):             value.contribute_to_class(cls, name)
0.78 options.py(263):         self.local_managers.append(manager)
0.78 options.py(264):         self._expire_cache()
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(731):                     delattr(self, cache_key)
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(731):                     delattr(self, cache_key)
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 base.py(370):         for index in cls._meta.indexes:
0.78 base.py(374):         class_prepared.send(sender=cls)
0.78 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.78 base.py(322):         return new_class
0.78 options.py(564):         try:
0.78 options.py(567):             return self._forward_fields_map[field_name]
0.78 options.py(564):         try:
0.78 options.py(567):             return self._forward_fields_map[field_name]
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 base.py(408):         cls = self.__class__
0.78 base.py(409):         opts = self._meta
0.78 base.py(410):         _setattr = setattr
0.78 base.py(411):         _DEFERRED = DEFERRED
0.78 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.78 base.py(416):         self._state = ModelState()
0.78 base.py(422):         if len(args) > len(opts.concrete_fields):
0.78 base.py(426):         if not kwargs:
0.78 base.py(438):             fields_iter = iter(opts.fields)
0.78 base.py(439):             for val, field in zip(args, fields_iter):
0.78 base.py(448):         for field in fields_iter:
0.78 base.py(449):             is_related_object = False
0.78 base.py(451):             if field.attname not in kwargs and field.column is None:
0.78 base.py(453):             if kwargs:
0.78 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.78 base.py(466):                     try:
0.78 base.py(467):                         val = kwargs.pop(field.attname)
0.78 base.py(468):                     except KeyError:
0.78 base.py(473):                         val = field.get_default()
0.78 base.py(477):             if is_related_object:
0.78 base.py(485):                 if val is not _DEFERRED:
0.78 base.py(486):                     _setattr(self, field.attname, val)
0.78 base.py(448):         for field in fields_iter:
0.78 base.py(449):             is_related_object = False
0.78 base.py(451):             if field.attname not in kwargs and field.column is None:
0.78 base.py(453):             if kwargs:
0.78 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.78 base.py(466):                     try:
0.78 base.py(467):                         val = kwargs.pop(field.attname)
0.78 base.py(477):             if is_related_object:
0.78 base.py(485):                 if val is not _DEFERRED:
0.78 base.py(486):                     _setattr(self, field.attname, val)
0.78 base.py(448):         for field in fields_iter:
0.78 base.py(449):             is_related_object = False
0.78 base.py(451):             if field.attname not in kwargs and field.column is None:
0.78 base.py(453):             if kwargs:
0.78 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.78 base.py(466):                     try:
0.78 base.py(467):                         val = kwargs.pop(field.attname)
0.78 base.py(477):             if is_related_object:
0.78 base.py(485):                 if val is not _DEFERRED:
0.78 base.py(486):                     _setattr(self, field.attname, val)
0.78 base.py(448):         for field in fields_iter:
0.78 base.py(449):             is_related_object = False
0.78 base.py(451):             if field.attname not in kwargs and field.column is None:
0.78 base.py(453):             if kwargs:
0.78 base.py(475):                 val = field.get_default()
0.78 base.py(477):             if is_related_object:
0.78 base.py(485):                 if val is not _DEFERRED:
0.78 base.py(486):                     _setattr(self, field.attname, val)
0.78 base.py(448):         for field in fields_iter:
0.78 base.py(488):         if kwargs:
0.78 base.py(502):         super().__init__()
0.78 base.py(503):         post_init.send(sender=cls, instance=self)
0.78 base.py(679):         for field in self._meta.concrete_fields:
0.78 base.py(682):             if field.is_relation and field.is_cached(self):
0.78 base.py(679):         for field in self._meta.concrete_fields:
0.78 base.py(682):             if field.is_relation and field.is_cached(self):
0.78 base.py(679):         for field in self._meta.concrete_fields:
0.78 base.py(682):             if field.is_relation and field.is_cached(self):
0.78 base.py(679):         for field in self._meta.concrete_fields:
0.78 base.py(682):             if field.is_relation and field.is_cached(self):
0.78 base.py(679):         for field in self._meta.concrete_fields:
0.78 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.78 base.py(710):         if force_insert and (force_update or update_fields):
0.78 base.py(713):         deferred_fields = self.get_deferred_fields()
0.78 base.py(583):         return {
0.78 base.py(584):             f.attname for f in self._meta.concrete_fields
0.78 base.py(583):         return {
0.78 base.py(584):             f.attname for f in self._meta.concrete_fields
0.78 base.py(585):             if f.attname not in self.__dict__
0.78 base.py(583):         return {
0.78 base.py(584):             f.attname for f in self._meta.concrete_fields
0.78 base.py(585):             if f.attname not in self.__dict__
0.78 base.py(583):         return {
0.78 base.py(584):             f.attname for f in self._meta.concrete_fields
0.78 base.py(585):             if f.attname not in self.__dict__
0.78 base.py(583):         return {
0.78 base.py(584):             f.attname for f in self._meta.concrete_fields
0.78 base.py(585):             if f.attname not in self.__dict__
0.78 base.py(583):         return {
0.78 base.py(714):         if update_fields is not None:
0.78 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.78 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.78 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.78 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.78 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.78 base.py(766):         assert update_fields is None or update_fields
0.78 base.py(767):         cls = origin = self.__class__
0.78 base.py(769):         if cls._meta.proxy:
0.78 base.py(771):         meta = cls._meta
0.78 base.py(772):         if not meta.auto_created:
0.78 base.py(773):             pre_save.send(
0.78 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.78 base.py(775):                 update_fields=update_fields,
0.78 base.py(778):         if meta.parents:
0.78 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.78 base.py(782):         with context_manager:
0.78 base.py(783):             parent_inserted = False
0.78 base.py(784):             if not raw:
0.78 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.78 base.py(806):         meta = cls._meta
0.78 base.py(807):         inserted = False
0.78 base.py(808):         for parent, field in meta.parents.items():
0.78 base.py(830):         return inserted
0.78 base.py(786):             updated = self._save_table(
0.78 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.78 base.py(788):                 force_update, using, update_fields,
0.78 base.py(838):         meta = cls._meta
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.78 base.py(841):         if update_fields:
0.78 base.py(845):         pk_val = self._get_pk_val(meta)
0.78 base.py(568):         meta = meta or self._meta
0.78 base.py(569):         return getattr(self, meta.pk.attname)
0.78 base.py(846):         if pk_val is None:
0.78 base.py(847):             pk_val = meta.pk.get_pk_value_on_save(self)
0.78 base.py(848):             setattr(self, meta.pk.attname, pk_val)
0.78 base.py(849):         pk_set = pk_val is not None
0.78 base.py(850):         if not pk_set and (force_update or update_fields):
0.78 base.py(852):         updated = False
0.78 base.py(855):             not raw and
0.78 base.py(856):             not force_insert and
0.78 base.py(863):         if pk_set and not force_insert:
0.78 base.py(874):         if not updated:
0.78 base.py(875):             if meta.order_with_respect_to:
0.78 base.py(886):             fields = meta.local_concrete_fields
0.78 base.py(887):             if not pk_set:
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.78 base.py(890):             returning_fields = meta.db_returning_fields
0.78 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.78 base.py(378):         return cls._meta.base_manager
0.78 base.py(928):         return manager._insert(
0.78 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.78 base.py(930):             using=using, raw=raw,
0.78 base.py(892):             for result, field in zip(results, returning_fields):
0.78 base.py(893):                 setattr(self, field.attname, result)
0.78 base.py(892):             for result, field in zip(results, returning_fields):
0.78 base.py(894):         return updated
0.78 base.py(791):         self._state.db = using
0.78 base.py(793):         self._state.adding = False
0.78 base.py(796):         if not meta.auto_created:
0.78 base.py(797):             post_save.send(
0.78 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.78 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
 OK
  Applying admin.0003_logentry_add_action_flag_choices...0.78 options.py(748):         if include_parents is False:
0.78 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(792):             for parent in self.parents:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(810):             all_fields = self._relation_tree
0.78 options.py(723):         return self._populate_directed_relation_graph()
0.78 options.py(692):         related_objects_graph = defaultdict(list)
0.78 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.78 options.py(349):             if swapped_for:
0.78 options.py(350):                 try:
0.78 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.78 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.78 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(696):             opts = model._meta
0.78 options.py(699):             if opts.abstract:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.78 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(703):                 if f.is_relation and f.related_model is not None
0.78 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.78 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.78 options.py(705):             for f in fields_with_relations:
0.78 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.78 options.py(695):         for model in all_models:
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.78 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.78 options.py(709):         for model in all_models:
0.78 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
0.78 options.py(811):             for field in all_fields:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(748):         if include_parents is False:
0.78 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(792):             for parent in self.parents:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(810):             all_fields = self._relation_tree
0.78 options.py(811):             for field in all_fields:
0.78 options.py(814):                 if include_hidden or not field.remote_field.hidden:
0.78 options.py(815):                     fields.append(field.remote_field)
0.78 options.py(811):             for field in all_fields:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(748):         if include_parents is False:
0.78 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.78 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.78 options.py(773):         topmost_call = seen_models is None
0.78 options.py(774):         if topmost_call:
0.78 options.py(775):             seen_models = set()
0.78 options.py(776):         seen_models.add(self.model)
0.78 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.78 options.py(781):         try:
0.78 options.py(784):             return self._get_fields_cache[cache_key]
0.78 options.py(785):         except KeyError:
0.78 options.py(786):             pass
0.78 options.py(788):         fields = []
0.78 options.py(791):         if include_parents is not False:
0.78 options.py(792):             for parent in self.parents:
0.78 options.py(806):         if reverse and not self.proxy:
0.78 options.py(810):             all_fields = self._relation_tree
0.78 options.py(811):             for field in all_fields:
0.78 options.py(814):                 if include_hidden or not field.remote_field.hidden:
0.78 options.py(815):                     fields.append(field.remote_field)
0.78 options.py(811):             for field in all_fields:
0.78 options.py(817):         if forward:
0.78 options.py(818):             fields += self.local_fields
0.78 options.py(819):             fields += self.local_many_to_many
0.78 options.py(825):             if topmost_call:
0.78 options.py(826):                 fields += self.private_fields
0.78 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.78 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.78 options.py(833):         self._get_fields_cache[cache_key] = fields
0.78 options.py(834):         return fields
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(735):                     delattr(self, cache_key)
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(735):                     delattr(self, cache_key)
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 options.py(347):         if self.swappable:
0.78 options.py(361):         return None
0.78 options.py(728):         if forward:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(730):                 if cache_key in self.__dict__:
0.78 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.78 options.py(732):         if reverse and not self.abstract:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(735):                     delattr(self, cache_key)
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(734):                 if cache_key in self.__dict__:
0.78 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.78 options.py(736):         self._get_fields_cache = {}
0.78 base.py(75):         super_new = super().__new__
0.78 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.78 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.78 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.78 base.py(80):         if not parents:
0.78 base.py(84):         module = attrs.pop('__module__')
0.78 base.py(85):         new_attrs = {'__module__': module}
0.78 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.78 base.py(87):         if classcell is not None:
0.78 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.78 base.py(93):         contributable_attrs = {}
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(95):             if _has_contribute_to_class(obj):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(96):                 contributable_attrs[obj_name] = obj
0.78 base.py(94):         for obj_name, obj in list(attrs.items()):
0.78 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.78 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.78 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.78 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.78 base.py(105):         app_label = None
0.78 base.py(108):         app_config = apps.get_containing_app_config(module)
0.78 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.78 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.78 options.py(76):         self._get_fields_cache = {}
0.78 options.py(77):         self.local_fields = []
0.78 options.py(78):         self.local_many_to_many = []
0.78 options.py(79):         self.private_fields = []
0.78 options.py(80):         self.local_managers = []
0.78 options.py(81):         self.base_manager_name = None
0.78 options.py(82):         self.default_manager_name = None
0.78 options.py(83):         self.model_name = None
0.78 options.py(84):         self.verbose_name = None
0.78 options.py(85):         self.verbose_name_plural = None
0.78 options.py(86):         self.db_table = ''
0.78 options.py(87):         self.ordering = []
0.78 options.py(88):         self._ordering_clash = False
0.78 options.py(89):         self.indexes = []
0.78 options.py(90):         self.constraints = []
0.78 options.py(91):         self.unique_together = []
0.78 options.py(92):         self.index_together = []
0.78 options.py(93):         self.select_on_save = False
0.78 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.78 options.py(95):         self.permissions = []
0.78 options.py(96):         self.object_name = None
0.78 options.py(97):         self.app_label = app_label
0.78 options.py(98):         self.get_latest_by = None
0.78 options.py(99):         self.order_with_respect_to = None
0.78 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.78 options.py(101):         self.required_db_features = []
0.78 options.py(102):         self.required_db_vendor = None
0.78 options.py(103):         self.meta = meta
0.78 options.py(104):         self.pk = None
0.78 options.py(105):         self.auto_field = None
0.78 options.py(106):         self.abstract = False
0.78 options.py(107):         self.managed = True
0.78 options.py(108):         self.proxy = False
0.78 options.py(114):         self.proxy_for_model = None
0.78 options.py(118):         self.concrete_model = None
0.78 options.py(119):         self.swappable = None
0.78 options.py(120):         self.parents = {}
0.78 options.py(121):         self.auto_created = False
0.78 options.py(125):         self.related_fkey_lookups = []
0.78 options.py(128):         self.apps = self.default_apps
0.78 options.py(130):         self.default_related_name = None
0.78 base.py(325):         if _has_contribute_to_class(value):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(326):             value.contribute_to_class(cls, name)
0.78 options.py(150):         from django.db import connection
0.78 options.py(151):         from django.db.backends.utils import truncate_name
0.78 options.py(153):         cls._meta = self
0.78 options.py(154):         self.model = cls
0.78 options.py(156):         self.object_name = cls.__name__
0.78 options.py(157):         self.model_name = self.object_name.lower()
0.78 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.78 options.py(162):         self.original_attrs = {}
0.78 options.py(165):         if self.meta:
0.78 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(172):                     del meta_attrs[name]
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(172):                     del meta_attrs[name]
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(172):                     del meta_attrs[name]
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(171):                 if name.startswith('_'):
0.78 options.py(172):                     del meta_attrs[name]
0.78 options.py(167):             for name in self.meta.__dict__:
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(177):                 elif hasattr(self.meta, attr_name):
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(174):                 if attr_name in meta_attrs:
0.78 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.78 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.78 options.py(173):             for attr_name in DEFAULT_NAMES:
0.78 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.78 options.py(45):     try:
0.78 options.py(46):         if not option_together:
0.78 options.py(47):             return ()
0.78 options.py(182):             self.index_together = normalize_together(self.index_together)
0.78 options.py(45):     try:
0.78 options.py(46):         if not option_together:
0.78 options.py(47):             return ()
0.78 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.78 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.78 options.py(187):                     objs = getattr(self, attr_name, [])
0.78 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.78 options.py(212):         new_objs = []
0.78 options.py(213):         for obj in objs:
0.78 options.py(220):         return new_objs
0.78 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.78 options.py(187):                     objs = getattr(self, attr_name, [])
0.78 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.78 options.py(212):         new_objs = []
0.78 options.py(213):         for obj in objs:
0.78 options.py(220):         return new_objs
0.78 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.78 options.py(192):             if self.verbose_name_plural is None:
0.78 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.78 options.py(199):             if meta_attrs != {}:
0.78 options.py(203):         del self.meta
0.78 options.py(206):         if not self.db_table:
0.78 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.78 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.78 base.py(123):         if not abstract:
0.78 base.py(124):             new_class.add_to_class(
0.78 base.py(125):                 'DoesNotExist',
0.78 base.py(126):                 subclass_exception(
0.78 base.py(127):                     'DoesNotExist',
0.78 base.py(128):                     tuple(
0.78 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(130):                     ) or (ObjectDoesNotExist,),
0.78 base.py(131):                     module,
0.78 base.py(132):                     attached_to=new_class))
0.78 base.py(61):     return type(name, bases, {
0.78 base.py(62):         '__module__': module,
0.78 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.78 base.py(325):         if _has_contribute_to_class(value):
0.78 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.78 base.py(328):             setattr(cls, name, value)
0.78 base.py(133):             new_class.add_to_class(
0.78 base.py(134):                 'MultipleObjectsReturned',
0.78 base.py(135):                 subclass_exception(
0.78 base.py(136):                     'MultipleObjectsReturned',
0.78 base.py(137):                     tuple(
0.78 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.78 base.py(139):                     ) or (MultipleObjectsReturned,),
0.79 base.py(140):                     module,
0.79 base.py(141):                     attached_to=new_class))
0.79 base.py(61):     return type(name, bases, {
0.79 base.py(62):         '__module__': module,
0.79 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(328):             setattr(cls, name, value)
0.79 base.py(142):             if base_meta and not base_meta.abstract:
0.79 base.py(151):         is_proxy = new_class._meta.proxy
0.79 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(298):             self.pk = field
0.79 options.py(299):             field.serialize = False
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(263):         self.local_managers.append(manager)
0.79 options.py(264):         self._expire_cache()
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(164):         new_fields = chain(
0.79 base.py(165):             new_class._meta.local_fields,
0.79 base.py(166):             new_class._meta.local_many_to_many,
0.79 base.py(167):             new_class._meta.private_fields
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(172):         if is_proxy:
0.79 base.py(192):             new_class._meta.concrete_model = new_class
0.79 base.py(195):         parent_links = {}
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(199):                 continue
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(201):             if base != new_class and not base._meta.abstract:
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(210):         inherited_attributes = set()
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(312):         if abstract:
0.79 base.py(320):         new_class._prepare()
0.79 base.py(332):         opts = cls._meta
0.79 base.py(333):         opts._prepare(cls)
0.79 options.py(223):         if self.order_with_respect_to:
0.79 options.py(239):             self.order_with_respect_to = None
0.79 options.py(241):         if self.pk is None:
0.79 base.py(335):         if opts.order_with_respect_to:
0.79 base.py(350):         if cls.__doc__ is None:
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 options.py(456):         def is_not_an_m2m_field(f):
0.79 options.py(459):         def is_not_a_generic_relation(f):
0.79 options.py(462):         def is_not_a_generic_foreign_key(f):
0.79 options.py(467):         return make_immutable_fields_list(
0.79 options.py(468):             "fields",
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.79 options.py(773):         topmost_call = seen_models is None
0.79 options.py(774):         if topmost_call:
0.79 options.py(775):             seen_models = set()
0.79 options.py(776):         seen_models.add(self.model)
0.79 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.79 options.py(781):         try:
0.79 options.py(784):             return self._get_fields_cache[cache_key]
0.79 options.py(785):         except KeyError:
0.79 options.py(786):             pass
0.79 options.py(788):         fields = []
0.79 options.py(791):         if include_parents is not False:
0.79 options.py(792):             for parent in self.parents:
0.79 options.py(806):         if reverse and not self.proxy:
0.79 options.py(817):         if forward:
0.79 options.py(818):             fields += self.local_fields
0.79 options.py(819):             fields += self.local_many_to_many
0.79 options.py(825):             if topmost_call:
0.79 options.py(826):                 fields += self.private_fields
0.79 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(833):         self._get_fields_cache[cache_key] = fields
0.79 options.py(834):         return fields
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.79 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.79 base.py(354):         if get_absolute_url_override:
0.79 base.py(357):         if not opts.managers:
0.79 options.py(365):         managers = []
0.79 options.py(366):         seen_managers = set()
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(370):                 if manager.name in seen_managers:
0.79 options.py(373):                 manager = copy.copy(manager)
0.79 options.py(374):                 manager.model = self.model
0.79 options.py(375):                 seen_managers.add(manager.name)
0.79 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(378):         return make_immutable_fields_list(
0.79 options.py(379):             "managers",
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 base.py(370):         for index in cls._meta.indexes:
0.79 base.py(374):         class_prepared.send(sender=cls)
0.79 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.79 base.py(322):         return new_class
0.79 base.py(75):         super_new = super().__new__
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(80):         if not parents:
0.79 base.py(84):         module = attrs.pop('__module__')
0.79 base.py(85):         new_attrs = {'__module__': module}
0.79 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.79 base.py(87):         if classcell is not None:
0.79 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.79 base.py(93):         contributable_attrs = {}
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.79 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.79 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.79 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.79 base.py(105):         app_label = None
0.79 base.py(108):         app_config = apps.get_containing_app_config(module)
0.79 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.79 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.79 options.py(76):         self._get_fields_cache = {}
0.79 options.py(77):         self.local_fields = []
0.79 options.py(78):         self.local_many_to_many = []
0.79 options.py(79):         self.private_fields = []
0.79 options.py(80):         self.local_managers = []
0.79 options.py(81):         self.base_manager_name = None
0.79 options.py(82):         self.default_manager_name = None
0.79 options.py(83):         self.model_name = None
0.79 options.py(84):         self.verbose_name = None
0.79 options.py(85):         self.verbose_name_plural = None
0.79 options.py(86):         self.db_table = ''
0.79 options.py(87):         self.ordering = []
0.79 options.py(88):         self._ordering_clash = False
0.79 options.py(89):         self.indexes = []
0.79 options.py(90):         self.constraints = []
0.79 options.py(91):         self.unique_together = []
0.79 options.py(92):         self.index_together = []
0.79 options.py(93):         self.select_on_save = False
0.79 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.79 options.py(95):         self.permissions = []
0.79 options.py(96):         self.object_name = None
0.79 options.py(97):         self.app_label = app_label
0.79 options.py(98):         self.get_latest_by = None
0.79 options.py(99):         self.order_with_respect_to = None
0.79 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.79 options.py(101):         self.required_db_features = []
0.79 options.py(102):         self.required_db_vendor = None
0.79 options.py(103):         self.meta = meta
0.79 options.py(104):         self.pk = None
0.79 options.py(105):         self.auto_field = None
0.79 options.py(106):         self.abstract = False
0.79 options.py(107):         self.managed = True
0.79 options.py(108):         self.proxy = False
0.79 options.py(114):         self.proxy_for_model = None
0.79 options.py(118):         self.concrete_model = None
0.79 options.py(119):         self.swappable = None
0.79 options.py(120):         self.parents = {}
0.79 options.py(121):         self.auto_created = False
0.79 options.py(125):         self.related_fkey_lookups = []
0.79 options.py(128):         self.apps = self.default_apps
0.79 options.py(130):         self.default_related_name = None
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(150):         from django.db import connection
0.79 options.py(151):         from django.db.backends.utils import truncate_name
0.79 options.py(153):         cls._meta = self
0.79 options.py(154):         self.model = cls
0.79 options.py(156):         self.object_name = cls.__name__
0.79 options.py(157):         self.model_name = self.object_name.lower()
0.79 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.79 options.py(162):         self.original_attrs = {}
0.79 options.py(165):         if self.meta:
0.79 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.79 options.py(45):     try:
0.79 options.py(46):         if not option_together:
0.79 options.py(47):             return ()
0.79 options.py(182):             self.index_together = normalize_together(self.index_together)
0.79 options.py(45):     try:
0.79 options.py(46):         if not option_together:
0.79 options.py(47):             return ()
0.79 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(187):                     objs = getattr(self, attr_name, [])
0.79 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.79 options.py(212):         new_objs = []
0.79 options.py(213):         for obj in objs:
0.79 options.py(220):         return new_objs
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(187):                     objs = getattr(self, attr_name, [])
0.79 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.79 options.py(212):         new_objs = []
0.79 options.py(213):         for obj in objs:
0.79 options.py(220):         return new_objs
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(192):             if self.verbose_name_plural is None:
0.79 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.79 options.py(199):             if meta_attrs != {}:
0.79 options.py(203):         del self.meta
0.79 options.py(206):         if not self.db_table:
0.79 base.py(123):         if not abstract:
0.79 base.py(124):             new_class.add_to_class(
0.79 base.py(125):                 'DoesNotExist',
0.79 base.py(126):                 subclass_exception(
0.79 base.py(127):                     'DoesNotExist',
0.79 base.py(128):                     tuple(
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(130):                     ) or (ObjectDoesNotExist,),
0.79 base.py(131):                     module,
0.79 base.py(132):                     attached_to=new_class))
0.79 base.py(61):     return type(name, bases, {
0.79 base.py(62):         '__module__': module,
0.79 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(328):             setattr(cls, name, value)
0.79 base.py(133):             new_class.add_to_class(
0.79 base.py(134):                 'MultipleObjectsReturned',
0.79 base.py(135):                 subclass_exception(
0.79 base.py(136):                     'MultipleObjectsReturned',
0.79 base.py(137):                     tuple(
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(139):                     ) or (MultipleObjectsReturned,),
0.79 base.py(140):                     module,
0.79 base.py(141):                     attached_to=new_class))
0.79 base.py(61):     return type(name, bases, {
0.79 base.py(62):         '__module__': module,
0.79 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(328):             setattr(cls, name, value)
0.79 base.py(142):             if base_meta and not base_meta.abstract:
0.79 base.py(151):         is_proxy = new_class._meta.proxy
0.79 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(298):             self.pk = field
0.79 options.py(299):             field.serialize = False
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(263):         self.local_managers.append(manager)
0.79 options.py(264):         self._expire_cache()
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(164):         new_fields = chain(
0.79 base.py(165):             new_class._meta.local_fields,
0.79 base.py(166):             new_class._meta.local_many_to_many,
0.79 base.py(167):             new_class._meta.private_fields
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(172):         if is_proxy:
0.79 base.py(192):             new_class._meta.concrete_model = new_class
0.79 base.py(195):         parent_links = {}
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(199):                 continue
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(201):             if base != new_class and not base._meta.abstract:
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(210):         inherited_attributes = set()
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(312):         if abstract:
0.79 base.py(320):         new_class._prepare()
0.79 base.py(332):         opts = cls._meta
0.79 base.py(333):         opts._prepare(cls)
0.79 options.py(223):         if self.order_with_respect_to:
0.79 options.py(239):             self.order_with_respect_to = None
0.79 options.py(241):         if self.pk is None:
0.79 base.py(335):         if opts.order_with_respect_to:
0.79 base.py(350):         if cls.__doc__ is None:
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 options.py(456):         def is_not_an_m2m_field(f):
0.79 options.py(459):         def is_not_a_generic_relation(f):
0.79 options.py(462):         def is_not_a_generic_foreign_key(f):
0.79 options.py(467):         return make_immutable_fields_list(
0.79 options.py(468):             "fields",
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.79 options.py(773):         topmost_call = seen_models is None
0.79 options.py(774):         if topmost_call:
0.79 options.py(775):             seen_models = set()
0.79 options.py(776):         seen_models.add(self.model)
0.79 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.79 options.py(781):         try:
0.79 options.py(784):             return self._get_fields_cache[cache_key]
0.79 options.py(785):         except KeyError:
0.79 options.py(786):             pass
0.79 options.py(788):         fields = []
0.79 options.py(791):         if include_parents is not False:
0.79 options.py(792):             for parent in self.parents:
0.79 options.py(806):         if reverse and not self.proxy:
0.79 options.py(817):         if forward:
0.79 options.py(818):             fields += self.local_fields
0.79 options.py(819):             fields += self.local_many_to_many
0.79 options.py(825):             if topmost_call:
0.79 options.py(826):                 fields += self.private_fields
0.79 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(833):         self._get_fields_cache[cache_key] = fields
0.79 options.py(834):         return fields
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.79 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.79 base.py(354):         if get_absolute_url_override:
0.79 base.py(357):         if not opts.managers:
0.79 options.py(365):         managers = []
0.79 options.py(366):         seen_managers = set()
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(370):                 if manager.name in seen_managers:
0.79 options.py(373):                 manager = copy.copy(manager)
0.79 options.py(374):                 manager.model = self.model
0.79 options.py(375):                 seen_managers.add(manager.name)
0.79 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(378):         return make_immutable_fields_list(
0.79 options.py(379):             "managers",
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 base.py(370):         for index in cls._meta.indexes:
0.79 base.py(374):         class_prepared.send(sender=cls)
0.79 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.79 base.py(322):         return new_class
0.79 base.py(75):         super_new = super().__new__
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.79 base.py(80):         if not parents:
0.79 base.py(84):         module = attrs.pop('__module__')
0.79 base.py(85):         new_attrs = {'__module__': module}
0.79 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.79 base.py(87):         if classcell is not None:
0.79 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.79 base.py(93):         contributable_attrs = {}
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(95):             if _has_contribute_to_class(obj):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(96):                 contributable_attrs[obj_name] = obj
0.79 base.py(94):         for obj_name, obj in list(attrs.items()):
0.79 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.79 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.79 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.79 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.79 base.py(105):         app_label = None
0.79 base.py(108):         app_config = apps.get_containing_app_config(module)
0.79 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.79 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.79 options.py(76):         self._get_fields_cache = {}
0.79 options.py(77):         self.local_fields = []
0.79 options.py(78):         self.local_many_to_many = []
0.79 options.py(79):         self.private_fields = []
0.79 options.py(80):         self.local_managers = []
0.79 options.py(81):         self.base_manager_name = None
0.79 options.py(82):         self.default_manager_name = None
0.79 options.py(83):         self.model_name = None
0.79 options.py(84):         self.verbose_name = None
0.79 options.py(85):         self.verbose_name_plural = None
0.79 options.py(86):         self.db_table = ''
0.79 options.py(87):         self.ordering = []
0.79 options.py(88):         self._ordering_clash = False
0.79 options.py(89):         self.indexes = []
0.79 options.py(90):         self.constraints = []
0.79 options.py(91):         self.unique_together = []
0.79 options.py(92):         self.index_together = []
0.79 options.py(93):         self.select_on_save = False
0.79 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.79 options.py(95):         self.permissions = []
0.79 options.py(96):         self.object_name = None
0.79 options.py(97):         self.app_label = app_label
0.79 options.py(98):         self.get_latest_by = None
0.79 options.py(99):         self.order_with_respect_to = None
0.79 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.79 options.py(101):         self.required_db_features = []
0.79 options.py(102):         self.required_db_vendor = None
0.79 options.py(103):         self.meta = meta
0.79 options.py(104):         self.pk = None
0.79 options.py(105):         self.auto_field = None
0.79 options.py(106):         self.abstract = False
0.79 options.py(107):         self.managed = True
0.79 options.py(108):         self.proxy = False
0.79 options.py(114):         self.proxy_for_model = None
0.79 options.py(118):         self.concrete_model = None
0.79 options.py(119):         self.swappable = None
0.79 options.py(120):         self.parents = {}
0.79 options.py(121):         self.auto_created = False
0.79 options.py(125):         self.related_fkey_lookups = []
0.79 options.py(128):         self.apps = self.default_apps
0.79 options.py(130):         self.default_related_name = None
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(150):         from django.db import connection
0.79 options.py(151):         from django.db.backends.utils import truncate_name
0.79 options.py(153):         cls._meta = self
0.79 options.py(154):         self.model = cls
0.79 options.py(156):         self.object_name = cls.__name__
0.79 options.py(157):         self.model_name = self.object_name.lower()
0.79 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.79 options.py(162):         self.original_attrs = {}
0.79 options.py(165):         if self.meta:
0.79 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(171):                 if name.startswith('_'):
0.79 options.py(172):                     del meta_attrs[name]
0.79 options.py(167):             for name in self.meta.__dict__:
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(177):                 elif hasattr(self.meta, attr_name):
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(174):                 if attr_name in meta_attrs:
0.79 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.79 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.79 options.py(173):             for attr_name in DEFAULT_NAMES:
0.79 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.79 options.py(45):     try:
0.79 options.py(46):         if not option_together:
0.79 options.py(47):             return ()
0.79 options.py(182):             self.index_together = normalize_together(self.index_together)
0.79 options.py(45):     try:
0.79 options.py(46):         if not option_together:
0.79 options.py(47):             return ()
0.79 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(187):                     objs = getattr(self, attr_name, [])
0.79 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.79 options.py(212):         new_objs = []
0.79 options.py(213):         for obj in objs:
0.79 options.py(220):         return new_objs
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(187):                     objs = getattr(self, attr_name, [])
0.79 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.79 options.py(212):         new_objs = []
0.79 options.py(213):         for obj in objs:
0.79 options.py(220):         return new_objs
0.79 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.79 options.py(192):             if self.verbose_name_plural is None:
0.79 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.79 options.py(199):             if meta_attrs != {}:
0.79 options.py(203):         del self.meta
0.79 options.py(206):         if not self.db_table:
0.79 base.py(123):         if not abstract:
0.79 base.py(124):             new_class.add_to_class(
0.79 base.py(125):                 'DoesNotExist',
0.79 base.py(126):                 subclass_exception(
0.79 base.py(127):                     'DoesNotExist',
0.79 base.py(128):                     tuple(
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(130):                     ) or (ObjectDoesNotExist,),
0.79 base.py(131):                     module,
0.79 base.py(132):                     attached_to=new_class))
0.79 base.py(61):     return type(name, bases, {
0.79 base.py(62):         '__module__': module,
0.79 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(328):             setattr(cls, name, value)
0.79 base.py(133):             new_class.add_to_class(
0.79 base.py(134):                 'MultipleObjectsReturned',
0.79 base.py(135):                 subclass_exception(
0.79 base.py(136):                     'MultipleObjectsReturned',
0.79 base.py(137):                     tuple(
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.79 base.py(139):                     ) or (MultipleObjectsReturned,),
0.79 base.py(140):                     module,
0.79 base.py(141):                     attached_to=new_class))
0.79 base.py(61):     return type(name, bases, {
0.79 base.py(62):         '__module__': module,
0.79 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(328):             setattr(cls, name, value)
0.79 base.py(142):             if base_meta and not base_meta.abstract:
0.79 base.py(151):         is_proxy = new_class._meta.proxy
0.79 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(298):             self.pk = field
0.79 options.py(299):             field.serialize = False
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(294):             self._expire_cache(reverse=False)
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(288):             try:
0.79 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.79 options.py(290):             except AttributeError:
0.79 options.py(291):                 pass
0.79 options.py(292):             self._expire_cache()
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(271):         if private:
0.79 options.py(273):         elif field.is_relation and field.many_to_many:
0.79 options.py(276):             bisect.insort(self.local_fields, field)
0.79 options.py(277):             self.setup_pk(field)
0.79 options.py(297):         if not self.pk and field.primary_key:
0.79 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.79 options.py(288):             try:
0.79 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.79 options.py(290):             except AttributeError:
0.79 options.py(291):                 pass
0.79 options.py(292):             self._expire_cache()
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(161):             new_class.add_to_class(obj_name, obj)
0.79 base.py(325):         if _has_contribute_to_class(value):
0.79 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.79 base.py(326):             value.contribute_to_class(cls, name)
0.79 options.py(263):         self.local_managers.append(manager)
0.79 options.py(264):         self._expire_cache()
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.79 base.py(164):         new_fields = chain(
0.79 base.py(165):             new_class._meta.local_fields,
0.79 base.py(166):             new_class._meta.local_many_to_many,
0.79 base.py(167):             new_class._meta.private_fields
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(169):         field_names = {f.name for f in new_fields}
0.79 base.py(172):         if is_proxy:
0.79 base.py(192):             new_class._meta.concrete_model = new_class
0.79 base.py(195):         parent_links = {}
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(199):                 continue
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(198):             if not hasattr(base, '_meta'):
0.79 base.py(201):             if base != new_class and not base._meta.abstract:
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(205):                 if isinstance(field, OneToOneField):
0.79 base.py(204):             for field in base._meta.local_fields:
0.79 base.py(196):         for base in reversed([new_class] + parents):
0.79 base.py(210):         inherited_attributes = set()
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.79 base.py(216):                 inherited_attributes.update(base.__dict__)
0.79 base.py(217):                 continue
0.79 base.py(212):         for base in new_class.mro():
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.79 base.py(312):         if abstract:
0.79 base.py(320):         new_class._prepare()
0.79 base.py(332):         opts = cls._meta
0.79 base.py(333):         opts._prepare(cls)
0.79 options.py(223):         if self.order_with_respect_to:
0.79 options.py(239):             self.order_with_respect_to = None
0.79 options.py(241):         if self.pk is None:
0.79 base.py(335):         if opts.order_with_respect_to:
0.79 base.py(350):         if cls.__doc__ is None:
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 options.py(456):         def is_not_an_m2m_field(f):
0.79 options.py(459):         def is_not_a_generic_relation(f):
0.79 options.py(462):         def is_not_a_generic_foreign_key(f):
0.79 options.py(467):         return make_immutable_fields_list(
0.79 options.py(468):             "fields",
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.79 options.py(773):         topmost_call = seen_models is None
0.79 options.py(774):         if topmost_call:
0.79 options.py(775):             seen_models = set()
0.79 options.py(776):         seen_models.add(self.model)
0.79 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.79 options.py(781):         try:
0.79 options.py(784):             return self._get_fields_cache[cache_key]
0.79 options.py(785):         except KeyError:
0.79 options.py(786):             pass
0.79 options.py(788):         fields = []
0.79 options.py(791):         if include_parents is not False:
0.79 options.py(792):             for parent in self.parents:
0.79 options.py(806):         if reverse and not self.proxy:
0.79 options.py(817):         if forward:
0.79 options.py(818):             fields += self.local_fields
0.79 options.py(819):             fields += self.local_many_to_many
0.79 options.py(825):             if topmost_call:
0.79 options.py(826):                 fields += self.private_fields
0.79 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(833):         self._get_fields_cache[cache_key] = fields
0.79 options.py(834):         return fields
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.79 options.py(457):             return not (f.is_relation and f.many_to_many)
0.79 options.py(460):             return not (f.is_relation and f.one_to_many)
0.79 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.79 options.py(469):             (f for f in self._get_fields(reverse=False)
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.79 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.79 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.79 base.py(354):         if get_absolute_url_override:
0.79 base.py(357):         if not opts.managers:
0.79 options.py(365):         managers = []
0.79 options.py(366):         seen_managers = set()
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(370):                 if manager.name in seen_managers:
0.79 options.py(373):                 manager = copy.copy(manager)
0.79 options.py(374):                 manager.model = self.model
0.79 options.py(375):                 seen_managers.add(manager.name)
0.79 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.79 options.py(369):             for manager in base._meta.local_managers:
0.79 options.py(368):         for depth, base in enumerate(bases):
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.79 options.py(378):         return make_immutable_fields_list(
0.79 options.py(379):             "managers",
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 options.py(380):             (m[2] for m in sorted(managers)),
0.79 base.py(370):         for index in cls._meta.indexes:
0.79 base.py(374):         class_prepared.send(sender=cls)
0.79 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 base.py(322):         return new_class
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(347):         if self.swappable:
0.79 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.79 options.py(349):             if swapped_for:
0.79 options.py(350):                 try:
0.79 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.79 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.79 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(728):         if forward:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(731):                     delattr(self, cache_key)
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(730):                 if cache_key in self.__dict__:
0.79 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.79 options.py(732):         if reverse and not self.abstract:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(734):                 if cache_key in self.__dict__:
0.79 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.79 options.py(736):         self._get_fields_cache = {}
0.79 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.79 options.py(347):         if self.swappable:
0.79 options.py(361):         return None
0.79 options.py(323):         if isinstance(connection, str):
0.79 options.py(324):             connection = connections[connection]
0.79 options.py(325):         if self.required_db_vendor:
0.79 options.py(327):         if self.required_db_features:
0.79 options.py(330):         return True
0.79 options.py(564):         try:
0.79 options.py(567):             return self._forward_fields_map[field_name]
0.79 options.py(564):         try:
0.79 options.py(567):             return self._forward_fields_map[field_name]
0.79 options.py(532):         res = {}
0.79 options.py(533):         fields = self._get_fields(reverse=False)
0.79 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.79 options.py(773):         topmost_call = seen_models is None
0.79 options.py(774):         if topmost_call:
0.79 options.py(775):             seen_models = set()
0.79 options.py(776):         seen_models.add(self.model)
0.79 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.79 options.py(781):         try:
0.79 options.py(784):             return self._get_fields_cache[cache_key]
0.79 options.py(785):         except KeyError:
0.79 options.py(786):             pass
0.79 options.py(788):         fields = []
0.79 options.py(791):         if include_parents is not False:
0.79 options.py(792):             for parent in self.parents:
0.79 options.py(806):         if reverse and not self.proxy:
0.79 options.py(817):         if forward:
0.79 options.py(818):             fields += self.local_fields
0.79 options.py(819):             fields += self.local_many_to_many
0.79 options.py(825):             if topmost_call:
0.79 options.py(826):                 fields += self.private_fields
0.79 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.79 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.79 options.py(833):         self._get_fields_cache[cache_key] = fields
0.79 options.py(834):         return fields
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.79 options.py(539):             try:
0.79 options.py(540):                 res[field.attname] = field
0.79 options.py(534):         for field in fields:
0.79 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(543):         return res
0.80 options.py(495):         return make_immutable_fields_list(
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.80 base.py(75):         super_new = super().__new__
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(80):         if not parents:
0.80 base.py(84):         module = attrs.pop('__module__')
0.80 base.py(85):         new_attrs = {'__module__': module}
0.80 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.80 base.py(87):         if classcell is not None:
0.80 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.80 base.py(93):         contributable_attrs = {}
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.80 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.80 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.80 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.80 base.py(105):         app_label = None
0.80 base.py(108):         app_config = apps.get_containing_app_config(module)
0.80 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.80 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.80 options.py(76):         self._get_fields_cache = {}
0.80 options.py(77):         self.local_fields = []
0.80 options.py(78):         self.local_many_to_many = []
0.80 options.py(79):         self.private_fields = []
0.80 options.py(80):         self.local_managers = []
0.80 options.py(81):         self.base_manager_name = None
0.80 options.py(82):         self.default_manager_name = None
0.80 options.py(83):         self.model_name = None
0.80 options.py(84):         self.verbose_name = None
0.80 options.py(85):         self.verbose_name_plural = None
0.80 options.py(86):         self.db_table = ''
0.80 options.py(87):         self.ordering = []
0.80 options.py(88):         self._ordering_clash = False
0.80 options.py(89):         self.indexes = []
0.80 options.py(90):         self.constraints = []
0.80 options.py(91):         self.unique_together = []
0.80 options.py(92):         self.index_together = []
0.80 options.py(93):         self.select_on_save = False
0.80 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.80 options.py(95):         self.permissions = []
0.80 options.py(96):         self.object_name = None
0.80 options.py(97):         self.app_label = app_label
0.80 options.py(98):         self.get_latest_by = None
0.80 options.py(99):         self.order_with_respect_to = None
0.80 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.80 options.py(101):         self.required_db_features = []
0.80 options.py(102):         self.required_db_vendor = None
0.80 options.py(103):         self.meta = meta
0.80 options.py(104):         self.pk = None
0.80 options.py(105):         self.auto_field = None
0.80 options.py(106):         self.abstract = False
0.80 options.py(107):         self.managed = True
0.80 options.py(108):         self.proxy = False
0.80 options.py(114):         self.proxy_for_model = None
0.80 options.py(118):         self.concrete_model = None
0.80 options.py(119):         self.swappable = None
0.80 options.py(120):         self.parents = {}
0.80 options.py(121):         self.auto_created = False
0.80 options.py(125):         self.related_fkey_lookups = []
0.80 options.py(128):         self.apps = self.default_apps
0.80 options.py(130):         self.default_related_name = None
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(150):         from django.db import connection
0.80 options.py(151):         from django.db.backends.utils import truncate_name
0.80 options.py(153):         cls._meta = self
0.80 options.py(154):         self.model = cls
0.80 options.py(156):         self.object_name = cls.__name__
0.80 options.py(157):         self.model_name = self.object_name.lower()
0.80 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.80 options.py(162):         self.original_attrs = {}
0.80 options.py(165):         if self.meta:
0.80 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.80 options.py(45):     try:
0.80 options.py(46):         if not option_together:
0.80 options.py(47):             return ()
0.80 options.py(182):             self.index_together = normalize_together(self.index_together)
0.80 options.py(45):     try:
0.80 options.py(46):         if not option_together:
0.80 options.py(47):             return ()
0.80 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(187):                     objs = getattr(self, attr_name, [])
0.80 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.80 options.py(212):         new_objs = []
0.80 options.py(213):         for obj in objs:
0.80 options.py(220):         return new_objs
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(187):                     objs = getattr(self, attr_name, [])
0.80 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.80 options.py(212):         new_objs = []
0.80 options.py(213):         for obj in objs:
0.80 options.py(220):         return new_objs
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(192):             if self.verbose_name_plural is None:
0.80 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.80 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.80 options.py(199):             if meta_attrs != {}:
0.80 options.py(203):         del self.meta
0.80 options.py(206):         if not self.db_table:
0.80 base.py(123):         if not abstract:
0.80 base.py(124):             new_class.add_to_class(
0.80 base.py(125):                 'DoesNotExist',
0.80 base.py(126):                 subclass_exception(
0.80 base.py(127):                     'DoesNotExist',
0.80 base.py(128):                     tuple(
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(130):                     ) or (ObjectDoesNotExist,),
0.80 base.py(131):                     module,
0.80 base.py(132):                     attached_to=new_class))
0.80 base.py(61):     return type(name, bases, {
0.80 base.py(62):         '__module__': module,
0.80 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(328):             setattr(cls, name, value)
0.80 base.py(133):             new_class.add_to_class(
0.80 base.py(134):                 'MultipleObjectsReturned',
0.80 base.py(135):                 subclass_exception(
0.80 base.py(136):                     'MultipleObjectsReturned',
0.80 base.py(137):                     tuple(
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(139):                     ) or (MultipleObjectsReturned,),
0.80 base.py(140):                     module,
0.80 base.py(141):                     attached_to=new_class))
0.80 base.py(61):     return type(name, bases, {
0.80 base.py(62):         '__module__': module,
0.80 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(328):             setattr(cls, name, value)
0.80 base.py(142):             if base_meta and not base_meta.abstract:
0.80 base.py(151):         is_proxy = new_class._meta.proxy
0.80 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(298):             self.pk = field
0.80 options.py(299):             field.serialize = False
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(288):             try:
0.80 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.80 options.py(728):         if forward:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(735):                     delattr(self, cache_key)
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 options.py(292):             self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(288):             try:
0.80 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.80 options.py(728):         if forward:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(735):                     delattr(self, cache_key)
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 options.py(292):             self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(164):         new_fields = chain(
0.80 base.py(165):             new_class._meta.local_fields,
0.80 base.py(166):             new_class._meta.local_many_to_many,
0.80 base.py(167):             new_class._meta.private_fields
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(172):         if is_proxy:
0.80 base.py(192):             new_class._meta.concrete_model = new_class
0.80 base.py(195):         parent_links = {}
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(198):             if not hasattr(base, '_meta'):
0.80 base.py(199):                 continue
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(198):             if not hasattr(base, '_meta'):
0.80 base.py(201):             if base != new_class and not base._meta.abstract:
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(210):         inherited_attributes = set()
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.80 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.80 base.py(312):         if abstract:
0.80 base.py(320):         new_class._prepare()
0.80 base.py(332):         opts = cls._meta
0.80 base.py(333):         opts._prepare(cls)
0.80 options.py(223):         if self.order_with_respect_to:
0.80 options.py(239):             self.order_with_respect_to = None
0.80 options.py(241):         if self.pk is None:
0.80 base.py(335):         if opts.order_with_respect_to:
0.80 base.py(350):         if cls.__doc__ is None:
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 options.py(456):         def is_not_an_m2m_field(f):
0.80 options.py(459):         def is_not_a_generic_relation(f):
0.80 options.py(462):         def is_not_a_generic_foreign_key(f):
0.80 options.py(467):         return make_immutable_fields_list(
0.80 options.py(468):             "fields",
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.80 options.py(773):         topmost_call = seen_models is None
0.80 options.py(774):         if topmost_call:
0.80 options.py(775):             seen_models = set()
0.80 options.py(776):         seen_models.add(self.model)
0.80 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.80 options.py(781):         try:
0.80 options.py(784):             return self._get_fields_cache[cache_key]
0.80 options.py(785):         except KeyError:
0.80 options.py(786):             pass
0.80 options.py(788):         fields = []
0.80 options.py(791):         if include_parents is not False:
0.80 options.py(792):             for parent in self.parents:
0.80 options.py(806):         if reverse and not self.proxy:
0.80 options.py(817):         if forward:
0.80 options.py(818):             fields += self.local_fields
0.80 options.py(819):             fields += self.local_many_to_many
0.80 options.py(825):             if topmost_call:
0.80 options.py(826):                 fields += self.private_fields
0.80 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(833):         self._get_fields_cache[cache_key] = fields
0.80 options.py(834):         return fields
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.80 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.80 base.py(354):         if get_absolute_url_override:
0.80 base.py(357):         if not opts.managers:
0.80 options.py(365):         managers = []
0.80 options.py(366):         seen_managers = set()
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(368):         for depth, base in enumerate(bases):
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(369):             for manager in base._meta.local_managers:
0.80 options.py(368):         for depth, base in enumerate(bases):
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(378):         return make_immutable_fields_list(
0.80 options.py(379):             "managers",
0.80 options.py(380):             (m[2] for m in sorted(managers)),
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(380):             (m[2] for m in sorted(managers)),
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(363):             manager = Manager()
0.80 base.py(364):             manager.auto_created = True
0.80 base.py(365):             cls.add_to_class('objects', manager)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(263):         self.local_managers.append(manager)
0.80 options.py(264):         self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(731):                     delattr(self, cache_key)
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(731):                     delattr(self, cache_key)
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(370):         for index in cls._meta.indexes:
0.80 base.py(374):         class_prepared.send(sender=cls)
0.80 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.80 base.py(322):         return new_class
0.80 base.py(75):         super_new = super().__new__
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.80 base.py(80):         if not parents:
0.80 base.py(84):         module = attrs.pop('__module__')
0.80 base.py(85):         new_attrs = {'__module__': module}
0.80 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.80 base.py(87):         if classcell is not None:
0.80 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.80 base.py(93):         contributable_attrs = {}
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(95):             if _has_contribute_to_class(obj):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(96):                 contributable_attrs[obj_name] = obj
0.80 base.py(94):         for obj_name, obj in list(attrs.items()):
0.80 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.80 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.80 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.80 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.80 base.py(105):         app_label = None
0.80 base.py(108):         app_config = apps.get_containing_app_config(module)
0.80 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.80 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.80 options.py(76):         self._get_fields_cache = {}
0.80 options.py(77):         self.local_fields = []
0.80 options.py(78):         self.local_many_to_many = []
0.80 options.py(79):         self.private_fields = []
0.80 options.py(80):         self.local_managers = []
0.80 options.py(81):         self.base_manager_name = None
0.80 options.py(82):         self.default_manager_name = None
0.80 options.py(83):         self.model_name = None
0.80 options.py(84):         self.verbose_name = None
0.80 options.py(85):         self.verbose_name_plural = None
0.80 options.py(86):         self.db_table = ''
0.80 options.py(87):         self.ordering = []
0.80 options.py(88):         self._ordering_clash = False
0.80 options.py(89):         self.indexes = []
0.80 options.py(90):         self.constraints = []
0.80 options.py(91):         self.unique_together = []
0.80 options.py(92):         self.index_together = []
0.80 options.py(93):         self.select_on_save = False
0.80 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.80 options.py(95):         self.permissions = []
0.80 options.py(96):         self.object_name = None
0.80 options.py(97):         self.app_label = app_label
0.80 options.py(98):         self.get_latest_by = None
0.80 options.py(99):         self.order_with_respect_to = None
0.80 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.80 options.py(101):         self.required_db_features = []
0.80 options.py(102):         self.required_db_vendor = None
0.80 options.py(103):         self.meta = meta
0.80 options.py(104):         self.pk = None
0.80 options.py(105):         self.auto_field = None
0.80 options.py(106):         self.abstract = False
0.80 options.py(107):         self.managed = True
0.80 options.py(108):         self.proxy = False
0.80 options.py(114):         self.proxy_for_model = None
0.80 options.py(118):         self.concrete_model = None
0.80 options.py(119):         self.swappable = None
0.80 options.py(120):         self.parents = {}
0.80 options.py(121):         self.auto_created = False
0.80 options.py(125):         self.related_fkey_lookups = []
0.80 options.py(128):         self.apps = self.default_apps
0.80 options.py(130):         self.default_related_name = None
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(150):         from django.db import connection
0.80 options.py(151):         from django.db.backends.utils import truncate_name
0.80 options.py(153):         cls._meta = self
0.80 options.py(154):         self.model = cls
0.80 options.py(156):         self.object_name = cls.__name__
0.80 options.py(157):         self.model_name = self.object_name.lower()
0.80 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.80 options.py(162):         self.original_attrs = {}
0.80 options.py(165):         if self.meta:
0.80 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(171):                 if name.startswith('_'):
0.80 options.py(172):                     del meta_attrs[name]
0.80 options.py(167):             for name in self.meta.__dict__:
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(177):                 elif hasattr(self.meta, attr_name):
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(174):                 if attr_name in meta_attrs:
0.80 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.80 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.80 options.py(173):             for attr_name in DEFAULT_NAMES:
0.80 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.80 options.py(45):     try:
0.80 options.py(46):         if not option_together:
0.80 options.py(47):             return ()
0.80 options.py(182):             self.index_together = normalize_together(self.index_together)
0.80 options.py(45):     try:
0.80 options.py(46):         if not option_together:
0.80 options.py(47):             return ()
0.80 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(187):                     objs = getattr(self, attr_name, [])
0.80 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.80 options.py(212):         new_objs = []
0.80 options.py(213):         for obj in objs:
0.80 options.py(220):         return new_objs
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(187):                     objs = getattr(self, attr_name, [])
0.80 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.80 options.py(212):         new_objs = []
0.80 options.py(213):         for obj in objs:
0.80 options.py(220):         return new_objs
0.80 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.80 options.py(192):             if self.verbose_name_plural is None:
0.80 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.80 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.80 options.py(199):             if meta_attrs != {}:
0.80 options.py(203):         del self.meta
0.80 options.py(206):         if not self.db_table:
0.80 base.py(123):         if not abstract:
0.80 base.py(124):             new_class.add_to_class(
0.80 base.py(125):                 'DoesNotExist',
0.80 base.py(126):                 subclass_exception(
0.80 base.py(127):                     'DoesNotExist',
0.80 base.py(128):                     tuple(
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(130):                     ) or (ObjectDoesNotExist,),
0.80 base.py(131):                     module,
0.80 base.py(132):                     attached_to=new_class))
0.80 base.py(61):     return type(name, bases, {
0.80 base.py(62):         '__module__': module,
0.80 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(328):             setattr(cls, name, value)
0.80 base.py(133):             new_class.add_to_class(
0.80 base.py(134):                 'MultipleObjectsReturned',
0.80 base.py(135):                 subclass_exception(
0.80 base.py(136):                     'MultipleObjectsReturned',
0.80 base.py(137):                     tuple(
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.80 base.py(139):                     ) or (MultipleObjectsReturned,),
0.80 base.py(140):                     module,
0.80 base.py(141):                     attached_to=new_class))
0.80 base.py(61):     return type(name, bases, {
0.80 base.py(62):         '__module__': module,
0.80 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(328):             setattr(cls, name, value)
0.80 base.py(142):             if base_meta and not base_meta.abstract:
0.80 base.py(151):         is_proxy = new_class._meta.proxy
0.80 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(298):             self.pk = field
0.80 options.py(299):             field.serialize = False
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(288):             try:
0.80 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.80 options.py(728):         if forward:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 options.py(292):             self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(288):             try:
0.80 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.80 options.py(728):         if forward:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 options.py(292):             self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(161):             new_class.add_to_class(obj_name, obj)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(271):         if private:
0.80 options.py(273):         elif field.is_relation and field.many_to_many:
0.80 options.py(276):             bisect.insort(self.local_fields, field)
0.80 options.py(277):             self.setup_pk(field)
0.80 options.py(297):         if not self.pk and field.primary_key:
0.80 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.80 options.py(294):             self._expire_cache(reverse=False)
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.80 base.py(164):         new_fields = chain(
0.80 base.py(165):             new_class._meta.local_fields,
0.80 base.py(166):             new_class._meta.local_many_to_many,
0.80 base.py(167):             new_class._meta.private_fields
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(169):         field_names = {f.name for f in new_fields}
0.80 base.py(172):         if is_proxy:
0.80 base.py(192):             new_class._meta.concrete_model = new_class
0.80 base.py(195):         parent_links = {}
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(198):             if not hasattr(base, '_meta'):
0.80 base.py(199):                 continue
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(198):             if not hasattr(base, '_meta'):
0.80 base.py(201):             if base != new_class and not base._meta.abstract:
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(205):                 if isinstance(field, OneToOneField):
0.80 base.py(204):             for field in base._meta.local_fields:
0.80 base.py(196):         for base in reversed([new_class] + parents):
0.80 base.py(210):         inherited_attributes = set()
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.80 base.py(216):                 inherited_attributes.update(base.__dict__)
0.80 base.py(217):                 continue
0.80 base.py(212):         for base in new_class.mro():
0.80 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.80 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.80 base.py(312):         if abstract:
0.80 base.py(320):         new_class._prepare()
0.80 base.py(332):         opts = cls._meta
0.80 base.py(333):         opts._prepare(cls)
0.80 options.py(223):         if self.order_with_respect_to:
0.80 options.py(239):             self.order_with_respect_to = None
0.80 options.py(241):         if self.pk is None:
0.80 base.py(335):         if opts.order_with_respect_to:
0.80 base.py(350):         if cls.__doc__ is None:
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 options.py(456):         def is_not_an_m2m_field(f):
0.80 options.py(459):         def is_not_a_generic_relation(f):
0.80 options.py(462):         def is_not_a_generic_foreign_key(f):
0.80 options.py(467):         return make_immutable_fields_list(
0.80 options.py(468):             "fields",
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.80 options.py(773):         topmost_call = seen_models is None
0.80 options.py(774):         if topmost_call:
0.80 options.py(775):             seen_models = set()
0.80 options.py(776):         seen_models.add(self.model)
0.80 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.80 options.py(781):         try:
0.80 options.py(784):             return self._get_fields_cache[cache_key]
0.80 options.py(785):         except KeyError:
0.80 options.py(786):             pass
0.80 options.py(788):         fields = []
0.80 options.py(791):         if include_parents is not False:
0.80 options.py(792):             for parent in self.parents:
0.80 options.py(806):         if reverse and not self.proxy:
0.80 options.py(817):         if forward:
0.80 options.py(818):             fields += self.local_fields
0.80 options.py(819):             fields += self.local_many_to_many
0.80 options.py(825):             if topmost_call:
0.80 options.py(826):                 fields += self.private_fields
0.80 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(833):         self._get_fields_cache[cache_key] = fields
0.80 options.py(834):         return fields
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.80 options.py(457):             return not (f.is_relation and f.many_to_many)
0.80 options.py(460):             return not (f.is_relation and f.one_to_many)
0.80 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.80 options.py(469):             (f for f in self._get_fields(reverse=False)
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.80 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.80 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.80 base.py(354):         if get_absolute_url_override:
0.80 base.py(357):         if not opts.managers:
0.80 options.py(365):         managers = []
0.80 options.py(366):         seen_managers = set()
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(368):         for depth, base in enumerate(bases):
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(369):             for manager in base._meta.local_managers:
0.80 options.py(368):         for depth, base in enumerate(bases):
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.80 options.py(378):         return make_immutable_fields_list(
0.80 options.py(379):             "managers",
0.80 options.py(380):             (m[2] for m in sorted(managers)),
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(380):             (m[2] for m in sorted(managers)),
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.80 base.py(363):             manager = Manager()
0.80 base.py(364):             manager.auto_created = True
0.80 base.py(365):             cls.add_to_class('objects', manager)
0.80 base.py(325):         if _has_contribute_to_class(value):
0.80 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.80 base.py(326):             value.contribute_to_class(cls, name)
0.80 options.py(263):         self.local_managers.append(manager)
0.80 options.py(264):         self._expire_cache()
0.80 options.py(728):         if forward:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(731):                     delattr(self, cache_key)
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(731):                     delattr(self, cache_key)
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(730):                 if cache_key in self.__dict__:
0.80 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.80 options.py(732):         if reverse and not self.abstract:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(734):                 if cache_key in self.__dict__:
0.80 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.80 options.py(736):         self._get_fields_cache = {}
0.80 base.py(370):         for index in cls._meta.indexes:
0.80 base.py(374):         class_prepared.send(sender=cls)
0.80 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.80 base.py(322):         return new_class
0.80 options.py(564):         try:
0.80 options.py(567):             return self._forward_fields_map[field_name]
0.80 options.py(532):         res = {}
0.80 options.py(533):         fields = self._get_fields(reverse=False)
0.80 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.80 options.py(773):         topmost_call = seen_models is None
0.80 options.py(774):         if topmost_call:
0.80 options.py(775):             seen_models = set()
0.80 options.py(776):         seen_models.add(self.model)
0.80 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.80 options.py(781):         try:
0.80 options.py(784):             return self._get_fields_cache[cache_key]
0.80 options.py(785):         except KeyError:
0.80 options.py(786):             pass
0.80 options.py(788):         fields = []
0.80 options.py(791):         if include_parents is not False:
0.80 options.py(792):             for parent in self.parents:
0.80 options.py(806):         if reverse and not self.proxy:
0.80 options.py(817):         if forward:
0.80 options.py(818):             fields += self.local_fields
0.80 options.py(819):             fields += self.local_many_to_many
0.80 options.py(825):             if topmost_call:
0.80 options.py(826):                 fields += self.private_fields
0.80 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(833):         self._get_fields_cache[cache_key] = fields
0.80 options.py(834):         return fields
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(543):         return res
0.80 options.py(564):         try:
0.80 options.py(567):             return self._forward_fields_map[field_name]
0.80 options.py(564):         try:
0.80 options.py(567):             return self._forward_fields_map[field_name]
0.80 options.py(532):         res = {}
0.80 options.py(533):         fields = self._get_fields(reverse=False)
0.80 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.80 options.py(773):         topmost_call = seen_models is None
0.80 options.py(774):         if topmost_call:
0.80 options.py(775):             seen_models = set()
0.80 options.py(776):         seen_models.add(self.model)
0.80 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.80 options.py(781):         try:
0.80 options.py(784):             return self._get_fields_cache[cache_key]
0.80 options.py(785):         except KeyError:
0.80 options.py(786):             pass
0.80 options.py(788):         fields = []
0.80 options.py(791):         if include_parents is not False:
0.80 options.py(792):             for parent in self.parents:
0.80 options.py(806):         if reverse and not self.proxy:
0.80 options.py(817):         if forward:
0.80 options.py(818):             fields += self.local_fields
0.80 options.py(819):             fields += self.local_many_to_many
0.80 options.py(825):             if topmost_call:
0.80 options.py(826):                 fields += self.private_fields
0.80 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.80 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.80 options.py(833):         self._get_fields_cache[cache_key] = fields
0.80 options.py(834):         return fields
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(535):             res[field.name] = field
0.80 options.py(539):             try:
0.80 options.py(540):                 res[field.attname] = field
0.80 options.py(534):         for field in fields:
0.80 options.py(543):         return res
0.80 options.py(347):         if self.swappable:
0.80 options.py(361):         return None
0.80 options.py(347):         if self.swappable:
0.80 options.py(361):         return None
0.80 base.py(408):         cls = self.__class__
0.80 base.py(409):         opts = self._meta
0.80 base.py(410):         _setattr = setattr
0.80 base.py(411):         _DEFERRED = DEFERRED
0.80 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.80 base.py(416):         self._state = ModelState()
0.80 base.py(422):         if len(args) > len(opts.concrete_fields):
0.80 base.py(426):         if not kwargs:
0.80 base.py(438):             fields_iter = iter(opts.fields)
0.80 base.py(439):             for val, field in zip(args, fields_iter):
0.80 base.py(448):         for field in fields_iter:
0.80 base.py(449):             is_related_object = False
0.80 base.py(451):             if field.attname not in kwargs and field.column is None:
0.80 base.py(453):             if kwargs:
0.80 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.80 base.py(466):                     try:
0.80 base.py(467):                         val = kwargs.pop(field.attname)
0.80 base.py(468):                     except KeyError:
0.80 base.py(473):                         val = field.get_default()
0.80 base.py(477):             if is_related_object:
0.80 base.py(485):                 if val is not _DEFERRED:
0.80 base.py(486):                     _setattr(self, field.attname, val)
0.80 base.py(448):         for field in fields_iter:
0.80 base.py(449):             is_related_object = False
0.80 base.py(451):             if field.attname not in kwargs and field.column is None:
0.80 base.py(453):             if kwargs:
0.80 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.80 base.py(466):                     try:
0.80 base.py(467):                         val = kwargs.pop(field.attname)
0.80 base.py(477):             if is_related_object:
0.80 base.py(485):                 if val is not _DEFERRED:
0.80 base.py(486):                     _setattr(self, field.attname, val)
0.80 base.py(448):         for field in fields_iter:
0.80 base.py(449):             is_related_object = False
0.80 base.py(451):             if field.attname not in kwargs and field.column is None:
0.80 base.py(453):             if kwargs:
0.80 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.80 base.py(466):                     try:
0.80 base.py(467):                         val = kwargs.pop(field.attname)
0.80 base.py(477):             if is_related_object:
0.80 base.py(485):                 if val is not _DEFERRED:
0.80 base.py(486):                     _setattr(self, field.attname, val)
0.80 base.py(448):         for field in fields_iter:
0.80 base.py(449):             is_related_object = False
0.80 base.py(451):             if field.attname not in kwargs and field.column is None:
0.80 base.py(453):             if kwargs:
0.80 base.py(475):                 val = field.get_default()
0.80 base.py(477):             if is_related_object:
0.80 base.py(485):                 if val is not _DEFERRED:
0.80 base.py(486):                     _setattr(self, field.attname, val)
0.80 base.py(448):         for field in fields_iter:
0.80 base.py(488):         if kwargs:
0.80 base.py(502):         super().__init__()
0.80 base.py(503):         post_init.send(sender=cls, instance=self)
0.80 base.py(679):         for field in self._meta.concrete_fields:
0.80 base.py(682):             if field.is_relation and field.is_cached(self):
0.80 base.py(679):         for field in self._meta.concrete_fields:
0.80 base.py(682):             if field.is_relation and field.is_cached(self):
0.80 base.py(679):         for field in self._meta.concrete_fields:
0.80 base.py(682):             if field.is_relation and field.is_cached(self):
0.80 base.py(679):         for field in self._meta.concrete_fields:
0.80 base.py(682):             if field.is_relation and field.is_cached(self):
0.80 base.py(679):         for field in self._meta.concrete_fields:
0.80 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.80 base.py(710):         if force_insert and (force_update or update_fields):
0.80 base.py(713):         deferred_fields = self.get_deferred_fields()
0.80 base.py(583):         return {
0.80 base.py(584):             f.attname for f in self._meta.concrete_fields
0.80 base.py(583):         return {
0.80 base.py(584):             f.attname for f in self._meta.concrete_fields
0.80 base.py(585):             if f.attname not in self.__dict__
0.80 base.py(583):         return {
0.80 base.py(584):             f.attname for f in self._meta.concrete_fields
0.80 base.py(585):             if f.attname not in self.__dict__
0.80 base.py(583):         return {
0.80 base.py(584):             f.attname for f in self._meta.concrete_fields
0.80 base.py(585):             if f.attname not in self.__dict__
0.80 base.py(583):         return {
0.80 base.py(584):             f.attname for f in self._meta.concrete_fields
0.80 base.py(585):             if f.attname not in self.__dict__
0.80 base.py(583):         return {
0.80 base.py(714):         if update_fields is not None:
0.80 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.80 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.80 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.80 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.80 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.80 base.py(766):         assert update_fields is None or update_fields
0.80 base.py(767):         cls = origin = self.__class__
0.80 base.py(769):         if cls._meta.proxy:
0.80 base.py(771):         meta = cls._meta
0.80 base.py(772):         if not meta.auto_created:
0.80 base.py(773):             pre_save.send(
0.80 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.80 base.py(775):                 update_fields=update_fields,
0.80 base.py(778):         if meta.parents:
0.80 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.80 base.py(782):         with context_manager:
0.80 base.py(783):             parent_inserted = False
0.80 base.py(784):             if not raw:
0.80 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.80 base.py(806):         meta = cls._meta
0.80 base.py(807):         inserted = False
0.80 base.py(808):         for parent, field in meta.parents.items():
0.80 base.py(830):         return inserted
0.80 base.py(786):             updated = self._save_table(
0.80 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.80 base.py(788):                 force_update, using, update_fields,
0.80 base.py(838):         meta = cls._meta
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.80 base.py(841):         if update_fields:
0.80 base.py(845):         pk_val = self._get_pk_val(meta)
0.80 base.py(568):         meta = meta or self._meta
0.80 base.py(569):         return getattr(self, meta.pk.attname)
0.80 base.py(846):         if pk_val is None:
0.80 base.py(847):             pk_val = meta.pk.get_pk_value_on_save(self)
0.80 base.py(848):             setattr(self, meta.pk.attname, pk_val)
0.80 base.py(849):         pk_set = pk_val is not None
0.80 base.py(850):         if not pk_set and (force_update or update_fields):
0.80 base.py(852):         updated = False
0.80 base.py(855):             not raw and
0.80 base.py(856):             not force_insert and
0.80 base.py(863):         if pk_set and not force_insert:
0.80 base.py(874):         if not updated:
0.80 base.py(875):             if meta.order_with_respect_to:
0.80 base.py(886):             fields = meta.local_concrete_fields
0.80 base.py(887):             if not pk_set:
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.80 base.py(890):             returning_fields = meta.db_returning_fields
0.80 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.80 base.py(378):         return cls._meta.base_manager
0.80 base.py(928):         return manager._insert(
0.80 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.80 base.py(930):             using=using, raw=raw,
0.81 base.py(892):             for result, field in zip(results, returning_fields):
0.81 base.py(893):                 setattr(self, field.attname, result)
0.81 base.py(892):             for result, field in zip(results, returning_fields):
0.81 base.py(894):         return updated
0.81 base.py(791):         self._state.db = using
0.81 base.py(793):         self._state.adding = False
0.81 base.py(796):         if not meta.auto_created:
0.81 base.py(797):             post_save.send(
0.81 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.81 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
 OK
  Applying sites.0001_initial...0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.81 options.py(349):             if swapped_for:
0.81 options.py(350):                 try:
0.81 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.81 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.81 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(731):                     delattr(self, cache_key)
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 base.py(75):         super_new = super().__new__
0.81 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.81 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.81 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.81 base.py(80):         if not parents:
0.81 base.py(84):         module = attrs.pop('__module__')
0.81 base.py(85):         new_attrs = {'__module__': module}
0.81 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.81 base.py(87):         if classcell is not None:
0.81 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.81 base.py(93):         contributable_attrs = {}
0.81 base.py(94):         for obj_name, obj in list(attrs.items()):
0.81 base.py(95):             if _has_contribute_to_class(obj):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(96):                 contributable_attrs[obj_name] = obj
0.81 base.py(94):         for obj_name, obj in list(attrs.items()):
0.81 base.py(95):             if _has_contribute_to_class(obj):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(96):                 contributable_attrs[obj_name] = obj
0.81 base.py(94):         for obj_name, obj in list(attrs.items()):
0.81 base.py(95):             if _has_contribute_to_class(obj):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(96):                 contributable_attrs[obj_name] = obj
0.81 base.py(94):         for obj_name, obj in list(attrs.items()):
0.81 base.py(95):             if _has_contribute_to_class(obj):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(96):                 contributable_attrs[obj_name] = obj
0.81 base.py(94):         for obj_name, obj in list(attrs.items()):
0.81 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.81 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.81 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.81 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.81 base.py(105):         app_label = None
0.81 base.py(108):         app_config = apps.get_containing_app_config(module)
0.81 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.81 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.81 options.py(76):         self._get_fields_cache = {}
0.81 options.py(77):         self.local_fields = []
0.81 options.py(78):         self.local_many_to_many = []
0.81 options.py(79):         self.private_fields = []
0.81 options.py(80):         self.local_managers = []
0.81 options.py(81):         self.base_manager_name = None
0.81 options.py(82):         self.default_manager_name = None
0.81 options.py(83):         self.model_name = None
0.81 options.py(84):         self.verbose_name = None
0.81 options.py(85):         self.verbose_name_plural = None
0.81 options.py(86):         self.db_table = ''
0.81 options.py(87):         self.ordering = []
0.81 options.py(88):         self._ordering_clash = False
0.81 options.py(89):         self.indexes = []
0.81 options.py(90):         self.constraints = []
0.81 options.py(91):         self.unique_together = []
0.81 options.py(92):         self.index_together = []
0.81 options.py(93):         self.select_on_save = False
0.81 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.81 options.py(95):         self.permissions = []
0.81 options.py(96):         self.object_name = None
0.81 options.py(97):         self.app_label = app_label
0.81 options.py(98):         self.get_latest_by = None
0.81 options.py(99):         self.order_with_respect_to = None
0.81 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.81 options.py(101):         self.required_db_features = []
0.81 options.py(102):         self.required_db_vendor = None
0.81 options.py(103):         self.meta = meta
0.81 options.py(104):         self.pk = None
0.81 options.py(105):         self.auto_field = None
0.81 options.py(106):         self.abstract = False
0.81 options.py(107):         self.managed = True
0.81 options.py(108):         self.proxy = False
0.81 options.py(114):         self.proxy_for_model = None
0.81 options.py(118):         self.concrete_model = None
0.81 options.py(119):         self.swappable = None
0.81 options.py(120):         self.parents = {}
0.81 options.py(121):         self.auto_created = False
0.81 options.py(125):         self.related_fkey_lookups = []
0.81 options.py(128):         self.apps = self.default_apps
0.81 options.py(130):         self.default_related_name = None
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(326):             value.contribute_to_class(cls, name)
0.81 options.py(150):         from django.db import connection
0.81 options.py(151):         from django.db.backends.utils import truncate_name
0.81 options.py(153):         cls._meta = self
0.81 options.py(154):         self.model = cls
0.81 options.py(156):         self.object_name = cls.__name__
0.81 options.py(157):         self.model_name = self.object_name.lower()
0.81 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.81 options.py(162):         self.original_attrs = {}
0.81 options.py(165):         if self.meta:
0.81 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(172):                     del meta_attrs[name]
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(172):                     del meta_attrs[name]
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(172):                     del meta_attrs[name]
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(171):                 if name.startswith('_'):
0.81 options.py(172):                     del meta_attrs[name]
0.81 options.py(167):             for name in self.meta.__dict__:
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(177):                 elif hasattr(self.meta, attr_name):
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(174):                 if attr_name in meta_attrs:
0.81 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.81 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.81 options.py(173):             for attr_name in DEFAULT_NAMES:
0.81 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.81 options.py(45):     try:
0.81 options.py(46):         if not option_together:
0.81 options.py(47):             return ()
0.81 options.py(182):             self.index_together = normalize_together(self.index_together)
0.81 options.py(45):     try:
0.81 options.py(46):         if not option_together:
0.81 options.py(47):             return ()
0.81 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.81 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.81 options.py(187):                     objs = getattr(self, attr_name, [])
0.81 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.81 options.py(212):         new_objs = []
0.81 options.py(213):         for obj in objs:
0.81 options.py(220):         return new_objs
0.81 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.81 options.py(187):                     objs = getattr(self, attr_name, [])
0.81 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.81 options.py(212):         new_objs = []
0.81 options.py(213):         for obj in objs:
0.81 options.py(220):         return new_objs
0.81 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.81 options.py(192):             if self.verbose_name_plural is None:
0.81 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.81 options.py(199):             if meta_attrs != {}:
0.81 options.py(203):         del self.meta
0.81 options.py(206):         if not self.db_table:
0.81 base.py(123):         if not abstract:
0.81 base.py(124):             new_class.add_to_class(
0.81 base.py(125):                 'DoesNotExist',
0.81 base.py(126):                 subclass_exception(
0.81 base.py(127):                     'DoesNotExist',
0.81 base.py(128):                     tuple(
0.81 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(130):                     ) or (ObjectDoesNotExist,),
0.81 base.py(131):                     module,
0.81 base.py(132):                     attached_to=new_class))
0.81 base.py(61):     return type(name, bases, {
0.81 base.py(62):         '__module__': module,
0.81 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(328):             setattr(cls, name, value)
0.81 base.py(133):             new_class.add_to_class(
0.81 base.py(134):                 'MultipleObjectsReturned',
0.81 base.py(135):                 subclass_exception(
0.81 base.py(136):                     'MultipleObjectsReturned',
0.81 base.py(137):                     tuple(
0.81 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.81 base.py(139):                     ) or (MultipleObjectsReturned,),
0.81 base.py(140):                     module,
0.81 base.py(141):                     attached_to=new_class))
0.81 base.py(61):     return type(name, bases, {
0.81 base.py(62):         '__module__': module,
0.81 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(328):             setattr(cls, name, value)
0.81 base.py(142):             if base_meta and not base_meta.abstract:
0.81 base.py(151):         is_proxy = new_class._meta.proxy
0.81 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.81 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.81 base.py(161):             new_class.add_to_class(obj_name, obj)
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(326):             value.contribute_to_class(cls, name)
0.81 options.py(271):         if private:
0.81 options.py(273):         elif field.is_relation and field.many_to_many:
0.81 options.py(276):             bisect.insort(self.local_fields, field)
0.81 options.py(277):             self.setup_pk(field)
0.81 options.py(297):         if not self.pk and field.primary_key:
0.81 options.py(298):             self.pk = field
0.81 options.py(299):             field.serialize = False
0.81 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.81 options.py(294):             self._expire_cache(reverse=False)
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.81 base.py(161):             new_class.add_to_class(obj_name, obj)
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(326):             value.contribute_to_class(cls, name)
0.81 options.py(271):         if private:
0.81 options.py(273):         elif field.is_relation and field.many_to_many:
0.81 options.py(276):             bisect.insort(self.local_fields, field)
0.81 options.py(277):             self.setup_pk(field)
0.81 options.py(297):         if not self.pk and field.primary_key:
0.81 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.81 options.py(294):             self._expire_cache(reverse=False)
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.81 base.py(161):             new_class.add_to_class(obj_name, obj)
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(326):             value.contribute_to_class(cls, name)
0.81 options.py(271):         if private:
0.81 options.py(273):         elif field.is_relation and field.many_to_many:
0.81 options.py(276):             bisect.insort(self.local_fields, field)
0.81 options.py(277):             self.setup_pk(field)
0.81 options.py(297):         if not self.pk and field.primary_key:
0.81 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.81 options.py(294):             self._expire_cache(reverse=False)
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.81 base.py(161):             new_class.add_to_class(obj_name, obj)
0.81 base.py(325):         if _has_contribute_to_class(value):
0.81 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.81 base.py(326):             value.contribute_to_class(cls, name)
0.81 options.py(263):         self.local_managers.append(manager)
0.81 options.py(264):         self._expire_cache()
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.81 base.py(164):         new_fields = chain(
0.81 base.py(165):             new_class._meta.local_fields,
0.81 base.py(166):             new_class._meta.local_many_to_many,
0.81 base.py(167):             new_class._meta.private_fields
0.81 base.py(169):         field_names = {f.name for f in new_fields}
0.81 base.py(169):         field_names = {f.name for f in new_fields}
0.81 base.py(169):         field_names = {f.name for f in new_fields}
0.81 base.py(169):         field_names = {f.name for f in new_fields}
0.81 base.py(169):         field_names = {f.name for f in new_fields}
0.81 base.py(172):         if is_proxy:
0.81 base.py(192):             new_class._meta.concrete_model = new_class
0.81 base.py(195):         parent_links = {}
0.81 base.py(196):         for base in reversed([new_class] + parents):
0.81 base.py(198):             if not hasattr(base, '_meta'):
0.81 base.py(199):                 continue
0.81 base.py(196):         for base in reversed([new_class] + parents):
0.81 base.py(198):             if not hasattr(base, '_meta'):
0.81 base.py(201):             if base != new_class and not base._meta.abstract:
0.81 base.py(204):             for field in base._meta.local_fields:
0.81 base.py(205):                 if isinstance(field, OneToOneField):
0.81 base.py(204):             for field in base._meta.local_fields:
0.81 base.py(205):                 if isinstance(field, OneToOneField):
0.81 base.py(204):             for field in base._meta.local_fields:
0.81 base.py(205):                 if isinstance(field, OneToOneField):
0.81 base.py(204):             for field in base._meta.local_fields:
0.81 base.py(196):         for base in reversed([new_class] + parents):
0.81 base.py(210):         inherited_attributes = set()
0.81 base.py(212):         for base in new_class.mro():
0.81 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.81 base.py(216):                 inherited_attributes.update(base.__dict__)
0.81 base.py(217):                 continue
0.81 base.py(212):         for base in new_class.mro():
0.81 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.81 base.py(216):                 inherited_attributes.update(base.__dict__)
0.81 base.py(217):                 continue
0.81 base.py(212):         for base in new_class.mro():
0.81 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.81 base.py(216):                 inherited_attributes.update(base.__dict__)
0.81 base.py(217):                 continue
0.81 base.py(212):         for base in new_class.mro():
0.81 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.81 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.81 base.py(312):         if abstract:
0.81 base.py(320):         new_class._prepare()
0.81 base.py(332):         opts = cls._meta
0.81 base.py(333):         opts._prepare(cls)
0.81 options.py(223):         if self.order_with_respect_to:
0.81 options.py(239):             self.order_with_respect_to = None
0.81 options.py(241):         if self.pk is None:
0.81 base.py(335):         if opts.order_with_respect_to:
0.81 base.py(350):         if cls.__doc__ is None:
0.81 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.81 options.py(456):         def is_not_an_m2m_field(f):
0.81 options.py(459):         def is_not_a_generic_relation(f):
0.81 options.py(462):         def is_not_a_generic_foreign_key(f):
0.81 options.py(467):         return make_immutable_fields_list(
0.81 options.py(468):             "fields",
0.81 options.py(469):             (f for f in self._get_fields(reverse=False)
0.81 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.81 options.py(773):         topmost_call = seen_models is None
0.81 options.py(774):         if topmost_call:
0.81 options.py(775):             seen_models = set()
0.81 options.py(776):         seen_models.add(self.model)
0.81 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.81 options.py(781):         try:
0.81 options.py(784):             return self._get_fields_cache[cache_key]
0.81 options.py(785):         except KeyError:
0.81 options.py(786):             pass
0.81 options.py(788):         fields = []
0.81 options.py(791):         if include_parents is not False:
0.81 options.py(792):             for parent in self.parents:
0.81 options.py(806):         if reverse and not self.proxy:
0.81 options.py(817):         if forward:
0.81 options.py(818):             fields += self.local_fields
0.81 options.py(819):             fields += self.local_many_to_many
0.81 options.py(825):             if topmost_call:
0.81 options.py(826):                 fields += self.private_fields
0.81 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.81 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.81 options.py(833):         self._get_fields_cache[cache_key] = fields
0.81 options.py(834):         return fields
0.81 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.81 options.py(469):             (f for f in self._get_fields(reverse=False)
0.81 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.81 options.py(457):             return not (f.is_relation and f.many_to_many)
0.81 options.py(460):             return not (f.is_relation and f.one_to_many)
0.81 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.81 options.py(469):             (f for f in self._get_fields(reverse=False)
0.81 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.81 options.py(457):             return not (f.is_relation and f.many_to_many)
0.81 options.py(460):             return not (f.is_relation and f.one_to_many)
0.81 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.81 options.py(469):             (f for f in self._get_fields(reverse=False)
0.81 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.81 options.py(457):             return not (f.is_relation and f.many_to_many)
0.81 options.py(460):             return not (f.is_relation and f.one_to_many)
0.81 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.81 options.py(469):             (f for f in self._get_fields(reverse=False)
0.81 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.81 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.81 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.81 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.81 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.81 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.81 base.py(354):         if get_absolute_url_override:
0.81 base.py(357):         if not opts.managers:
0.81 options.py(365):         managers = []
0.81 options.py(366):         seen_managers = set()
0.81 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.81 options.py(368):         for depth, base in enumerate(bases):
0.81 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.81 options.py(369):             for manager in base._meta.local_managers:
0.81 options.py(370):                 if manager.name in seen_managers:
0.81 options.py(373):                 manager = copy.copy(manager)
0.81 options.py(374):                 manager.model = self.model
0.81 options.py(375):                 seen_managers.add(manager.name)
0.81 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.81 options.py(369):             for manager in base._meta.local_managers:
0.81 options.py(368):         for depth, base in enumerate(bases):
0.81 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.81 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.81 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.81 options.py(378):         return make_immutable_fields_list(
0.81 options.py(379):             "managers",
0.81 options.py(380):             (m[2] for m in sorted(managers)),
0.81 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.81 options.py(380):             (m[2] for m in sorted(managers)),
0.81 options.py(380):             (m[2] for m in sorted(managers)),
0.81 base.py(370):         for index in cls._meta.indexes:
0.81 base.py(374):         class_prepared.send(sender=cls)
0.81 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.81 base.py(322):         return new_class
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.81 options.py(349):             if swapped_for:
0.81 options.py(350):                 try:
0.81 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.81 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.81 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(728):         if forward:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(731):                     delattr(self, cache_key)
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(731):                     delattr(self, cache_key)
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(730):                 if cache_key in self.__dict__:
0.81 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.81 options.py(732):         if reverse and not self.abstract:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(734):                 if cache_key in self.__dict__:
0.81 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.81 options.py(736):         self._get_fields_cache = {}
0.81 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(323):         if isinstance(connection, str):
0.81 options.py(324):             connection = connections[connection]
0.81 options.py(325):         if self.required_db_vendor:
0.81 options.py(327):         if self.required_db_features:
0.81 options.py(330):         return True
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 options.py(347):         if self.swappable:
0.81 options.py(361):         return None
0.81 base.py(408):         cls = self.__class__
0.81 base.py(409):         opts = self._meta
0.81 base.py(410):         _setattr = setattr
0.81 base.py(411):         _DEFERRED = DEFERRED
0.81 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.81 base.py(416):         self._state = ModelState()
0.81 base.py(422):         if len(args) > len(opts.concrete_fields):
0.81 base.py(426):         if not kwargs:
0.81 base.py(438):             fields_iter = iter(opts.fields)
0.81 base.py(439):             for val, field in zip(args, fields_iter):
0.81 base.py(448):         for field in fields_iter:
0.81 base.py(449):             is_related_object = False
0.81 base.py(451):             if field.attname not in kwargs and field.column is None:
0.81 base.py(453):             if kwargs:
0.81 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.81 base.py(466):                     try:
0.81 base.py(467):                         val = kwargs.pop(field.attname)
0.81 base.py(468):                     except KeyError:
0.81 base.py(473):                         val = field.get_default()
0.81 base.py(477):             if is_related_object:
0.81 base.py(485):                 if val is not _DEFERRED:
0.81 base.py(486):                     _setattr(self, field.attname, val)
0.81 base.py(448):         for field in fields_iter:
0.81 base.py(449):             is_related_object = False
0.81 base.py(451):             if field.attname not in kwargs and field.column is None:
0.81 base.py(453):             if kwargs:
0.81 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.81 base.py(466):                     try:
0.81 base.py(467):                         val = kwargs.pop(field.attname)
0.81 base.py(477):             if is_related_object:
0.81 base.py(485):                 if val is not _DEFERRED:
0.81 base.py(486):                     _setattr(self, field.attname, val)
0.81 base.py(448):         for field in fields_iter:
0.81 base.py(449):             is_related_object = False
0.81 base.py(451):             if field.attname not in kwargs and field.column is None:
0.81 base.py(453):             if kwargs:
0.81 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.81 base.py(466):                     try:
0.81 base.py(467):                         val = kwargs.pop(field.attname)
0.81 base.py(477):             if is_related_object:
0.81 base.py(485):                 if val is not _DEFERRED:
0.81 base.py(486):                     _setattr(self, field.attname, val)
0.81 base.py(448):         for field in fields_iter:
0.81 base.py(449):             is_related_object = False
0.81 base.py(451):             if field.attname not in kwargs and field.column is None:
0.81 base.py(453):             if kwargs:
0.81 base.py(475):                 val = field.get_default()
0.81 base.py(477):             if is_related_object:
0.81 base.py(485):                 if val is not _DEFERRED:
0.81 base.py(486):                     _setattr(self, field.attname, val)
0.81 base.py(448):         for field in fields_iter:
0.81 base.py(488):         if kwargs:
0.81 base.py(502):         super().__init__()
0.81 base.py(503):         post_init.send(sender=cls, instance=self)
0.81 base.py(679):         for field in self._meta.concrete_fields:
0.81 base.py(682):             if field.is_relation and field.is_cached(self):
0.81 base.py(679):         for field in self._meta.concrete_fields:
0.81 base.py(682):             if field.is_relation and field.is_cached(self):
0.81 base.py(679):         for field in self._meta.concrete_fields:
0.81 base.py(682):             if field.is_relation and field.is_cached(self):
0.81 base.py(679):         for field in self._meta.concrete_fields:
0.81 base.py(682):             if field.is_relation and field.is_cached(self):
0.81 base.py(679):         for field in self._meta.concrete_fields:
0.81 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.81 base.py(710):         if force_insert and (force_update or update_fields):
0.81 base.py(713):         deferred_fields = self.get_deferred_fields()
0.81 base.py(583):         return {
0.81 base.py(584):             f.attname for f in self._meta.concrete_fields
0.81 base.py(583):         return {
0.81 base.py(584):             f.attname for f in self._meta.concrete_fields
0.81 base.py(585):             if f.attname not in self.__dict__
0.81 base.py(583):         return {
0.81 base.py(584):             f.attname for f in self._meta.concrete_fields
0.81 base.py(585):             if f.attname not in self.__dict__
0.81 base.py(583):         return {
0.81 base.py(584):             f.attname for f in self._meta.concrete_fields
0.81 base.py(585):             if f.attname not in self.__dict__
0.81 base.py(583):         return {
0.81 base.py(584):             f.attname for f in self._meta.concrete_fields
0.81 base.py(585):             if f.attname not in self.__dict__
0.81 base.py(583):         return {
0.81 base.py(714):         if update_fields is not None:
0.81 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.81 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.81 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.81 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.81 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.81 base.py(766):         assert update_fields is None or update_fields
0.81 base.py(767):         cls = origin = self.__class__
0.81 base.py(769):         if cls._meta.proxy:
0.81 base.py(771):         meta = cls._meta
0.81 base.py(772):         if not meta.auto_created:
0.81 base.py(773):             pre_save.send(
0.81 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.81 base.py(775):                 update_fields=update_fields,
0.81 base.py(778):         if meta.parents:
0.81 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.81 base.py(782):         with context_manager:
0.81 base.py(783):             parent_inserted = False
0.81 base.py(784):             if not raw:
0.81 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.81 base.py(806):         meta = cls._meta
0.81 base.py(807):         inserted = False
0.81 base.py(808):         for parent, field in meta.parents.items():
0.81 base.py(830):         return inserted
0.81 base.py(786):             updated = self._save_table(
0.81 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.81 base.py(788):                 force_update, using, update_fields,
0.81 base.py(838):         meta = cls._meta
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.81 base.py(841):         if update_fields:
0.81 base.py(845):         pk_val = self._get_pk_val(meta)
0.81 base.py(568):         meta = meta or self._meta
0.81 base.py(569):         return getattr(self, meta.pk.attname)
0.81 base.py(846):         if pk_val is None:
0.81 base.py(847):             pk_val = meta.pk.get_pk_value_on_save(self)
0.81 base.py(848):             setattr(self, meta.pk.attname, pk_val)
0.81 base.py(849):         pk_set = pk_val is not None
0.81 base.py(850):         if not pk_set and (force_update or update_fields):
0.81 base.py(852):         updated = False
0.81 base.py(855):             not raw and
0.81 base.py(856):             not force_insert and
0.81 base.py(863):         if pk_set and not force_insert:
0.81 base.py(874):         if not updated:
0.81 base.py(875):             if meta.order_with_respect_to:
0.81 base.py(886):             fields = meta.local_concrete_fields
0.81 base.py(887):             if not pk_set:
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.81 base.py(890):             returning_fields = meta.db_returning_fields
0.81 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.81 base.py(378):         return cls._meta.base_manager
0.81 base.py(928):         return manager._insert(
0.81 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.81 base.py(930):             using=using, raw=raw,
0.81 base.py(892):             for result, field in zip(results, returning_fields):
0.81 base.py(893):                 setattr(self, field.attname, result)
0.81 base.py(892):             for result, field in zip(results, returning_fields):
0.81 base.py(894):         return updated
0.81 base.py(791):         self._state.db = using
0.81 base.py(793):         self._state.adding = False
0.81 base.py(796):         if not meta.auto_created:
0.81 base.py(797):             post_save.send(
0.81 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.81 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
 OK
  Applying sites.0002_alter_domain_unique...0.82 options.py(748):         if include_parents is False:
0.82 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(792):             for parent in self.parents:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(810):             all_fields = self._relation_tree
0.82 options.py(723):         return self._populate_directed_relation_graph()
0.82 options.py(692):         related_objects_graph = defaultdict(list)
0.82 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.82 options.py(349):             if swapped_for:
0.82 options.py(350):                 try:
0.82 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.82 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.82 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.82 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.82 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(696):             opts = model._meta
0.82 options.py(699):             if opts.abstract:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(705):             for f in fields_with_relations:
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(703):                 if f.is_relation and f.related_model is not None
0.82 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.82 options.py(695):         for model in all_models:
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.82 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.82 options.py(709):         for model in all_models:
0.82 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
0.82 options.py(811):             for field in all_fields:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.82 options.py(349):             if swapped_for:
0.82 options.py(350):                 try:
0.82 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.82 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.82 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(735):                     delattr(self, cache_key)
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(75):         super_new = super().__new__
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(80):         if not parents:
0.82 base.py(84):         module = attrs.pop('__module__')
0.82 base.py(85):         new_attrs = {'__module__': module}
0.82 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.82 base.py(87):         if classcell is not None:
0.82 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.82 base.py(93):         contributable_attrs = {}
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.82 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.82 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.82 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.82 base.py(105):         app_label = None
0.82 base.py(108):         app_config = apps.get_containing_app_config(module)
0.82 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.82 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.82 options.py(76):         self._get_fields_cache = {}
0.82 options.py(77):         self.local_fields = []
0.82 options.py(78):         self.local_many_to_many = []
0.82 options.py(79):         self.private_fields = []
0.82 options.py(80):         self.local_managers = []
0.82 options.py(81):         self.base_manager_name = None
0.82 options.py(82):         self.default_manager_name = None
0.82 options.py(83):         self.model_name = None
0.82 options.py(84):         self.verbose_name = None
0.82 options.py(85):         self.verbose_name_plural = None
0.82 options.py(86):         self.db_table = ''
0.82 options.py(87):         self.ordering = []
0.82 options.py(88):         self._ordering_clash = False
0.82 options.py(89):         self.indexes = []
0.82 options.py(90):         self.constraints = []
0.82 options.py(91):         self.unique_together = []
0.82 options.py(92):         self.index_together = []
0.82 options.py(93):         self.select_on_save = False
0.82 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.82 options.py(95):         self.permissions = []
0.82 options.py(96):         self.object_name = None
0.82 options.py(97):         self.app_label = app_label
0.82 options.py(98):         self.get_latest_by = None
0.82 options.py(99):         self.order_with_respect_to = None
0.82 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.82 options.py(101):         self.required_db_features = []
0.82 options.py(102):         self.required_db_vendor = None
0.82 options.py(103):         self.meta = meta
0.82 options.py(104):         self.pk = None
0.82 options.py(105):         self.auto_field = None
0.82 options.py(106):         self.abstract = False
0.82 options.py(107):         self.managed = True
0.82 options.py(108):         self.proxy = False
0.82 options.py(114):         self.proxy_for_model = None
0.82 options.py(118):         self.concrete_model = None
0.82 options.py(119):         self.swappable = None
0.82 options.py(120):         self.parents = {}
0.82 options.py(121):         self.auto_created = False
0.82 options.py(125):         self.related_fkey_lookups = []
0.82 options.py(128):         self.apps = self.default_apps
0.82 options.py(130):         self.default_related_name = None
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(150):         from django.db import connection
0.82 options.py(151):         from django.db.backends.utils import truncate_name
0.82 options.py(153):         cls._meta = self
0.82 options.py(154):         self.model = cls
0.82 options.py(156):         self.object_name = cls.__name__
0.82 options.py(157):         self.model_name = self.object_name.lower()
0.82 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.82 options.py(162):         self.original_attrs = {}
0.82 options.py(165):         if self.meta:
0.82 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(182):             self.index_together = normalize_together(self.index_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(192):             if self.verbose_name_plural is None:
0.82 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.82 options.py(199):             if meta_attrs != {}:
0.82 options.py(203):         del self.meta
0.82 options.py(206):         if not self.db_table:
0.82 base.py(123):         if not abstract:
0.82 base.py(124):             new_class.add_to_class(
0.82 base.py(125):                 'DoesNotExist',
0.82 base.py(126):                 subclass_exception(
0.82 base.py(127):                     'DoesNotExist',
0.82 base.py(128):                     tuple(
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(130):                     ) or (ObjectDoesNotExist,),
0.82 base.py(131):                     module,
0.82 base.py(132):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(133):             new_class.add_to_class(
0.82 base.py(134):                 'MultipleObjectsReturned',
0.82 base.py(135):                 subclass_exception(
0.82 base.py(136):                     'MultipleObjectsReturned',
0.82 base.py(137):                     tuple(
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(139):                     ) or (MultipleObjectsReturned,),
0.82 base.py(140):                     module,
0.82 base.py(141):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(142):             if base_meta and not base_meta.abstract:
0.82 base.py(151):         is_proxy = new_class._meta.proxy
0.82 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(298):             self.pk = field
0.82 options.py(299):             field.serialize = False
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(263):         self.local_managers.append(manager)
0.82 options.py(264):         self._expire_cache()
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(164):         new_fields = chain(
0.82 base.py(165):             new_class._meta.local_fields,
0.82 base.py(166):             new_class._meta.local_many_to_many,
0.82 base.py(167):             new_class._meta.private_fields
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(172):         if is_proxy:
0.82 base.py(192):             new_class._meta.concrete_model = new_class
0.82 base.py(195):         parent_links = {}
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(198):             if not hasattr(base, '_meta'):
0.82 base.py(199):                 continue
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(198):             if not hasattr(base, '_meta'):
0.82 base.py(201):             if base != new_class and not base._meta.abstract:
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(210):         inherited_attributes = set()
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.82 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.82 base.py(312):         if abstract:
0.82 base.py(320):         new_class._prepare()
0.82 base.py(332):         opts = cls._meta
0.82 base.py(333):         opts._prepare(cls)
0.82 options.py(223):         if self.order_with_respect_to:
0.82 options.py(239):             self.order_with_respect_to = None
0.82 options.py(241):         if self.pk is None:
0.82 base.py(335):         if opts.order_with_respect_to:
0.82 base.py(350):         if cls.__doc__ is None:
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 options.py(456):         def is_not_an_m2m_field(f):
0.82 options.py(459):         def is_not_a_generic_relation(f):
0.82 options.py(462):         def is_not_a_generic_foreign_key(f):
0.82 options.py(467):         return make_immutable_fields_list(
0.82 options.py(468):             "fields",
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(792):             for parent in self.parents:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.82 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.82 base.py(354):         if get_absolute_url_override:
0.82 base.py(357):         if not opts.managers:
0.82 options.py(365):         managers = []
0.82 options.py(366):         seen_managers = set()
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(368):         for depth, base in enumerate(bases):
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(369):             for manager in base._meta.local_managers:
0.82 options.py(370):                 if manager.name in seen_managers:
0.82 options.py(373):                 manager = copy.copy(manager)
0.82 options.py(374):                 manager.model = self.model
0.82 options.py(375):                 seen_managers.add(manager.name)
0.82 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.82 options.py(369):             for manager in base._meta.local_managers:
0.82 options.py(368):         for depth, base in enumerate(bases):
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(378):         return make_immutable_fields_list(
0.82 options.py(379):             "managers",
0.82 options.py(380):             (m[2] for m in sorted(managers)),
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(380):             (m[2] for m in sorted(managers)),
0.82 options.py(380):             (m[2] for m in sorted(managers)),
0.82 base.py(370):         for index in cls._meta.indexes:
0.82 base.py(374):         class_prepared.send(sender=cls)
0.82 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.82 base.py(322):         return new_class
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.82 options.py(349):             if swapped_for:
0.82 options.py(350):                 try:
0.82 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.82 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.82 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(731):                     delattr(self, cache_key)
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(731):                     delattr(self, cache_key)
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.82 options.py(347):         if self.swappable:
0.82 options.py(361):         return None
0.82 options.py(323):         if isinstance(connection, str):
0.82 options.py(324):             connection = connections[connection]
0.82 options.py(325):         if self.required_db_vendor:
0.82 options.py(327):         if self.required_db_features:
0.82 options.py(330):         return True
0.82 options.py(564):         try:
0.82 options.py(567):             return self._forward_fields_map[field_name]
0.82 options.py(532):         res = {}
0.82 options.py(533):         fields = self._get_fields(reverse=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(792):             for parent in self.parents:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(543):         return res
0.82 options.py(564):         try:
0.82 options.py(567):             return self._forward_fields_map[field_name]
0.82 options.py(532):         res = {}
0.82 options.py(533):         fields = self._get_fields(reverse=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(792):             for parent in self.parents:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(535):             res[field.name] = field
0.82 options.py(539):             try:
0.82 options.py(540):                 res[field.attname] = field
0.82 options.py(534):         for field in fields:
0.82 options.py(543):         return res
0.82 options.py(495):         return make_immutable_fields_list(
0.82 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.82 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.82 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.82 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.82 base.py(75):         super_new = super().__new__
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(80):         if not parents:
0.82 base.py(84):         module = attrs.pop('__module__')
0.82 base.py(85):         new_attrs = {'__module__': module}
0.82 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.82 base.py(87):         if classcell is not None:
0.82 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.82 base.py(93):         contributable_attrs = {}
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.82 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.82 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.82 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.82 base.py(105):         app_label = None
0.82 base.py(108):         app_config = apps.get_containing_app_config(module)
0.82 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.82 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.82 options.py(76):         self._get_fields_cache = {}
0.82 options.py(77):         self.local_fields = []
0.82 options.py(78):         self.local_many_to_many = []
0.82 options.py(79):         self.private_fields = []
0.82 options.py(80):         self.local_managers = []
0.82 options.py(81):         self.base_manager_name = None
0.82 options.py(82):         self.default_manager_name = None
0.82 options.py(83):         self.model_name = None
0.82 options.py(84):         self.verbose_name = None
0.82 options.py(85):         self.verbose_name_plural = None
0.82 options.py(86):         self.db_table = ''
0.82 options.py(87):         self.ordering = []
0.82 options.py(88):         self._ordering_clash = False
0.82 options.py(89):         self.indexes = []
0.82 options.py(90):         self.constraints = []
0.82 options.py(91):         self.unique_together = []
0.82 options.py(92):         self.index_together = []
0.82 options.py(93):         self.select_on_save = False
0.82 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.82 options.py(95):         self.permissions = []
0.82 options.py(96):         self.object_name = None
0.82 options.py(97):         self.app_label = app_label
0.82 options.py(98):         self.get_latest_by = None
0.82 options.py(99):         self.order_with_respect_to = None
0.82 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.82 options.py(101):         self.required_db_features = []
0.82 options.py(102):         self.required_db_vendor = None
0.82 options.py(103):         self.meta = meta
0.82 options.py(104):         self.pk = None
0.82 options.py(105):         self.auto_field = None
0.82 options.py(106):         self.abstract = False
0.82 options.py(107):         self.managed = True
0.82 options.py(108):         self.proxy = False
0.82 options.py(114):         self.proxy_for_model = None
0.82 options.py(118):         self.concrete_model = None
0.82 options.py(119):         self.swappable = None
0.82 options.py(120):         self.parents = {}
0.82 options.py(121):         self.auto_created = False
0.82 options.py(125):         self.related_fkey_lookups = []
0.82 options.py(128):         self.apps = self.default_apps
0.82 options.py(130):         self.default_related_name = None
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(150):         from django.db import connection
0.82 options.py(151):         from django.db.backends.utils import truncate_name
0.82 options.py(153):         cls._meta = self
0.82 options.py(154):         self.model = cls
0.82 options.py(156):         self.object_name = cls.__name__
0.82 options.py(157):         self.model_name = self.object_name.lower()
0.82 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.82 options.py(162):         self.original_attrs = {}
0.82 options.py(165):         if self.meta:
0.82 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(182):             self.index_together = normalize_together(self.index_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(192):             if self.verbose_name_plural is None:
0.82 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.82 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.82 options.py(199):             if meta_attrs != {}:
0.82 options.py(203):         del self.meta
0.82 options.py(206):         if not self.db_table:
0.82 base.py(123):         if not abstract:
0.82 base.py(124):             new_class.add_to_class(
0.82 base.py(125):                 'DoesNotExist',
0.82 base.py(126):                 subclass_exception(
0.82 base.py(127):                     'DoesNotExist',
0.82 base.py(128):                     tuple(
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(130):                     ) or (ObjectDoesNotExist,),
0.82 base.py(131):                     module,
0.82 base.py(132):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(133):             new_class.add_to_class(
0.82 base.py(134):                 'MultipleObjectsReturned',
0.82 base.py(135):                 subclass_exception(
0.82 base.py(136):                     'MultipleObjectsReturned',
0.82 base.py(137):                     tuple(
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(139):                     ) or (MultipleObjectsReturned,),
0.82 base.py(140):                     module,
0.82 base.py(141):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(142):             if base_meta and not base_meta.abstract:
0.82 base.py(151):         is_proxy = new_class._meta.proxy
0.82 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(298):             self.pk = field
0.82 options.py(299):             field.serialize = False
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(271):         if private:
0.82 options.py(273):         elif field.is_relation and field.many_to_many:
0.82 options.py(276):             bisect.insort(self.local_fields, field)
0.82 options.py(277):             self.setup_pk(field)
0.82 options.py(297):         if not self.pk and field.primary_key:
0.82 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.82 options.py(294):             self._expire_cache(reverse=False)
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(164):         new_fields = chain(
0.82 base.py(165):             new_class._meta.local_fields,
0.82 base.py(166):             new_class._meta.local_many_to_many,
0.82 base.py(167):             new_class._meta.private_fields
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(169):         field_names = {f.name for f in new_fields}
0.82 base.py(172):         if is_proxy:
0.82 base.py(192):             new_class._meta.concrete_model = new_class
0.82 base.py(195):         parent_links = {}
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(198):             if not hasattr(base, '_meta'):
0.82 base.py(199):                 continue
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(198):             if not hasattr(base, '_meta'):
0.82 base.py(201):             if base != new_class and not base._meta.abstract:
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(205):                 if isinstance(field, OneToOneField):
0.82 base.py(204):             for field in base._meta.local_fields:
0.82 base.py(196):         for base in reversed([new_class] + parents):
0.82 base.py(210):         inherited_attributes = set()
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.82 base.py(216):                 inherited_attributes.update(base.__dict__)
0.82 base.py(217):                 continue
0.82 base.py(212):         for base in new_class.mro():
0.82 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.82 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.82 base.py(312):         if abstract:
0.82 base.py(320):         new_class._prepare()
0.82 base.py(332):         opts = cls._meta
0.82 base.py(333):         opts._prepare(cls)
0.82 options.py(223):         if self.order_with_respect_to:
0.82 options.py(239):             self.order_with_respect_to = None
0.82 options.py(241):         if self.pk is None:
0.82 base.py(335):         if opts.order_with_respect_to:
0.82 base.py(350):         if cls.__doc__ is None:
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 options.py(456):         def is_not_an_m2m_field(f):
0.82 options.py(459):         def is_not_a_generic_relation(f):
0.82 options.py(462):         def is_not_a_generic_foreign_key(f):
0.82 options.py(467):         return make_immutable_fields_list(
0.82 options.py(468):             "fields",
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.82 options.py(773):         topmost_call = seen_models is None
0.82 options.py(774):         if topmost_call:
0.82 options.py(775):             seen_models = set()
0.82 options.py(776):         seen_models.add(self.model)
0.82 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.82 options.py(781):         try:
0.82 options.py(784):             return self._get_fields_cache[cache_key]
0.82 options.py(785):         except KeyError:
0.82 options.py(786):             pass
0.82 options.py(788):         fields = []
0.82 options.py(791):         if include_parents is not False:
0.82 options.py(792):             for parent in self.parents:
0.82 options.py(806):         if reverse and not self.proxy:
0.82 options.py(817):         if forward:
0.82 options.py(818):             fields += self.local_fields
0.82 options.py(819):             fields += self.local_many_to_many
0.82 options.py(825):             if topmost_call:
0.82 options.py(826):                 fields += self.private_fields
0.82 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(833):         self._get_fields_cache[cache_key] = fields
0.82 options.py(834):         return fields
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.82 options.py(457):             return not (f.is_relation and f.many_to_many)
0.82 options.py(460):             return not (f.is_relation and f.one_to_many)
0.82 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.82 options.py(469):             (f for f in self._get_fields(reverse=False)
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.82 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.82 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.82 base.py(354):         if get_absolute_url_override:
0.82 base.py(357):         if not opts.managers:
0.82 options.py(365):         managers = []
0.82 options.py(366):         seen_managers = set()
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(368):         for depth, base in enumerate(bases):
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(369):             for manager in base._meta.local_managers:
0.82 options.py(368):         for depth, base in enumerate(bases):
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.82 options.py(378):         return make_immutable_fields_list(
0.82 options.py(379):             "managers",
0.82 options.py(380):             (m[2] for m in sorted(managers)),
0.82 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.82 options.py(380):             (m[2] for m in sorted(managers)),
0.82 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.82 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.82 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.82 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.82 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.82 base.py(363):             manager = Manager()
0.82 base.py(364):             manager.auto_created = True
0.82 base.py(365):             cls.add_to_class('objects', manager)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(263):         self.local_managers.append(manager)
0.82 options.py(264):         self._expire_cache()
0.82 options.py(728):         if forward:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(731):                     delattr(self, cache_key)
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(731):                     delattr(self, cache_key)
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(730):                 if cache_key in self.__dict__:
0.82 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.82 options.py(732):         if reverse and not self.abstract:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(734):                 if cache_key in self.__dict__:
0.82 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.82 options.py(736):         self._get_fields_cache = {}
0.82 base.py(370):         for index in cls._meta.indexes:
0.82 base.py(374):         class_prepared.send(sender=cls)
0.82 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.82 base.py(322):         return new_class
0.82 base.py(75):         super_new = super().__new__
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.82 base.py(80):         if not parents:
0.82 base.py(84):         module = attrs.pop('__module__')
0.82 base.py(85):         new_attrs = {'__module__': module}
0.82 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.82 base.py(87):         if classcell is not None:
0.82 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.82 base.py(93):         contributable_attrs = {}
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(95):             if _has_contribute_to_class(obj):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(96):                 contributable_attrs[obj_name] = obj
0.82 base.py(94):         for obj_name, obj in list(attrs.items()):
0.82 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.82 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.82 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.82 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.82 base.py(105):         app_label = None
0.82 base.py(108):         app_config = apps.get_containing_app_config(module)
0.82 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.82 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.82 options.py(76):         self._get_fields_cache = {}
0.82 options.py(77):         self.local_fields = []
0.82 options.py(78):         self.local_many_to_many = []
0.82 options.py(79):         self.private_fields = []
0.82 options.py(80):         self.local_managers = []
0.82 options.py(81):         self.base_manager_name = None
0.82 options.py(82):         self.default_manager_name = None
0.82 options.py(83):         self.model_name = None
0.82 options.py(84):         self.verbose_name = None
0.82 options.py(85):         self.verbose_name_plural = None
0.82 options.py(86):         self.db_table = ''
0.82 options.py(87):         self.ordering = []
0.82 options.py(88):         self._ordering_clash = False
0.82 options.py(89):         self.indexes = []
0.82 options.py(90):         self.constraints = []
0.82 options.py(91):         self.unique_together = []
0.82 options.py(92):         self.index_together = []
0.82 options.py(93):         self.select_on_save = False
0.82 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.82 options.py(95):         self.permissions = []
0.82 options.py(96):         self.object_name = None
0.82 options.py(97):         self.app_label = app_label
0.82 options.py(98):         self.get_latest_by = None
0.82 options.py(99):         self.order_with_respect_to = None
0.82 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.82 options.py(101):         self.required_db_features = []
0.82 options.py(102):         self.required_db_vendor = None
0.82 options.py(103):         self.meta = meta
0.82 options.py(104):         self.pk = None
0.82 options.py(105):         self.auto_field = None
0.82 options.py(106):         self.abstract = False
0.82 options.py(107):         self.managed = True
0.82 options.py(108):         self.proxy = False
0.82 options.py(114):         self.proxy_for_model = None
0.82 options.py(118):         self.concrete_model = None
0.82 options.py(119):         self.swappable = None
0.82 options.py(120):         self.parents = {}
0.82 options.py(121):         self.auto_created = False
0.82 options.py(125):         self.related_fkey_lookups = []
0.82 options.py(128):         self.apps = self.default_apps
0.82 options.py(130):         self.default_related_name = None
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.82 options.py(150):         from django.db import connection
0.82 options.py(151):         from django.db.backends.utils import truncate_name
0.82 options.py(153):         cls._meta = self
0.82 options.py(154):         self.model = cls
0.82 options.py(156):         self.object_name = cls.__name__
0.82 options.py(157):         self.model_name = self.object_name.lower()
0.82 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.82 options.py(162):         self.original_attrs = {}
0.82 options.py(165):         if self.meta:
0.82 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(171):                 if name.startswith('_'):
0.82 options.py(172):                     del meta_attrs[name]
0.82 options.py(167):             for name in self.meta.__dict__:
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(177):                 elif hasattr(self.meta, attr_name):
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(174):                 if attr_name in meta_attrs:
0.82 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.82 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.82 options.py(173):             for attr_name in DEFAULT_NAMES:
0.82 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(182):             self.index_together = normalize_together(self.index_together)
0.82 options.py(45):     try:
0.82 options.py(46):         if not option_together:
0.82 options.py(47):             return ()
0.82 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(187):                     objs = getattr(self, attr_name, [])
0.82 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.82 options.py(212):         new_objs = []
0.82 options.py(213):         for obj in objs:
0.82 options.py(220):         return new_objs
0.82 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.82 options.py(192):             if self.verbose_name_plural is None:
0.82 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
0.82 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.82 options.py(199):             if meta_attrs != {}:
0.82 options.py(203):         del self.meta
0.82 options.py(206):         if not self.db_table:
0.82 base.py(123):         if not abstract:
0.82 base.py(124):             new_class.add_to_class(
0.82 base.py(125):                 'DoesNotExist',
0.82 base.py(126):                 subclass_exception(
0.82 base.py(127):                     'DoesNotExist',
0.82 base.py(128):                     tuple(
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(130):                     ) or (ObjectDoesNotExist,),
0.82 base.py(131):                     module,
0.82 base.py(132):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(133):             new_class.add_to_class(
0.82 base.py(134):                 'MultipleObjectsReturned',
0.82 base.py(135):                 subclass_exception(
0.82 base.py(136):                     'MultipleObjectsReturned',
0.82 base.py(137):                     tuple(
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.82 base.py(139):                     ) or (MultipleObjectsReturned,),
0.82 base.py(140):                     module,
0.82 base.py(141):                     attached_to=new_class))
0.82 base.py(61):     return type(name, bases, {
0.82 base.py(62):         '__module__': module,
0.82 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(328):             setattr(cls, name, value)
0.82 base.py(142):             if base_meta and not base_meta.abstract:
0.82 base.py(151):         is_proxy = new_class._meta.proxy
0.82 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.82 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.82 base.py(161):             new_class.add_to_class(obj_name, obj)
0.82 base.py(325):         if _has_contribute_to_class(value):
0.82 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.82 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(298):             self.pk = field
0.83 options.py(299):             field.serialize = False
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(164):         new_fields = chain(
0.83 base.py(165):             new_class._meta.local_fields,
0.83 base.py(166):             new_class._meta.local_many_to_many,
0.83 base.py(167):             new_class._meta.private_fields
0.83 base.py(169):         field_names = {f.name for f in new_fields}
0.83 base.py(169):         field_names = {f.name for f in new_fields}
0.83 base.py(169):         field_names = {f.name for f in new_fields}
0.83 base.py(169):         field_names = {f.name for f in new_fields}
0.83 base.py(169):         field_names = {f.name for f in new_fields}
0.83 base.py(172):         if is_proxy:
0.83 base.py(192):             new_class._meta.concrete_model = new_class
0.83 base.py(195):         parent_links = {}
0.83 base.py(196):         for base in reversed([new_class] + parents):
0.83 base.py(198):             if not hasattr(base, '_meta'):
0.83 base.py(199):                 continue
0.83 base.py(196):         for base in reversed([new_class] + parents):
0.83 base.py(198):             if not hasattr(base, '_meta'):
0.83 base.py(201):             if base != new_class and not base._meta.abstract:
0.83 base.py(204):             for field in base._meta.local_fields:
0.83 base.py(205):                 if isinstance(field, OneToOneField):
0.83 base.py(204):             for field in base._meta.local_fields:
0.83 base.py(205):                 if isinstance(field, OneToOneField):
0.83 base.py(204):             for field in base._meta.local_fields:
0.83 base.py(205):                 if isinstance(field, OneToOneField):
0.83 base.py(204):             for field in base._meta.local_fields:
0.83 base.py(196):         for base in reversed([new_class] + parents):
0.83 base.py(210):         inherited_attributes = set()
0.83 base.py(212):         for base in new_class.mro():
0.83 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.83 base.py(216):                 inherited_attributes.update(base.__dict__)
0.83 base.py(217):                 continue
0.83 base.py(212):         for base in new_class.mro():
0.83 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.83 base.py(216):                 inherited_attributes.update(base.__dict__)
0.83 base.py(217):                 continue
0.83 base.py(212):         for base in new_class.mro():
0.83 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.83 base.py(216):                 inherited_attributes.update(base.__dict__)
0.83 base.py(217):                 continue
0.83 base.py(212):         for base in new_class.mro():
0.83 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.83 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.83 base.py(312):         if abstract:
0.83 base.py(320):         new_class._prepare()
0.83 base.py(332):         opts = cls._meta
0.83 base.py(333):         opts._prepare(cls)
0.83 options.py(223):         if self.order_with_respect_to:
0.83 options.py(239):             self.order_with_respect_to = None
0.83 options.py(241):         if self.pk is None:
0.83 base.py(335):         if opts.order_with_respect_to:
0.83 base.py(350):         if cls.__doc__ is None:
0.83 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.83 options.py(456):         def is_not_an_m2m_field(f):
0.83 options.py(459):         def is_not_a_generic_relation(f):
0.83 options.py(462):         def is_not_a_generic_foreign_key(f):
0.83 options.py(467):         return make_immutable_fields_list(
0.83 options.py(468):             "fields",
0.83 options.py(469):             (f for f in self._get_fields(reverse=False)
0.83 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.83 options.py(773):         topmost_call = seen_models is None
0.83 options.py(774):         if topmost_call:
0.83 options.py(775):             seen_models = set()
0.83 options.py(776):         seen_models.add(self.model)
0.83 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.83 options.py(781):         try:
0.83 options.py(784):             return self._get_fields_cache[cache_key]
0.83 options.py(785):         except KeyError:
0.83 options.py(786):             pass
0.83 options.py(788):         fields = []
0.83 options.py(791):         if include_parents is not False:
0.83 options.py(792):             for parent in self.parents:
0.83 options.py(806):         if reverse and not self.proxy:
0.83 options.py(817):         if forward:
0.83 options.py(818):             fields += self.local_fields
0.83 options.py(819):             fields += self.local_many_to_many
0.83 options.py(825):             if topmost_call:
0.83 options.py(826):                 fields += self.private_fields
0.83 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.83 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.83 options.py(833):         self._get_fields_cache[cache_key] = fields
0.83 options.py(834):         return fields
0.83 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.83 options.py(469):             (f for f in self._get_fields(reverse=False)
0.83 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.83 options.py(457):             return not (f.is_relation and f.many_to_many)
0.83 options.py(460):             return not (f.is_relation and f.one_to_many)
0.83 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.83 options.py(469):             (f for f in self._get_fields(reverse=False)
0.83 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.83 options.py(457):             return not (f.is_relation and f.many_to_many)
0.83 options.py(460):             return not (f.is_relation and f.one_to_many)
0.83 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.83 options.py(469):             (f for f in self._get_fields(reverse=False)
0.83 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.83 options.py(457):             return not (f.is_relation and f.many_to_many)
0.83 options.py(460):             return not (f.is_relation and f.one_to_many)
0.83 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.83 options.py(469):             (f for f in self._get_fields(reverse=False)
0.83 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.83 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.83 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.83 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.83 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.83 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.83 base.py(354):         if get_absolute_url_override:
0.83 base.py(357):         if not opts.managers:
0.83 options.py(365):         managers = []
0.83 options.py(366):         seen_managers = set()
0.83 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.83 options.py(368):         for depth, base in enumerate(bases):
0.83 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.83 options.py(369):             for manager in base._meta.local_managers:
0.83 options.py(368):         for depth, base in enumerate(bases):
0.83 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.83 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.83 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.83 options.py(378):         return make_immutable_fields_list(
0.83 options.py(379):             "managers",
0.83 options.py(380):             (m[2] for m in sorted(managers)),
0.83 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.83 options.py(380):             (m[2] for m in sorted(managers)),
0.83 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.83 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.83 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.83 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.83 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.83 base.py(363):             manager = Manager()
0.83 base.py(364):             manager.auto_created = True
0.83 base.py(365):             cls.add_to_class('objects', manager)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(263):         self.local_managers.append(manager)
0.83 options.py(264):         self._expire_cache()
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(731):                     delattr(self, cache_key)
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(731):                     delattr(self, cache_key)
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.83 options.py(734):                 if cache_key in self.__dict__:
0.83 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.83 options.py(734):                 if cache_key in self.__dict__:
0.83 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.83 options.py(734):                 if cache_key in self.__dict__:
0.83 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(370):         for index in cls._meta.indexes:
0.83 base.py(374):         class_prepared.send(sender=cls)
0.83 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.83 base.py(322):         return new_class
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(438):             fields_iter = iter(opts.fields)
0.83 base.py(439):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(449):             is_related_object = False
0.83 base.py(451):             if field.attname not in kwargs and field.column is None:
0.83 base.py(453):             if kwargs:
0.83 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.83 base.py(466):                     try:
0.83 base.py(467):                         val = kwargs.pop(field.attname)
0.83 base.py(468):                     except KeyError:
0.83 base.py(473):                         val = field.get_default()
0.83 base.py(477):             if is_related_object:
0.83 base.py(485):                 if val is not _DEFERRED:
0.83 base.py(486):                     _setattr(self, field.attname, val)
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(449):             is_related_object = False
0.83 base.py(451):             if field.attname not in kwargs and field.column is None:
0.83 base.py(453):             if kwargs:
0.83 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.83 base.py(466):                     try:
0.83 base.py(467):                         val = kwargs.pop(field.attname)
0.83 base.py(477):             if is_related_object:
0.83 base.py(485):                 if val is not _DEFERRED:
0.83 base.py(486):                     _setattr(self, field.attname, val)
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(449):             is_related_object = False
0.83 base.py(451):             if field.attname not in kwargs and field.column is None:
0.83 base.py(453):             if kwargs:
0.83 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.83 base.py(466):                     try:
0.83 base.py(467):                         val = kwargs.pop(field.attname)
0.83 base.py(477):             if is_related_object:
0.83 base.py(485):                 if val is not _DEFERRED:
0.83 base.py(486):                     _setattr(self, field.attname, val)
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(449):             is_related_object = False
0.83 base.py(451):             if field.attname not in kwargs and field.column is None:
0.83 base.py(453):             if kwargs:
0.83 base.py(475):                 val = field.get_default()
0.83 base.py(477):             if is_related_object:
0.83 base.py(485):                 if val is not _DEFERRED:
0.83 base.py(486):                     _setattr(self, field.attname, val)
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(679):         for field in self._meta.concrete_fields:
0.83 base.py(682):             if field.is_relation and field.is_cached(self):
0.83 base.py(679):         for field in self._meta.concrete_fields:
0.83 base.py(682):             if field.is_relation and field.is_cached(self):
0.83 base.py(679):         for field in self._meta.concrete_fields:
0.83 base.py(682):             if field.is_relation and field.is_cached(self):
0.83 base.py(679):         for field in self._meta.concrete_fields:
0.83 base.py(682):             if field.is_relation and field.is_cached(self):
0.83 base.py(679):         for field in self._meta.concrete_fields:
0.83 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.83 base.py(710):         if force_insert and (force_update or update_fields):
0.83 base.py(713):         deferred_fields = self.get_deferred_fields()
0.83 base.py(583):         return {
0.83 base.py(584):             f.attname for f in self._meta.concrete_fields
0.83 base.py(583):         return {
0.83 base.py(584):             f.attname for f in self._meta.concrete_fields
0.83 base.py(585):             if f.attname not in self.__dict__
0.83 base.py(583):         return {
0.83 base.py(584):             f.attname for f in self._meta.concrete_fields
0.83 base.py(585):             if f.attname not in self.__dict__
0.83 base.py(583):         return {
0.83 base.py(584):             f.attname for f in self._meta.concrete_fields
0.83 base.py(585):             if f.attname not in self.__dict__
0.83 base.py(583):         return {
0.83 base.py(584):             f.attname for f in self._meta.concrete_fields
0.83 base.py(585):             if f.attname not in self.__dict__
0.83 base.py(583):         return {
0.83 base.py(714):         if update_fields is not None:
0.83 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.83 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.83 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.83 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.83 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.83 base.py(766):         assert update_fields is None or update_fields
0.83 base.py(767):         cls = origin = self.__class__
0.83 base.py(769):         if cls._meta.proxy:
0.83 base.py(771):         meta = cls._meta
0.83 base.py(772):         if not meta.auto_created:
0.83 base.py(773):             pre_save.send(
0.83 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.83 base.py(775):                 update_fields=update_fields,
0.83 base.py(778):         if meta.parents:
0.83 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.83 base.py(782):         with context_manager:
0.83 base.py(783):             parent_inserted = False
0.83 base.py(784):             if not raw:
0.83 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.83 base.py(806):         meta = cls._meta
0.83 base.py(807):         inserted = False
0.83 base.py(808):         for parent, field in meta.parents.items():
0.83 base.py(830):         return inserted
0.83 base.py(786):             updated = self._save_table(
0.83 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.83 base.py(788):                 force_update, using, update_fields,
0.83 base.py(838):         meta = cls._meta
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.83 base.py(841):         if update_fields:
0.83 base.py(845):         pk_val = self._get_pk_val(meta)
0.83 base.py(568):         meta = meta or self._meta
0.83 base.py(569):         return getattr(self, meta.pk.attname)
0.83 base.py(846):         if pk_val is None:
0.83 base.py(847):             pk_val = meta.pk.get_pk_value_on_save(self)
0.83 base.py(848):             setattr(self, meta.pk.attname, pk_val)
0.83 base.py(849):         pk_set = pk_val is not None
0.83 base.py(850):         if not pk_set and (force_update or update_fields):
0.83 base.py(852):         updated = False
0.83 base.py(855):             not raw and
0.83 base.py(856):             not force_insert and
0.83 base.py(863):         if pk_set and not force_insert:
0.83 base.py(874):         if not updated:
0.83 base.py(875):             if meta.order_with_respect_to:
0.83 base.py(886):             fields = meta.local_concrete_fields
0.83 base.py(887):             if not pk_set:
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(888):                 fields = [f for f in fields if f is not meta.auto_field]
0.83 base.py(890):             returning_fields = meta.db_returning_fields
0.83 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.83 base.py(378):         return cls._meta.base_manager
0.83 base.py(928):         return manager._insert(
0.83 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.83 base.py(930):             using=using, raw=raw,
0.83 base.py(892):             for result, field in zip(results, returning_fields):
0.83 base.py(893):                 setattr(self, field.attname, result)
0.83 base.py(892):             for result, field in zip(results, returning_fields):
0.83 base.py(894):         return updated
0.83 base.py(791):         self._state.db = using
0.83 base.py(793):         self._state.adding = False
0.83 base.py(796):         if not meta.auto_created:
0.83 base.py(797):             post_save.send(
0.83 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.83 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
 OK
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.83 base.py(513):         new = cls(*values)
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(514):         new._state.adding = False
0.83 base.py(515):         new._state.db = db
0.83 base.py(516):         return new
0.83 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.83 base.py(513):         new = cls(*values)
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(514):         new._state.adding = False
0.83 base.py(515):         new._state.db = db
0.83 base.py(516):         return new
0.83 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.83 base.py(513):         new = cls(*values)
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(514):         new._state.adding = False
0.83 base.py(515):         new._state.db = db
0.83 base.py(516):         return new
0.83 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.83 base.py(513):         new = cls(*values)
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(514):         new._state.adding = False
0.83 base.py(515):         new._state.db = db
0.83 base.py(516):         return new
0.83 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.83 base.py(513):         new = cls(*values)
0.83 base.py(408):         cls = self.__class__
0.83 base.py(409):         opts = self._meta
0.83 base.py(410):         _setattr = setattr
0.83 base.py(411):         _DEFERRED = DEFERRED
0.83 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.83 base.py(416):         self._state = ModelState()
0.83 base.py(422):         if len(args) > len(opts.concrete_fields):
0.83 base.py(426):         if not kwargs:
0.83 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(433):                 if val is _DEFERRED:
0.83 base.py(435):                 _setattr(self, field.attname, val)
0.83 base.py(432):             for val, field in zip(args, fields_iter):
0.83 base.py(448):         for field in fields_iter:
0.83 base.py(488):         if kwargs:
0.83 base.py(502):         super().__init__()
0.83 base.py(503):         post_init.send(sender=cls, instance=self)
0.83 base.py(514):         new._state.adding = False
0.83 base.py(515):         new._state.db = db
0.83 base.py(516):         return new
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 options.py(45):     try:
0.83 options.py(46):         if not option_together:
0.83 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.83 options.py(50):         first_element = option_together[0]
0.83 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 options.py(347):         if self.swappable:
0.83 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.83 options.py(349):             if swapped_for:
0.83 options.py(350):                 try:
0.83 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.83 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.83 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.83 options.py(361):         return None
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 options.py(347):         if self.swappable:
0.83 options.py(361):         return None
0.83 options.py(45):     try:
0.83 options.py(46):         if not option_together:
0.83 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.83 options.py(50):         first_element = option_together[0]
0.83 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.83 base.py(75):         super_new = super().__new__
0.83 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.83 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.83 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.83 base.py(80):         if not parents:
0.83 base.py(84):         module = attrs.pop('__module__')
0.83 base.py(85):         new_attrs = {'__module__': module}
0.83 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.83 base.py(87):         if classcell is not None:
0.83 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.83 base.py(93):         contributable_attrs = {}
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(95):             if _has_contribute_to_class(obj):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(96):                 contributable_attrs[obj_name] = obj
0.83 base.py(94):         for obj_name, obj in list(attrs.items()):
0.83 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.83 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.83 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.83 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.83 base.py(105):         app_label = None
0.83 base.py(108):         app_config = apps.get_containing_app_config(module)
0.83 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.83 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.83 options.py(76):         self._get_fields_cache = {}
0.83 options.py(77):         self.local_fields = []
0.83 options.py(78):         self.local_many_to_many = []
0.83 options.py(79):         self.private_fields = []
0.83 options.py(80):         self.local_managers = []
0.83 options.py(81):         self.base_manager_name = None
0.83 options.py(82):         self.default_manager_name = None
0.83 options.py(83):         self.model_name = None
0.83 options.py(84):         self.verbose_name = None
0.83 options.py(85):         self.verbose_name_plural = None
0.83 options.py(86):         self.db_table = ''
0.83 options.py(87):         self.ordering = []
0.83 options.py(88):         self._ordering_clash = False
0.83 options.py(89):         self.indexes = []
0.83 options.py(90):         self.constraints = []
0.83 options.py(91):         self.unique_together = []
0.83 options.py(92):         self.index_together = []
0.83 options.py(93):         self.select_on_save = False
0.83 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.83 options.py(95):         self.permissions = []
0.83 options.py(96):         self.object_name = None
0.83 options.py(97):         self.app_label = app_label
0.83 options.py(98):         self.get_latest_by = None
0.83 options.py(99):         self.order_with_respect_to = None
0.83 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.83 options.py(101):         self.required_db_features = []
0.83 options.py(102):         self.required_db_vendor = None
0.83 options.py(103):         self.meta = meta
0.83 options.py(104):         self.pk = None
0.83 options.py(105):         self.auto_field = None
0.83 options.py(106):         self.abstract = False
0.83 options.py(107):         self.managed = True
0.83 options.py(108):         self.proxy = False
0.83 options.py(114):         self.proxy_for_model = None
0.83 options.py(118):         self.concrete_model = None
0.83 options.py(119):         self.swappable = None
0.83 options.py(120):         self.parents = {}
0.83 options.py(121):         self.auto_created = False
0.83 options.py(125):         self.related_fkey_lookups = []
0.83 options.py(128):         self.apps = self.default_apps
0.83 options.py(130):         self.default_related_name = None
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(150):         from django.db import connection
0.83 options.py(151):         from django.db.backends.utils import truncate_name
0.83 options.py(153):         cls._meta = self
0.83 options.py(154):         self.model = cls
0.83 options.py(156):         self.object_name = cls.__name__
0.83 options.py(157):         self.model_name = self.object_name.lower()
0.83 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.83 options.py(162):         self.original_attrs = {}
0.83 options.py(165):         if self.meta:
0.83 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(172):                     del meta_attrs[name]
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(172):                     del meta_attrs[name]
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(172):                     del meta_attrs[name]
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(171):                 if name.startswith('_'):
0.83 options.py(172):                     del meta_attrs[name]
0.83 options.py(167):             for name in self.meta.__dict__:
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(177):                 elif hasattr(self.meta, attr_name):
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(174):                 if attr_name in meta_attrs:
0.83 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.83 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.83 options.py(173):             for attr_name in DEFAULT_NAMES:
0.83 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.83 options.py(45):     try:
0.83 options.py(46):         if not option_together:
0.83 options.py(47):             return ()
0.83 options.py(182):             self.index_together = normalize_together(self.index_together)
0.83 options.py(45):     try:
0.83 options.py(46):         if not option_together:
0.83 options.py(47):             return ()
0.83 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.83 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.83 options.py(187):                     objs = getattr(self, attr_name, [])
0.83 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.83 options.py(212):         new_objs = []
0.83 options.py(213):         for obj in objs:
0.83 options.py(220):         return new_objs
0.83 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.83 options.py(187):                     objs = getattr(self, attr_name, [])
0.83 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.83 options.py(212):         new_objs = []
0.83 options.py(213):         for obj in objs:
0.83 options.py(220):         return new_objs
0.83 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.83 options.py(192):             if self.verbose_name_plural is None:
0.83 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.83 options.py(199):             if meta_attrs != {}:
0.83 options.py(203):         del self.meta
0.83 options.py(206):         if not self.db_table:
0.83 base.py(123):         if not abstract:
0.83 base.py(124):             new_class.add_to_class(
0.83 base.py(125):                 'DoesNotExist',
0.83 base.py(126):                 subclass_exception(
0.83 base.py(127):                     'DoesNotExist',
0.83 base.py(128):                     tuple(
0.83 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(130):                     ) or (ObjectDoesNotExist,),
0.83 base.py(131):                     module,
0.83 base.py(132):                     attached_to=new_class))
0.83 base.py(61):     return type(name, bases, {
0.83 base.py(62):         '__module__': module,
0.83 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(328):             setattr(cls, name, value)
0.83 base.py(133):             new_class.add_to_class(
0.83 base.py(134):                 'MultipleObjectsReturned',
0.83 base.py(135):                 subclass_exception(
0.83 base.py(136):                     'MultipleObjectsReturned',
0.83 base.py(137):                     tuple(
0.83 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.83 base.py(139):                     ) or (MultipleObjectsReturned,),
0.83 base.py(140):                     module,
0.83 base.py(141):                     attached_to=new_class))
0.83 base.py(61):     return type(name, bases, {
0.83 base.py(62):         '__module__': module,
0.83 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(328):             setattr(cls, name, value)
0.83 base.py(142):             if base_meta and not base_meta.abstract:
0.83 base.py(151):         is_proxy = new_class._meta.proxy
0.83 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(298):             self.pk = field
0.83 options.py(299):             field.serialize = False
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(732):         if reverse and not self.abstract:
0.83 options.py(736):         self._get_fields_cache = {}
0.83 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.83 base.py(161):             new_class.add_to_class(obj_name, obj)
0.83 base.py(325):         if _has_contribute_to_class(value):
0.83 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.83 base.py(326):             value.contribute_to_class(cls, name)
0.83 options.py(271):         if private:
0.83 options.py(273):         elif field.is_relation and field.many_to_many:
0.83 options.py(276):             bisect.insort(self.local_fields, field)
0.83 options.py(277):             self.setup_pk(field)
0.83 options.py(297):         if not self.pk and field.primary_key:
0.83 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.83 options.py(294):             self._expire_cache(reverse=False)
0.83 options.py(728):         if forward:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.83 options.py(730):                 if cache_key in self.__dict__:
0.83 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(288):             try:
0.84 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.84 options.py(290):             except AttributeError:
0.84 options.py(291):                 pass
0.84 options.py(292):             self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(288):             try:
0.84 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.84 options.py(290):             except AttributeError:
0.84 options.py(291):                 pass
0.84 options.py(292):             self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(263):         self.local_managers.append(manager)
0.84 options.py(264):         self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(164):         new_fields = chain(
0.84 base.py(165):             new_class._meta.local_fields,
0.84 base.py(166):             new_class._meta.local_many_to_many,
0.84 base.py(167):             new_class._meta.private_fields
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(172):         if is_proxy:
0.84 base.py(192):             new_class._meta.concrete_model = new_class
0.84 base.py(195):         parent_links = {}
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(199):                 continue
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(201):             if base != new_class and not base._meta.abstract:
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(210):         inherited_attributes = set()
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(312):         if abstract:
0.84 base.py(320):         new_class._prepare()
0.84 base.py(332):         opts = cls._meta
0.84 base.py(333):         opts._prepare(cls)
0.84 options.py(223):         if self.order_with_respect_to:
0.84 options.py(239):             self.order_with_respect_to = None
0.84 options.py(241):         if self.pk is None:
0.84 base.py(335):         if opts.order_with_respect_to:
0.84 base.py(350):         if cls.__doc__ is None:
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 options.py(456):         def is_not_an_m2m_field(f):
0.84 options.py(459):         def is_not_a_generic_relation(f):
0.84 options.py(462):         def is_not_a_generic_foreign_key(f):
0.84 options.py(467):         return make_immutable_fields_list(
0.84 options.py(468):             "fields",
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.84 options.py(773):         topmost_call = seen_models is None
0.84 options.py(774):         if topmost_call:
0.84 options.py(775):             seen_models = set()
0.84 options.py(776):         seen_models.add(self.model)
0.84 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.84 options.py(781):         try:
0.84 options.py(784):             return self._get_fields_cache[cache_key]
0.84 options.py(785):         except KeyError:
0.84 options.py(786):             pass
0.84 options.py(788):         fields = []
0.84 options.py(791):         if include_parents is not False:
0.84 options.py(792):             for parent in self.parents:
0.84 options.py(806):         if reverse and not self.proxy:
0.84 options.py(817):         if forward:
0.84 options.py(818):             fields += self.local_fields
0.84 options.py(819):             fields += self.local_many_to_many
0.84 options.py(825):             if topmost_call:
0.84 options.py(826):                 fields += self.private_fields
0.84 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(833):         self._get_fields_cache[cache_key] = fields
0.84 options.py(834):         return fields
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.84 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.84 base.py(354):         if get_absolute_url_override:
0.84 base.py(357):         if not opts.managers:
0.84 options.py(365):         managers = []
0.84 options.py(366):         seen_managers = set()
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(370):                 if manager.name in seen_managers:
0.84 options.py(373):                 manager = copy.copy(manager)
0.84 options.py(374):                 manager.model = self.model
0.84 options.py(375):                 seen_managers.add(manager.name)
0.84 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(378):         return make_immutable_fields_list(
0.84 options.py(379):             "managers",
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 base.py(370):         for index in cls._meta.indexes:
0.84 base.py(374):         class_prepared.send(sender=cls)
0.84 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.84 base.py(322):         return new_class
0.84 base.py(75):         super_new = super().__new__
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(80):         if not parents:
0.84 base.py(84):         module = attrs.pop('__module__')
0.84 base.py(85):         new_attrs = {'__module__': module}
0.84 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.84 base.py(87):         if classcell is not None:
0.84 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.84 base.py(93):         contributable_attrs = {}
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.84 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.84 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.84 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.84 base.py(105):         app_label = None
0.84 base.py(108):         app_config = apps.get_containing_app_config(module)
0.84 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.84 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.84 options.py(76):         self._get_fields_cache = {}
0.84 options.py(77):         self.local_fields = []
0.84 options.py(78):         self.local_many_to_many = []
0.84 options.py(79):         self.private_fields = []
0.84 options.py(80):         self.local_managers = []
0.84 options.py(81):         self.base_manager_name = None
0.84 options.py(82):         self.default_manager_name = None
0.84 options.py(83):         self.model_name = None
0.84 options.py(84):         self.verbose_name = None
0.84 options.py(85):         self.verbose_name_plural = None
0.84 options.py(86):         self.db_table = ''
0.84 options.py(87):         self.ordering = []
0.84 options.py(88):         self._ordering_clash = False
0.84 options.py(89):         self.indexes = []
0.84 options.py(90):         self.constraints = []
0.84 options.py(91):         self.unique_together = []
0.84 options.py(92):         self.index_together = []
0.84 options.py(93):         self.select_on_save = False
0.84 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.84 options.py(95):         self.permissions = []
0.84 options.py(96):         self.object_name = None
0.84 options.py(97):         self.app_label = app_label
0.84 options.py(98):         self.get_latest_by = None
0.84 options.py(99):         self.order_with_respect_to = None
0.84 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.84 options.py(101):         self.required_db_features = []
0.84 options.py(102):         self.required_db_vendor = None
0.84 options.py(103):         self.meta = meta
0.84 options.py(104):         self.pk = None
0.84 options.py(105):         self.auto_field = None
0.84 options.py(106):         self.abstract = False
0.84 options.py(107):         self.managed = True
0.84 options.py(108):         self.proxy = False
0.84 options.py(114):         self.proxy_for_model = None
0.84 options.py(118):         self.concrete_model = None
0.84 options.py(119):         self.swappable = None
0.84 options.py(120):         self.parents = {}
0.84 options.py(121):         self.auto_created = False
0.84 options.py(125):         self.related_fkey_lookups = []
0.84 options.py(128):         self.apps = self.default_apps
0.84 options.py(130):         self.default_related_name = None
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(150):         from django.db import connection
0.84 options.py(151):         from django.db.backends.utils import truncate_name
0.84 options.py(153):         cls._meta = self
0.84 options.py(154):         self.model = cls
0.84 options.py(156):         self.object_name = cls.__name__
0.84 options.py(157):         self.model_name = self.object_name.lower()
0.84 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.84 options.py(162):         self.original_attrs = {}
0.84 options.py(165):         if self.meta:
0.84 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(182):             self.index_together = normalize_together(self.index_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(192):             if self.verbose_name_plural is None:
0.84 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.84 options.py(199):             if meta_attrs != {}:
0.84 options.py(203):         del self.meta
0.84 options.py(206):         if not self.db_table:
0.84 base.py(123):         if not abstract:
0.84 base.py(124):             new_class.add_to_class(
0.84 base.py(125):                 'DoesNotExist',
0.84 base.py(126):                 subclass_exception(
0.84 base.py(127):                     'DoesNotExist',
0.84 base.py(128):                     tuple(
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(130):                     ) or (ObjectDoesNotExist,),
0.84 base.py(131):                     module,
0.84 base.py(132):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(133):             new_class.add_to_class(
0.84 base.py(134):                 'MultipleObjectsReturned',
0.84 base.py(135):                 subclass_exception(
0.84 base.py(136):                     'MultipleObjectsReturned',
0.84 base.py(137):                     tuple(
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(139):                     ) or (MultipleObjectsReturned,),
0.84 base.py(140):                     module,
0.84 base.py(141):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(142):             if base_meta and not base_meta.abstract:
0.84 base.py(151):         is_proxy = new_class._meta.proxy
0.84 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(298):             self.pk = field
0.84 options.py(299):             field.serialize = False
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(263):         self.local_managers.append(manager)
0.84 options.py(264):         self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(164):         new_fields = chain(
0.84 base.py(165):             new_class._meta.local_fields,
0.84 base.py(166):             new_class._meta.local_many_to_many,
0.84 base.py(167):             new_class._meta.private_fields
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(172):         if is_proxy:
0.84 base.py(192):             new_class._meta.concrete_model = new_class
0.84 base.py(195):         parent_links = {}
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(199):                 continue
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(201):             if base != new_class and not base._meta.abstract:
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(210):         inherited_attributes = set()
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(312):         if abstract:
0.84 base.py(320):         new_class._prepare()
0.84 base.py(332):         opts = cls._meta
0.84 base.py(333):         opts._prepare(cls)
0.84 options.py(223):         if self.order_with_respect_to:
0.84 options.py(239):             self.order_with_respect_to = None
0.84 options.py(241):         if self.pk is None:
0.84 base.py(335):         if opts.order_with_respect_to:
0.84 base.py(350):         if cls.__doc__ is None:
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 options.py(456):         def is_not_an_m2m_field(f):
0.84 options.py(459):         def is_not_a_generic_relation(f):
0.84 options.py(462):         def is_not_a_generic_foreign_key(f):
0.84 options.py(467):         return make_immutable_fields_list(
0.84 options.py(468):             "fields",
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.84 options.py(773):         topmost_call = seen_models is None
0.84 options.py(774):         if topmost_call:
0.84 options.py(775):             seen_models = set()
0.84 options.py(776):         seen_models.add(self.model)
0.84 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.84 options.py(781):         try:
0.84 options.py(784):             return self._get_fields_cache[cache_key]
0.84 options.py(785):         except KeyError:
0.84 options.py(786):             pass
0.84 options.py(788):         fields = []
0.84 options.py(791):         if include_parents is not False:
0.84 options.py(792):             for parent in self.parents:
0.84 options.py(806):         if reverse and not self.proxy:
0.84 options.py(817):         if forward:
0.84 options.py(818):             fields += self.local_fields
0.84 options.py(819):             fields += self.local_many_to_many
0.84 options.py(825):             if topmost_call:
0.84 options.py(826):                 fields += self.private_fields
0.84 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(833):         self._get_fields_cache[cache_key] = fields
0.84 options.py(834):         return fields
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.84 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.84 base.py(354):         if get_absolute_url_override:
0.84 base.py(357):         if not opts.managers:
0.84 options.py(365):         managers = []
0.84 options.py(366):         seen_managers = set()
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(370):                 if manager.name in seen_managers:
0.84 options.py(373):                 manager = copy.copy(manager)
0.84 options.py(374):                 manager.model = self.model
0.84 options.py(375):                 seen_managers.add(manager.name)
0.84 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(378):         return make_immutable_fields_list(
0.84 options.py(379):             "managers",
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 base.py(370):         for index in cls._meta.indexes:
0.84 base.py(374):         class_prepared.send(sender=cls)
0.84 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.84 base.py(322):         return new_class
0.84 base.py(75):         super_new = super().__new__
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(80):         if not parents:
0.84 base.py(84):         module = attrs.pop('__module__')
0.84 base.py(85):         new_attrs = {'__module__': module}
0.84 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.84 base.py(87):         if classcell is not None:
0.84 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.84 base.py(93):         contributable_attrs = {}
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.84 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.84 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.84 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.84 base.py(105):         app_label = None
0.84 base.py(108):         app_config = apps.get_containing_app_config(module)
0.84 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.84 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.84 options.py(76):         self._get_fields_cache = {}
0.84 options.py(77):         self.local_fields = []
0.84 options.py(78):         self.local_many_to_many = []
0.84 options.py(79):         self.private_fields = []
0.84 options.py(80):         self.local_managers = []
0.84 options.py(81):         self.base_manager_name = None
0.84 options.py(82):         self.default_manager_name = None
0.84 options.py(83):         self.model_name = None
0.84 options.py(84):         self.verbose_name = None
0.84 options.py(85):         self.verbose_name_plural = None
0.84 options.py(86):         self.db_table = ''
0.84 options.py(87):         self.ordering = []
0.84 options.py(88):         self._ordering_clash = False
0.84 options.py(89):         self.indexes = []
0.84 options.py(90):         self.constraints = []
0.84 options.py(91):         self.unique_together = []
0.84 options.py(92):         self.index_together = []
0.84 options.py(93):         self.select_on_save = False
0.84 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.84 options.py(95):         self.permissions = []
0.84 options.py(96):         self.object_name = None
0.84 options.py(97):         self.app_label = app_label
0.84 options.py(98):         self.get_latest_by = None
0.84 options.py(99):         self.order_with_respect_to = None
0.84 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.84 options.py(101):         self.required_db_features = []
0.84 options.py(102):         self.required_db_vendor = None
0.84 options.py(103):         self.meta = meta
0.84 options.py(104):         self.pk = None
0.84 options.py(105):         self.auto_field = None
0.84 options.py(106):         self.abstract = False
0.84 options.py(107):         self.managed = True
0.84 options.py(108):         self.proxy = False
0.84 options.py(114):         self.proxy_for_model = None
0.84 options.py(118):         self.concrete_model = None
0.84 options.py(119):         self.swappable = None
0.84 options.py(120):         self.parents = {}
0.84 options.py(121):         self.auto_created = False
0.84 options.py(125):         self.related_fkey_lookups = []
0.84 options.py(128):         self.apps = self.default_apps
0.84 options.py(130):         self.default_related_name = None
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(150):         from django.db import connection
0.84 options.py(151):         from django.db.backends.utils import truncate_name
0.84 options.py(153):         cls._meta = self
0.84 options.py(154):         self.model = cls
0.84 options.py(156):         self.object_name = cls.__name__
0.84 options.py(157):         self.model_name = self.object_name.lower()
0.84 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.84 options.py(162):         self.original_attrs = {}
0.84 options.py(165):         if self.meta:
0.84 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(182):             self.index_together = normalize_together(self.index_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(192):             if self.verbose_name_plural is None:
0.84 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.84 options.py(199):             if meta_attrs != {}:
0.84 options.py(203):         del self.meta
0.84 options.py(206):         if not self.db_table:
0.84 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.84 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.84 base.py(123):         if not abstract:
0.84 base.py(124):             new_class.add_to_class(
0.84 base.py(125):                 'DoesNotExist',
0.84 base.py(126):                 subclass_exception(
0.84 base.py(127):                     'DoesNotExist',
0.84 base.py(128):                     tuple(
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(130):                     ) or (ObjectDoesNotExist,),
0.84 base.py(131):                     module,
0.84 base.py(132):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(133):             new_class.add_to_class(
0.84 base.py(134):                 'MultipleObjectsReturned',
0.84 base.py(135):                 subclass_exception(
0.84 base.py(136):                     'MultipleObjectsReturned',
0.84 base.py(137):                     tuple(
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(139):                     ) or (MultipleObjectsReturned,),
0.84 base.py(140):                     module,
0.84 base.py(141):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(142):             if base_meta and not base_meta.abstract:
0.84 base.py(151):         is_proxy = new_class._meta.proxy
0.84 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(298):             self.pk = field
0.84 options.py(299):             field.serialize = False
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(263):         self.local_managers.append(manager)
0.84 options.py(264):         self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(164):         new_fields = chain(
0.84 base.py(165):             new_class._meta.local_fields,
0.84 base.py(166):             new_class._meta.local_many_to_many,
0.84 base.py(167):             new_class._meta.private_fields
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(172):         if is_proxy:
0.84 base.py(192):             new_class._meta.concrete_model = new_class
0.84 base.py(195):         parent_links = {}
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(199):                 continue
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(201):             if base != new_class and not base._meta.abstract:
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(210):         inherited_attributes = set()
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(312):         if abstract:
0.84 base.py(320):         new_class._prepare()
0.84 base.py(332):         opts = cls._meta
0.84 base.py(333):         opts._prepare(cls)
0.84 options.py(223):         if self.order_with_respect_to:
0.84 options.py(239):             self.order_with_respect_to = None
0.84 options.py(241):         if self.pk is None:
0.84 base.py(335):         if opts.order_with_respect_to:
0.84 base.py(350):         if cls.__doc__ is None:
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 options.py(456):         def is_not_an_m2m_field(f):
0.84 options.py(459):         def is_not_a_generic_relation(f):
0.84 options.py(462):         def is_not_a_generic_foreign_key(f):
0.84 options.py(467):         return make_immutable_fields_list(
0.84 options.py(468):             "fields",
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.84 options.py(773):         topmost_call = seen_models is None
0.84 options.py(774):         if topmost_call:
0.84 options.py(775):             seen_models = set()
0.84 options.py(776):         seen_models.add(self.model)
0.84 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.84 options.py(781):         try:
0.84 options.py(784):             return self._get_fields_cache[cache_key]
0.84 options.py(785):         except KeyError:
0.84 options.py(786):             pass
0.84 options.py(788):         fields = []
0.84 options.py(791):         if include_parents is not False:
0.84 options.py(792):             for parent in self.parents:
0.84 options.py(806):         if reverse and not self.proxy:
0.84 options.py(817):         if forward:
0.84 options.py(818):             fields += self.local_fields
0.84 options.py(819):             fields += self.local_many_to_many
0.84 options.py(825):             if topmost_call:
0.84 options.py(826):                 fields += self.private_fields
0.84 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(833):         self._get_fields_cache[cache_key] = fields
0.84 options.py(834):         return fields
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.84 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.84 base.py(354):         if get_absolute_url_override:
0.84 base.py(357):         if not opts.managers:
0.84 options.py(365):         managers = []
0.84 options.py(366):         seen_managers = set()
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(370):                 if manager.name in seen_managers:
0.84 options.py(373):                 manager = copy.copy(manager)
0.84 options.py(374):                 manager.model = self.model
0.84 options.py(375):                 seen_managers.add(manager.name)
0.84 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(378):         return make_immutable_fields_list(
0.84 options.py(379):             "managers",
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 base.py(370):         for index in cls._meta.indexes:
0.84 base.py(374):         class_prepared.send(sender=cls)
0.84 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.84 base.py(322):         return new_class
0.84 base.py(75):         super_new = super().__new__
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(80):         if not parents:
0.84 base.py(84):         module = attrs.pop('__module__')
0.84 base.py(85):         new_attrs = {'__module__': module}
0.84 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.84 base.py(87):         if classcell is not None:
0.84 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.84 base.py(93):         contributable_attrs = {}
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.84 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.84 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.84 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.84 base.py(105):         app_label = None
0.84 base.py(108):         app_config = apps.get_containing_app_config(module)
0.84 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.84 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.84 options.py(76):         self._get_fields_cache = {}
0.84 options.py(77):         self.local_fields = []
0.84 options.py(78):         self.local_many_to_many = []
0.84 options.py(79):         self.private_fields = []
0.84 options.py(80):         self.local_managers = []
0.84 options.py(81):         self.base_manager_name = None
0.84 options.py(82):         self.default_manager_name = None
0.84 options.py(83):         self.model_name = None
0.84 options.py(84):         self.verbose_name = None
0.84 options.py(85):         self.verbose_name_plural = None
0.84 options.py(86):         self.db_table = ''
0.84 options.py(87):         self.ordering = []
0.84 options.py(88):         self._ordering_clash = False
0.84 options.py(89):         self.indexes = []
0.84 options.py(90):         self.constraints = []
0.84 options.py(91):         self.unique_together = []
0.84 options.py(92):         self.index_together = []
0.84 options.py(93):         self.select_on_save = False
0.84 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.84 options.py(95):         self.permissions = []
0.84 options.py(96):         self.object_name = None
0.84 options.py(97):         self.app_label = app_label
0.84 options.py(98):         self.get_latest_by = None
0.84 options.py(99):         self.order_with_respect_to = None
0.84 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.84 options.py(101):         self.required_db_features = []
0.84 options.py(102):         self.required_db_vendor = None
0.84 options.py(103):         self.meta = meta
0.84 options.py(104):         self.pk = None
0.84 options.py(105):         self.auto_field = None
0.84 options.py(106):         self.abstract = False
0.84 options.py(107):         self.managed = True
0.84 options.py(108):         self.proxy = False
0.84 options.py(114):         self.proxy_for_model = None
0.84 options.py(118):         self.concrete_model = None
0.84 options.py(119):         self.swappable = None
0.84 options.py(120):         self.parents = {}
0.84 options.py(121):         self.auto_created = False
0.84 options.py(125):         self.related_fkey_lookups = []
0.84 options.py(128):         self.apps = self.default_apps
0.84 options.py(130):         self.default_related_name = None
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(150):         from django.db import connection
0.84 options.py(151):         from django.db.backends.utils import truncate_name
0.84 options.py(153):         cls._meta = self
0.84 options.py(154):         self.model = cls
0.84 options.py(156):         self.object_name = cls.__name__
0.84 options.py(157):         self.model_name = self.object_name.lower()
0.84 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.84 options.py(162):         self.original_attrs = {}
0.84 options.py(165):         if self.meta:
0.84 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(171):                 if name.startswith('_'):
0.84 options.py(172):                     del meta_attrs[name]
0.84 options.py(167):             for name in self.meta.__dict__:
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(177):                 elif hasattr(self.meta, attr_name):
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(174):                 if attr_name in meta_attrs:
0.84 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.84 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.84 options.py(173):             for attr_name in DEFAULT_NAMES:
0.84 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(182):             self.index_together = normalize_together(self.index_together)
0.84 options.py(45):     try:
0.84 options.py(46):         if not option_together:
0.84 options.py(47):             return ()
0.84 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(187):                     objs = getattr(self, attr_name, [])
0.84 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.84 options.py(212):         new_objs = []
0.84 options.py(213):         for obj in objs:
0.84 options.py(220):         return new_objs
0.84 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.84 options.py(192):             if self.verbose_name_plural is None:
0.84 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.84 options.py(199):             if meta_attrs != {}:
0.84 options.py(203):         del self.meta
0.84 options.py(206):         if not self.db_table:
0.84 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.84 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.84 base.py(123):         if not abstract:
0.84 base.py(124):             new_class.add_to_class(
0.84 base.py(125):                 'DoesNotExist',
0.84 base.py(126):                 subclass_exception(
0.84 base.py(127):                     'DoesNotExist',
0.84 base.py(128):                     tuple(
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(130):                     ) or (ObjectDoesNotExist,),
0.84 base.py(131):                     module,
0.84 base.py(132):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(133):             new_class.add_to_class(
0.84 base.py(134):                 'MultipleObjectsReturned',
0.84 base.py(135):                 subclass_exception(
0.84 base.py(136):                     'MultipleObjectsReturned',
0.84 base.py(137):                     tuple(
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.84 base.py(139):                     ) or (MultipleObjectsReturned,),
0.84 base.py(140):                     module,
0.84 base.py(141):                     attached_to=new_class))
0.84 base.py(61):     return type(name, bases, {
0.84 base.py(62):         '__module__': module,
0.84 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(328):             setattr(cls, name, value)
0.84 base.py(142):             if base_meta and not base_meta.abstract:
0.84 base.py(151):         is_proxy = new_class._meta.proxy
0.84 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(298):             self.pk = field
0.84 options.py(299):             field.serialize = False
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(271):         if private:
0.84 options.py(273):         elif field.is_relation and field.many_to_many:
0.84 options.py(276):             bisect.insort(self.local_fields, field)
0.84 options.py(277):             self.setup_pk(field)
0.84 options.py(297):         if not self.pk and field.primary_key:
0.84 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.84 options.py(294):             self._expire_cache(reverse=False)
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(161):             new_class.add_to_class(obj_name, obj)
0.84 base.py(325):         if _has_contribute_to_class(value):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(326):             value.contribute_to_class(cls, name)
0.84 options.py(263):         self.local_managers.append(manager)
0.84 options.py(264):         self._expire_cache()
0.84 options.py(728):         if forward:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(730):                 if cache_key in self.__dict__:
0.84 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.84 options.py(732):         if reverse and not self.abstract:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(734):                 if cache_key in self.__dict__:
0.84 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.84 options.py(736):         self._get_fields_cache = {}
0.84 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.84 base.py(164):         new_fields = chain(
0.84 base.py(165):             new_class._meta.local_fields,
0.84 base.py(166):             new_class._meta.local_many_to_many,
0.84 base.py(167):             new_class._meta.private_fields
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(169):         field_names = {f.name for f in new_fields}
0.84 base.py(172):         if is_proxy:
0.84 base.py(192):             new_class._meta.concrete_model = new_class
0.84 base.py(195):         parent_links = {}
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(199):                 continue
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(198):             if not hasattr(base, '_meta'):
0.84 base.py(201):             if base != new_class and not base._meta.abstract:
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(205):                 if isinstance(field, OneToOneField):
0.84 base.py(204):             for field in base._meta.local_fields:
0.84 base.py(196):         for base in reversed([new_class] + parents):
0.84 base.py(210):         inherited_attributes = set()
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.84 base.py(216):                 inherited_attributes.update(base.__dict__)
0.84 base.py(217):                 continue
0.84 base.py(212):         for base in new_class.mro():
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.84 base.py(312):         if abstract:
0.84 base.py(320):         new_class._prepare()
0.84 base.py(332):         opts = cls._meta
0.84 base.py(333):         opts._prepare(cls)
0.84 options.py(223):         if self.order_with_respect_to:
0.84 options.py(239):             self.order_with_respect_to = None
0.84 options.py(241):         if self.pk is None:
0.84 base.py(335):         if opts.order_with_respect_to:
0.84 base.py(350):         if cls.__doc__ is None:
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 options.py(456):         def is_not_an_m2m_field(f):
0.84 options.py(459):         def is_not_a_generic_relation(f):
0.84 options.py(462):         def is_not_a_generic_foreign_key(f):
0.84 options.py(467):         return make_immutable_fields_list(
0.84 options.py(468):             "fields",
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.84 options.py(773):         topmost_call = seen_models is None
0.84 options.py(774):         if topmost_call:
0.84 options.py(775):             seen_models = set()
0.84 options.py(776):         seen_models.add(self.model)
0.84 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.84 options.py(781):         try:
0.84 options.py(784):             return self._get_fields_cache[cache_key]
0.84 options.py(785):         except KeyError:
0.84 options.py(786):             pass
0.84 options.py(788):         fields = []
0.84 options.py(791):         if include_parents is not False:
0.84 options.py(792):             for parent in self.parents:
0.84 options.py(806):         if reverse and not self.proxy:
0.84 options.py(817):         if forward:
0.84 options.py(818):             fields += self.local_fields
0.84 options.py(819):             fields += self.local_many_to_many
0.84 options.py(825):             if topmost_call:
0.84 options.py(826):                 fields += self.private_fields
0.84 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(833):         self._get_fields_cache[cache_key] = fields
0.84 options.py(834):         return fields
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.84 options.py(457):             return not (f.is_relation and f.many_to_many)
0.84 options.py(460):             return not (f.is_relation and f.one_to_many)
0.84 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.84 options.py(469):             (f for f in self._get_fields(reverse=False)
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.84 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.84 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.84 base.py(354):         if get_absolute_url_override:
0.84 base.py(357):         if not opts.managers:
0.84 options.py(365):         managers = []
0.84 options.py(366):         seen_managers = set()
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(370):                 if manager.name in seen_managers:
0.84 options.py(373):                 manager = copy.copy(manager)
0.84 options.py(374):                 manager.model = self.model
0.84 options.py(375):                 seen_managers.add(manager.name)
0.84 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.84 options.py(369):             for manager in base._meta.local_managers:
0.84 options.py(368):         for depth, base in enumerate(bases):
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.84 options.py(378):         return make_immutable_fields_list(
0.84 options.py(379):             "managers",
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 options.py(380):             (m[2] for m in sorted(managers)),
0.84 base.py(370):         for index in cls._meta.indexes:
0.84 base.py(374):         class_prepared.send(sender=cls)
0.84 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.84 base.py(322):         return new_class
0.84 base.py(75):         super_new = super().__new__
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.84 base.py(80):         if not parents:
0.84 base.py(84):         module = attrs.pop('__module__')
0.84 base.py(85):         new_attrs = {'__module__': module}
0.84 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.84 base.py(87):         if classcell is not None:
0.84 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.84 base.py(93):         contributable_attrs = {}
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.84 base.py(95):             if _has_contribute_to_class(obj):
0.84 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.84 base.py(96):                 contributable_attrs[obj_name] = obj
0.84 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.85 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.85 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.85 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.85 base.py(105):         app_label = None
0.85 base.py(108):         app_config = apps.get_containing_app_config(module)
0.85 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.85 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.85 options.py(76):         self._get_fields_cache = {}
0.85 options.py(77):         self.local_fields = []
0.85 options.py(78):         self.local_many_to_many = []
0.85 options.py(79):         self.private_fields = []
0.85 options.py(80):         self.local_managers = []
0.85 options.py(81):         self.base_manager_name = None
0.85 options.py(82):         self.default_manager_name = None
0.85 options.py(83):         self.model_name = None
0.85 options.py(84):         self.verbose_name = None
0.85 options.py(85):         self.verbose_name_plural = None
0.85 options.py(86):         self.db_table = ''
0.85 options.py(87):         self.ordering = []
0.85 options.py(88):         self._ordering_clash = False
0.85 options.py(89):         self.indexes = []
0.85 options.py(90):         self.constraints = []
0.85 options.py(91):         self.unique_together = []
0.85 options.py(92):         self.index_together = []
0.85 options.py(93):         self.select_on_save = False
0.85 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.85 options.py(95):         self.permissions = []
0.85 options.py(96):         self.object_name = None
0.85 options.py(97):         self.app_label = app_label
0.85 options.py(98):         self.get_latest_by = None
0.85 options.py(99):         self.order_with_respect_to = None
0.85 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.85 options.py(101):         self.required_db_features = []
0.85 options.py(102):         self.required_db_vendor = None
0.85 options.py(103):         self.meta = meta
0.85 options.py(104):         self.pk = None
0.85 options.py(105):         self.auto_field = None
0.85 options.py(106):         self.abstract = False
0.85 options.py(107):         self.managed = True
0.85 options.py(108):         self.proxy = False
0.85 options.py(114):         self.proxy_for_model = None
0.85 options.py(118):         self.concrete_model = None
0.85 options.py(119):         self.swappable = None
0.85 options.py(120):         self.parents = {}
0.85 options.py(121):         self.auto_created = False
0.85 options.py(125):         self.related_fkey_lookups = []
0.85 options.py(128):         self.apps = self.default_apps
0.85 options.py(130):         self.default_related_name = None
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(150):         from django.db import connection
0.85 options.py(151):         from django.db.backends.utils import truncate_name
0.85 options.py(153):         cls._meta = self
0.85 options.py(154):         self.model = cls
0.85 options.py(156):         self.object_name = cls.__name__
0.85 options.py(157):         self.model_name = self.object_name.lower()
0.85 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.85 options.py(162):         self.original_attrs = {}
0.85 options.py(165):         if self.meta:
0.85 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(182):             self.index_together = normalize_together(self.index_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(192):             if self.verbose_name_plural is None:
0.85 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.85 options.py(199):             if meta_attrs != {}:
0.85 options.py(203):         del self.meta
0.85 options.py(206):         if not self.db_table:
0.85 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.85 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.85 base.py(123):         if not abstract:
0.85 base.py(124):             new_class.add_to_class(
0.85 base.py(125):                 'DoesNotExist',
0.85 base.py(126):                 subclass_exception(
0.85 base.py(127):                     'DoesNotExist',
0.85 base.py(128):                     tuple(
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(130):                     ) or (ObjectDoesNotExist,),
0.85 base.py(131):                     module,
0.85 base.py(132):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(133):             new_class.add_to_class(
0.85 base.py(134):                 'MultipleObjectsReturned',
0.85 base.py(135):                 subclass_exception(
0.85 base.py(136):                     'MultipleObjectsReturned',
0.85 base.py(137):                     tuple(
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(139):                     ) or (MultipleObjectsReturned,),
0.85 base.py(140):                     module,
0.85 base.py(141):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(142):             if base_meta and not base_meta.abstract:
0.85 base.py(151):         is_proxy = new_class._meta.proxy
0.85 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(298):             self.pk = field
0.85 options.py(299):             field.serialize = False
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(263):         self.local_managers.append(manager)
0.85 options.py(264):         self._expire_cache()
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(164):         new_fields = chain(
0.85 base.py(165):             new_class._meta.local_fields,
0.85 base.py(166):             new_class._meta.local_many_to_many,
0.85 base.py(167):             new_class._meta.private_fields
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(172):         if is_proxy:
0.85 base.py(192):             new_class._meta.concrete_model = new_class
0.85 base.py(195):         parent_links = {}
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(199):                 continue
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(201):             if base != new_class and not base._meta.abstract:
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(210):         inherited_attributes = set()
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(312):         if abstract:
0.85 base.py(320):         new_class._prepare()
0.85 base.py(332):         opts = cls._meta
0.85 base.py(333):         opts._prepare(cls)
0.85 options.py(223):         if self.order_with_respect_to:
0.85 options.py(239):             self.order_with_respect_to = None
0.85 options.py(241):         if self.pk is None:
0.85 base.py(335):         if opts.order_with_respect_to:
0.85 base.py(350):         if cls.__doc__ is None:
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 options.py(456):         def is_not_an_m2m_field(f):
0.85 options.py(459):         def is_not_a_generic_relation(f):
0.85 options.py(462):         def is_not_a_generic_foreign_key(f):
0.85 options.py(467):         return make_immutable_fields_list(
0.85 options.py(468):             "fields",
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.85 options.py(773):         topmost_call = seen_models is None
0.85 options.py(774):         if topmost_call:
0.85 options.py(775):             seen_models = set()
0.85 options.py(776):         seen_models.add(self.model)
0.85 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.85 options.py(781):         try:
0.85 options.py(784):             return self._get_fields_cache[cache_key]
0.85 options.py(785):         except KeyError:
0.85 options.py(786):             pass
0.85 options.py(788):         fields = []
0.85 options.py(791):         if include_parents is not False:
0.85 options.py(792):             for parent in self.parents:
0.85 options.py(806):         if reverse and not self.proxy:
0.85 options.py(817):         if forward:
0.85 options.py(818):             fields += self.local_fields
0.85 options.py(819):             fields += self.local_many_to_many
0.85 options.py(825):             if topmost_call:
0.85 options.py(826):                 fields += self.private_fields
0.85 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(833):         self._get_fields_cache[cache_key] = fields
0.85 options.py(834):         return fields
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.85 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.85 base.py(354):         if get_absolute_url_override:
0.85 base.py(357):         if not opts.managers:
0.85 options.py(365):         managers = []
0.85 options.py(366):         seen_managers = set()
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(370):                 if manager.name in seen_managers:
0.85 options.py(373):                 manager = copy.copy(manager)
0.85 options.py(374):                 manager.model = self.model
0.85 options.py(375):                 seen_managers.add(manager.name)
0.85 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(378):         return make_immutable_fields_list(
0.85 options.py(379):             "managers",
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 base.py(370):         for index in cls._meta.indexes:
0.85 base.py(374):         class_prepared.send(sender=cls)
0.85 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 base.py(322):         return new_class
0.85 base.py(75):         super_new = super().__new__
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(80):         if not parents:
0.85 base.py(84):         module = attrs.pop('__module__')
0.85 base.py(85):         new_attrs = {'__module__': module}
0.85 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.85 base.py(87):         if classcell is not None:
0.85 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.85 base.py(93):         contributable_attrs = {}
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.85 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.85 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.85 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.85 base.py(105):         app_label = None
0.85 base.py(108):         app_config = apps.get_containing_app_config(module)
0.85 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.85 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.85 options.py(76):         self._get_fields_cache = {}
0.85 options.py(77):         self.local_fields = []
0.85 options.py(78):         self.local_many_to_many = []
0.85 options.py(79):         self.private_fields = []
0.85 options.py(80):         self.local_managers = []
0.85 options.py(81):         self.base_manager_name = None
0.85 options.py(82):         self.default_manager_name = None
0.85 options.py(83):         self.model_name = None
0.85 options.py(84):         self.verbose_name = None
0.85 options.py(85):         self.verbose_name_plural = None
0.85 options.py(86):         self.db_table = ''
0.85 options.py(87):         self.ordering = []
0.85 options.py(88):         self._ordering_clash = False
0.85 options.py(89):         self.indexes = []
0.85 options.py(90):         self.constraints = []
0.85 options.py(91):         self.unique_together = []
0.85 options.py(92):         self.index_together = []
0.85 options.py(93):         self.select_on_save = False
0.85 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.85 options.py(95):         self.permissions = []
0.85 options.py(96):         self.object_name = None
0.85 options.py(97):         self.app_label = app_label
0.85 options.py(98):         self.get_latest_by = None
0.85 options.py(99):         self.order_with_respect_to = None
0.85 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.85 options.py(101):         self.required_db_features = []
0.85 options.py(102):         self.required_db_vendor = None
0.85 options.py(103):         self.meta = meta
0.85 options.py(104):         self.pk = None
0.85 options.py(105):         self.auto_field = None
0.85 options.py(106):         self.abstract = False
0.85 options.py(107):         self.managed = True
0.85 options.py(108):         self.proxy = False
0.85 options.py(114):         self.proxy_for_model = None
0.85 options.py(118):         self.concrete_model = None
0.85 options.py(119):         self.swappable = None
0.85 options.py(120):         self.parents = {}
0.85 options.py(121):         self.auto_created = False
0.85 options.py(125):         self.related_fkey_lookups = []
0.85 options.py(128):         self.apps = self.default_apps
0.85 options.py(130):         self.default_related_name = None
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(150):         from django.db import connection
0.85 options.py(151):         from django.db.backends.utils import truncate_name
0.85 options.py(153):         cls._meta = self
0.85 options.py(154):         self.model = cls
0.85 options.py(156):         self.object_name = cls.__name__
0.85 options.py(157):         self.model_name = self.object_name.lower()
0.85 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.85 options.py(162):         self.original_attrs = {}
0.85 options.py(165):         if self.meta:
0.85 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(182):             self.index_together = normalize_together(self.index_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(192):             if self.verbose_name_plural is None:
0.85 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.85 options.py(199):             if meta_attrs != {}:
0.85 options.py(203):         del self.meta
0.85 options.py(206):         if not self.db_table:
0.85 base.py(123):         if not abstract:
0.85 base.py(124):             new_class.add_to_class(
0.85 base.py(125):                 'DoesNotExist',
0.85 base.py(126):                 subclass_exception(
0.85 base.py(127):                     'DoesNotExist',
0.85 base.py(128):                     tuple(
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(130):                     ) or (ObjectDoesNotExist,),
0.85 base.py(131):                     module,
0.85 base.py(132):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(133):             new_class.add_to_class(
0.85 base.py(134):                 'MultipleObjectsReturned',
0.85 base.py(135):                 subclass_exception(
0.85 base.py(136):                     'MultipleObjectsReturned',
0.85 base.py(137):                     tuple(
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(139):                     ) or (MultipleObjectsReturned,),
0.85 base.py(140):                     module,
0.85 base.py(141):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(142):             if base_meta and not base_meta.abstract:
0.85 base.py(151):         is_proxy = new_class._meta.proxy
0.85 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(298):             self.pk = field
0.85 options.py(299):             field.serialize = False
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(263):         self.local_managers.append(manager)
0.85 options.py(264):         self._expire_cache()
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(164):         new_fields = chain(
0.85 base.py(165):             new_class._meta.local_fields,
0.85 base.py(166):             new_class._meta.local_many_to_many,
0.85 base.py(167):             new_class._meta.private_fields
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(172):         if is_proxy:
0.85 base.py(192):             new_class._meta.concrete_model = new_class
0.85 base.py(195):         parent_links = {}
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(199):                 continue
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(201):             if base != new_class and not base._meta.abstract:
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(210):         inherited_attributes = set()
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(312):         if abstract:
0.85 base.py(320):         new_class._prepare()
0.85 base.py(332):         opts = cls._meta
0.85 base.py(333):         opts._prepare(cls)
0.85 options.py(223):         if self.order_with_respect_to:
0.85 options.py(239):             self.order_with_respect_to = None
0.85 options.py(241):         if self.pk is None:
0.85 base.py(335):         if opts.order_with_respect_to:
0.85 base.py(350):         if cls.__doc__ is None:
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 options.py(456):         def is_not_an_m2m_field(f):
0.85 options.py(459):         def is_not_a_generic_relation(f):
0.85 options.py(462):         def is_not_a_generic_foreign_key(f):
0.85 options.py(467):         return make_immutable_fields_list(
0.85 options.py(468):             "fields",
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.85 options.py(773):         topmost_call = seen_models is None
0.85 options.py(774):         if topmost_call:
0.85 options.py(775):             seen_models = set()
0.85 options.py(776):         seen_models.add(self.model)
0.85 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.85 options.py(781):         try:
0.85 options.py(784):             return self._get_fields_cache[cache_key]
0.85 options.py(785):         except KeyError:
0.85 options.py(786):             pass
0.85 options.py(788):         fields = []
0.85 options.py(791):         if include_parents is not False:
0.85 options.py(792):             for parent in self.parents:
0.85 options.py(806):         if reverse and not self.proxy:
0.85 options.py(817):         if forward:
0.85 options.py(818):             fields += self.local_fields
0.85 options.py(819):             fields += self.local_many_to_many
0.85 options.py(825):             if topmost_call:
0.85 options.py(826):                 fields += self.private_fields
0.85 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(833):         self._get_fields_cache[cache_key] = fields
0.85 options.py(834):         return fields
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.85 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.85 base.py(354):         if get_absolute_url_override:
0.85 base.py(357):         if not opts.managers:
0.85 options.py(365):         managers = []
0.85 options.py(366):         seen_managers = set()
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(370):                 if manager.name in seen_managers:
0.85 options.py(373):                 manager = copy.copy(manager)
0.85 options.py(374):                 manager.model = self.model
0.85 options.py(375):                 seen_managers.add(manager.name)
0.85 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(378):         return make_immutable_fields_list(
0.85 options.py(379):             "managers",
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 base.py(370):         for index in cls._meta.indexes:
0.85 base.py(374):         class_prepared.send(sender=cls)
0.85 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.85 base.py(322):         return new_class
0.85 base.py(75):         super_new = super().__new__
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.85 base.py(80):         if not parents:
0.85 base.py(84):         module = attrs.pop('__module__')
0.85 base.py(85):         new_attrs = {'__module__': module}
0.85 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.85 base.py(87):         if classcell is not None:
0.85 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.85 base.py(93):         contributable_attrs = {}
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(95):             if _has_contribute_to_class(obj):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(96):                 contributable_attrs[obj_name] = obj
0.85 base.py(94):         for obj_name, obj in list(attrs.items()):
0.85 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.85 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.85 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.85 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.85 base.py(105):         app_label = None
0.85 base.py(108):         app_config = apps.get_containing_app_config(module)
0.85 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.85 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.85 options.py(76):         self._get_fields_cache = {}
0.85 options.py(77):         self.local_fields = []
0.85 options.py(78):         self.local_many_to_many = []
0.85 options.py(79):         self.private_fields = []
0.85 options.py(80):         self.local_managers = []
0.85 options.py(81):         self.base_manager_name = None
0.85 options.py(82):         self.default_manager_name = None
0.85 options.py(83):         self.model_name = None
0.85 options.py(84):         self.verbose_name = None
0.85 options.py(85):         self.verbose_name_plural = None
0.85 options.py(86):         self.db_table = ''
0.85 options.py(87):         self.ordering = []
0.85 options.py(88):         self._ordering_clash = False
0.85 options.py(89):         self.indexes = []
0.85 options.py(90):         self.constraints = []
0.85 options.py(91):         self.unique_together = []
0.85 options.py(92):         self.index_together = []
0.85 options.py(93):         self.select_on_save = False
0.85 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.85 options.py(95):         self.permissions = []
0.85 options.py(96):         self.object_name = None
0.85 options.py(97):         self.app_label = app_label
0.85 options.py(98):         self.get_latest_by = None
0.85 options.py(99):         self.order_with_respect_to = None
0.85 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.85 options.py(101):         self.required_db_features = []
0.85 options.py(102):         self.required_db_vendor = None
0.85 options.py(103):         self.meta = meta
0.85 options.py(104):         self.pk = None
0.85 options.py(105):         self.auto_field = None
0.85 options.py(106):         self.abstract = False
0.85 options.py(107):         self.managed = True
0.85 options.py(108):         self.proxy = False
0.85 options.py(114):         self.proxy_for_model = None
0.85 options.py(118):         self.concrete_model = None
0.85 options.py(119):         self.swappable = None
0.85 options.py(120):         self.parents = {}
0.85 options.py(121):         self.auto_created = False
0.85 options.py(125):         self.related_fkey_lookups = []
0.85 options.py(128):         self.apps = self.default_apps
0.85 options.py(130):         self.default_related_name = None
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(150):         from django.db import connection
0.85 options.py(151):         from django.db.backends.utils import truncate_name
0.85 options.py(153):         cls._meta = self
0.85 options.py(154):         self.model = cls
0.85 options.py(156):         self.object_name = cls.__name__
0.85 options.py(157):         self.model_name = self.object_name.lower()
0.85 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.85 options.py(162):         self.original_attrs = {}
0.85 options.py(165):         if self.meta:
0.85 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(171):                 if name.startswith('_'):
0.85 options.py(172):                     del meta_attrs[name]
0.85 options.py(167):             for name in self.meta.__dict__:
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(177):                 elif hasattr(self.meta, attr_name):
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(174):                 if attr_name in meta_attrs:
0.85 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.85 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.85 options.py(173):             for attr_name in DEFAULT_NAMES:
0.85 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(182):             self.index_together = normalize_together(self.index_together)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(47):             return ()
0.85 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(187):                     objs = getattr(self, attr_name, [])
0.85 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.85 options.py(212):         new_objs = []
0.85 options.py(213):         for obj in objs:
0.85 options.py(220):         return new_objs
0.85 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.85 options.py(192):             if self.verbose_name_plural is None:
0.85 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.85 options.py(199):             if meta_attrs != {}:
0.85 options.py(203):         del self.meta
0.85 options.py(206):         if not self.db_table:
0.85 base.py(123):         if not abstract:
0.85 base.py(124):             new_class.add_to_class(
0.85 base.py(125):                 'DoesNotExist',
0.85 base.py(126):                 subclass_exception(
0.85 base.py(127):                     'DoesNotExist',
0.85 base.py(128):                     tuple(
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(130):                     ) or (ObjectDoesNotExist,),
0.85 base.py(131):                     module,
0.85 base.py(132):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(133):             new_class.add_to_class(
0.85 base.py(134):                 'MultipleObjectsReturned',
0.85 base.py(135):                 subclass_exception(
0.85 base.py(136):                     'MultipleObjectsReturned',
0.85 base.py(137):                     tuple(
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.85 base.py(139):                     ) or (MultipleObjectsReturned,),
0.85 base.py(140):                     module,
0.85 base.py(141):                     attached_to=new_class))
0.85 base.py(61):     return type(name, bases, {
0.85 base.py(62):         '__module__': module,
0.85 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(328):             setattr(cls, name, value)
0.85 base.py(142):             if base_meta and not base_meta.abstract:
0.85 base.py(151):         is_proxy = new_class._meta.proxy
0.85 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(298):             self.pk = field
0.85 options.py(299):             field.serialize = False
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(271):         if private:
0.85 options.py(273):         elif field.is_relation and field.many_to_many:
0.85 options.py(276):             bisect.insort(self.local_fields, field)
0.85 options.py(277):             self.setup_pk(field)
0.85 options.py(297):         if not self.pk and field.primary_key:
0.85 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.85 options.py(294):             self._expire_cache(reverse=False)
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(161):             new_class.add_to_class(obj_name, obj)
0.85 base.py(325):         if _has_contribute_to_class(value):
0.85 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.85 base.py(326):             value.contribute_to_class(cls, name)
0.85 options.py(263):         self.local_managers.append(manager)
0.85 options.py(264):         self._expire_cache()
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.85 base.py(164):         new_fields = chain(
0.85 base.py(165):             new_class._meta.local_fields,
0.85 base.py(166):             new_class._meta.local_many_to_many,
0.85 base.py(167):             new_class._meta.private_fields
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(169):         field_names = {f.name for f in new_fields}
0.85 base.py(172):         if is_proxy:
0.85 base.py(192):             new_class._meta.concrete_model = new_class
0.85 base.py(195):         parent_links = {}
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(199):                 continue
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(198):             if not hasattr(base, '_meta'):
0.85 base.py(201):             if base != new_class and not base._meta.abstract:
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(205):                 if isinstance(field, OneToOneField):
0.85 base.py(204):             for field in base._meta.local_fields:
0.85 base.py(196):         for base in reversed([new_class] + parents):
0.85 base.py(210):         inherited_attributes = set()
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.85 base.py(216):                 inherited_attributes.update(base.__dict__)
0.85 base.py(217):                 continue
0.85 base.py(212):         for base in new_class.mro():
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.85 base.py(312):         if abstract:
0.85 base.py(320):         new_class._prepare()
0.85 base.py(332):         opts = cls._meta
0.85 base.py(333):         opts._prepare(cls)
0.85 options.py(223):         if self.order_with_respect_to:
0.85 options.py(239):             self.order_with_respect_to = None
0.85 options.py(241):         if self.pk is None:
0.85 base.py(335):         if opts.order_with_respect_to:
0.85 base.py(350):         if cls.__doc__ is None:
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 options.py(456):         def is_not_an_m2m_field(f):
0.85 options.py(459):         def is_not_a_generic_relation(f):
0.85 options.py(462):         def is_not_a_generic_foreign_key(f):
0.85 options.py(467):         return make_immutable_fields_list(
0.85 options.py(468):             "fields",
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.85 options.py(773):         topmost_call = seen_models is None
0.85 options.py(774):         if topmost_call:
0.85 options.py(775):             seen_models = set()
0.85 options.py(776):         seen_models.add(self.model)
0.85 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.85 options.py(781):         try:
0.85 options.py(784):             return self._get_fields_cache[cache_key]
0.85 options.py(785):         except KeyError:
0.85 options.py(786):             pass
0.85 options.py(788):         fields = []
0.85 options.py(791):         if include_parents is not False:
0.85 options.py(792):             for parent in self.parents:
0.85 options.py(806):         if reverse and not self.proxy:
0.85 options.py(817):         if forward:
0.85 options.py(818):             fields += self.local_fields
0.85 options.py(819):             fields += self.local_many_to_many
0.85 options.py(825):             if topmost_call:
0.85 options.py(826):                 fields += self.private_fields
0.85 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(833):         self._get_fields_cache[cache_key] = fields
0.85 options.py(834):         return fields
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.85 options.py(457):             return not (f.is_relation and f.many_to_many)
0.85 options.py(460):             return not (f.is_relation and f.one_to_many)
0.85 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.85 options.py(469):             (f for f in self._get_fields(reverse=False)
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.85 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.85 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.85 base.py(354):         if get_absolute_url_override:
0.85 base.py(357):         if not opts.managers:
0.85 options.py(365):         managers = []
0.85 options.py(366):         seen_managers = set()
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(370):                 if manager.name in seen_managers:
0.85 options.py(373):                 manager = copy.copy(manager)
0.85 options.py(374):                 manager.model = self.model
0.85 options.py(375):                 seen_managers.add(manager.name)
0.85 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.85 options.py(369):             for manager in base._meta.local_managers:
0.85 options.py(368):         for depth, base in enumerate(bases):
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.85 options.py(378):         return make_immutable_fields_list(
0.85 options.py(379):             "managers",
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 options.py(380):             (m[2] for m in sorted(managers)),
0.85 base.py(370):         for index in cls._meta.indexes:
0.85 base.py(374):         class_prepared.send(sender=cls)
0.85 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 base.py(322):         return new_class
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.85 options.py(349):             if swapped_for:
0.85 options.py(350):                 try:
0.85 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.85 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.85 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(731):                     delattr(self, cache_key)
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(347):         if self.swappable:
0.85 options.py(361):         return None
0.85 options.py(728):         if forward:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(730):                 if cache_key in self.__dict__:
0.85 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.85 options.py(732):         if reverse and not self.abstract:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(734):                 if cache_key in self.__dict__:
0.85 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.85 options.py(736):         self._get_fields_cache = {}
0.85 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.85 options.py(45):     try:
0.85 options.py(46):         if not option_together:
0.85 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.85 options.py(50):         first_element = option_together[0]
0.85 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.85 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.85 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.85 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.86 options.py(349):             if swapped_for:
0.86 options.py(350):                 try:
0.86 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.86 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.86 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.86 options.py(349):             if swapped_for:
0.86 options.py(350):                 try:
0.86 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.86 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.86 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.86 options.py(361):         return None
0.86 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.86 options.py(349):             if swapped_for:
0.86 options.py(350):                 try:
0.86 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.86 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.86 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.86 options.py(361):         return None
0.86 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.86 options.py(50):         first_element = option_together[0]
0.86 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 base.py(75):         super_new = super().__new__
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(80):         if not parents:
0.86 base.py(84):         module = attrs.pop('__module__')
0.86 base.py(85):         new_attrs = {'__module__': module}
0.86 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.86 base.py(87):         if classcell is not None:
0.86 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.86 base.py(93):         contributable_attrs = {}
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.86 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.86 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.86 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.86 base.py(105):         app_label = None
0.86 base.py(108):         app_config = apps.get_containing_app_config(module)
0.86 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.86 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.86 options.py(76):         self._get_fields_cache = {}
0.86 options.py(77):         self.local_fields = []
0.86 options.py(78):         self.local_many_to_many = []
0.86 options.py(79):         self.private_fields = []
0.86 options.py(80):         self.local_managers = []
0.86 options.py(81):         self.base_manager_name = None
0.86 options.py(82):         self.default_manager_name = None
0.86 options.py(83):         self.model_name = None
0.86 options.py(84):         self.verbose_name = None
0.86 options.py(85):         self.verbose_name_plural = None
0.86 options.py(86):         self.db_table = ''
0.86 options.py(87):         self.ordering = []
0.86 options.py(88):         self._ordering_clash = False
0.86 options.py(89):         self.indexes = []
0.86 options.py(90):         self.constraints = []
0.86 options.py(91):         self.unique_together = []
0.86 options.py(92):         self.index_together = []
0.86 options.py(93):         self.select_on_save = False
0.86 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.86 options.py(95):         self.permissions = []
0.86 options.py(96):         self.object_name = None
0.86 options.py(97):         self.app_label = app_label
0.86 options.py(98):         self.get_latest_by = None
0.86 options.py(99):         self.order_with_respect_to = None
0.86 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.86 options.py(101):         self.required_db_features = []
0.86 options.py(102):         self.required_db_vendor = None
0.86 options.py(103):         self.meta = meta
0.86 options.py(104):         self.pk = None
0.86 options.py(105):         self.auto_field = None
0.86 options.py(106):         self.abstract = False
0.86 options.py(107):         self.managed = True
0.86 options.py(108):         self.proxy = False
0.86 options.py(114):         self.proxy_for_model = None
0.86 options.py(118):         self.concrete_model = None
0.86 options.py(119):         self.swappable = None
0.86 options.py(120):         self.parents = {}
0.86 options.py(121):         self.auto_created = False
0.86 options.py(125):         self.related_fkey_lookups = []
0.86 options.py(128):         self.apps = self.default_apps
0.86 options.py(130):         self.default_related_name = None
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(150):         from django.db import connection
0.86 options.py(151):         from django.db.backends.utils import truncate_name
0.86 options.py(153):         cls._meta = self
0.86 options.py(154):         self.model = cls
0.86 options.py(156):         self.object_name = cls.__name__
0.86 options.py(157):         self.model_name = self.object_name.lower()
0.86 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.86 options.py(162):         self.original_attrs = {}
0.86 options.py(165):         if self.meta:
0.86 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.86 options.py(49):             raise TypeError
0.86 options.py(55):     except TypeError:
0.86 options.py(58):         return option_together
0.86 options.py(182):             self.index_together = normalize_together(self.index_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(47):             return ()
0.86 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(192):             if self.verbose_name_plural is None:
0.86 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.86 options.py(199):             if meta_attrs != {}:
0.86 options.py(203):         del self.meta
0.86 options.py(206):         if not self.db_table:
0.86 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.86 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.86 base.py(123):         if not abstract:
0.86 base.py(124):             new_class.add_to_class(
0.86 base.py(125):                 'DoesNotExist',
0.86 base.py(126):                 subclass_exception(
0.86 base.py(127):                     'DoesNotExist',
0.86 base.py(128):                     tuple(
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(130):                     ) or (ObjectDoesNotExist,),
0.86 base.py(131):                     module,
0.86 base.py(132):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(133):             new_class.add_to_class(
0.86 base.py(134):                 'MultipleObjectsReturned',
0.86 base.py(135):                 subclass_exception(
0.86 base.py(136):                     'MultipleObjectsReturned',
0.86 base.py(137):                     tuple(
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(139):                     ) or (MultipleObjectsReturned,),
0.86 base.py(140):                     module,
0.86 base.py(141):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(142):             if base_meta and not base_meta.abstract:
0.86 base.py(151):         is_proxy = new_class._meta.proxy
0.86 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(298):             self.pk = field
0.86 options.py(299):             field.serialize = False
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(288):             try:
0.86 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.86 options.py(290):             except AttributeError:
0.86 options.py(291):                 pass
0.86 options.py(292):             self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(263):         self.local_managers.append(manager)
0.86 options.py(264):         self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(164):         new_fields = chain(
0.86 base.py(165):             new_class._meta.local_fields,
0.86 base.py(166):             new_class._meta.local_many_to_many,
0.86 base.py(167):             new_class._meta.private_fields
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(172):         if is_proxy:
0.86 base.py(192):             new_class._meta.concrete_model = new_class
0.86 base.py(195):         parent_links = {}
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(199):                 continue
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(201):             if base != new_class and not base._meta.abstract:
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(210):         inherited_attributes = set()
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.86 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.86 base.py(312):         if abstract:
0.86 base.py(320):         new_class._prepare()
0.86 base.py(332):         opts = cls._meta
0.86 base.py(333):         opts._prepare(cls)
0.86 options.py(223):         if self.order_with_respect_to:
0.86 options.py(239):             self.order_with_respect_to = None
0.86 options.py(241):         if self.pk is None:
0.86 base.py(335):         if opts.order_with_respect_to:
0.86 base.py(350):         if cls.__doc__ is None:
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 options.py(456):         def is_not_an_m2m_field(f):
0.86 options.py(459):         def is_not_a_generic_relation(f):
0.86 options.py(462):         def is_not_a_generic_foreign_key(f):
0.86 options.py(467):         return make_immutable_fields_list(
0.86 options.py(468):             "fields",
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.86 options.py(773):         topmost_call = seen_models is None
0.86 options.py(774):         if topmost_call:
0.86 options.py(775):             seen_models = set()
0.86 options.py(776):         seen_models.add(self.model)
0.86 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.86 options.py(781):         try:
0.86 options.py(784):             return self._get_fields_cache[cache_key]
0.86 options.py(785):         except KeyError:
0.86 options.py(786):             pass
0.86 options.py(788):         fields = []
0.86 options.py(791):         if include_parents is not False:
0.86 options.py(792):             for parent in self.parents:
0.86 options.py(806):         if reverse and not self.proxy:
0.86 options.py(817):         if forward:
0.86 options.py(818):             fields += self.local_fields
0.86 options.py(819):             fields += self.local_many_to_many
0.86 options.py(825):             if topmost_call:
0.86 options.py(826):                 fields += self.private_fields
0.86 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(833):         self._get_fields_cache[cache_key] = fields
0.86 options.py(834):         return fields
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.86 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.86 base.py(354):         if get_absolute_url_override:
0.86 base.py(357):         if not opts.managers:
0.86 options.py(365):         managers = []
0.86 options.py(366):         seen_managers = set()
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(368):         for depth, base in enumerate(bases):
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(369):             for manager in base._meta.local_managers:
0.86 options.py(370):                 if manager.name in seen_managers:
0.86 options.py(373):                 manager = copy.copy(manager)
0.86 options.py(374):                 manager.model = self.model
0.86 options.py(375):                 seen_managers.add(manager.name)
0.86 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.86 options.py(369):             for manager in base._meta.local_managers:
0.86 options.py(368):         for depth, base in enumerate(bases):
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(378):         return make_immutable_fields_list(
0.86 options.py(379):             "managers",
0.86 options.py(380):             (m[2] for m in sorted(managers)),
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(380):             (m[2] for m in sorted(managers)),
0.86 options.py(380):             (m[2] for m in sorted(managers)),
0.86 base.py(370):         for index in cls._meta.indexes:
0.86 base.py(374):         class_prepared.send(sender=cls)
0.86 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.86 base.py(322):         return new_class
0.86 base.py(75):         super_new = super().__new__
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(80):         if not parents:
0.86 base.py(84):         module = attrs.pop('__module__')
0.86 base.py(85):         new_attrs = {'__module__': module}
0.86 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.86 base.py(87):         if classcell is not None:
0.86 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.86 base.py(93):         contributable_attrs = {}
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.86 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.86 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.86 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.86 base.py(105):         app_label = None
0.86 base.py(108):         app_config = apps.get_containing_app_config(module)
0.86 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.86 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.86 options.py(76):         self._get_fields_cache = {}
0.86 options.py(77):         self.local_fields = []
0.86 options.py(78):         self.local_many_to_many = []
0.86 options.py(79):         self.private_fields = []
0.86 options.py(80):         self.local_managers = []
0.86 options.py(81):         self.base_manager_name = None
0.86 options.py(82):         self.default_manager_name = None
0.86 options.py(83):         self.model_name = None
0.86 options.py(84):         self.verbose_name = None
0.86 options.py(85):         self.verbose_name_plural = None
0.86 options.py(86):         self.db_table = ''
0.86 options.py(87):         self.ordering = []
0.86 options.py(88):         self._ordering_clash = False
0.86 options.py(89):         self.indexes = []
0.86 options.py(90):         self.constraints = []
0.86 options.py(91):         self.unique_together = []
0.86 options.py(92):         self.index_together = []
0.86 options.py(93):         self.select_on_save = False
0.86 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.86 options.py(95):         self.permissions = []
0.86 options.py(96):         self.object_name = None
0.86 options.py(97):         self.app_label = app_label
0.86 options.py(98):         self.get_latest_by = None
0.86 options.py(99):         self.order_with_respect_to = None
0.86 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.86 options.py(101):         self.required_db_features = []
0.86 options.py(102):         self.required_db_vendor = None
0.86 options.py(103):         self.meta = meta
0.86 options.py(104):         self.pk = None
0.86 options.py(105):         self.auto_field = None
0.86 options.py(106):         self.abstract = False
0.86 options.py(107):         self.managed = True
0.86 options.py(108):         self.proxy = False
0.86 options.py(114):         self.proxy_for_model = None
0.86 options.py(118):         self.concrete_model = None
0.86 options.py(119):         self.swappable = None
0.86 options.py(120):         self.parents = {}
0.86 options.py(121):         self.auto_created = False
0.86 options.py(125):         self.related_fkey_lookups = []
0.86 options.py(128):         self.apps = self.default_apps
0.86 options.py(130):         self.default_related_name = None
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(150):         from django.db import connection
0.86 options.py(151):         from django.db.backends.utils import truncate_name
0.86 options.py(153):         cls._meta = self
0.86 options.py(154):         self.model = cls
0.86 options.py(156):         self.object_name = cls.__name__
0.86 options.py(157):         self.model_name = self.object_name.lower()
0.86 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.86 options.py(162):         self.original_attrs = {}
0.86 options.py(165):         if self.meta:
0.86 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(47):             return ()
0.86 options.py(182):             self.index_together = normalize_together(self.index_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(47):             return ()
0.86 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(192):             if self.verbose_name_plural is None:
0.86 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.86 options.py(199):             if meta_attrs != {}:
0.86 options.py(203):         del self.meta
0.86 options.py(206):         if not self.db_table:
0.86 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.86 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.86 base.py(123):         if not abstract:
0.86 base.py(124):             new_class.add_to_class(
0.86 base.py(125):                 'DoesNotExist',
0.86 base.py(126):                 subclass_exception(
0.86 base.py(127):                     'DoesNotExist',
0.86 base.py(128):                     tuple(
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(130):                     ) or (ObjectDoesNotExist,),
0.86 base.py(131):                     module,
0.86 base.py(132):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(133):             new_class.add_to_class(
0.86 base.py(134):                 'MultipleObjectsReturned',
0.86 base.py(135):                 subclass_exception(
0.86 base.py(136):                     'MultipleObjectsReturned',
0.86 base.py(137):                     tuple(
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(139):                     ) or (MultipleObjectsReturned,),
0.86 base.py(140):                     module,
0.86 base.py(141):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(142):             if base_meta and not base_meta.abstract:
0.86 base.py(151):         is_proxy = new_class._meta.proxy
0.86 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(298):             self.pk = field
0.86 options.py(299):             field.serialize = False
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(288):             try:
0.86 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.86 options.py(290):             except AttributeError:
0.86 options.py(291):                 pass
0.86 options.py(292):             self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 options.py(347):         if self.swappable:
0.86 options.py(361):         return None
0.86 base.py(75):         super_new = super().__new__
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.86 base.py(80):         if not parents:
0.86 base.py(84):         module = attrs.pop('__module__')
0.86 base.py(85):         new_attrs = {'__module__': module}
0.86 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.86 base.py(87):         if classcell is not None:
0.86 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.86 base.py(93):         contributable_attrs = {}
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(95):             if _has_contribute_to_class(obj):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(96):                 contributable_attrs[obj_name] = obj
0.86 base.py(94):         for obj_name, obj in list(attrs.items()):
0.86 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.86 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.86 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.86 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.86 base.py(105):         app_label = None
0.86 base.py(108):         app_config = apps.get_containing_app_config(module)
0.86 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.86 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.86 options.py(76):         self._get_fields_cache = {}
0.86 options.py(77):         self.local_fields = []
0.86 options.py(78):         self.local_many_to_many = []
0.86 options.py(79):         self.private_fields = []
0.86 options.py(80):         self.local_managers = []
0.86 options.py(81):         self.base_manager_name = None
0.86 options.py(82):         self.default_manager_name = None
0.86 options.py(83):         self.model_name = None
0.86 options.py(84):         self.verbose_name = None
0.86 options.py(85):         self.verbose_name_plural = None
0.86 options.py(86):         self.db_table = ''
0.86 options.py(87):         self.ordering = []
0.86 options.py(88):         self._ordering_clash = False
0.86 options.py(89):         self.indexes = []
0.86 options.py(90):         self.constraints = []
0.86 options.py(91):         self.unique_together = []
0.86 options.py(92):         self.index_together = []
0.86 options.py(93):         self.select_on_save = False
0.86 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.86 options.py(95):         self.permissions = []
0.86 options.py(96):         self.object_name = None
0.86 options.py(97):         self.app_label = app_label
0.86 options.py(98):         self.get_latest_by = None
0.86 options.py(99):         self.order_with_respect_to = None
0.86 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.86 options.py(101):         self.required_db_features = []
0.86 options.py(102):         self.required_db_vendor = None
0.86 options.py(103):         self.meta = meta
0.86 options.py(104):         self.pk = None
0.86 options.py(105):         self.auto_field = None
0.86 options.py(106):         self.abstract = False
0.86 options.py(107):         self.managed = True
0.86 options.py(108):         self.proxy = False
0.86 options.py(114):         self.proxy_for_model = None
0.86 options.py(118):         self.concrete_model = None
0.86 options.py(119):         self.swappable = None
0.86 options.py(120):         self.parents = {}
0.86 options.py(121):         self.auto_created = False
0.86 options.py(125):         self.related_fkey_lookups = []
0.86 options.py(128):         self.apps = self.default_apps
0.86 options.py(130):         self.default_related_name = None
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(150):         from django.db import connection
0.86 options.py(151):         from django.db.backends.utils import truncate_name
0.86 options.py(153):         cls._meta = self
0.86 options.py(154):         self.model = cls
0.86 options.py(156):         self.object_name = cls.__name__
0.86 options.py(157):         self.model_name = self.object_name.lower()
0.86 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.86 options.py(162):         self.original_attrs = {}
0.86 options.py(165):         if self.meta:
0.86 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(171):                 if name.startswith('_'):
0.86 options.py(172):                     del meta_attrs[name]
0.86 options.py(167):             for name in self.meta.__dict__:
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.86 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(174):                 if attr_name in meta_attrs:
0.86 options.py(177):                 elif hasattr(self.meta, attr_name):
0.86 options.py(173):             for attr_name in DEFAULT_NAMES:
0.86 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.86 options.py(50):         first_element = option_together[0]
0.86 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.86 options.py(52):             option_together = (option_together,)
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.86 options.py(182):             self.index_together = normalize_together(self.index_together)
0.86 options.py(45):     try:
0.86 options.py(46):         if not option_together:
0.86 options.py(47):             return ()
0.86 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(187):                     objs = getattr(self, attr_name, [])
0.86 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.86 options.py(212):         new_objs = []
0.86 options.py(213):         for obj in objs:
0.86 options.py(220):         return new_objs
0.86 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.86 options.py(192):             if self.verbose_name_plural is None:
0.86 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.86 options.py(199):             if meta_attrs != {}:
0.86 options.py(203):         del self.meta
0.86 options.py(206):         if not self.db_table:
0.86 base.py(123):         if not abstract:
0.86 base.py(124):             new_class.add_to_class(
0.86 base.py(125):                 'DoesNotExist',
0.86 base.py(126):                 subclass_exception(
0.86 base.py(127):                     'DoesNotExist',
0.86 base.py(128):                     tuple(
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(130):                     ) or (ObjectDoesNotExist,),
0.86 base.py(131):                     module,
0.86 base.py(132):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(133):             new_class.add_to_class(
0.86 base.py(134):                 'MultipleObjectsReturned',
0.86 base.py(135):                 subclass_exception(
0.86 base.py(136):                     'MultipleObjectsReturned',
0.86 base.py(137):                     tuple(
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.86 base.py(139):                     ) or (MultipleObjectsReturned,),
0.86 base.py(140):                     module,
0.86 base.py(141):                     attached_to=new_class))
0.86 base.py(61):     return type(name, bases, {
0.86 base.py(62):         '__module__': module,
0.86 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(328):             setattr(cls, name, value)
0.86 base.py(142):             if base_meta and not base_meta.abstract:
0.86 base.py(151):         is_proxy = new_class._meta.proxy
0.86 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(288):             try:
0.86 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.86 options.py(728):         if forward:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 options.py(292):             self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(288):             try:
0.86 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.86 options.py(290):             except AttributeError:
0.86 options.py(291):                 pass
0.86 options.py(292):             self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(164):         new_fields = chain(
0.86 base.py(165):             new_class._meta.local_fields,
0.86 base.py(166):             new_class._meta.local_many_to_many,
0.86 base.py(167):             new_class._meta.private_fields
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(172):         if is_proxy:
0.86 base.py(192):             new_class._meta.concrete_model = new_class
0.86 base.py(195):         parent_links = {}
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(199):                 continue
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(201):             if base != new_class and not base._meta.abstract:
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(210):         inherited_attributes = set()
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.86 base.py(217):                 continue
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.86 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.86 base.py(312):         if abstract:
0.86 base.py(320):         new_class._prepare()
0.86 base.py(332):         opts = cls._meta
0.86 base.py(333):         opts._prepare(cls)
0.86 options.py(223):         if self.order_with_respect_to:
0.86 options.py(239):             self.order_with_respect_to = None
0.86 options.py(241):         if self.pk is None:
0.86 options.py(242):             if self.parents:
0.86 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.86 options.py(260):                 model.add_to_class('id', auto)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(271):         if private:
0.86 options.py(273):         elif field.is_relation and field.many_to_many:
0.86 options.py(276):             bisect.insort(self.local_fields, field)
0.86 options.py(277):             self.setup_pk(field)
0.86 options.py(297):         if not self.pk and field.primary_key:
0.86 options.py(298):             self.pk = field
0.86 options.py(299):             field.serialize = False
0.86 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.86 options.py(294):             self._expire_cache(reverse=False)
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(335):         if opts.order_with_respect_to:
0.86 base.py(350):         if cls.__doc__ is None:
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 options.py(456):         def is_not_an_m2m_field(f):
0.86 options.py(459):         def is_not_a_generic_relation(f):
0.86 options.py(462):         def is_not_a_generic_foreign_key(f):
0.86 options.py(467):         return make_immutable_fields_list(
0.86 options.py(468):             "fields",
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.86 options.py(773):         topmost_call = seen_models is None
0.86 options.py(774):         if topmost_call:
0.86 options.py(775):             seen_models = set()
0.86 options.py(776):         seen_models.add(self.model)
0.86 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.86 options.py(781):         try:
0.86 options.py(784):             return self._get_fields_cache[cache_key]
0.86 options.py(785):         except KeyError:
0.86 options.py(786):             pass
0.86 options.py(788):         fields = []
0.86 options.py(791):         if include_parents is not False:
0.86 options.py(792):             for parent in self.parents:
0.86 options.py(806):         if reverse and not self.proxy:
0.86 options.py(817):         if forward:
0.86 options.py(818):             fields += self.local_fields
0.86 options.py(819):             fields += self.local_many_to_many
0.86 options.py(825):             if topmost_call:
0.86 options.py(826):                 fields += self.private_fields
0.86 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(833):         self._get_fields_cache[cache_key] = fields
0.86 options.py(834):         return fields
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.86 options.py(457):             return not (f.is_relation and f.many_to_many)
0.86 options.py(460):             return not (f.is_relation and f.one_to_many)
0.86 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.86 options.py(469):             (f for f in self._get_fields(reverse=False)
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.86 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.86 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.86 base.py(354):         if get_absolute_url_override:
0.86 base.py(357):         if not opts.managers:
0.86 options.py(365):         managers = []
0.86 options.py(366):         seen_managers = set()
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(368):         for depth, base in enumerate(bases):
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(369):             for manager in base._meta.local_managers:
0.86 options.py(368):         for depth, base in enumerate(bases):
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.86 options.py(378):         return make_immutable_fields_list(
0.86 options.py(379):             "managers",
0.86 options.py(380):             (m[2] for m in sorted(managers)),
0.86 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.86 options.py(380):             (m[2] for m in sorted(managers)),
0.86 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.86 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.86 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.86 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.86 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.86 base.py(363):             manager = Manager()
0.86 base.py(364):             manager.auto_created = True
0.86 base.py(365):             cls.add_to_class('objects', manager)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(263):         self.local_managers.append(manager)
0.86 options.py(264):         self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(731):                     delattr(self, cache_key)
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(731):                     delattr(self, cache_key)
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(370):         for index in cls._meta.indexes:
0.86 base.py(374):         class_prepared.send(sender=cls)
0.86 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.86 base.py(322):         return new_class
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(161):             new_class.add_to_class(obj_name, obj)
0.86 base.py(325):         if _has_contribute_to_class(value):
0.86 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.86 base.py(326):             value.contribute_to_class(cls, name)
0.86 options.py(263):         self.local_managers.append(manager)
0.86 options.py(264):         self._expire_cache()
0.86 options.py(728):         if forward:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(730):                 if cache_key in self.__dict__:
0.86 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.86 options.py(732):         if reverse and not self.abstract:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(734):                 if cache_key in self.__dict__:
0.86 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.86 options.py(736):         self._get_fields_cache = {}
0.86 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.86 base.py(164):         new_fields = chain(
0.86 base.py(165):             new_class._meta.local_fields,
0.86 base.py(166):             new_class._meta.local_many_to_many,
0.86 base.py(167):             new_class._meta.private_fields
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(169):         field_names = {f.name for f in new_fields}
0.86 base.py(172):         if is_proxy:
0.86 base.py(192):             new_class._meta.concrete_model = new_class
0.86 base.py(195):         parent_links = {}
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(199):                 continue
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(198):             if not hasattr(base, '_meta'):
0.86 base.py(201):             if base != new_class and not base._meta.abstract:
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(205):                 if isinstance(field, OneToOneField):
0.86 base.py(204):             for field in base._meta.local_fields:
0.86 base.py(196):         for base in reversed([new_class] + parents):
0.86 base.py(210):         inherited_attributes = set()
0.86 base.py(212):         for base in new_class.mro():
0.86 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.86 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(312):         if abstract:
0.87 base.py(320):         new_class._prepare()
0.87 base.py(332):         opts = cls._meta
0.87 base.py(333):         opts._prepare(cls)
0.87 options.py(223):         if self.order_with_respect_to:
0.87 options.py(239):             self.order_with_respect_to = None
0.87 options.py(241):         if self.pk is None:
0.87 base.py(335):         if opts.order_with_respect_to:
0.87 base.py(350):         if cls.__doc__ is None:
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 options.py(456):         def is_not_an_m2m_field(f):
0.87 options.py(459):         def is_not_a_generic_relation(f):
0.87 options.py(462):         def is_not_a_generic_foreign_key(f):
0.87 options.py(467):         return make_immutable_fields_list(
0.87 options.py(468):             "fields",
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.87 options.py(773):         topmost_call = seen_models is None
0.87 options.py(774):         if topmost_call:
0.87 options.py(775):             seen_models = set()
0.87 options.py(776):         seen_models.add(self.model)
0.87 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.87 options.py(781):         try:
0.87 options.py(784):             return self._get_fields_cache[cache_key]
0.87 options.py(785):         except KeyError:
0.87 options.py(786):             pass
0.87 options.py(788):         fields = []
0.87 options.py(791):         if include_parents is not False:
0.87 options.py(792):             for parent in self.parents:
0.87 options.py(806):         if reverse and not self.proxy:
0.87 options.py(817):         if forward:
0.87 options.py(818):             fields += self.local_fields
0.87 options.py(819):             fields += self.local_many_to_many
0.87 options.py(825):             if topmost_call:
0.87 options.py(826):                 fields += self.private_fields
0.87 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(833):         self._get_fields_cache[cache_key] = fields
0.87 options.py(834):         return fields
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(460):             return not (f.is_relation and f.one_to_many)
0.87 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(460):             return not (f.is_relation and f.one_to_many)
0.87 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.87 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.87 base.py(354):         if get_absolute_url_override:
0.87 base.py(357):         if not opts.managers:
0.87 options.py(365):         managers = []
0.87 options.py(366):         seen_managers = set()
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(368):         for depth, base in enumerate(bases):
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(369):             for manager in base._meta.local_managers:
0.87 options.py(370):                 if manager.name in seen_managers:
0.87 options.py(373):                 manager = copy.copy(manager)
0.87 options.py(374):                 manager.model = self.model
0.87 options.py(375):                 seen_managers.add(manager.name)
0.87 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.87 options.py(369):             for manager in base._meta.local_managers:
0.87 options.py(368):         for depth, base in enumerate(bases):
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(378):         return make_immutable_fields_list(
0.87 options.py(379):             "managers",
0.87 options.py(380):             (m[2] for m in sorted(managers)),
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(380):             (m[2] for m in sorted(managers)),
0.87 options.py(380):             (m[2] for m in sorted(managers)),
0.87 base.py(370):         for index in cls._meta.indexes:
0.87 base.py(374):         class_prepared.send(sender=cls)
0.87 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.87 options.py(347):         if self.swappable:
0.87 options.py(361):         return None
0.87 base.py(322):         return new_class
0.87 base.py(75):         super_new = super().__new__
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(80):         if not parents:
0.87 base.py(84):         module = attrs.pop('__module__')
0.87 base.py(85):         new_attrs = {'__module__': module}
0.87 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.87 base.py(87):         if classcell is not None:
0.87 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.87 base.py(93):         contributable_attrs = {}
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.87 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.87 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.87 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.87 base.py(105):         app_label = None
0.87 base.py(108):         app_config = apps.get_containing_app_config(module)
0.87 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.87 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.87 options.py(76):         self._get_fields_cache = {}
0.87 options.py(77):         self.local_fields = []
0.87 options.py(78):         self.local_many_to_many = []
0.87 options.py(79):         self.private_fields = []
0.87 options.py(80):         self.local_managers = []
0.87 options.py(81):         self.base_manager_name = None
0.87 options.py(82):         self.default_manager_name = None
0.87 options.py(83):         self.model_name = None
0.87 options.py(84):         self.verbose_name = None
0.87 options.py(85):         self.verbose_name_plural = None
0.87 options.py(86):         self.db_table = ''
0.87 options.py(87):         self.ordering = []
0.87 options.py(88):         self._ordering_clash = False
0.87 options.py(89):         self.indexes = []
0.87 options.py(90):         self.constraints = []
0.87 options.py(91):         self.unique_together = []
0.87 options.py(92):         self.index_together = []
0.87 options.py(93):         self.select_on_save = False
0.87 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.87 options.py(95):         self.permissions = []
0.87 options.py(96):         self.object_name = None
0.87 options.py(97):         self.app_label = app_label
0.87 options.py(98):         self.get_latest_by = None
0.87 options.py(99):         self.order_with_respect_to = None
0.87 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.87 options.py(101):         self.required_db_features = []
0.87 options.py(102):         self.required_db_vendor = None
0.87 options.py(103):         self.meta = meta
0.87 options.py(104):         self.pk = None
0.87 options.py(105):         self.auto_field = None
0.87 options.py(106):         self.abstract = False
0.87 options.py(107):         self.managed = True
0.87 options.py(108):         self.proxy = False
0.87 options.py(114):         self.proxy_for_model = None
0.87 options.py(118):         self.concrete_model = None
0.87 options.py(119):         self.swappable = None
0.87 options.py(120):         self.parents = {}
0.87 options.py(121):         self.auto_created = False
0.87 options.py(125):         self.related_fkey_lookups = []
0.87 options.py(128):         self.apps = self.default_apps
0.87 options.py(130):         self.default_related_name = None
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(150):         from django.db import connection
0.87 options.py(151):         from django.db.backends.utils import truncate_name
0.87 options.py(153):         cls._meta = self
0.87 options.py(154):         self.model = cls
0.87 options.py(156):         self.object_name = cls.__name__
0.87 options.py(157):         self.model_name = self.object_name.lower()
0.87 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.87 options.py(162):         self.original_attrs = {}
0.87 options.py(165):         if self.meta:
0.87 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(47):             return ()
0.87 options.py(182):             self.index_together = normalize_together(self.index_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(47):             return ()
0.87 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(192):             if self.verbose_name_plural is None:
0.87 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.87 options.py(199):             if meta_attrs != {}:
0.87 options.py(203):         del self.meta
0.87 options.py(206):         if not self.db_table:
0.87 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
0.87 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
0.87 base.py(123):         if not abstract:
0.87 base.py(124):             new_class.add_to_class(
0.87 base.py(125):                 'DoesNotExist',
0.87 base.py(126):                 subclass_exception(
0.87 base.py(127):                     'DoesNotExist',
0.87 base.py(128):                     tuple(
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(130):                     ) or (ObjectDoesNotExist,),
0.87 base.py(131):                     module,
0.87 base.py(132):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(133):             new_class.add_to_class(
0.87 base.py(134):                 'MultipleObjectsReturned',
0.87 base.py(135):                 subclass_exception(
0.87 base.py(136):                     'MultipleObjectsReturned',
0.87 base.py(137):                     tuple(
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(139):                     ) or (MultipleObjectsReturned,),
0.87 base.py(140):                     module,
0.87 base.py(141):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(142):             if base_meta and not base_meta.abstract:
0.87 base.py(151):         is_proxy = new_class._meta.proxy
0.87 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(298):             self.pk = field
0.87 options.py(299):             field.serialize = False
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(290):             except AttributeError:
0.87 options.py(291):                 pass
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 options.py(347):         if self.swappable:
0.87 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.87 options.py(349):             if swapped_for:
0.87 options.py(350):                 try:
0.87 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.87 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.87 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.87 options.py(361):         return None
0.87 base.py(75):         super_new = super().__new__
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(80):         if not parents:
0.87 base.py(84):         module = attrs.pop('__module__')
0.87 base.py(85):         new_attrs = {'__module__': module}
0.87 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.87 base.py(87):         if classcell is not None:
0.87 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.87 base.py(93):         contributable_attrs = {}
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.87 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.87 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.87 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.87 base.py(105):         app_label = None
0.87 base.py(108):         app_config = apps.get_containing_app_config(module)
0.87 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.87 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.87 options.py(76):         self._get_fields_cache = {}
0.87 options.py(77):         self.local_fields = []
0.87 options.py(78):         self.local_many_to_many = []
0.87 options.py(79):         self.private_fields = []
0.87 options.py(80):         self.local_managers = []
0.87 options.py(81):         self.base_manager_name = None
0.87 options.py(82):         self.default_manager_name = None
0.87 options.py(83):         self.model_name = None
0.87 options.py(84):         self.verbose_name = None
0.87 options.py(85):         self.verbose_name_plural = None
0.87 options.py(86):         self.db_table = ''
0.87 options.py(87):         self.ordering = []
0.87 options.py(88):         self._ordering_clash = False
0.87 options.py(89):         self.indexes = []
0.87 options.py(90):         self.constraints = []
0.87 options.py(91):         self.unique_together = []
0.87 options.py(92):         self.index_together = []
0.87 options.py(93):         self.select_on_save = False
0.87 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.87 options.py(95):         self.permissions = []
0.87 options.py(96):         self.object_name = None
0.87 options.py(97):         self.app_label = app_label
0.87 options.py(98):         self.get_latest_by = None
0.87 options.py(99):         self.order_with_respect_to = None
0.87 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.87 options.py(101):         self.required_db_features = []
0.87 options.py(102):         self.required_db_vendor = None
0.87 options.py(103):         self.meta = meta
0.87 options.py(104):         self.pk = None
0.87 options.py(105):         self.auto_field = None
0.87 options.py(106):         self.abstract = False
0.87 options.py(107):         self.managed = True
0.87 options.py(108):         self.proxy = False
0.87 options.py(114):         self.proxy_for_model = None
0.87 options.py(118):         self.concrete_model = None
0.87 options.py(119):         self.swappable = None
0.87 options.py(120):         self.parents = {}
0.87 options.py(121):         self.auto_created = False
0.87 options.py(125):         self.related_fkey_lookups = []
0.87 options.py(128):         self.apps = self.default_apps
0.87 options.py(130):         self.default_related_name = None
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(150):         from django.db import connection
0.87 options.py(151):         from django.db.backends.utils import truncate_name
0.87 options.py(153):         cls._meta = self
0.87 options.py(154):         self.model = cls
0.87 options.py(156):         self.object_name = cls.__name__
0.87 options.py(157):         self.model_name = self.object_name.lower()
0.87 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.87 options.py(162):         self.original_attrs = {}
0.87 options.py(165):         if self.meta:
0.87 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.87 options.py(50):         first_element = option_together[0]
0.87 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.87 options.py(52):             option_together = (option_together,)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(182):             self.index_together = normalize_together(self.index_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(47):             return ()
0.87 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(192):             if self.verbose_name_plural is None:
0.87 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.87 options.py(199):             if meta_attrs != {}:
0.87 options.py(203):         del self.meta
0.87 options.py(206):         if not self.db_table:
0.87 base.py(123):         if not abstract:
0.87 base.py(124):             new_class.add_to_class(
0.87 base.py(125):                 'DoesNotExist',
0.87 base.py(126):                 subclass_exception(
0.87 base.py(127):                     'DoesNotExist',
0.87 base.py(128):                     tuple(
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(130):                     ) or (ObjectDoesNotExist,),
0.87 base.py(131):                     module,
0.87 base.py(132):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(133):             new_class.add_to_class(
0.87 base.py(134):                 'MultipleObjectsReturned',
0.87 base.py(135):                 subclass_exception(
0.87 base.py(136):                     'MultipleObjectsReturned',
0.87 base.py(137):                     tuple(
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(139):                     ) or (MultipleObjectsReturned,),
0.87 base.py(140):                     module,
0.87 base.py(141):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(142):             if base_meta and not base_meta.abstract:
0.87 base.py(151):         is_proxy = new_class._meta.proxy
0.87 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(728):         if forward:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(290):             except AttributeError:
0.87 options.py(291):                 pass
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(164):         new_fields = chain(
0.87 base.py(165):             new_class._meta.local_fields,
0.87 base.py(166):             new_class._meta.local_many_to_many,
0.87 base.py(167):             new_class._meta.private_fields
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(172):         if is_proxy:
0.87 base.py(192):             new_class._meta.concrete_model = new_class
0.87 base.py(195):         parent_links = {}
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(198):             if not hasattr(base, '_meta'):
0.87 base.py(199):                 continue
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(198):             if not hasattr(base, '_meta'):
0.87 base.py(201):             if base != new_class and not base._meta.abstract:
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(205):                 if isinstance(field, OneToOneField):
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(205):                 if isinstance(field, OneToOneField):
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(210):         inherited_attributes = set()
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(312):         if abstract:
0.87 base.py(320):         new_class._prepare()
0.87 base.py(332):         opts = cls._meta
0.87 base.py(333):         opts._prepare(cls)
0.87 options.py(223):         if self.order_with_respect_to:
0.87 options.py(239):             self.order_with_respect_to = None
0.87 options.py(241):         if self.pk is None:
0.87 options.py(242):             if self.parents:
0.87 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.87 options.py(260):                 model.add_to_class('id', auto)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(298):             self.pk = field
0.87 options.py(299):             field.serialize = False
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(335):         if opts.order_with_respect_to:
0.87 base.py(350):         if cls.__doc__ is None:
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 options.py(456):         def is_not_an_m2m_field(f):
0.87 options.py(459):         def is_not_a_generic_relation(f):
0.87 options.py(462):         def is_not_a_generic_foreign_key(f):
0.87 options.py(467):         return make_immutable_fields_list(
0.87 options.py(468):             "fields",
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.87 options.py(773):         topmost_call = seen_models is None
0.87 options.py(774):         if topmost_call:
0.87 options.py(775):             seen_models = set()
0.87 options.py(776):         seen_models.add(self.model)
0.87 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.87 options.py(781):         try:
0.87 options.py(784):             return self._get_fields_cache[cache_key]
0.87 options.py(785):         except KeyError:
0.87 options.py(786):             pass
0.87 options.py(788):         fields = []
0.87 options.py(791):         if include_parents is not False:
0.87 options.py(792):             for parent in self.parents:
0.87 options.py(806):         if reverse and not self.proxy:
0.87 options.py(817):         if forward:
0.87 options.py(818):             fields += self.local_fields
0.87 options.py(819):             fields += self.local_many_to_many
0.87 options.py(825):             if topmost_call:
0.87 options.py(826):                 fields += self.private_fields
0.87 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(833):         self._get_fields_cache[cache_key] = fields
0.87 options.py(834):         return fields
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(460):             return not (f.is_relation and f.one_to_many)
0.87 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(460):             return not (f.is_relation and f.one_to_many)
0.87 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.87 options.py(457):             return not (f.is_relation and f.many_to_many)
0.87 options.py(460):             return not (f.is_relation and f.one_to_many)
0.87 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.87 options.py(469):             (f for f in self._get_fields(reverse=False)
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.87 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.87 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.87 base.py(354):         if get_absolute_url_override:
0.87 base.py(357):         if not opts.managers:
0.87 options.py(365):         managers = []
0.87 options.py(366):         seen_managers = set()
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(368):         for depth, base in enumerate(bases):
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(369):             for manager in base._meta.local_managers:
0.87 options.py(368):         for depth, base in enumerate(bases):
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.87 options.py(378):         return make_immutable_fields_list(
0.87 options.py(379):             "managers",
0.87 options.py(380):             (m[2] for m in sorted(managers)),
0.87 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.87 options.py(380):             (m[2] for m in sorted(managers)),
0.87 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.87 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.87 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.87 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.87 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.87 base.py(363):             manager = Manager()
0.87 base.py(364):             manager.auto_created = True
0.87 base.py(365):             cls.add_to_class('objects', manager)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(263):         self.local_managers.append(manager)
0.87 options.py(264):         self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(731):                     delattr(self, cache_key)
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(731):                     delattr(self, cache_key)
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(370):         for index in cls._meta.indexes:
0.87 base.py(374):         class_prepared.send(sender=cls)
0.87 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.87 base.py(322):         return new_class
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(274):             bisect.insort(self.local_many_to_many, field)
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(290):             except AttributeError:
0.87 options.py(291):                 pass
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 options.py(347):         if self.swappable:
0.87 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.87 options.py(349):             if swapped_for:
0.87 options.py(350):                 try:
0.87 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.87 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.87 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.87 options.py(361):         return None
0.87 base.py(75):         super_new = super().__new__
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.87 base.py(80):         if not parents:
0.87 base.py(84):         module = attrs.pop('__module__')
0.87 base.py(85):         new_attrs = {'__module__': module}
0.87 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.87 base.py(87):         if classcell is not None:
0.87 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.87 base.py(93):         contributable_attrs = {}
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(95):             if _has_contribute_to_class(obj):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(96):                 contributable_attrs[obj_name] = obj
0.87 base.py(94):         for obj_name, obj in list(attrs.items()):
0.87 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.87 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.87 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.87 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.87 base.py(105):         app_label = None
0.87 base.py(108):         app_config = apps.get_containing_app_config(module)
0.87 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.87 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.87 options.py(76):         self._get_fields_cache = {}
0.87 options.py(77):         self.local_fields = []
0.87 options.py(78):         self.local_many_to_many = []
0.87 options.py(79):         self.private_fields = []
0.87 options.py(80):         self.local_managers = []
0.87 options.py(81):         self.base_manager_name = None
0.87 options.py(82):         self.default_manager_name = None
0.87 options.py(83):         self.model_name = None
0.87 options.py(84):         self.verbose_name = None
0.87 options.py(85):         self.verbose_name_plural = None
0.87 options.py(86):         self.db_table = ''
0.87 options.py(87):         self.ordering = []
0.87 options.py(88):         self._ordering_clash = False
0.87 options.py(89):         self.indexes = []
0.87 options.py(90):         self.constraints = []
0.87 options.py(91):         self.unique_together = []
0.87 options.py(92):         self.index_together = []
0.87 options.py(93):         self.select_on_save = False
0.87 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.87 options.py(95):         self.permissions = []
0.87 options.py(96):         self.object_name = None
0.87 options.py(97):         self.app_label = app_label
0.87 options.py(98):         self.get_latest_by = None
0.87 options.py(99):         self.order_with_respect_to = None
0.87 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.87 options.py(101):         self.required_db_features = []
0.87 options.py(102):         self.required_db_vendor = None
0.87 options.py(103):         self.meta = meta
0.87 options.py(104):         self.pk = None
0.87 options.py(105):         self.auto_field = None
0.87 options.py(106):         self.abstract = False
0.87 options.py(107):         self.managed = True
0.87 options.py(108):         self.proxy = False
0.87 options.py(114):         self.proxy_for_model = None
0.87 options.py(118):         self.concrete_model = None
0.87 options.py(119):         self.swappable = None
0.87 options.py(120):         self.parents = {}
0.87 options.py(121):         self.auto_created = False
0.87 options.py(125):         self.related_fkey_lookups = []
0.87 options.py(128):         self.apps = self.default_apps
0.87 options.py(130):         self.default_related_name = None
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(150):         from django.db import connection
0.87 options.py(151):         from django.db.backends.utils import truncate_name
0.87 options.py(153):         cls._meta = self
0.87 options.py(154):         self.model = cls
0.87 options.py(156):         self.object_name = cls.__name__
0.87 options.py(157):         self.model_name = self.object_name.lower()
0.87 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.87 options.py(162):         self.original_attrs = {}
0.87 options.py(165):         if self.meta:
0.87 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(171):                 if name.startswith('_'):
0.87 options.py(172):                     del meta_attrs[name]
0.87 options.py(167):             for name in self.meta.__dict__:
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.87 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(174):                 if attr_name in meta_attrs:
0.87 options.py(177):                 elif hasattr(self.meta, attr_name):
0.87 options.py(173):             for attr_name in DEFAULT_NAMES:
0.87 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.87 options.py(50):         first_element = option_together[0]
0.87 options.py(51):         if not isinstance(first_element, (tuple, list)):
0.87 options.py(52):             option_together = (option_together,)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(54):         return tuple(tuple(ot) for ot in option_together)
0.87 options.py(182):             self.index_together = normalize_together(self.index_together)
0.87 options.py(45):     try:
0.87 options.py(46):         if not option_together:
0.87 options.py(47):             return ()
0.87 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(187):                     objs = getattr(self, attr_name, [])
0.87 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.87 options.py(212):         new_objs = []
0.87 options.py(213):         for obj in objs:
0.87 options.py(220):         return new_objs
0.87 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.87 options.py(192):             if self.verbose_name_plural is None:
0.87 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.87 options.py(199):             if meta_attrs != {}:
0.87 options.py(203):         del self.meta
0.87 options.py(206):         if not self.db_table:
0.87 base.py(123):         if not abstract:
0.87 base.py(124):             new_class.add_to_class(
0.87 base.py(125):                 'DoesNotExist',
0.87 base.py(126):                 subclass_exception(
0.87 base.py(127):                     'DoesNotExist',
0.87 base.py(128):                     tuple(
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(130):                     ) or (ObjectDoesNotExist,),
0.87 base.py(131):                     module,
0.87 base.py(132):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(133):             new_class.add_to_class(
0.87 base.py(134):                 'MultipleObjectsReturned',
0.87 base.py(135):                 subclass_exception(
0.87 base.py(136):                     'MultipleObjectsReturned',
0.87 base.py(137):                     tuple(
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.87 base.py(139):                     ) or (MultipleObjectsReturned,),
0.87 base.py(140):                     module,
0.87 base.py(141):                     attached_to=new_class))
0.87 base.py(61):     return type(name, bases, {
0.87 base.py(62):         '__module__': module,
0.87 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(328):             setattr(cls, name, value)
0.87 base.py(142):             if base_meta and not base_meta.abstract:
0.87 base.py(151):         is_proxy = new_class._meta.proxy
0.87 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(728):         if forward:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(161):             new_class.add_to_class(obj_name, obj)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(288):             try:
0.87 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
0.87 options.py(290):             except AttributeError:
0.87 options.py(291):                 pass
0.87 options.py(292):             self._expire_cache()
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(732):         if reverse and not self.abstract:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(734):                 if cache_key in self.__dict__:
0.87 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.87 options.py(736):         self._get_fields_cache = {}
0.87 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.87 base.py(164):         new_fields = chain(
0.87 base.py(165):             new_class._meta.local_fields,
0.87 base.py(166):             new_class._meta.local_many_to_many,
0.87 base.py(167):             new_class._meta.private_fields
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(169):         field_names = {f.name for f in new_fields}
0.87 base.py(172):         if is_proxy:
0.87 base.py(192):             new_class._meta.concrete_model = new_class
0.87 base.py(195):         parent_links = {}
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(198):             if not hasattr(base, '_meta'):
0.87 base.py(199):                 continue
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(198):             if not hasattr(base, '_meta'):
0.87 base.py(201):             if base != new_class and not base._meta.abstract:
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(205):                 if isinstance(field, OneToOneField):
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(205):                 if isinstance(field, OneToOneField):
0.87 base.py(204):             for field in base._meta.local_fields:
0.87 base.py(196):         for base in reversed([new_class] + parents):
0.87 base.py(210):         inherited_attributes = set()
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.87 base.py(216):                 inherited_attributes.update(base.__dict__)
0.87 base.py(217):                 continue
0.87 base.py(212):         for base in new_class.mro():
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.87 base.py(312):         if abstract:
0.87 base.py(320):         new_class._prepare()
0.87 base.py(332):         opts = cls._meta
0.87 base.py(333):         opts._prepare(cls)
0.87 options.py(223):         if self.order_with_respect_to:
0.87 options.py(239):             self.order_with_respect_to = None
0.87 options.py(241):         if self.pk is None:
0.87 options.py(242):             if self.parents:
0.87 options.py(259):                 auto = AutoField(verbose_name='ID', primary_key=True, auto_created=True)
0.87 options.py(260):                 model.add_to_class('id', auto)
0.87 base.py(325):         if _has_contribute_to_class(value):
0.87 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.87 base.py(326):             value.contribute_to_class(cls, name)
0.87 options.py(271):         if private:
0.87 options.py(273):         elif field.is_relation and field.many_to_many:
0.87 options.py(276):             bisect.insort(self.local_fields, field)
0.87 options.py(277):             self.setup_pk(field)
0.87 options.py(297):         if not self.pk and field.primary_key:
0.87 options.py(298):             self.pk = field
0.87 options.py(299):             field.serialize = False
0.87 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.87 options.py(294):             self._expire_cache(reverse=False)
0.87 options.py(728):         if forward:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.87 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.87 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(335):         if opts.order_with_respect_to:
0.88 base.py(350):         if cls.__doc__ is None:
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 options.py(456):         def is_not_an_m2m_field(f):
0.88 options.py(459):         def is_not_a_generic_relation(f):
0.88 options.py(462):         def is_not_a_generic_foreign_key(f):
0.88 options.py(467):         return make_immutable_fields_list(
0.88 options.py(468):             "fields",
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.88 options.py(773):         topmost_call = seen_models is None
0.88 options.py(774):         if topmost_call:
0.88 options.py(775):             seen_models = set()
0.88 options.py(776):         seen_models.add(self.model)
0.88 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.88 options.py(781):         try:
0.88 options.py(784):             return self._get_fields_cache[cache_key]
0.88 options.py(785):         except KeyError:
0.88 options.py(786):             pass
0.88 options.py(788):         fields = []
0.88 options.py(791):         if include_parents is not False:
0.88 options.py(792):             for parent in self.parents:
0.88 options.py(806):         if reverse and not self.proxy:
0.88 options.py(817):         if forward:
0.88 options.py(818):             fields += self.local_fields
0.88 options.py(819):             fields += self.local_many_to_many
0.88 options.py(825):             if topmost_call:
0.88 options.py(826):                 fields += self.private_fields
0.88 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(833):         self._get_fields_cache[cache_key] = fields
0.88 options.py(834):         return fields
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 base.py(354):         if get_absolute_url_override:
0.88 base.py(357):         if not opts.managers:
0.88 options.py(365):         managers = []
0.88 options.py(366):         seen_managers = set()
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(378):         return make_immutable_fields_list(
0.88 options.py(379):             "managers",
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.88 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.88 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.88 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.88 base.py(358):             if any(f.name == 'objects' for f in opts.fields):
0.88 base.py(363):             manager = Manager()
0.88 base.py(364):             manager.auto_created = True
0.88 base.py(365):             cls.add_to_class('objects', manager)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(263):         self.local_managers.append(manager)
0.88 options.py(264):         self._expire_cache()
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(370):         for index in cls._meta.indexes:
0.88 base.py(374):         class_prepared.send(sender=cls)
0.88 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.88 base.py(322):         return new_class
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(263):         self.local_managers.append(manager)
0.88 options.py(264):         self._expire_cache()
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(164):         new_fields = chain(
0.88 base.py(165):             new_class._meta.local_fields,
0.88 base.py(166):             new_class._meta.local_many_to_many,
0.88 base.py(167):             new_class._meta.private_fields
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(172):         if is_proxy:
0.88 base.py(192):             new_class._meta.concrete_model = new_class
0.88 base.py(195):         parent_links = {}
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(199):                 continue
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(201):             if base != new_class and not base._meta.abstract:
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(210):         inherited_attributes = set()
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(312):         if abstract:
0.88 base.py(320):         new_class._prepare()
0.88 base.py(332):         opts = cls._meta
0.88 base.py(333):         opts._prepare(cls)
0.88 options.py(223):         if self.order_with_respect_to:
0.88 options.py(239):             self.order_with_respect_to = None
0.88 options.py(241):         if self.pk is None:
0.88 base.py(335):         if opts.order_with_respect_to:
0.88 base.py(350):         if cls.__doc__ is None:
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 options.py(456):         def is_not_an_m2m_field(f):
0.88 options.py(459):         def is_not_a_generic_relation(f):
0.88 options.py(462):         def is_not_a_generic_foreign_key(f):
0.88 options.py(467):         return make_immutable_fields_list(
0.88 options.py(468):             "fields",
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.88 options.py(773):         topmost_call = seen_models is None
0.88 options.py(774):         if topmost_call:
0.88 options.py(775):             seen_models = set()
0.88 options.py(776):         seen_models.add(self.model)
0.88 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.88 options.py(781):         try:
0.88 options.py(784):             return self._get_fields_cache[cache_key]
0.88 options.py(785):         except KeyError:
0.88 options.py(786):             pass
0.88 options.py(788):         fields = []
0.88 options.py(791):         if include_parents is not False:
0.88 options.py(792):             for parent in self.parents:
0.88 options.py(806):         if reverse and not self.proxy:
0.88 options.py(817):         if forward:
0.88 options.py(818):             fields += self.local_fields
0.88 options.py(819):             fields += self.local_many_to_many
0.88 options.py(825):             if topmost_call:
0.88 options.py(826):                 fields += self.private_fields
0.88 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(833):         self._get_fields_cache[cache_key] = fields
0.88 options.py(834):         return fields
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 base.py(354):         if get_absolute_url_override:
0.88 base.py(357):         if not opts.managers:
0.88 options.py(365):         managers = []
0.88 options.py(366):         seen_managers = set()
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(370):                 if manager.name in seen_managers:
0.88 options.py(373):                 manager = copy.copy(manager)
0.88 options.py(374):                 manager.model = self.model
0.88 options.py(375):                 seen_managers.add(manager.name)
0.88 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(378):         return make_immutable_fields_list(
0.88 options.py(379):             "managers",
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 base.py(370):         for index in cls._meta.indexes:
0.88 base.py(374):         class_prepared.send(sender=cls)
0.88 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.88 options.py(347):         if self.swappable:
0.88 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.88 options.py(349):             if swapped_for:
0.88 options.py(350):                 try:
0.88 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.88 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 options.py(361):         return None
0.88 options.py(347):         if self.swappable:
0.88 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.88 options.py(349):             if swapped_for:
0.88 options.py(350):                 try:
0.88 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.88 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 options.py(361):         return None
0.88 base.py(322):         return new_class
0.88 base.py(75):         super_new = super().__new__
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(80):         if not parents:
0.88 base.py(84):         module = attrs.pop('__module__')
0.88 base.py(85):         new_attrs = {'__module__': module}
0.88 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.88 base.py(87):         if classcell is not None:
0.88 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.88 base.py(93):         contributable_attrs = {}
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.88 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.88 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.88 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.88 base.py(105):         app_label = None
0.88 base.py(108):         app_config = apps.get_containing_app_config(module)
0.88 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.88 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.88 options.py(76):         self._get_fields_cache = {}
0.88 options.py(77):         self.local_fields = []
0.88 options.py(78):         self.local_many_to_many = []
0.88 options.py(79):         self.private_fields = []
0.88 options.py(80):         self.local_managers = []
0.88 options.py(81):         self.base_manager_name = None
0.88 options.py(82):         self.default_manager_name = None
0.88 options.py(83):         self.model_name = None
0.88 options.py(84):         self.verbose_name = None
0.88 options.py(85):         self.verbose_name_plural = None
0.88 options.py(86):         self.db_table = ''
0.88 options.py(87):         self.ordering = []
0.88 options.py(88):         self._ordering_clash = False
0.88 options.py(89):         self.indexes = []
0.88 options.py(90):         self.constraints = []
0.88 options.py(91):         self.unique_together = []
0.88 options.py(92):         self.index_together = []
0.88 options.py(93):         self.select_on_save = False
0.88 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.88 options.py(95):         self.permissions = []
0.88 options.py(96):         self.object_name = None
0.88 options.py(97):         self.app_label = app_label
0.88 options.py(98):         self.get_latest_by = None
0.88 options.py(99):         self.order_with_respect_to = None
0.88 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.88 options.py(101):         self.required_db_features = []
0.88 options.py(102):         self.required_db_vendor = None
0.88 options.py(103):         self.meta = meta
0.88 options.py(104):         self.pk = None
0.88 options.py(105):         self.auto_field = None
0.88 options.py(106):         self.abstract = False
0.88 options.py(107):         self.managed = True
0.88 options.py(108):         self.proxy = False
0.88 options.py(114):         self.proxy_for_model = None
0.88 options.py(118):         self.concrete_model = None
0.88 options.py(119):         self.swappable = None
0.88 options.py(120):         self.parents = {}
0.88 options.py(121):         self.auto_created = False
0.88 options.py(125):         self.related_fkey_lookups = []
0.88 options.py(128):         self.apps = self.default_apps
0.88 options.py(130):         self.default_related_name = None
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(150):         from django.db import connection
0.88 options.py(151):         from django.db.backends.utils import truncate_name
0.88 options.py(153):         cls._meta = self
0.88 options.py(154):         self.model = cls
0.88 options.py(156):         self.object_name = cls.__name__
0.88 options.py(157):         self.model_name = self.object_name.lower()
0.88 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.88 options.py(162):         self.original_attrs = {}
0.88 options.py(165):         if self.meta:
0.88 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.88 options.py(45):     try:
0.88 options.py(46):         if not option_together:
0.88 options.py(47):             return ()
0.88 options.py(182):             self.index_together = normalize_together(self.index_together)
0.88 options.py(45):     try:
0.88 options.py(46):         if not option_together:
0.88 options.py(47):             return ()
0.88 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(187):                     objs = getattr(self, attr_name, [])
0.88 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.88 options.py(212):         new_objs = []
0.88 options.py(213):         for obj in objs:
0.88 options.py(220):         return new_objs
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(187):                     objs = getattr(self, attr_name, [])
0.88 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.88 options.py(212):         new_objs = []
0.88 options.py(213):         for obj in objs:
0.88 options.py(220):         return new_objs
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(192):             if self.verbose_name_plural is None:
0.88 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.88 options.py(199):             if meta_attrs != {}:
0.88 options.py(203):         del self.meta
0.88 options.py(206):         if not self.db_table:
0.88 base.py(123):         if not abstract:
0.88 base.py(124):             new_class.add_to_class(
0.88 base.py(125):                 'DoesNotExist',
0.88 base.py(126):                 subclass_exception(
0.88 base.py(127):                     'DoesNotExist',
0.88 base.py(128):                     tuple(
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(130):                     ) or (ObjectDoesNotExist,),
0.88 base.py(131):                     module,
0.88 base.py(132):                     attached_to=new_class))
0.88 base.py(61):     return type(name, bases, {
0.88 base.py(62):         '__module__': module,
0.88 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(328):             setattr(cls, name, value)
0.88 base.py(133):             new_class.add_to_class(
0.88 base.py(134):                 'MultipleObjectsReturned',
0.88 base.py(135):                 subclass_exception(
0.88 base.py(136):                     'MultipleObjectsReturned',
0.88 base.py(137):                     tuple(
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(139):                     ) or (MultipleObjectsReturned,),
0.88 base.py(140):                     module,
0.88 base.py(141):                     attached_to=new_class))
0.88 base.py(61):     return type(name, bases, {
0.88 base.py(62):         '__module__': module,
0.88 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(328):             setattr(cls, name, value)
0.88 base.py(142):             if base_meta and not base_meta.abstract:
0.88 base.py(151):         is_proxy = new_class._meta.proxy
0.88 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(298):             self.pk = field
0.88 options.py(299):             field.serialize = False
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(263):         self.local_managers.append(manager)
0.88 options.py(264):         self._expire_cache()
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(164):         new_fields = chain(
0.88 base.py(165):             new_class._meta.local_fields,
0.88 base.py(166):             new_class._meta.local_many_to_many,
0.88 base.py(167):             new_class._meta.private_fields
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(172):         if is_proxy:
0.88 base.py(192):             new_class._meta.concrete_model = new_class
0.88 base.py(195):         parent_links = {}
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(199):                 continue
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(201):             if base != new_class and not base._meta.abstract:
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(210):         inherited_attributes = set()
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(312):         if abstract:
0.88 base.py(320):         new_class._prepare()
0.88 base.py(332):         opts = cls._meta
0.88 base.py(333):         opts._prepare(cls)
0.88 options.py(223):         if self.order_with_respect_to:
0.88 options.py(239):             self.order_with_respect_to = None
0.88 options.py(241):         if self.pk is None:
0.88 base.py(335):         if opts.order_with_respect_to:
0.88 base.py(350):         if cls.__doc__ is None:
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 options.py(456):         def is_not_an_m2m_field(f):
0.88 options.py(459):         def is_not_a_generic_relation(f):
0.88 options.py(462):         def is_not_a_generic_foreign_key(f):
0.88 options.py(467):         return make_immutable_fields_list(
0.88 options.py(468):             "fields",
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.88 options.py(773):         topmost_call = seen_models is None
0.88 options.py(774):         if topmost_call:
0.88 options.py(775):             seen_models = set()
0.88 options.py(776):         seen_models.add(self.model)
0.88 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.88 options.py(781):         try:
0.88 options.py(784):             return self._get_fields_cache[cache_key]
0.88 options.py(785):         except KeyError:
0.88 options.py(786):             pass
0.88 options.py(788):         fields = []
0.88 options.py(791):         if include_parents is not False:
0.88 options.py(792):             for parent in self.parents:
0.88 options.py(806):         if reverse and not self.proxy:
0.88 options.py(817):         if forward:
0.88 options.py(818):             fields += self.local_fields
0.88 options.py(819):             fields += self.local_many_to_many
0.88 options.py(825):             if topmost_call:
0.88 options.py(826):                 fields += self.private_fields
0.88 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(833):         self._get_fields_cache[cache_key] = fields
0.88 options.py(834):         return fields
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 base.py(354):         if get_absolute_url_override:
0.88 base.py(357):         if not opts.managers:
0.88 options.py(365):         managers = []
0.88 options.py(366):         seen_managers = set()
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(370):                 if manager.name in seen_managers:
0.88 options.py(373):                 manager = copy.copy(manager)
0.88 options.py(374):                 manager.model = self.model
0.88 options.py(375):                 seen_managers.add(manager.name)
0.88 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(378):         return make_immutable_fields_list(
0.88 options.py(379):             "managers",
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 base.py(370):         for index in cls._meta.indexes:
0.88 base.py(374):         class_prepared.send(sender=cls)
0.88 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.88 base.py(322):         return new_class
0.88 base.py(75):         super_new = super().__new__
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
0.88 base.py(80):         if not parents:
0.88 base.py(84):         module = attrs.pop('__module__')
0.88 base.py(85):         new_attrs = {'__module__': module}
0.88 base.py(86):         classcell = attrs.pop('__classcell__', None)
0.88 base.py(87):         if classcell is not None:
0.88 base.py(89):         attr_meta = attrs.pop('Meta', None)
0.88 base.py(93):         contributable_attrs = {}
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(95):             if _has_contribute_to_class(obj):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(96):                 contributable_attrs[obj_name] = obj
0.88 base.py(94):         for obj_name, obj in list(attrs.items()):
0.88 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
0.88 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
0.88 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
0.88 base.py(103):         base_meta = getattr(new_class, '_meta', None)
0.88 base.py(105):         app_label = None
0.88 base.py(108):         app_config = apps.get_containing_app_config(module)
0.88 base.py(110):         if getattr(meta, 'app_label', None) is None:
0.88 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
0.88 options.py(76):         self._get_fields_cache = {}
0.88 options.py(77):         self.local_fields = []
0.88 options.py(78):         self.local_many_to_many = []
0.88 options.py(79):         self.private_fields = []
0.88 options.py(80):         self.local_managers = []
0.88 options.py(81):         self.base_manager_name = None
0.88 options.py(82):         self.default_manager_name = None
0.88 options.py(83):         self.model_name = None
0.88 options.py(84):         self.verbose_name = None
0.88 options.py(85):         self.verbose_name_plural = None
0.88 options.py(86):         self.db_table = ''
0.88 options.py(87):         self.ordering = []
0.88 options.py(88):         self._ordering_clash = False
0.88 options.py(89):         self.indexes = []
0.88 options.py(90):         self.constraints = []
0.88 options.py(91):         self.unique_together = []
0.88 options.py(92):         self.index_together = []
0.88 options.py(93):         self.select_on_save = False
0.88 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
0.88 options.py(95):         self.permissions = []
0.88 options.py(96):         self.object_name = None
0.88 options.py(97):         self.app_label = app_label
0.88 options.py(98):         self.get_latest_by = None
0.88 options.py(99):         self.order_with_respect_to = None
0.88 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
0.88 options.py(101):         self.required_db_features = []
0.88 options.py(102):         self.required_db_vendor = None
0.88 options.py(103):         self.meta = meta
0.88 options.py(104):         self.pk = None
0.88 options.py(105):         self.auto_field = None
0.88 options.py(106):         self.abstract = False
0.88 options.py(107):         self.managed = True
0.88 options.py(108):         self.proxy = False
0.88 options.py(114):         self.proxy_for_model = None
0.88 options.py(118):         self.concrete_model = None
0.88 options.py(119):         self.swappable = None
0.88 options.py(120):         self.parents = {}
0.88 options.py(121):         self.auto_created = False
0.88 options.py(125):         self.related_fkey_lookups = []
0.88 options.py(128):         self.apps = self.default_apps
0.88 options.py(130):         self.default_related_name = None
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(150):         from django.db import connection
0.88 options.py(151):         from django.db.backends.utils import truncate_name
0.88 options.py(153):         cls._meta = self
0.88 options.py(154):         self.model = cls
0.88 options.py(156):         self.object_name = cls.__name__
0.88 options.py(157):         self.model_name = self.object_name.lower()
0.88 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
0.88 options.py(162):         self.original_attrs = {}
0.88 options.py(165):         if self.meta:
0.88 options.py(166):             meta_attrs = self.meta.__dict__.copy()
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(171):                 if name.startswith('_'):
0.88 options.py(172):                     del meta_attrs[name]
0.88 options.py(167):             for name in self.meta.__dict__:
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(177):                 elif hasattr(self.meta, attr_name):
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(174):                 if attr_name in meta_attrs:
0.88 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
0.88 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
0.88 options.py(173):             for attr_name in DEFAULT_NAMES:
0.88 options.py(181):             self.unique_together = normalize_together(self.unique_together)
0.88 options.py(45):     try:
0.88 options.py(46):         if not option_together:
0.88 options.py(48):         if not isinstance(option_together, (tuple, list)):
0.88 options.py(49):             raise TypeError
0.88 options.py(55):     except TypeError:
0.88 options.py(58):         return option_together
0.88 options.py(182):             self.index_together = normalize_together(self.index_together)
0.88 options.py(45):     try:
0.88 options.py(46):         if not option_together:
0.88 options.py(47):             return ()
0.88 options.py(185):             if not getattr(cls._meta, 'abstract', False):
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(187):                     objs = getattr(self, attr_name, [])
0.88 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.88 options.py(212):         new_objs = []
0.88 options.py(213):         for obj in objs:
0.88 options.py(220):         return new_objs
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(187):                     objs = getattr(self, attr_name, [])
0.88 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
0.88 options.py(212):         new_objs = []
0.88 options.py(213):         for obj in objs:
0.88 options.py(220):         return new_objs
0.88 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
0.88 options.py(192):             if self.verbose_name_plural is None:
0.88 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
0.88 options.py(199):             if meta_attrs != {}:
0.88 options.py(203):         del self.meta
0.88 options.py(206):         if not self.db_table:
0.88 base.py(123):         if not abstract:
0.88 base.py(124):             new_class.add_to_class(
0.88 base.py(125):                 'DoesNotExist',
0.88 base.py(126):                 subclass_exception(
0.88 base.py(127):                     'DoesNotExist',
0.88 base.py(128):                     tuple(
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(130):                     ) or (ObjectDoesNotExist,),
0.88 base.py(131):                     module,
0.88 base.py(132):                     attached_to=new_class))
0.88 base.py(61):     return type(name, bases, {
0.88 base.py(62):         '__module__': module,
0.88 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(328):             setattr(cls, name, value)
0.88 base.py(133):             new_class.add_to_class(
0.88 base.py(134):                 'MultipleObjectsReturned',
0.88 base.py(135):                 subclass_exception(
0.88 base.py(136):                     'MultipleObjectsReturned',
0.88 base.py(137):                     tuple(
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
0.88 base.py(139):                     ) or (MultipleObjectsReturned,),
0.88 base.py(140):                     module,
0.88 base.py(141):                     attached_to=new_class))
0.88 base.py(61):     return type(name, bases, {
0.88 base.py(62):         '__module__': module,
0.88 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(328):             setattr(cls, name, value)
0.88 base.py(142):             if base_meta and not base_meta.abstract:
0.88 base.py(151):         is_proxy = new_class._meta.proxy
0.88 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(298):             self.pk = field
0.88 options.py(299):             field.serialize = False
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(271):         if private:
0.88 options.py(273):         elif field.is_relation and field.many_to_many:
0.88 options.py(276):             bisect.insort(self.local_fields, field)
0.88 options.py(277):             self.setup_pk(field)
0.88 options.py(297):         if not self.pk and field.primary_key:
0.88 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
0.88 options.py(294):             self._expire_cache(reverse=False)
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(161):             new_class.add_to_class(obj_name, obj)
0.88 base.py(325):         if _has_contribute_to_class(value):
0.88 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
0.88 base.py(326):             value.contribute_to_class(cls, name)
0.88 options.py(263):         self.local_managers.append(manager)
0.88 options.py(264):         self._expire_cache()
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 base.py(160):         for obj_name, obj in contributable_attrs.items():
0.88 base.py(164):         new_fields = chain(
0.88 base.py(165):             new_class._meta.local_fields,
0.88 base.py(166):             new_class._meta.local_many_to_many,
0.88 base.py(167):             new_class._meta.private_fields
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(169):         field_names = {f.name for f in new_fields}
0.88 base.py(172):         if is_proxy:
0.88 base.py(192):             new_class._meta.concrete_model = new_class
0.88 base.py(195):         parent_links = {}
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(199):                 continue
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(198):             if not hasattr(base, '_meta'):
0.88 base.py(201):             if base != new_class and not base._meta.abstract:
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(205):                 if isinstance(field, OneToOneField):
0.88 base.py(204):             for field in base._meta.local_fields:
0.88 base.py(196):         for base in reversed([new_class] + parents):
0.88 base.py(210):         inherited_attributes = set()
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
0.88 base.py(216):                 inherited_attributes.update(base.__dict__)
0.88 base.py(217):                 continue
0.88 base.py(212):         for base in new_class.mro():
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
0.88 base.py(312):         if abstract:
0.88 base.py(320):         new_class._prepare()
0.88 base.py(332):         opts = cls._meta
0.88 base.py(333):         opts._prepare(cls)
0.88 options.py(223):         if self.order_with_respect_to:
0.88 options.py(239):             self.order_with_respect_to = None
0.88 options.py(241):         if self.pk is None:
0.88 base.py(335):         if opts.order_with_respect_to:
0.88 base.py(350):         if cls.__doc__ is None:
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 options.py(456):         def is_not_an_m2m_field(f):
0.88 options.py(459):         def is_not_a_generic_relation(f):
0.88 options.py(462):         def is_not_a_generic_foreign_key(f):
0.88 options.py(467):         return make_immutable_fields_list(
0.88 options.py(468):             "fields",
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.88 options.py(773):         topmost_call = seen_models is None
0.88 options.py(774):         if topmost_call:
0.88 options.py(775):             seen_models = set()
0.88 options.py(776):         seen_models.add(self.model)
0.88 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.88 options.py(781):         try:
0.88 options.py(784):             return self._get_fields_cache[cache_key]
0.88 options.py(785):         except KeyError:
0.88 options.py(786):             pass
0.88 options.py(788):         fields = []
0.88 options.py(791):         if include_parents is not False:
0.88 options.py(792):             for parent in self.parents:
0.88 options.py(806):         if reverse and not self.proxy:
0.88 options.py(817):         if forward:
0.88 options.py(818):             fields += self.local_fields
0.88 options.py(819):             fields += self.local_many_to_many
0.88 options.py(825):             if topmost_call:
0.88 options.py(826):                 fields += self.private_fields
0.88 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(833):         self._get_fields_cache[cache_key] = fields
0.88 options.py(834):         return fields
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.88 options.py(457):             return not (f.is_relation and f.many_to_many)
0.88 options.py(460):             return not (f.is_relation and f.one_to_many)
0.88 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.88 options.py(469):             (f for f in self._get_fields(reverse=False)
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
0.88 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 base.py(354):         if get_absolute_url_override:
0.88 base.py(357):         if not opts.managers:
0.88 options.py(365):         managers = []
0.88 options.py(366):         seen_managers = set()
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(370):                 if manager.name in seen_managers:
0.88 options.py(373):                 manager = copy.copy(manager)
0.88 options.py(374):                 manager.model = self.model
0.88 options.py(375):                 seen_managers.add(manager.name)
0.88 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(378):         return make_immutable_fields_list(
0.88 options.py(379):             "managers",
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 base.py(370):         for index in cls._meta.indexes:
0.88 base.py(374):         class_prepared.send(sender=cls)
0.88 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 base.py(322):         return new_class
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.88 options.py(349):             if swapped_for:
0.88 options.py(350):                 try:
0.88 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.88 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.88 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(731):                     delattr(self, cache_key)
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(728):         if forward:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(730):                 if cache_key in self.__dict__:
0.88 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
0.88 options.py(732):         if reverse and not self.abstract:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(734):                 if cache_key in self.__dict__:
0.88 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
0.88 options.py(736):         self._get_fields_cache = {}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(385):         return {manager.name: manager for manager in self.managers}
0.88 options.py(365):         managers = []
0.88 options.py(366):         seen_managers = set()
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(370):                 if manager.name in seen_managers:
0.88 options.py(373):                 manager = copy.copy(manager)
0.88 options.py(374):                 manager.model = self.model
0.88 options.py(375):                 seen_managers.add(manager.name)
0.88 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.88 options.py(369):             for manager in base._meta.local_managers:
0.88 options.py(368):         for depth, base in enumerate(bases):
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.88 options.py(378):         return make_immutable_fields_list(
0.88 options.py(379):             "managers",
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(380):             (m[2] for m in sorted(managers)),
0.88 options.py(385):         return {manager.name: manager for manager in self.managers}
0.88 options.py(385):         return {manager.name: manager for manager in self.managers}
0.88 options.py(347):         if self.swappable:
0.88 options.py(361):         return None
0.88 options.py(564):         try:
0.88 options.py(567):             return self._forward_fields_map[field_name]
0.88 options.py(532):         res = {}
0.88 options.py(533):         fields = self._get_fields(reverse=False)
0.88 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.88 options.py(773):         topmost_call = seen_models is None
0.88 options.py(774):         if topmost_call:
0.88 options.py(775):             seen_models = set()
0.88 options.py(776):         seen_models.add(self.model)
0.88 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.88 options.py(781):         try:
0.88 options.py(784):             return self._get_fields_cache[cache_key]
0.88 options.py(785):         except KeyError:
0.88 options.py(786):             pass
0.88 options.py(788):         fields = []
0.88 options.py(791):         if include_parents is not False:
0.88 options.py(792):             for parent in self.parents:
0.88 options.py(806):         if reverse and not self.proxy:
0.88 options.py(817):         if forward:
0.88 options.py(818):             fields += self.local_fields
0.88 options.py(819):             fields += self.local_many_to_many
0.88 options.py(825):             if topmost_call:
0.88 options.py(826):                 fields += self.private_fields
0.88 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.88 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.88 options.py(833):         self._get_fields_cache[cache_key] = fields
0.88 options.py(834):         return fields
0.88 options.py(534):         for field in fields:
0.88 options.py(535):             res[field.name] = field
0.88 options.py(539):             try:
0.88 options.py(540):                 res[field.attname] = field
0.88 options.py(534):         for field in fields:
0.88 options.py(535):             res[field.name] = field
0.88 options.py(539):             try:
0.88 options.py(540):                 res[field.attname] = field
0.88 options.py(534):         for field in fields:
0.88 options.py(535):             res[field.name] = field
0.88 options.py(539):             try:
0.88 options.py(540):                 res[field.attname] = field
0.88 options.py(534):         for field in fields:
0.88 options.py(543):         return res
0.88 options.py(564):         try:
0.88 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(482):         return make_immutable_fields_list(
0.89 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.89 options.py(456):         def is_not_an_m2m_field(f):
0.89 options.py(459):         def is_not_a_generic_relation(f):
0.89 options.py(462):         def is_not_a_generic_foreign_key(f):
0.89 options.py(467):         return make_immutable_fields_list(
0.89 options.py(468):             "fields",
0.89 options.py(469):             (f for f in self._get_fields(reverse=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(469):             (f for f in self._get_fields(reverse=False)
0.89 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.89 options.py(457):             return not (f.is_relation and f.many_to_many)
0.89 options.py(460):             return not (f.is_relation and f.one_to_many)
0.89 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.89 options.py(469):             (f for f in self._get_fields(reverse=False)
0.89 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.89 options.py(457):             return not (f.is_relation and f.many_to_many)
0.89 options.py(460):             return not (f.is_relation and f.one_to_many)
0.89 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.89 options.py(469):             (f for f in self._get_fields(reverse=False)
0.89 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.89 options.py(457):             return not (f.is_relation and f.many_to_many)
0.89 options.py(460):             return not (f.is_relation and f.one_to_many)
0.89 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.89 options.py(469):             (f for f in self._get_fields(reverse=False)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.89 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.89 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.89 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 base.py(408):         cls = self.__class__
0.89 base.py(409):         opts = self._meta
0.89 base.py(410):         _setattr = setattr
0.89 base.py(411):         _DEFERRED = DEFERRED
0.89 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.89 base.py(416):         self._state = ModelState()
0.89 base.py(422):         if len(args) > len(opts.concrete_fields):
0.89 base.py(426):         if not kwargs:
0.89 base.py(438):             fields_iter = iter(opts.fields)
0.89 base.py(439):             for val, field in zip(args, fields_iter):
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(449):             is_related_object = False
0.89 base.py(451):             if field.attname not in kwargs and field.column is None:
0.89 base.py(453):             if kwargs:
0.89 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.89 base.py(466):                     try:
0.89 base.py(467):                         val = kwargs.pop(field.attname)
0.89 base.py(468):                     except KeyError:
0.89 base.py(473):                         val = field.get_default()
0.89 base.py(477):             if is_related_object:
0.89 base.py(485):                 if val is not _DEFERRED:
0.89 base.py(486):                     _setattr(self, field.attname, val)
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(449):             is_related_object = False
0.89 base.py(451):             if field.attname not in kwargs and field.column is None:
0.89 base.py(453):             if kwargs:
0.89 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.89 base.py(466):                     try:
0.89 base.py(467):                         val = kwargs.pop(field.attname)
0.89 base.py(477):             if is_related_object:
0.89 base.py(485):                 if val is not _DEFERRED:
0.89 base.py(486):                     _setattr(self, field.attname, val)
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(449):             is_related_object = False
0.89 base.py(451):             if field.attname not in kwargs and field.column is None:
0.89 base.py(453):             if kwargs:
0.89 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.89 base.py(466):                     try:
0.89 base.py(467):                         val = kwargs.pop(field.attname)
0.89 base.py(477):             if is_related_object:
0.89 base.py(485):                 if val is not _DEFERRED:
0.89 base.py(486):                     _setattr(self, field.attname, val)
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(488):         if kwargs:
0.89 base.py(502):         super().__init__()
0.89 base.py(503):         post_init.send(sender=cls, instance=self)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(607):         result = OrderedSet(self.parents)
0.89 options.py(608):         for parent in self.parents:
0.89 options.py(611):         return list(result)
0.89 base.py(568):         meta = meta or self._meta
0.89 base.py(569):         return getattr(self, meta.pk.attname)
0.89 base.py(572):         for parent_link in self._meta.parents.values():
0.89 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.89 base.py(568):         meta = meta or self._meta
0.89 base.py(569):         return getattr(self, meta.pk.attname)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.89 base.py(513):         new = cls(*values)
0.89 base.py(408):         cls = self.__class__
0.89 base.py(409):         opts = self._meta
0.89 base.py(410):         _setattr = setattr
0.89 base.py(411):         _DEFERRED = DEFERRED
0.89 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.89 base.py(416):         self._state = ModelState()
0.89 base.py(422):         if len(args) > len(opts.concrete_fields):
0.89 base.py(426):         if not kwargs:
0.89 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(488):         if kwargs:
0.89 base.py(502):         super().__init__()
0.89 base.py(503):         post_init.send(sender=cls, instance=self)
0.89 base.py(514):         new._state.adding = False
0.89 base.py(515):         new._state.db = db
0.89 base.py(516):         return new
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(607):         result = OrderedSet(self.parents)
0.89 options.py(608):         for parent in self.parents:
0.89 options.py(611):         return list(result)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.89 base.py(513):         new = cls(*values)
0.89 base.py(408):         cls = self.__class__
0.89 base.py(409):         opts = self._meta
0.89 base.py(410):         _setattr = setattr
0.89 base.py(411):         _DEFERRED = DEFERRED
0.89 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.89 base.py(416):         self._state = ModelState()
0.89 base.py(422):         if len(args) > len(opts.concrete_fields):
0.89 base.py(426):         if not kwargs:
0.89 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(433):                 if val is _DEFERRED:
0.89 base.py(435):                 _setattr(self, field.attname, val)
0.89 base.py(432):             for val, field in zip(args, fields_iter):
0.89 base.py(448):         for field in fields_iter:
0.89 base.py(488):         if kwargs:
0.89 base.py(502):         super().__init__()
0.89 base.py(503):         post_init.send(sender=cls, instance=self)
0.89 base.py(514):         new._state.adding = False
0.89 base.py(515):         new._state.db = db
0.89 base.py(516):         return new
0.89 base.py(535):         if self.pk is None:
0.89 base.py(568):         meta = meta or self._meta
0.89 base.py(569):         return getattr(self, meta.pk.attname)
0.89 base.py(537):         return hash(self.pk)
0.89 base.py(568):         meta = meta or self._meta
0.89 base.py(569):         return getattr(self, meta.pk.attname)
0.89 options.py(335):         with override(None):
0.89 options.py(336):             return str(self.verbose_name)
0.89 options.py(335):         with override(None):
0.89 options.py(336):             return str(self.verbose_name)
0.89 options.py(335):         with override(None):
0.89 options.py(336):             return str(self.verbose_name)
0.89 options.py(335):         with override(None):
0.89 options.py(336):             return str(self.verbose_name)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(385):         return {manager.name: manager for manager in self.managers}
0.89 options.py(365):         managers = []
0.89 options.py(366):         seen_managers = set()
0.89 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.89 options.py(368):         for depth, base in enumerate(bases):
0.89 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.89 options.py(369):             for manager in base._meta.local_managers:
0.89 options.py(370):                 if manager.name in seen_managers:
0.89 options.py(373):                 manager = copy.copy(manager)
0.89 options.py(374):                 manager.model = self.model
0.89 options.py(375):                 seen_managers.add(manager.name)
0.89 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.89 options.py(369):             for manager in base._meta.local_managers:
0.89 options.py(368):         for depth, base in enumerate(bases):
0.89 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.89 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.89 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.89 options.py(378):         return make_immutable_fields_list(
0.89 options.py(379):             "managers",
0.89 options.py(380):             (m[2] for m in sorted(managers)),
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(380):             (m[2] for m in sorted(managers)),
0.89 options.py(380):             (m[2] for m in sorted(managers)),
0.89 options.py(385):         return {manager.name: manager for manager in self.managers}
0.89 options.py(385):         return {manager.name: manager for manager in self.managers}
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(532):         res = {}
0.89 options.py(533):         fields = self._get_fields(reverse=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(792):             for parent in self.parents:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(534):         for field in fields:
0.89 options.py(535):             res[field.name] = field
0.89 options.py(539):             try:
0.89 options.py(540):                 res[field.attname] = field
0.89 options.py(534):         for field in fields:
0.89 options.py(535):             res[field.name] = field
0.89 options.py(539):             try:
0.89 options.py(540):                 res[field.attname] = field
0.89 options.py(534):         for field in fields:
0.89 options.py(535):             res[field.name] = field
0.89 options.py(539):             try:
0.89 options.py(540):                 res[field.attname] = field
0.89 options.py(534):         for field in fields:
0.89 options.py(535):             res[field.name] = field
0.89 options.py(539):             try:
0.89 options.py(540):                 res[field.attname] = field
0.89 options.py(534):         for field in fields:
0.89 options.py(543):         return res
0.89 options.py(564):         try:
0.89 options.py(567):             return self._forward_fields_map[field_name]
0.89 options.py(568):         except KeyError:
0.89 options.py(571):             if not self.apps.models_ready:
0.89 options.py(578):         try:
0.89 options.py(581):             return self.fields_map[field_name]
0.89 options.py(547):         res = {}
0.89 options.py(548):         fields = self._get_fields(forward=False, include_hidden=True)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(792):             for parent in self.parents:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(810):             all_fields = self._relation_tree
0.89 options.py(723):         return self._populate_directed_relation_graph()
0.89 options.py(692):         related_objects_graph = defaultdict(list)
0.89 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.89 options.py(349):             if swapped_for:
0.89 options.py(350):                 try:
0.89 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.89 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.89 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(347):         if self.swappable:
0.89 options.py(361):         return None
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.89 options.py(773):         topmost_call = seen_models is None
0.89 options.py(774):         if topmost_call:
0.89 options.py(775):             seen_models = set()
0.89 options.py(776):         seen_models.add(self.model)
0.89 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.89 options.py(781):         try:
0.89 options.py(784):             return self._get_fields_cache[cache_key]
0.89 options.py(785):         except KeyError:
0.89 options.py(786):             pass
0.89 options.py(788):         fields = []
0.89 options.py(791):         if include_parents is not False:
0.89 options.py(806):         if reverse and not self.proxy:
0.89 options.py(817):         if forward:
0.89 options.py(818):             fields += self.local_fields
0.89 options.py(819):             fields += self.local_many_to_many
0.89 options.py(825):             if topmost_call:
0.89 options.py(826):                 fields += self.private_fields
0.89 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.89 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.89 options.py(833):         self._get_fields_cache[cache_key] = fields
0.89 options.py(834):         return fields
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(703):                 if f.is_relation and f.related_model is not None
0.89 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.89 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.89 options.py(705):             for f in fields_with_relations:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.89 options.py(695):         for model in all_models:
0.89 options.py(696):             opts = model._meta
0.89 options.py(699):             if opts.abstract:
0.89 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(785):         except KeyError:
0.90 options.py(786):             pass
0.90 options.py(788):         fields = []
0.90 options.py(791):         if include_parents is not False:
0.90 options.py(806):         if reverse and not self.proxy:
0.90 options.py(817):         if forward:
0.90 options.py(818):             fields += self.local_fields
0.90 options.py(819):             fields += self.local_many_to_many
0.90 options.py(825):             if topmost_call:
0.90 options.py(826):                 fields += self.private_fields
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.90 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.90 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(695):         for model in all_models:
0.90 options.py(696):             opts = model._meta
0.90 options.py(699):             if opts.abstract:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(785):         except KeyError:
0.90 options.py(786):             pass
0.90 options.py(788):         fields = []
0.90 options.py(791):         if include_parents is not False:
0.90 options.py(806):         if reverse and not self.proxy:
0.90 options.py(817):         if forward:
0.90 options.py(818):             fields += self.local_fields
0.90 options.py(819):             fields += self.local_many_to_many
0.90 options.py(825):             if topmost_call:
0.90 options.py(826):                 fields += self.private_fields
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.90 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(706):                 if not isinstance(f.remote_field.model, str):
0.90 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(695):         for model in all_models:
0.90 options.py(696):             opts = model._meta
0.90 options.py(699):             if opts.abstract:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(785):         except KeyError:
0.90 options.py(786):             pass
0.90 options.py(788):         fields = []
0.90 options.py(791):         if include_parents is not False:
0.90 options.py(806):         if reverse and not self.proxy:
0.90 options.py(817):         if forward:
0.90 options.py(818):             fields += self.local_fields
0.90 options.py(819):             fields += self.local_many_to_many
0.90 options.py(825):             if topmost_call:
0.90 options.py(826):                 fields += self.private_fields
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(695):         for model in all_models:
0.90 options.py(696):             opts = model._meta
0.90 options.py(699):             if opts.abstract:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(785):         except KeyError:
0.90 options.py(786):             pass
0.90 options.py(788):         fields = []
0.90 options.py(791):         if include_parents is not False:
0.90 options.py(806):         if reverse and not self.proxy:
0.90 options.py(817):         if forward:
0.90 options.py(818):             fields += self.local_fields
0.90 options.py(819):             fields += self.local_many_to_many
0.90 options.py(825):             if topmost_call:
0.90 options.py(826):                 fields += self.private_fields
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(695):         for model in all_models:
0.90 options.py(696):             opts = model._meta
0.90 options.py(699):             if opts.abstract:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(785):         except KeyError:
0.90 options.py(786):             pass
0.90 options.py(788):         fields = []
0.90 options.py(791):         if include_parents is not False:
0.90 options.py(806):         if reverse and not self.proxy:
0.90 options.py(817):         if forward:
0.90 options.py(818):             fields += self.local_fields
0.90 options.py(819):             fields += self.local_many_to_many
0.90 options.py(825):             if topmost_call:
0.90 options.py(826):                 fields += self.private_fields
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(705):             for f in fields_with_relations:
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(703):                 if f.is_relation and f.related_model is not None
0.90 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
0.90 options.py(695):         for model in all_models:
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
0.90 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
0.90 options.py(709):         for model in all_models:
0.90 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
0.90 options.py(811):             for field in all_fields:
0.90 options.py(814):                 if include_hidden or not field.remote_field.hidden:
0.90 options.py(815):                     fields.append(field.remote_field)
0.90 options.py(811):             for field in all_fields:
0.90 options.py(817):         if forward:
0.90 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(833):         self._get_fields_cache[cache_key] = fields
0.90 options.py(834):         return fields
0.90 options.py(549):         for field in fields:
0.90 options.py(550):             res[field.name] = field
0.90 options.py(554):             try:
0.90 options.py(555):                 res[field.attname] = field
0.90 options.py(556):             except AttributeError:
0.90 options.py(557):                 pass
0.90 options.py(549):         for field in fields:
0.90 options.py(558):         return res
0.90 options.py(582):         except KeyError:
0.90 options.py(583):             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 options.py(482):         return make_immutable_fields_list(
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 options.py(456):         def is_not_an_m2m_field(f):
0.90 options.py(459):         def is_not_a_generic_relation(f):
0.90 options.py(462):         def is_not_a_generic_foreign_key(f):
0.90 options.py(467):         return make_immutable_fields_list(
0.90 options.py(468):             "fields",
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.90 options.py(773):         topmost_call = seen_models is None
0.90 options.py(774):         if topmost_call:
0.90 options.py(775):             seen_models = set()
0.90 options.py(776):         seen_models.add(self.model)
0.90 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.90 options.py(781):         try:
0.90 options.py(784):             return self._get_fields_cache[cache_key]
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.90 options.py(457):             return not (f.is_relation and f.many_to_many)
0.90 options.py(460):             return not (f.is_relation and f.one_to_many)
0.90 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.90 options.py(457):             return not (f.is_relation and f.many_to_many)
0.90 options.py(460):             return not (f.is_relation and f.one_to_many)
0.90 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.90 options.py(457):             return not (f.is_relation and f.many_to_many)
0.90 options.py(460):             return not (f.is_relation and f.one_to_many)
0.90 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.90 options.py(457):             return not (f.is_relation and f.many_to_many)
0.90 options.py(460):             return not (f.is_relation and f.one_to_many)
0.90 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.90 options.py(469):             (f for f in self._get_fields(reverse=False)
0.90 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(455):                     try:
0.90 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.90 base.py(458):                         is_related_object = True
0.90 base.py(477):             if is_related_object:
0.90 base.py(482):                 if rel_obj is not _DEFERRED:
0.90 base.py(483):                     _setattr(self, field.name, rel_obj)
0.90 base.py(387):         if instance is None:
0.90 base.py(389):         res = instance.fields_cache = {}
0.90 base.py(390):         return res
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(455):                     try:
0.90 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.90 base.py(458):                         is_related_object = True
0.90 base.py(477):             if is_related_object:
0.90 base.py(482):                 if rel_obj is not _DEFERRED:
0.90 base.py(483):                     _setattr(self, field.name, rel_obj)
0.90 base.py(387):         if instance is None:
0.90 base.py(389):         res = instance.fields_cache = {}
0.90 base.py(390):         return res
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(455):                     try:
0.90 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.90 base.py(458):                         is_related_object = True
0.90 base.py(477):             if is_related_object:
0.90 base.py(482):                 if rel_obj is not _DEFERRED:
0.90 base.py(483):                     _setattr(self, field.name, rel_obj)
0.90 base.py(387):         if instance is None:
0.90 base.py(389):         res = instance.fields_cache = {}
0.90 base.py(390):         return res
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(455):                     try:
0.90 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.90 base.py(458):                         is_related_object = True
0.90 base.py(477):             if is_related_object:
0.90 base.py(482):                 if rel_obj is not _DEFERRED:
0.90 base.py(483):                     _setattr(self, field.name, rel_obj)
0.90 base.py(387):         if instance is None:
0.90 base.py(389):         res = instance.fields_cache = {}
0.90 base.py(390):         return res
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(607):         result = OrderedSet(self.parents)
0.90 options.py(608):         for parent in self.parents:
0.90 options.py(611):         return list(result)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.90 options.py(349):             if swapped_for:
0.90 options.py(350):                 try:
0.90 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.90 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.90 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.90 options.py(361):         return None
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(438):             fields_iter = iter(opts.fields)
0.90 base.py(439):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(468):                     except KeyError:
0.90 base.py(473):                         val = field.get_default()
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(449):             is_related_object = False
0.90 base.py(451):             if field.attname not in kwargs and field.column is None:
0.90 base.py(453):             if kwargs:
0.90 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.90 base.py(466):                     try:
0.90 base.py(467):                         val = kwargs.pop(field.attname)
0.90 base.py(477):             if is_related_object:
0.90 base.py(485):                 if val is not _DEFERRED:
0.90 base.py(486):                     _setattr(self, field.attname, val)
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(607):         result = OrderedSet(self.parents)
0.90 options.py(608):         for parent in self.parents:
0.90 options.py(611):         return list(result)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(572):         for parent_link in self._meta.parents.values():
0.90 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.90 base.py(513):         new = cls(*values)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(514):         new._state.adding = False
0.90 base.py(515):         new._state.db = db
0.90 base.py(516):         return new
0.90 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.90 base.py(513):         new = cls(*values)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(514):         new._state.adding = False
0.90 base.py(515):         new._state.db = db
0.90 base.py(516):         return new
0.90 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.90 base.py(513):         new = cls(*values)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(514):         new._state.adding = False
0.90 base.py(515):         new._state.db = db
0.90 base.py(516):         return new
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.90 options.py(349):             if swapped_for:
0.90 options.py(350):                 try:
0.90 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.90 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.90 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(607):         result = OrderedSet(self.parents)
0.90 options.py(608):         for parent in self.parents:
0.90 options.py(611):         return list(result)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.90 base.py(513):         new = cls(*values)
0.90 base.py(408):         cls = self.__class__
0.90 base.py(409):         opts = self._meta
0.90 base.py(410):         _setattr = setattr
0.90 base.py(411):         _DEFERRED = DEFERRED
0.90 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.90 base.py(416):         self._state = ModelState()
0.90 base.py(422):         if len(args) > len(opts.concrete_fields):
0.90 base.py(426):         if not kwargs:
0.90 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(433):                 if val is _DEFERRED:
0.90 base.py(435):                 _setattr(self, field.attname, val)
0.90 base.py(432):             for val, field in zip(args, fields_iter):
0.90 base.py(448):         for field in fields_iter:
0.90 base.py(488):         if kwargs:
0.90 base.py(502):         super().__init__()
0.90 base.py(503):         post_init.send(sender=cls, instance=self)
0.90 base.py(514):         new._state.adding = False
0.90 base.py(515):         new._state.db = db
0.90 base.py(516):         return new
0.90 base.py(535):         if self.pk is None:
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 base.py(537):         return hash(self.pk)
0.90 base.py(568):         meta = meta or self._meta
0.90 base.py(569):         return getattr(self, meta.pk.attname)
0.90 options.py(335):         with override(None):
0.90 options.py(336):             return str(self.verbose_name)
0.90 options.py(335):         with override(None):
0.90 options.py(336):             return str(self.verbose_name)
0.90 options.py(335):         with override(None):
0.90 options.py(336):             return str(self.verbose_name)
0.90 options.py(335):         with override(None):
0.90 options.py(336):             return str(self.verbose_name)
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(347):         if self.swappable:
0.90 options.py(361):         return None
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.90 options.py(564):         try:
0.90 options.py(567):             return self._forward_fields_map[field_name]
0.91 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.91 base.py(513):         new = cls(*values)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(514):         new._state.adding = False
0.91 base.py(515):         new._state.db = db
0.91 base.py(516):         return new
0.91 base.py(535):         if self.pk is None:
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(537):         return hash(self.pk)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(347):         if self.swappable:
0.91 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
0.91 options.py(349):             if swapped_for:
0.91 options.py(350):                 try:
0.91 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
0.91 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
0.91 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
0.91 options.py(361):         return None
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.91 base.py(513):         new = cls(*values)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(433):                 if val is _DEFERRED:
0.91 base.py(435):                 _setattr(self, field.attname, val)
0.91 base.py(432):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(514):         new._state.adding = False
0.91 base.py(515):         new._state.db = db
0.91 base.py(516):         return new
0.91 base.py(535):         if self.pk is None:
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(537):         return hash(self.pk)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(335):         with override(None):
0.91 options.py(336):             return str(self.verbose_name)
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(568):         except KeyError:
0.91 options.py(571):             if not self.apps.models_ready:
0.91 options.py(578):         try:
0.91 options.py(581):             return self.fields_map[field_name]
0.91 options.py(582):         except KeyError:
0.91 options.py(583):             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(455):                     try:
0.91 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.91 base.py(458):                         is_related_object = True
0.91 base.py(477):             if is_related_object:
0.91 base.py(482):                 if rel_obj is not _DEFERRED:
0.91 base.py(483):                     _setattr(self, field.name, rel_obj)
0.91 base.py(387):         if instance is None:
0.91 base.py(389):         res = instance.fields_cache = {}
0.91 base.py(390):         return res
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(607):         result = OrderedSet(self.parents)
0.91 options.py(608):         for parent in self.parents:
0.91 options.py(611):         return list(result)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(564):         try:
0.91 options.py(567):             return self._forward_fields_map[field_name]
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 base.py(408):         cls = self.__class__
0.91 base.py(409):         opts = self._meta
0.91 base.py(410):         _setattr = setattr
0.91 base.py(411):         _DEFERRED = DEFERRED
0.91 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.91 base.py(416):         self._state = ModelState()
0.91 base.py(422):         if len(args) > len(opts.concrete_fields):
0.91 base.py(426):         if not kwargs:
0.91 base.py(438):             fields_iter = iter(opts.fields)
0.91 base.py(439):             for val, field in zip(args, fields_iter):
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(468):                     except KeyError:
0.91 base.py(473):                         val = field.get_default()
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(449):             is_related_object = False
0.91 base.py(451):             if field.attname not in kwargs and field.column is None:
0.91 base.py(453):             if kwargs:
0.91 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.91 base.py(466):                     try:
0.91 base.py(467):                         val = kwargs.pop(field.attname)
0.91 base.py(477):             if is_related_object:
0.91 base.py(485):                 if val is not _DEFERRED:
0.91 base.py(486):                     _setattr(self, field.attname, val)
0.91 base.py(448):         for field in fields_iter:
0.91 base.py(488):         if kwargs:
0.91 base.py(502):         super().__init__()
0.91 base.py(503):         post_init.send(sender=cls, instance=self)
0.91 options.py(347):         if self.swappable:
0.91 options.py(361):         return None
0.91 options.py(607):         result = OrderedSet(self.parents)
0.91 options.py(608):         for parent in self.parents:
0.91 options.py(611):         return list(result)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.91 base.py(572):         for parent_link in self._meta.parents.values():
0.91 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.91 base.py(568):         meta = meta or self._meta
0.91 base.py(569):         return getattr(self, meta.pk.attname)
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.92 base.py(513):         new = cls(*values)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(514):         new._state.adding = False
0.92 base.py(515):         new._state.db = db
0.92 base.py(516):         return new
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(607):         result = OrderedSet(self.parents)
0.92 options.py(608):         for parent in self.parents:
0.92 options.py(611):         return list(result)
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.92 base.py(513):         new = cls(*values)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(433):                 if val is _DEFERRED:
0.92 base.py(435):                 _setattr(self, field.attname, val)
0.92 base.py(432):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(514):         new._state.adding = False
0.92 base.py(515):         new._state.db = db
0.92 base.py(516):         return new
0.92 base.py(535):         if self.pk is None:
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(537):         return hash(self.pk)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 options.py(335):         with override(None):
0.92 options.py(336):             return str(self.verbose_name)
0.92 options.py(335):         with override(None):
0.92 options.py(336):             return str(self.verbose_name)
0.92 options.py(335):         with override(None):
0.92 options.py(336):             return str(self.verbose_name)
0.92 options.py(335):         with override(None):
0.92 options.py(336):             return str(self.verbose_name)
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(568):         except KeyError:
0.92 options.py(571):             if not self.apps.models_ready:
0.92 options.py(578):         try:
0.92 options.py(581):             return self.fields_map[field_name]
0.92 options.py(582):         except KeyError:
0.92 options.py(583):             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 options.py(564):         try:
0.92 options.py(567):             return self._forward_fields_map[field_name]
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(438):             fields_iter = iter(opts.fields)
0.92 base.py(439):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(468):                     except KeyError:
0.92 base.py(473):                         val = field.get_default()
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(455):                     try:
0.92 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.92 base.py(458):                         is_related_object = True
0.92 base.py(477):             if is_related_object:
0.92 base.py(482):                 if rel_obj is not _DEFERRED:
0.92 base.py(483):                     _setattr(self, field.name, rel_obj)
0.92 base.py(387):         if instance is None:
0.92 base.py(389):         res = instance.fields_cache = {}
0.92 base.py(390):         return res
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(438):             fields_iter = iter(opts.fields)
0.92 base.py(439):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(468):                     except KeyError:
0.92 base.py(473):                         val = field.get_default()
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(455):                     try:
0.92 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.92 base.py(458):                         is_related_object = True
0.92 base.py(477):             if is_related_object:
0.92 base.py(482):                 if rel_obj is not _DEFERRED:
0.92 base.py(483):                     _setattr(self, field.name, rel_obj)
0.92 base.py(387):         if instance is None:
0.92 base.py(389):         res = instance.fields_cache = {}
0.92 base.py(390):         return res
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(438):             fields_iter = iter(opts.fields)
0.92 base.py(439):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(468):                     except KeyError:
0.92 base.py(473):                         val = field.get_default()
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(455):                     try:
0.92 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.92 base.py(458):                         is_related_object = True
0.92 base.py(477):             if is_related_object:
0.92 base.py(482):                 if rel_obj is not _DEFERRED:
0.92 base.py(483):                     _setattr(self, field.name, rel_obj)
0.92 base.py(387):         if instance is None:
0.92 base.py(389):         res = instance.fields_cache = {}
0.92 base.py(390):         return res
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 base.py(426):         if not kwargs:
0.92 base.py(438):             fields_iter = iter(opts.fields)
0.92 base.py(439):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(468):                     except KeyError:
0.92 base.py(473):                         val = field.get_default()
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(455):                     try:
0.92 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.92 base.py(458):                         is_related_object = True
0.92 base.py(477):             if is_related_object:
0.92 base.py(482):                 if rel_obj is not _DEFERRED:
0.92 base.py(483):                     _setattr(self, field.name, rel_obj)
0.92 base.py(387):         if instance is None:
0.92 base.py(389):         res = instance.fields_cache = {}
0.92 base.py(390):         return res
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(607):         result = OrderedSet(self.parents)
0.92 options.py(608):         for parent in self.parents:
0.92 options.py(611):         return list(result)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(572):         for parent_link in self._meta.parents.values():
0.92 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(572):         for parent_link in self._meta.parents.values():
0.92 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(572):         for parent_link in self._meta.parents.values():
0.92 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(572):         for parent_link in self._meta.parents.values():
0.92 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 options.py(347):         if self.swappable:
0.92 options.py(361):         return None
0.92 options.py(385):         return {manager.name: manager for manager in self.managers}
0.92 options.py(365):         managers = []
0.92 options.py(366):         seen_managers = set()
0.92 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.92 options.py(368):         for depth, base in enumerate(bases):
0.92 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.92 options.py(369):             for manager in base._meta.local_managers:
0.92 options.py(370):                 if manager.name in seen_managers:
0.92 options.py(373):                 manager = copy.copy(manager)
0.92 options.py(374):                 manager.model = self.model
0.92 options.py(375):                 seen_managers.add(manager.name)
0.92 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.92 options.py(369):             for manager in base._meta.local_managers:
0.92 options.py(368):         for depth, base in enumerate(bases):
0.92 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.92 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.92 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.92 options.py(378):         return make_immutable_fields_list(
0.92 options.py(379):             "managers",
0.92 options.py(380):             (m[2] for m in sorted(managers)),
0.92 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.92 options.py(380):             (m[2] for m in sorted(managers)),
0.92 options.py(380):             (m[2] for m in sorted(managers)),
0.92 options.py(385):         return {manager.name: manager for manager in self.managers}
0.92 options.py(385):         return {manager.name: manager for manager in self.managers}
0.92 base.py(408):         cls = self.__class__
0.92 base.py(409):         opts = self._meta
0.92 base.py(410):         _setattr = setattr
0.92 base.py(411):         _DEFERRED = DEFERRED
0.92 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.92 base.py(416):         self._state = ModelState()
0.92 base.py(422):         if len(args) > len(opts.concrete_fields):
0.92 options.py(482):         return make_immutable_fields_list(
0.92 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.92 options.py(456):         def is_not_an_m2m_field(f):
0.92 options.py(459):         def is_not_a_generic_relation(f):
0.92 options.py(462):         def is_not_a_generic_foreign_key(f):
0.92 options.py(467):         return make_immutable_fields_list(
0.92 options.py(468):             "fields",
0.92 options.py(469):             (f for f in self._get_fields(reverse=False)
0.92 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.92 options.py(773):         topmost_call = seen_models is None
0.92 options.py(774):         if topmost_call:
0.92 options.py(775):             seen_models = set()
0.92 options.py(776):         seen_models.add(self.model)
0.92 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.92 options.py(781):         try:
0.92 options.py(784):             return self._get_fields_cache[cache_key]
0.92 options.py(785):         except KeyError:
0.92 options.py(786):             pass
0.92 options.py(788):         fields = []
0.92 options.py(791):         if include_parents is not False:
0.92 options.py(792):             for parent in self.parents:
0.92 options.py(806):         if reverse and not self.proxy:
0.92 options.py(817):         if forward:
0.92 options.py(818):             fields += self.local_fields
0.92 options.py(819):             fields += self.local_many_to_many
0.92 options.py(825):             if topmost_call:
0.92 options.py(826):                 fields += self.private_fields
0.92 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.92 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.92 options.py(833):         self._get_fields_cache[cache_key] = fields
0.92 options.py(834):         return fields
0.92 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.92 options.py(469):             (f for f in self._get_fields(reverse=False)
0.92 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.92 options.py(457):             return not (f.is_relation and f.many_to_many)
0.92 options.py(460):             return not (f.is_relation and f.one_to_many)
0.92 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.92 options.py(469):             (f for f in self._get_fields(reverse=False)
0.92 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.92 options.py(457):             return not (f.is_relation and f.many_to_many)
0.92 options.py(460):             return not (f.is_relation and f.one_to_many)
0.92 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.92 options.py(469):             (f for f in self._get_fields(reverse=False)
0.92 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.92 options.py(457):             return not (f.is_relation and f.many_to_many)
0.92 options.py(460):             return not (f.is_relation and f.one_to_many)
0.92 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.92 options.py(469):             (f for f in self._get_fields(reverse=False)
0.92 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.92 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.92 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.92 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.92 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.92 base.py(426):         if not kwargs:
0.92 base.py(438):             fields_iter = iter(opts.fields)
0.92 base.py(439):             for val, field in zip(args, fields_iter):
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(468):                     except KeyError:
0.92 base.py(473):                         val = field.get_default()
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(449):             is_related_object = False
0.92 base.py(451):             if field.attname not in kwargs and field.column is None:
0.92 base.py(453):             if kwargs:
0.92 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.92 base.py(466):                     try:
0.92 base.py(467):                         val = kwargs.pop(field.attname)
0.92 base.py(477):             if is_related_object:
0.92 base.py(485):                 if val is not _DEFERRED:
0.92 base.py(486):                     _setattr(self, field.attname, val)
0.92 base.py(448):         for field in fields_iter:
0.92 base.py(488):         if kwargs:
0.92 base.py(489):             property_names = opts._property_names
0.92 options.py(839):         names = []
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(843):                 names.append(name)
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(841):             attr = inspect.getattr_static(self.model, name)
0.92 options.py(842):             if isinstance(attr, property):
0.92 options.py(840):         for name in dir(self.model):
0.92 options.py(844):         return frozenset(names)
0.92 base.py(490):             for prop in tuple(kwargs):
0.92 base.py(491):                 try:
0.92 base.py(494):                     if prop in property_names or opts.get_field(prop):
0.92 base.py(495):                         if kwargs[prop] is not _DEFERRED:
0.92 base.py(496):                             _setattr(self, prop, kwargs[prop])
0.92 base.py(572):         for parent_link in self._meta.parents.values():
0.92 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.92 base.py(497):                         del kwargs[prop]
0.92 base.py(490):             for prop in tuple(kwargs):
0.92 base.py(500):             for kwarg in kwargs:
0.92 base.py(502):         super().__init__()
0.92 base.py(503):         post_init.send(sender=cls, instance=self)
0.92 base.py(679):         for field in self._meta.concrete_fields:
0.92 base.py(682):             if field.is_relation and field.is_cached(self):
0.92 base.py(679):         for field in self._meta.concrete_fields:
0.92 base.py(682):             if field.is_relation and field.is_cached(self):
0.92 base.py(679):         for field in self._meta.concrete_fields:
0.92 base.py(682):             if field.is_relation and field.is_cached(self):
0.92 base.py(679):         for field in self._meta.concrete_fields:
0.92 base.py(709):         using = using or router.db_for_write(self.__class__, instance=self)
0.92 base.py(710):         if force_insert and (force_update or update_fields):
0.92 base.py(713):         deferred_fields = self.get_deferred_fields()
0.92 base.py(583):         return {
0.92 base.py(584):             f.attname for f in self._meta.concrete_fields
0.92 base.py(583):         return {
0.92 base.py(584):             f.attname for f in self._meta.concrete_fields
0.92 base.py(585):             if f.attname not in self.__dict__
0.92 base.py(583):         return {
0.92 base.py(584):             f.attname for f in self._meta.concrete_fields
0.92 base.py(585):             if f.attname not in self.__dict__
0.92 base.py(583):         return {
0.92 base.py(584):             f.attname for f in self._meta.concrete_fields
0.92 base.py(585):             if f.attname not in self.__dict__
0.92 base.py(583):         return {
0.92 base.py(714):         if update_fields is not None:
0.92 base.py(740):         elif not force_insert and deferred_fields and using == self._state.db:
0.92 base.py(749):         self.save_base(using=using, force_insert=force_insert,
0.92 base.py(750):                        force_update=force_update, update_fields=update_fields)
0.92 base.py(764):         using = using or router.db_for_write(self.__class__, instance=self)
0.92 base.py(765):         assert not (force_insert and (force_update or update_fields))
0.92 base.py(766):         assert update_fields is None or update_fields
0.92 base.py(767):         cls = origin = self.__class__
0.92 base.py(769):         if cls._meta.proxy:
0.92 base.py(771):         meta = cls._meta
0.92 base.py(772):         if not meta.auto_created:
0.92 base.py(773):             pre_save.send(
0.92 base.py(774):                 sender=origin, instance=self, raw=raw, using=using,
0.92 base.py(775):                 update_fields=update_fields,
0.92 base.py(778):         if meta.parents:
0.92 base.py(781):             context_manager = transaction.mark_for_rollback_on_error(using=using)
0.92 base.py(782):         with context_manager:
0.92 base.py(783):             parent_inserted = False
0.92 base.py(784):             if not raw:
0.92 base.py(785):                 parent_inserted = self._save_parents(cls, using, update_fields)
0.92 base.py(806):         meta = cls._meta
0.92 base.py(807):         inserted = False
0.92 base.py(808):         for parent, field in meta.parents.items():
0.92 base.py(830):         return inserted
0.92 base.py(786):             updated = self._save_table(
0.92 base.py(787):                 raw, cls, force_insert or parent_inserted,
0.92 base.py(788):                 force_update, using, update_fields,
0.92 base.py(838):         meta = cls._meta
0.92 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.92 options.py(495):         return make_immutable_fields_list(
0.92 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.92 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.92 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.92 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.92 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.92 options.py(496):             "local_concrete_fields", (f for f in self.local_fields if f.concrete)
0.92 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.92 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.92 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.92 base.py(839):         non_pks = [f for f in meta.local_concrete_fields if not f.primary_key]
0.92 base.py(841):         if update_fields:
0.92 base.py(845):         pk_val = self._get_pk_val(meta)
0.92 base.py(568):         meta = meta or self._meta
0.92 base.py(569):         return getattr(self, meta.pk.attname)
0.92 base.py(846):         if pk_val is None:
0.92 base.py(849):         pk_set = pk_val is not None
0.92 base.py(850):         if not pk_set and (force_update or update_fields):
0.92 base.py(852):         updated = False
0.92 base.py(855):             not raw and
0.92 base.py(856):             not force_insert and
0.92 base.py(857):             self._state.adding and
0.92 base.py(858):             self._meta.pk.default and
0.92 base.py(859):             self._meta.pk.default is not NOT_PROVIDED
0.92 base.py(863):         if pk_set and not force_insert:
0.92 base.py(864):             base_qs = cls._base_manager.using(using)
0.92 base.py(378):         return cls._meta.base_manager
0.92 options.py(389):         base_manager_name = self.base_manager_name
0.92 options.py(390):         if not base_manager_name:
0.92 options.py(392):             for parent in self.model.mro()[1:]:
0.92 options.py(393):                 if hasattr(parent, '_meta'):
0.92 options.py(392):             for parent in self.model.mro()[1:]:
0.92 options.py(393):                 if hasattr(parent, '_meta'):
0.92 options.py(392):             for parent in self.model.mro()[1:]:
0.93 options.py(398):         if base_manager_name:
0.93 options.py(409):         manager = Manager()
0.93 options.py(410):         manager.name = '_base_manager'
0.93 options.py(411):         manager.model = self.model
0.93 options.py(412):         manager.auto_created = True
0.93 options.py(413):         return manager
0.93 base.py(865):             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
0.93 base.py(866):                       for f in non_pks]
0.93 base.py(865):             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
0.93 base.py(866):                       for f in non_pks]
0.93 base.py(865):             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
0.93 base.py(866):                       for f in non_pks]
0.93 base.py(865):             values = [(f, None, (getattr(self, f.attname) if raw else f.pre_save(self, False)))
0.93 base.py(867):             forced_update = update_fields or force_update
0.93 base.py(868):             updated = self._do_update(base_qs, using, pk_val, values, update_fields,
0.93 base.py(869):                                       forced_update)
0.93 base.py(901):         filtered = base_qs.filter(pk=pk_val)
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(532):         res = {}
0.93 options.py(533):         fields = self._get_fields(reverse=False)
0.93 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.93 options.py(773):         topmost_call = seen_models is None
0.93 options.py(774):         if topmost_call:
0.93 options.py(775):             seen_models = set()
0.93 options.py(776):         seen_models.add(self.model)
0.93 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.93 options.py(781):         try:
0.93 options.py(784):             return self._get_fields_cache[cache_key]
0.93 options.py(534):         for field in fields:
0.93 options.py(535):             res[field.name] = field
0.93 options.py(539):             try:
0.93 options.py(540):                 res[field.attname] = field
0.93 options.py(534):         for field in fields:
0.93 options.py(535):             res[field.name] = field
0.93 options.py(539):             try:
0.93 options.py(540):                 res[field.attname] = field
0.93 options.py(534):         for field in fields:
0.93 options.py(535):             res[field.name] = field
0.93 options.py(539):             try:
0.93 options.py(540):                 res[field.attname] = field
0.93 options.py(534):         for field in fields:
0.93 options.py(543):         return res
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 base.py(902):         if not values:
0.93 base.py(909):         if self._meta.select_on_save and not forced_update:
0.93 base.py(921):         return filtered._update(values) > 0
0.93 base.py(870):             if force_update and not updated:
0.93 base.py(872):             if update_fields and not updated:
0.93 base.py(874):         if not updated:
0.93 base.py(875):             if meta.order_with_respect_to:
0.93 base.py(886):             fields = meta.local_concrete_fields
0.93 base.py(887):             if not pk_set:
0.93 base.py(890):             returning_fields = meta.db_returning_fields
0.93 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.93 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.93 options.py(773):         topmost_call = seen_models is None
0.93 options.py(774):         if topmost_call:
0.93 options.py(775):             seen_models = set()
0.93 options.py(776):         seen_models.add(self.model)
0.93 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.93 options.py(781):         try:
0.93 options.py(784):             return self._get_fields_cache[cache_key]
0.93 options.py(785):         except KeyError:
0.93 options.py(786):             pass
0.93 options.py(788):         fields = []
0.93 options.py(791):         if include_parents is not False:
0.93 options.py(792):             for parent in self.parents:
0.93 options.py(806):         if reverse and not self.proxy:
0.93 options.py(817):         if forward:
0.93 options.py(818):             fields += self.local_fields
0.93 options.py(819):             fields += self.local_many_to_many
0.93 options.py(825):             if topmost_call:
0.93 options.py(826):                 fields += self.private_fields
0.93 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.93 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.93 options.py(833):         self._get_fields_cache[cache_key] = fields
0.93 options.py(834):         return fields
0.93 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.93 options.py(854):             if getattr(field, 'db_returning', False)
0.93 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.93 options.py(854):             if getattr(field, 'db_returning', False)
0.93 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.93 options.py(854):             if getattr(field, 'db_returning', False)
0.93 options.py(853):             field for field in self._get_fields(forward=True, reverse=False, include_parents=PROXY_PARENTS)
0.93 base.py(891):             results = self._do_insert(cls._base_manager, using, fields, returning_fields, raw)
0.93 base.py(378):         return cls._meta.base_manager
0.93 base.py(928):         return manager._insert(
0.93 base.py(929):             [self], fields=fields, returning_fields=returning_fields,
0.93 base.py(930):             using=using, raw=raw,
0.93 base.py(892):             for result, field in zip(results, returning_fields):
0.93 base.py(893):                 setattr(self, field.attname, result)
0.93 base.py(892):             for result, field in zip(results, returning_fields):
0.93 base.py(894):         return updated
0.93 base.py(791):         self._state.db = using
0.93 base.py(793):         self._state.adding = False
0.93 base.py(796):         if not meta.auto_created:
0.93 base.py(797):             post_save.send(
0.93 base.py(798):                 sender=origin, instance=self, created=(not updated),
0.93 base.py(799):                 update_fields=update_fields, raw=raw, using=using,
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(607):         result = OrderedSet(self.parents)
0.93 options.py(608):         for parent in self.parents:
0.93 options.py(611):         return list(result)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.93 base.py(513):         new = cls(*values)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 base.py(514):         new._state.adding = False
0.93 base.py(515):         new._state.db = db
0.93 base.py(516):         return new
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(607):         result = OrderedSet(self.parents)
0.93 options.py(608):         for parent in self.parents:
0.93 options.py(611):         return list(result)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.93 base.py(513):         new = cls(*values)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(433):                 if val is _DEFERRED:
0.93 base.py(435):                 _setattr(self, field.attname, val)
0.93 base.py(432):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 base.py(514):         new._state.adding = False
0.93 base.py(515):         new._state.db = db
0.93 base.py(516):         return new
0.93 base.py(535):         if self.pk is None:
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(537):         return hash(self.pk)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 options.py(335):         with override(None):
0.93 options.py(336):             return str(self.verbose_name)
0.93 options.py(335):         with override(None):
0.93 options.py(336):             return str(self.verbose_name)
0.93 options.py(335):         with override(None):
0.93 options.py(336):             return str(self.verbose_name)
0.93 options.py(335):         with override(None):
0.93 options.py(336):             return str(self.verbose_name)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(568):         except KeyError:
0.93 options.py(571):             if not self.apps.models_ready:
0.93 options.py(578):         try:
0.93 options.py(581):             return self.fields_map[field_name]
0.93 options.py(582):         except KeyError:
0.93 options.py(583):             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(455):                     try:
0.93 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.93 base.py(458):                         is_related_object = True
0.93 base.py(477):             if is_related_object:
0.93 base.py(482):                 if rel_obj is not _DEFERRED:
0.93 base.py(483):                     _setattr(self, field.name, rel_obj)
0.93 base.py(387):         if instance is None:
0.93 base.py(389):         res = instance.fields_cache = {}
0.93 base.py(390):         return res
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(455):                     try:
0.93 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.93 base.py(458):                         is_related_object = True
0.93 base.py(477):             if is_related_object:
0.93 base.py(482):                 if rel_obj is not _DEFERRED:
0.93 base.py(483):                     _setattr(self, field.name, rel_obj)
0.93 base.py(387):         if instance is None:
0.93 base.py(389):         res = instance.fields_cache = {}
0.93 base.py(390):         return res
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(455):                     try:
0.93 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.93 base.py(458):                         is_related_object = True
0.93 base.py(477):             if is_related_object:
0.93 base.py(482):                 if rel_obj is not _DEFERRED:
0.93 base.py(483):                     _setattr(self, field.name, rel_obj)
0.93 base.py(387):         if instance is None:
0.93 base.py(389):         res = instance.fields_cache = {}
0.93 base.py(390):         return res
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(455):                     try:
0.93 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.93 base.py(458):                         is_related_object = True
0.93 base.py(477):             if is_related_object:
0.93 base.py(482):                 if rel_obj is not _DEFERRED:
0.93 base.py(483):                     _setattr(self, field.name, rel_obj)
0.93 base.py(387):         if instance is None:
0.93 base.py(389):         res = instance.fields_cache = {}
0.93 base.py(390):         return res
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(607):         result = OrderedSet(self.parents)
0.93 options.py(608):         for parent in self.parents:
0.93 options.py(611):         return list(result)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(564):         try:
0.93 options.py(567):             return self._forward_fields_map[field_name]
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 base.py(408):         cls = self.__class__
0.93 base.py(409):         opts = self._meta
0.93 base.py(410):         _setattr = setattr
0.93 base.py(411):         _DEFERRED = DEFERRED
0.93 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.93 base.py(416):         self._state = ModelState()
0.93 base.py(422):         if len(args) > len(opts.concrete_fields):
0.93 base.py(426):         if not kwargs:
0.93 base.py(438):             fields_iter = iter(opts.fields)
0.93 base.py(439):             for val, field in zip(args, fields_iter):
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(468):                     except KeyError:
0.93 base.py(473):                         val = field.get_default()
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(449):             is_related_object = False
0.93 base.py(451):             if field.attname not in kwargs and field.column is None:
0.93 base.py(453):             if kwargs:
0.93 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.93 base.py(466):                     try:
0.93 base.py(467):                         val = kwargs.pop(field.attname)
0.93 base.py(477):             if is_related_object:
0.93 base.py(485):                 if val is not _DEFERRED:
0.93 base.py(486):                     _setattr(self, field.attname, val)
0.93 base.py(448):         for field in fields_iter:
0.93 base.py(488):         if kwargs:
0.93 base.py(502):         super().__init__()
0.93 base.py(503):         post_init.send(sender=cls, instance=self)
0.93 options.py(347):         if self.swappable:
0.93 options.py(361):         return None
0.93 options.py(607):         result = OrderedSet(self.parents)
0.93 options.py(608):         for parent in self.parents:
0.93 options.py(611):         return list(result)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.93 base.py(572):         for parent_link in self._meta.parents.values():
0.93 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.93 base.py(568):         meta = meta or self._meta
0.93 base.py(569):         return getattr(self, meta.pk.attname)
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(607):         result = OrderedSet(self.parents)
0.94 options.py(608):         for parent in self.parents:
0.94 options.py(611):         return list(result)
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 base.py(535):         if self.pk is None:
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(537):         return hash(self.pk)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 options.py(335):         with override(None):
0.94 options.py(336):             return str(self.verbose_name)
0.94 options.py(335):         with override(None):
0.94 options.py(336):             return str(self.verbose_name)
0.94 options.py(335):         with override(None):
0.94 options.py(336):             return str(self.verbose_name)
0.94 options.py(335):         with override(None):
0.94 options.py(336):             return str(self.verbose_name)
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(568):         except KeyError:
0.94 options.py(571):             if not self.apps.models_ready:
0.94 options.py(578):         try:
0.94 options.py(581):             return self.fields_map[field_name]
0.94 options.py(582):         except KeyError:
0.94 options.py(583):             raise FieldDoesNotExist("%s has no field named '%s'" % (self.object_name, field_name))
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 options.py(564):         try:
0.94 options.py(567):             return self._forward_fields_map[field_name]
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(438):             fields_iter = iter(opts.fields)
0.94 base.py(439):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(468):                     except KeyError:
0.94 base.py(473):                         val = field.get_default()
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(455):                     try:
0.94 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.94 base.py(458):                         is_related_object = True
0.94 base.py(477):             if is_related_object:
0.94 base.py(482):                 if rel_obj is not _DEFERRED:
0.94 base.py(483):                     _setattr(self, field.name, rel_obj)
0.94 base.py(387):         if instance is None:
0.94 base.py(389):         res = instance.fields_cache = {}
0.94 base.py(390):         return res
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(438):             fields_iter = iter(opts.fields)
0.94 base.py(439):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(468):                     except KeyError:
0.94 base.py(473):                         val = field.get_default()
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(455):                     try:
0.94 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.94 base.py(458):                         is_related_object = True
0.94 base.py(477):             if is_related_object:
0.94 base.py(482):                 if rel_obj is not _DEFERRED:
0.94 base.py(483):                     _setattr(self, field.name, rel_obj)
0.94 base.py(387):         if instance is None:
0.94 base.py(389):         res = instance.fields_cache = {}
0.94 base.py(390):         return res
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(438):             fields_iter = iter(opts.fields)
0.94 base.py(439):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(468):                     except KeyError:
0.94 base.py(473):                         val = field.get_default()
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(455):                     try:
0.94 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.94 base.py(458):                         is_related_object = True
0.94 base.py(477):             if is_related_object:
0.94 base.py(482):                 if rel_obj is not _DEFERRED:
0.94 base.py(483):                     _setattr(self, field.name, rel_obj)
0.94 base.py(387):         if instance is None:
0.94 base.py(389):         res = instance.fields_cache = {}
0.94 base.py(390):         return res
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(438):             fields_iter = iter(opts.fields)
0.94 base.py(439):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(468):                     except KeyError:
0.94 base.py(473):                         val = field.get_default()
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(455):                     try:
0.94 base.py(457):                         rel_obj = kwargs.pop(field.name)
0.94 base.py(458):                         is_related_object = True
0.94 base.py(477):             if is_related_object:
0.94 base.py(482):                 if rel_obj is not _DEFERRED:
0.94 base.py(483):                     _setattr(self, field.name, rel_obj)
0.94 base.py(387):         if instance is None:
0.94 base.py(389):         res = instance.fields_cache = {}
0.94 base.py(390):         return res
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(449):             is_related_object = False
0.94 base.py(451):             if field.attname not in kwargs and field.column is None:
0.94 base.py(453):             if kwargs:
0.94 base.py(454):                 if isinstance(field.remote_field, ForeignObjectRel):
0.94 base.py(466):                     try:
0.94 base.py(467):                         val = kwargs.pop(field.attname)
0.94 base.py(477):             if is_related_object:
0.94 base.py(485):                 if val is not _DEFERRED:
0.94 base.py(486):                     _setattr(self, field.attname, val)
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 options.py(607):         result = OrderedSet(self.parents)
0.94 options.py(608):         for parent in self.parents:
0.94 options.py(611):         return list(result)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(572):         for parent_link in self._meta.parents.values():
0.94 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(572):         for parent_link in self._meta.parents.values():
0.94 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(572):         for parent_link in self._meta.parents.values():
0.94 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(572):         for parent_link in self._meta.parents.values():
0.94 base.py(575):         return setattr(self, self._meta.pk.attname, value)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 base.py(568):         meta = meta or self._meta
0.94 base.py(569):         return getattr(self, meta.pk.attname)
0.94 options.py(347):         if self.swappable:
0.94 options.py(361):         return None
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.94 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.94 base.py(513):         new = cls(*values)
0.94 base.py(408):         cls = self.__class__
0.94 base.py(409):         opts = self._meta
0.94 base.py(410):         _setattr = setattr
0.94 base.py(411):         _DEFERRED = DEFERRED
0.94 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.94 base.py(416):         self._state = ModelState()
0.94 base.py(422):         if len(args) > len(opts.concrete_fields):
0.94 base.py(426):         if not kwargs:
0.94 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(433):                 if val is _DEFERRED:
0.94 base.py(435):                 _setattr(self, field.attname, val)
0.94 base.py(432):             for val, field in zip(args, fields_iter):
0.94 base.py(448):         for field in fields_iter:
0.94 base.py(488):         if kwargs:
0.94 base.py(502):         super().__init__()
0.94 base.py(503):         post_init.send(sender=cls, instance=self)
0.94 base.py(514):         new._state.adding = False
0.94 base.py(515):         new._state.db = db
0.94 base.py(516):         return new
0.98 options.py(347):         if self.swappable:
0.98 options.py(361):         return None
0.98 options.py(456):         def is_not_an_m2m_field(f):
0.98 options.py(459):         def is_not_a_generic_relation(f):
0.98 options.py(462):         def is_not_a_generic_foreign_key(f):
0.98 options.py(467):         return make_immutable_fields_list(
0.98 options.py(468):             "fields",
0.98 options.py(469):             (f for f in self._get_fields(reverse=False)
0.98 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.98 options.py(773):         topmost_call = seen_models is None
0.98 options.py(774):         if topmost_call:
0.98 options.py(775):             seen_models = set()
0.98 options.py(776):         seen_models.add(self.model)
0.98 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.98 options.py(781):         try:
0.98 options.py(784):             return self._get_fields_cache[cache_key]
0.98 options.py(785):         except KeyError:
0.98 options.py(786):             pass
0.98 options.py(788):         fields = []
0.98 options.py(791):         if include_parents is not False:
0.98 options.py(792):             for parent in self.parents:
0.99 options.py(806):         if reverse and not self.proxy:
0.99 options.py(817):         if forward:
0.99 options.py(818):             fields += self.local_fields
0.99 options.py(819):             fields += self.local_many_to_many
0.99 options.py(825):             if topmost_call:
0.99 options.py(826):                 fields += self.private_fields
0.99 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(833):         self._get_fields_cache[cache_key] = fields
0.99 options.py(834):         return fields
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(508):         return make_immutable_fields_list(
0.99 options.py(509):             "many_to_many",
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.99 options.py(773):         topmost_call = seen_models is None
0.99 options.py(774):         if topmost_call:
0.99 options.py(775):             seen_models = set()
0.99 options.py(776):         seen_models.add(self.model)
0.99 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.99 options.py(781):         try:
0.99 options.py(784):             return self._get_fields_cache[cache_key]
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(347):         if self.swappable:
0.99 options.py(361):         return None
0.99 options.py(456):         def is_not_an_m2m_field(f):
0.99 options.py(459):         def is_not_a_generic_relation(f):
0.99 options.py(462):         def is_not_a_generic_foreign_key(f):
0.99 options.py(467):         return make_immutable_fields_list(
0.99 options.py(468):             "fields",
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.99 options.py(773):         topmost_call = seen_models is None
0.99 options.py(774):         if topmost_call:
0.99 options.py(775):             seen_models = set()
0.99 options.py(776):         seen_models.add(self.model)
0.99 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.99 options.py(781):         try:
0.99 options.py(784):             return self._get_fields_cache[cache_key]
0.99 options.py(785):         except KeyError:
0.99 options.py(786):             pass
0.99 options.py(788):         fields = []
0.99 options.py(791):         if include_parents is not False:
0.99 options.py(792):             for parent in self.parents:
0.99 options.py(806):         if reverse and not self.proxy:
0.99 options.py(817):         if forward:
0.99 options.py(818):             fields += self.local_fields
0.99 options.py(819):             fields += self.local_many_to_many
0.99 options.py(825):             if topmost_call:
0.99 options.py(826):                 fields += self.private_fields
0.99 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(833):         self._get_fields_cache[cache_key] = fields
0.99 options.py(834):         return fields
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
0.99 options.py(457):             return not (f.is_relation and f.many_to_many)
0.99 options.py(460):             return not (f.is_relation and f.one_to_many)
0.99 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
0.99 options.py(469):             (f for f in self._get_fields(reverse=False)
0.99 options.py(508):         return make_immutable_fields_list(
0.99 options.py(509):             "many_to_many",
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.99 options.py(773):         topmost_call = seen_models is None
0.99 options.py(774):         if topmost_call:
0.99 options.py(775):             seen_models = set()
0.99 options.py(776):         seen_models.add(self.model)
0.99 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.99 options.py(781):         try:
0.99 options.py(784):             return self._get_fields_cache[cache_key]
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
0.99 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.99 options.py(347):         if self.swappable:
0.99 options.py(361):         return None
0.99 options.py(323):         if isinstance(connection, str):
0.99 options.py(325):         if self.required_db_vendor:
0.99 options.py(327):         if self.required_db_features:
0.99 options.py(330):         return True
0.99 base.py(382):         return cls._meta.default_manager
0.99 options.py(417):         default_manager_name = self.default_manager_name
0.99 options.py(418):         if not default_manager_name and not self.local_managers:
0.99 options.py(425):         if default_manager_name:
0.99 options.py(436):         if self.managers:
0.99 options.py(365):         managers = []
0.99 options.py(366):         seen_managers = set()
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(368):         for depth, base in enumerate(bases):
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(369):             for manager in base._meta.local_managers:
0.99 options.py(370):                 if manager.name in seen_managers:
0.99 options.py(373):                 manager = copy.copy(manager)
0.99 options.py(374):                 manager.model = self.model
0.99 options.py(375):                 seen_managers.add(manager.name)
0.99 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.99 options.py(369):             for manager in base._meta.local_managers:
0.99 options.py(368):         for depth, base in enumerate(bases):
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(378):         return make_immutable_fields_list(
0.99 options.py(379):             "managers",
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(437):             return self.managers[0]
0.99 options.py(482):         return make_immutable_fields_list(
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(564):         try:
0.99 options.py(567):             return self._forward_fields_map[field_name]
0.99 options.py(532):         res = {}
0.99 options.py(533):         fields = self._get_fields(reverse=False)
0.99 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.99 options.py(773):         topmost_call = seen_models is None
0.99 options.py(774):         if topmost_call:
0.99 options.py(775):             seen_models = set()
0.99 options.py(776):         seen_models.add(self.model)
0.99 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.99 options.py(781):         try:
0.99 options.py(784):             return self._get_fields_cache[cache_key]
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(543):         return res
0.99 base.py(507):         if len(values) != len(cls._meta.concrete_fields):
0.99 base.py(513):         new = cls(*values)
0.99 base.py(408):         cls = self.__class__
0.99 base.py(409):         opts = self._meta
0.99 base.py(410):         _setattr = setattr
0.99 base.py(411):         _DEFERRED = DEFERRED
0.99 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
0.99 base.py(416):         self._state = ModelState()
0.99 base.py(422):         if len(args) > len(opts.concrete_fields):
0.99 base.py(426):         if not kwargs:
0.99 base.py(427):             fields_iter = iter(opts.concrete_fields)
0.99 base.py(432):             for val, field in zip(args, fields_iter):
0.99 base.py(433):                 if val is _DEFERRED:
0.99 base.py(435):                 _setattr(self, field.attname, val)
0.99 base.py(432):             for val, field in zip(args, fields_iter):
0.99 base.py(433):                 if val is _DEFERRED:
0.99 base.py(435):                 _setattr(self, field.attname, val)
0.99 base.py(432):             for val, field in zip(args, fields_iter):
0.99 base.py(433):                 if val is _DEFERRED:
0.99 base.py(435):                 _setattr(self, field.attname, val)
0.99 base.py(432):             for val, field in zip(args, fields_iter):
0.99 base.py(448):         for field in fields_iter:
0.99 base.py(488):         if kwargs:
0.99 base.py(502):         super().__init__()
0.99 base.py(503):         post_init.send(sender=cls, instance=self)
0.99 base.py(514):         new._state.adding = False
0.99 base.py(515):         new._state.db = db
0.99 base.py(516):         return new
0.99 options.py(314):         return "%s.%s" % (self.app_label, self.model_name)
0.99 options.py(321):         if self.proxy or self.swapped or not self.managed:
0.99 options.py(347):         if self.swappable:
0.99 options.py(361):         return None
0.99 options.py(323):         if isinstance(connection, str):
0.99 options.py(325):         if self.required_db_vendor:
0.99 options.py(327):         if self.required_db_features:
0.99 options.py(330):         return True
0.99 base.py(382):         return cls._meta.default_manager
0.99 options.py(417):         default_manager_name = self.default_manager_name
0.99 options.py(418):         if not default_manager_name and not self.local_managers:
0.99 options.py(425):         if default_manager_name:
0.99 options.py(436):         if self.managers:
0.99 options.py(365):         managers = []
0.99 options.py(366):         seen_managers = set()
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(368):         for depth, base in enumerate(bases):
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(369):             for manager in base._meta.local_managers:
0.99 options.py(370):                 if manager.name in seen_managers:
0.99 options.py(373):                 manager = copy.copy(manager)
0.99 options.py(374):                 manager.model = self.model
0.99 options.py(375):                 seen_managers.add(manager.name)
0.99 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
0.99 options.py(369):             for manager in base._meta.local_managers:
0.99 options.py(368):         for depth, base in enumerate(bases):
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
0.99 options.py(378):         return make_immutable_fields_list(
0.99 options.py(379):             "managers",
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(380):             (m[2] for m in sorted(managers)),
0.99 options.py(437):             return self.managers[0]
0.99 options.py(482):         return make_immutable_fields_list(
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
0.99 options.py(564):         try:
0.99 options.py(567):             return self._forward_fields_map[field_name]
0.99 options.py(564):         try:
0.99 options.py(567):             return self._forward_fields_map[field_name]
0.99 options.py(532):         res = {}
0.99 options.py(533):         fields = self._get_fields(reverse=False)
0.99 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
0.99 options.py(773):         topmost_call = seen_models is None
0.99 options.py(774):         if topmost_call:
0.99 options.py(775):             seen_models = set()
0.99 options.py(776):         seen_models.add(self.model)
0.99 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
0.99 options.py(781):         try:
0.99 options.py(784):             return self._get_fields_cache[cache_key]
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(535):             res[field.name] = field
0.99 options.py(539):             try:
0.99 options.py(540):                 res[field.attname] = field
0.99 options.py(534):         for field in fields:
0.99 options.py(543):         return res
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
1.00 options.py(349):             if swapped_for:
1.00 options.py(350):                 try:
1.00 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
1.00 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
1.00 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(347):         if self.swappable:
1.00 options.py(361):         return None
1.00 options.py(564):         try:
1.00 options.py(567):             return self._forward_fields_map[field_name]
1.00 base.py(408):         cls = self.__class__
1.00 base.py(409):         opts = self._meta
1.00 base.py(410):         _setattr = setattr
1.00 base.py(411):         _DEFERRED = DEFERRED
1.00 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
1.00 base.py(416):         self._state = ModelState()
1.00 base.py(422):         if len(args) > len(opts.concrete_fields):
1.00 options.py(482):         return make_immutable_fields_list(
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(456):         def is_not_an_m2m_field(f):
1.00 options.py(459):         def is_not_a_generic_relation(f):
1.00 options.py(462):         def is_not_a_generic_foreign_key(f):
1.00 options.py(467):         return make_immutable_fields_list(
1.00 options.py(468):             "fields",
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.00 options.py(773):         topmost_call = seen_models is None
1.00 options.py(774):         if topmost_call:
1.00 options.py(775):             seen_models = set()
1.00 options.py(776):         seen_models.add(self.model)
1.00 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.00 options.py(781):         try:
1.00 options.py(784):             return self._get_fields_cache[cache_key]
1.00 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(460):             return not (f.is_relation and f.one_to_many)
1.00 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.00 options.py(457):             return not (f.is_relation and f.many_to_many)
1.00 options.py(469):             (f for f in self._get_fields(reverse=False)
1.00 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 options.py(483):             "concrete_fields", (f for f in self.fields if f.concrete)
1.00 base.py(426):         if not kwargs:
1.00 base.py(427):             fields_iter = iter(opts.concrete_fields)
1.00 base.py(432):             for val, field in zip(args, fields_iter):
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(488):         if kwargs:
1.00 base.py(502):         super().__init__()
1.00 base.py(503):         post_init.send(sender=cls, instance=self)
1.00 base.py(408):         cls = self.__class__
1.00 base.py(409):         opts = self._meta
1.00 base.py(410):         _setattr = setattr
1.00 base.py(411):         _DEFERRED = DEFERRED
1.00 base.py(413):         pre_init.send(sender=cls, args=args, kwargs=kwargs)
1.00 base.py(416):         self._state = ModelState()
1.00 base.py(422):         if len(args) > len(opts.concrete_fields):
1.00 base.py(426):         if not kwargs:
1.00 base.py(427):             fields_iter = iter(opts.concrete_fields)
1.00 base.py(432):             for val, field in zip(args, fields_iter):
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(449):             is_related_object = False
1.00 base.py(451):             if field.attname not in kwargs and field.column is None:
1.00 base.py(453):             if kwargs:
1.00 base.py(475):                 val = field.get_default()
1.00 base.py(477):             if is_related_object:
1.00 base.py(485):                 if val is not _DEFERRED:
1.00 base.py(486):                     _setattr(self, field.attname, val)
1.00 base.py(448):         for field in fields_iter:
1.00 base.py(488):         if kwargs:
1.00 base.py(502):         super().__init__()
1.00 base.py(503):         post_init.send(sender=cls, instance=self)
1.00 options.py(564):         try:
1.00 options.py(567):             return self._forward_fields_map[field_name]
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.00 options.py(336):             return str(self.verbose_name)
1.00 options.py(335):         with override(None):
1.01 options.py(336):             return str(self.verbose_name)
1.01 options.py(335):         with override(None):
1.01 options.py(336):             return str(self.verbose_name)
1.01 options.py(335):         with override(None):
1.01 options.py(336):             return str(self.verbose_name)
1.02 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.02 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.02 base.py(1288):         errors = []
1.02 base.py(1289):         if cls._meta.swapped:
1.02 options.py(347):         if self.swappable:
1.02 options.py(361):         return None
1.02 base.py(1310):         return errors
1.02 base.py(1314):         errors = []
1.02 base.py(1315):         if cls._meta.proxy:
1.02 base.py(1323):         return errors
1.02 base.py(1328):         errors = []
1.02 base.py(1329):         for manager in cls._meta.managers:
1.02 base.py(1330):             errors.extend(manager.check(**kwargs))
1.02 base.py(1329):         for manager in cls._meta.managers:
1.02 base.py(1331):         return errors
1.02 base.py(1257):         if not cls._meta.swapped:
1.02 options.py(347):         if self.swappable:
1.02 options.py(361):         return None
1.02 base.py(1258):             errors += [
1.02 base.py(1259):                 *cls._check_fields(**kwargs),
1.02 base.py(1336):         errors = []
1.02 base.py(1337):         for field in cls._meta.local_fields:
1.02 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1339):         for field in cls._meta.local_many_to_many:
1.03 base.py(1341):         return errors
1.03 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.03 base.py(1348):         errors = []
1.03 base.py(1349):         seen_intermediary_signatures = []
1.03 base.py(1351):         fields = cls._meta.local_many_to_many
1.03 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.03 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.03 base.py(1359):         for f in fields:
1.03 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.03 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.03 base.py(1373):         return errors
1.03 base.py(1261):                 *cls._check_long_column_names(),
1.03 base.py(1771):         errors = []
1.03 base.py(1772):         allowed_len = None
1.03 base.py(1773):         db_alias = None
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1780):             connection = connections[db]
1.03 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.03 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1780):             connection = connections[db]
1.03 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.03 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1792):         if allowed_len is None:
1.03 base.py(1793):             return errors
1.03 base.py(1264):                 *cls._check_id_field(),
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.03 base.py(1390):             return []
1.03 base.py(1265):                 *cls._check_field_name_clashes(),
1.03 base.py(1395):         errors = []
1.03 base.py(1396):         used_fields = {}  # name or attname -> field
1.03 base.py(1399):         for parent in cls._meta.get_parent_list():
1.03 options.py(607):         result = OrderedSet(self.parents)
1.03 options.py(608):         for parent in self.parents:
1.03 options.py(611):         return list(result)
1.03 base.py(1421):         for parent in cls._meta.get_parent_list():
1.03 options.py(607):         result = OrderedSet(self.parents)
1.03 options.py(608):         for parent in self.parents:
1.03 options.py(611):         return list(result)
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1447):         return errors
1.03 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.03 base.py(1476):         errors = []
1.03 base.py(1477):         model_name = cls.__name__
1.03 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.03 base.py(1487):         elif LOOKUP_SEP in model_name:
1.03 base.py(1496):         return errors
1.03 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.03 base.py(1500):         errors = []
1.03 base.py(1501):         property_names = cls._meta._property_names
1.03 options.py(839):         names = []
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(843):                 names.append(name)
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(843):                 names.append(name)
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(843):                 names.append(name)
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(844):         return frozenset(names)
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1506):         for accessor in related_field_accessors:
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1516):         return errors
1.03 base.py(1268):                 *cls._check_single_primary_key(),
1.03 base.py(1520):         errors = []
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1530):         return errors
1.03 base.py(1270):             errors.extend(clash_errors)
1.03 base.py(1273):             if not clash_errors:
1.03 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.03 base.py(1452):         used_column_names = []
1.03 base.py(1453):         errors = []
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1472):         return errors
1.03 base.py(1275):             errors += [
1.03 base.py(1276):                 *cls._check_index_together(),
1.03 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.03 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.03 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.03 base.py(1554):             errors = []
1.03 base.py(1555):             for fields in cls._meta.index_together:
1.03 base.py(1557):             return errors
1.03 base.py(1277):                 *cls._check_unique_together(),
1.03 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1581):             errors = []
1.03 base.py(1582):             for fields in cls._meta.unique_together:
1.03 base.py(1583):                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1.03 base.py(1617):         from django.db import models
1.03 base.py(1621):         forward_fields_map = {}
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1627):         errors = []
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1629):             try:
1.03 base.py(1630):                 field = forward_fields_map[field_name]
1.03 base.py(1642):                 if isinstance(field.remote_field, models.ManyToManyRel):
1.03 base.py(1653):                 elif field not in cls._meta.local_fields:
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1629):             try:
1.03 base.py(1630):                 field = forward_fields_map[field_name]
1.03 base.py(1642):                 if isinstance(field.remote_field, models.ManyToManyRel):
1.03 base.py(1653):                 elif field not in cls._meta.local_fields:
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1663):         return errors
1.03 base.py(1582):             for fields in cls._meta.unique_together:
1.03 base.py(1584):             return errors
1.03 base.py(1278):                 *cls._check_indexes(),
1.03 base.py(1589):         errors = []
1.03 base.py(1590):         for index in cls._meta.indexes:
1.03 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.03 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.03 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.03 base.py(1617):         from django.db import models
1.03 base.py(1621):         forward_fields_map = {}
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1627):         errors = []
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1663):         return errors
1.03 base.py(1613):         return errors
1.03 base.py(1279):                 *cls._check_ordering(),
1.03 base.py(1671):         if cls._meta._ordering_clash:
1.03 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.03 base.py(1681):             return []
1.03 base.py(1280):                 *cls._check_constraints(),
1.03 base.py(1840):         errors = []
1.03 base.py(1841):         for db in settings.DATABASES:
1.03 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1844):             connection = connections[db]
1.03 base.py(1846):                 connection.features.supports_table_check_constraints or
1.03 base.py(1841):         for db in settings.DATABASES:
1.03 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1844):             connection = connections[db]
1.03 base.py(1846):                 connection.features.supports_table_check_constraints or
1.03 base.py(1841):         for db in settings.DATABASES:
1.03 base.py(1862):         return errors
1.03 base.py(1283):         return errors
1.03 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.03 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.03 base.py(1288):         errors = []
1.03 base.py(1289):         if cls._meta.swapped:
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 base.py(1310):         return errors
1.03 base.py(1314):         errors = []
1.03 base.py(1315):         if cls._meta.proxy:
1.03 base.py(1323):         return errors
1.03 base.py(1328):         errors = []
1.03 base.py(1329):         for manager in cls._meta.managers:
1.03 base.py(1330):             errors.extend(manager.check(**kwargs))
1.03 base.py(1329):         for manager in cls._meta.managers:
1.03 base.py(1331):         return errors
1.03 base.py(1257):         if not cls._meta.swapped:
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 base.py(1258):             errors += [
1.03 base.py(1259):                 *cls._check_fields(**kwargs),
1.03 base.py(1336):         errors = []
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 options.py(456):         def is_not_an_m2m_field(f):
1.03 options.py(459):         def is_not_a_generic_relation(f):
1.03 options.py(462):         def is_not_a_generic_foreign_key(f):
1.03 options.py(467):         return make_immutable_fields_list(
1.03 options.py(468):             "fields",
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(508):         return make_immutable_fields_list(
1.03 options.py(509):             "many_to_many",
1.03 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.03 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.03 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.03 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.03 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(792):             for parent in self.parents:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(810):             all_fields = self._relation_tree
1.03 options.py(723):         return self._populate_directed_relation_graph()
1.03 options.py(692):         related_objects_graph = defaultdict(list)
1.03 options.py(694):         all_models = self.apps.get_models(include_auto_created=True)
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
1.03 options.py(349):             if swapped_for:
1.03 options.py(350):                 try:
1.03 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
1.03 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
1.03 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(347):         if self.swappable:
1.03 options.py(361):         return None
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(696):             opts = model._meta
1.03 options.py(699):             if opts.abstract:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(706):                 if not isinstance(f.remote_field.model, str):
1.03 options.py(707):                     related_objects_graph[f.remote_field.model._meta.concrete_model._meta].append(f)
1.03 options.py(705):             for f in fields_with_relations:
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(703):                 if f.is_relation and f.related_model is not None
1.03 options.py(702):                 f for f in opts._get_fields(reverse=False, include_parents=False)
1.03 options.py(695):         for model in all_models:
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(715):             related_objects = related_objects_graph[model._meta.concrete_model._meta]
1.03 options.py(716):             model._meta.__dict__['_relation_tree'] = related_objects
1.03 options.py(709):         for model in all_models:
1.03 options.py(719):         return self.__dict__.get('_relation_tree', EMPTY_RELATION_TREE)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(817):         if forward:
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(525):         return make_immutable_fields_list(
1.03 options.py(526):             "related_objects",
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(564):         try:
1.03 options.py(567):             return self._forward_fields_map[field_name]
1.03 options.py(748):         if include_parents is False:
1.03 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(792):             for parent in self.parents:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(810):             all_fields = self._relation_tree
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(817):         if forward:
1.03 options.py(818):             fields += self.local_fields
1.03 options.py(819):             fields += self.local_many_to_many
1.03 options.py(825):             if topmost_call:
1.03 options.py(826):                 fields += self.private_fields
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1338):             errors.extend(field.check(**kwargs))
1.03 base.py(1337):         for field in cls._meta.local_fields:
1.03 base.py(1339):         for field in cls._meta.local_many_to_many:
1.03 base.py(1341):         return errors
1.03 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.03 base.py(1348):         errors = []
1.03 base.py(1349):         seen_intermediary_signatures = []
1.03 base.py(1351):         fields = cls._meta.local_many_to_many
1.03 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.03 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.03 base.py(1359):         for f in fields:
1.03 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.03 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.03 base.py(1373):         return errors
1.03 base.py(1261):                 *cls._check_long_column_names(),
1.03 base.py(1771):         errors = []
1.03 base.py(1772):         allowed_len = None
1.03 base.py(1773):         db_alias = None
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1780):             connection = connections[db]
1.03 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.03 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.03 base.py(1780):             connection = connections[db]
1.03 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.03 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.03 base.py(1776):         for db in settings.DATABASES:
1.03 base.py(1792):         if allowed_len is None:
1.03 base.py(1793):             return errors
1.03 base.py(1264):                 *cls._check_id_field(),
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.03 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.03 base.py(1390):             return []
1.03 base.py(1265):                 *cls._check_field_name_clashes(),
1.03 base.py(1395):         errors = []
1.03 base.py(1396):         used_fields = {}  # name or attname -> field
1.03 base.py(1399):         for parent in cls._meta.get_parent_list():
1.03 options.py(607):         result = OrderedSet(self.parents)
1.03 options.py(608):         for parent in self.parents:
1.03 options.py(611):         return list(result)
1.03 base.py(1421):         for parent in cls._meta.get_parent_list():
1.03 options.py(607):         result = OrderedSet(self.parents)
1.03 options.py(608):         for parent in self.parents:
1.03 options.py(611):         return list(result)
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.03 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.03 base.py(1433):             if clash and not id_conflict:
1.03 base.py(1444):             used_fields[f.name] = f
1.03 base.py(1445):             used_fields[f.attname] = f
1.03 base.py(1426):         for f in cls._meta.local_fields:
1.03 base.py(1447):         return errors
1.03 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.03 base.py(1476):         errors = []
1.03 base.py(1477):         model_name = cls.__name__
1.03 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.03 base.py(1487):         elif LOOKUP_SEP in model_name:
1.03 base.py(1496):         return errors
1.03 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.03 base.py(1500):         errors = []
1.03 base.py(1501):         property_names = cls._meta._property_names
1.03 options.py(839):         names = []
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(843):                 names.append(name)
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.03 options.py(842):             if isinstance(attr, property):
1.03 options.py(840):         for name in dir(self.model):
1.03 options.py(844):         return frozenset(names)
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1506):         for accessor in related_field_accessors:
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1507):             if accessor in property_names:
1.03 base.py(1506):         for accessor in related_field_accessors:
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1504):             if f.is_relation and f.related_model is not None
1.03 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.03 base.py(1516):         return errors
1.03 base.py(1268):                 *cls._check_single_primary_key(),
1.03 base.py(1520):         errors = []
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.03 base.py(1530):         return errors
1.03 base.py(1270):             errors.extend(clash_errors)
1.03 base.py(1273):             if not clash_errors:
1.03 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.03 base.py(1452):         used_column_names = []
1.03 base.py(1453):         errors = []
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1456):             _, column_name = f.get_attname_column()
1.03 base.py(1459):             if column_name and column_name in used_column_names:
1.03 base.py(1470):                 used_column_names.append(column_name)
1.03 base.py(1455):         for f in cls._meta.local_fields:
1.03 base.py(1472):         return errors
1.03 base.py(1275):             errors += [
1.03 base.py(1276):                 *cls._check_index_together(),
1.03 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.03 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.03 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.03 base.py(1554):             errors = []
1.03 base.py(1555):             for fields in cls._meta.index_together:
1.03 base.py(1557):             return errors
1.03 base.py(1277):                 *cls._check_unique_together(),
1.03 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.03 base.py(1581):             errors = []
1.03 base.py(1582):             for fields in cls._meta.unique_together:
1.03 base.py(1583):                 errors.extend(cls._check_local_fields(fields, "unique_together"))
1.03 base.py(1617):         from django.db import models
1.03 base.py(1621):         forward_fields_map = {}
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1627):         errors = []
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1629):             try:
1.03 base.py(1630):                 field = forward_fields_map[field_name]
1.03 base.py(1642):                 if isinstance(field.remote_field, models.ManyToManyRel):
1.03 base.py(1653):                 elif field not in cls._meta.local_fields:
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1629):             try:
1.03 base.py(1630):                 field = forward_fields_map[field_name]
1.03 base.py(1642):                 if isinstance(field.remote_field, models.ManyToManyRel):
1.03 base.py(1653):                 elif field not in cls._meta.local_fields:
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1663):         return errors
1.03 base.py(1582):             for fields in cls._meta.unique_together:
1.03 base.py(1584):             return errors
1.03 base.py(1278):                 *cls._check_indexes(),
1.03 base.py(1589):         errors = []
1.03 base.py(1590):         for index in cls._meta.indexes:
1.03 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.03 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.03 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.03 base.py(1617):         from django.db import models
1.03 base.py(1621):         forward_fields_map = {}
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1623):             forward_fields_map[field.name] = field
1.03 base.py(1624):             if hasattr(field, 'attname'):
1.03 base.py(1625):                 forward_fields_map[field.attname] = field
1.03 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.03 base.py(1627):         errors = []
1.03 base.py(1628):         for field_name in fields:
1.03 base.py(1663):         return errors
1.03 base.py(1613):         return errors
1.03 base.py(1279):                 *cls._check_ordering(),
1.03 base.py(1671):         if cls._meta._ordering_clash:
1.03 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.03 base.py(1683):         if not isinstance(cls._meta.ordering, (list, tuple)):
1.03 base.py(1692):         errors = []
1.03 base.py(1693):         fields = cls._meta.ordering
1.03 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.03 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.03 base.py(1702):         _fields = []
1.03 base.py(1703):         related_fields = []
1.03 base.py(1704):         for f in fields:
1.03 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.03 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.03 base.py(1705):             if LOOKUP_SEP in f:
1.03 base.py(1706):                 related_fields.append(f)
1.03 base.py(1704):         for f in fields:
1.03 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.03 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.03 base.py(1705):             if LOOKUP_SEP in f:
1.03 base.py(1706):                 related_fields.append(f)
1.03 base.py(1704):         for f in fields:
1.03 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.03 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.03 base.py(1705):             if LOOKUP_SEP in f:
1.03 base.py(1708):                 _fields.append(f)
1.03 base.py(1704):         for f in fields:
1.03 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.03 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.03 base.py(1709):         fields = _fields
1.03 base.py(1712):         for field in related_fields:
1.03 base.py(1713):             _cls = cls
1.03 base.py(1714):             fld = None
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1716):                 try:
1.03 base.py(1718):                     if part == 'pk':
1.03 base.py(1721):                         fld = _cls._meta.get_field(part)
1.03 options.py(564):         try:
1.03 options.py(567):             return self._forward_fields_map[field_name]
1.03 base.py(1722):                     if fld.is_relation:
1.03 base.py(1723):                         _cls = fld.get_path_info()[-1].to_opts.model
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1716):                 try:
1.03 base.py(1718):                     if part == 'pk':
1.03 base.py(1721):                         fld = _cls._meta.get_field(part)
1.03 options.py(564):         try:
1.03 options.py(567):             return self._forward_fields_map[field_name]
1.03 base.py(1722):                     if fld.is_relation:
1.03 base.py(1725):                         _cls = None
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1712):         for field in related_fields:
1.03 base.py(1713):             _cls = cls
1.03 base.py(1714):             fld = None
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1716):                 try:
1.03 base.py(1718):                     if part == 'pk':
1.03 base.py(1721):                         fld = _cls._meta.get_field(part)
1.03 options.py(564):         try:
1.03 options.py(567):             return self._forward_fields_map[field_name]
1.03 base.py(1722):                     if fld.is_relation:
1.03 base.py(1723):                         _cls = fld.get_path_info()[-1].to_opts.model
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1716):                 try:
1.03 base.py(1718):                     if part == 'pk':
1.03 base.py(1721):                         fld = _cls._meta.get_field(part)
1.03 options.py(564):         try:
1.03 options.py(567):             return self._forward_fields_map[field_name]
1.03 base.py(1722):                     if fld.is_relation:
1.03 base.py(1725):                         _cls = None
1.03 base.py(1715):             for part in field.split(LOOKUP_SEP):
1.03 base.py(1712):         for field in related_fields:
1.03 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.03 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.03 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.03 base.py(1742):         invalid_fields = []
1.03 base.py(1746):         opts = cls._meta
1.03 base.py(1747):         valid_fields = set(chain.from_iterable(
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 options.py(456):         def is_not_an_m2m_field(f):
1.03 options.py(459):         def is_not_a_generic_relation(f):
1.03 options.py(462):         def is_not_a_generic_foreign_key(f):
1.03 options.py(467):         return make_immutable_fields_list(
1.03 options.py(468):             "fields",
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.03 options.py(457):             return not (f.is_relation and f.many_to_many)
1.03 options.py(460):             return not (f.is_relation and f.one_to_many)
1.03 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.03 options.py(469):             (f for f in self._get_fields(reverse=False)
1.03 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.03 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.03 options.py(773):         topmost_call = seen_models is None
1.03 options.py(774):         if topmost_call:
1.03 options.py(775):             seen_models = set()
1.03 options.py(776):         seen_models.add(self.model)
1.03 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.03 options.py(781):         try:
1.03 options.py(784):             return self._get_fields_cache[cache_key]
1.03 options.py(785):         except KeyError:
1.03 options.py(786):             pass
1.03 options.py(788):         fields = []
1.03 options.py(791):         if include_parents is not False:
1.03 options.py(792):             for parent in self.parents:
1.03 options.py(806):         if reverse and not self.proxy:
1.03 options.py(810):             all_fields = self._relation_tree
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.03 options.py(815):                     fields.append(field.remote_field)
1.03 options.py(811):             for field in all_fields:
1.03 options.py(817):         if forward:
1.03 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(833):         self._get_fields_cache[cache_key] = fields
1.03 options.py(834):         return fields
1.03 options.py(525):         return make_immutable_fields_list(
1.03 options.py(526):             "related_objects",
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.03 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.03 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.04 base.py(1752):         invalid_fields.extend(fields - valid_fields)
1.04 base.py(1754):         for invalid_field in invalid_fields:
1.04 base.py(1763):         return errors
1.04 base.py(1280):                 *cls._check_constraints(),
1.04 base.py(1840):         errors = []
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1844):             connection = connections[db]
1.04 base.py(1846):                 connection.features.supports_table_check_constraints or
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1844):             connection = connections[db]
1.04 base.py(1846):                 connection.features.supports_table_check_constraints or
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1862):         return errors
1.04 base.py(1283):         return errors
1.04 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.04 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.04 base.py(1288):         errors = []
1.04 base.py(1289):         if cls._meta.swapped:
1.04 options.py(347):         if self.swappable:
1.04 options.py(361):         return None
1.04 base.py(1310):         return errors
1.04 base.py(1314):         errors = []
1.04 base.py(1315):         if cls._meta.proxy:
1.04 base.py(1323):         return errors
1.04 base.py(1328):         errors = []
1.04 base.py(1329):         for manager in cls._meta.managers:
1.04 base.py(1330):             errors.extend(manager.check(**kwargs))
1.04 base.py(1329):         for manager in cls._meta.managers:
1.04 base.py(1331):         return errors
1.04 base.py(1257):         if not cls._meta.swapped:
1.04 options.py(347):         if self.swappable:
1.04 options.py(361):         return None
1.04 base.py(1258):             errors += [
1.04 base.py(1259):                 *cls._check_fields(**kwargs),
1.04 base.py(1336):         errors = []
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1339):         for field in cls._meta.local_many_to_many:
1.04 base.py(1340):             errors.extend(field.check(from_model=cls, **kwargs))
1.04 options.py(508):         return make_immutable_fields_list(
1.04 options.py(509):             "many_to_many",
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(456):         def is_not_an_m2m_field(f):
1.04 options.py(459):         def is_not_a_generic_relation(f):
1.04 options.py(462):         def is_not_a_generic_foreign_key(f):
1.04 options.py(467):         return make_immutable_fields_list(
1.04 options.py(468):             "fields",
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 base.py(1339):         for field in cls._meta.local_many_to_many:
1.04 base.py(1341):         return errors
1.04 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.04 base.py(1348):         errors = []
1.04 base.py(1349):         seen_intermediary_signatures = []
1.04 base.py(1351):         fields = cls._meta.local_many_to_many
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1359):         for f in fields:
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1360):             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1.04 base.py(1361):             if signature in seen_intermediary_signatures:
1.04 base.py(1372):                 seen_intermediary_signatures.append(signature)
1.04 base.py(1359):         for f in fields:
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1373):         return errors
1.04 base.py(1261):                 *cls._check_long_column_names(),
1.04 base.py(1771):         errors = []
1.04 base.py(1772):         allowed_len = None
1.04 base.py(1773):         db_alias = None
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1780):             connection = connections[db]
1.04 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.04 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1780):             connection = connections[db]
1.04 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.04 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1792):         if allowed_len is None:
1.04 base.py(1793):             return errors
1.04 base.py(1264):                 *cls._check_id_field(),
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.04 base.py(1390):             return []
1.04 base.py(1265):                 *cls._check_field_name_clashes(),
1.04 base.py(1395):         errors = []
1.04 base.py(1396):         used_fields = {}  # name or attname -> field
1.04 base.py(1399):         for parent in cls._meta.get_parent_list():
1.04 options.py(607):         result = OrderedSet(self.parents)
1.04 options.py(608):         for parent in self.parents:
1.04 options.py(611):         return list(result)
1.04 base.py(1421):         for parent in cls._meta.get_parent_list():
1.04 options.py(607):         result = OrderedSet(self.parents)
1.04 options.py(608):         for parent in self.parents:
1.04 options.py(611):         return list(result)
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1447):         return errors
1.04 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.04 base.py(1476):         errors = []
1.04 base.py(1477):         model_name = cls.__name__
1.04 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.04 base.py(1487):         elif LOOKUP_SEP in model_name:
1.04 base.py(1496):         return errors
1.04 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.04 base.py(1500):         errors = []
1.04 base.py(1501):         property_names = cls._meta._property_names
1.04 options.py(839):         names = []
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(843):                 names.append(name)
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(844):         return frozenset(names)
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 base.py(1506):         for accessor in related_field_accessors:
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1507):             if accessor in property_names:
1.04 base.py(1506):         for accessor in related_field_accessors:
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1516):         return errors
1.04 base.py(1268):                 *cls._check_single_primary_key(),
1.04 base.py(1520):         errors = []
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1530):         return errors
1.04 base.py(1270):             errors.extend(clash_errors)
1.04 base.py(1273):             if not clash_errors:
1.04 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.04 base.py(1452):         used_column_names = []
1.04 base.py(1453):         errors = []
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1472):         return errors
1.04 base.py(1275):             errors += [
1.04 base.py(1276):                 *cls._check_index_together(),
1.04 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.04 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.04 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.04 base.py(1554):             errors = []
1.04 base.py(1555):             for fields in cls._meta.index_together:
1.04 base.py(1557):             return errors
1.04 base.py(1277):                 *cls._check_unique_together(),
1.04 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.04 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.04 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.04 base.py(1581):             errors = []
1.04 base.py(1582):             for fields in cls._meta.unique_together:
1.04 base.py(1584):             return errors
1.04 base.py(1278):                 *cls._check_indexes(),
1.04 base.py(1589):         errors = []
1.04 base.py(1590):         for index in cls._meta.indexes:
1.04 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.04 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.04 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.04 base.py(1617):         from django.db import models
1.04 base.py(1621):         forward_fields_map = {}
1.04 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 base.py(1623):             forward_fields_map[field.name] = field
1.04 base.py(1624):             if hasattr(field, 'attname'):
1.04 base.py(1625):                 forward_fields_map[field.attname] = field
1.04 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.04 base.py(1623):             forward_fields_map[field.name] = field
1.04 base.py(1624):             if hasattr(field, 'attname'):
1.04 base.py(1625):                 forward_fields_map[field.attname] = field
1.04 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.04 base.py(1623):             forward_fields_map[field.name] = field
1.04 base.py(1624):             if hasattr(field, 'attname'):
1.04 base.py(1625):                 forward_fields_map[field.attname] = field
1.04 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.04 base.py(1627):         errors = []
1.04 base.py(1628):         for field_name in fields:
1.04 base.py(1663):         return errors
1.04 base.py(1613):         return errors
1.04 base.py(1279):                 *cls._check_ordering(),
1.04 base.py(1671):         if cls._meta._ordering_clash:
1.04 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.04 base.py(1681):             return []
1.04 base.py(1280):                 *cls._check_constraints(),
1.04 base.py(1840):         errors = []
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1844):             connection = connections[db]
1.04 base.py(1846):                 connection.features.supports_table_check_constraints or
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1844):             connection = connections[db]
1.04 base.py(1846):                 connection.features.supports_table_check_constraints or
1.04 base.py(1841):         for db in settings.DATABASES:
1.04 base.py(1862):         return errors
1.04 base.py(1283):         return errors
1.04 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.04 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.04 base.py(1288):         errors = []
1.04 base.py(1289):         if cls._meta.swapped:
1.04 options.py(347):         if self.swappable:
1.04 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
1.04 options.py(349):             if swapped_for:
1.04 options.py(350):                 try:
1.04 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
1.04 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
1.04 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.04 options.py(361):         return None
1.04 base.py(1310):         return errors
1.04 base.py(1314):         errors = []
1.04 base.py(1315):         if cls._meta.proxy:
1.04 base.py(1323):         return errors
1.04 base.py(1328):         errors = []
1.04 base.py(1329):         for manager in cls._meta.managers:
1.04 base.py(1330):             errors.extend(manager.check(**kwargs))
1.04 base.py(1329):         for manager in cls._meta.managers:
1.04 base.py(1331):         return errors
1.04 base.py(1257):         if not cls._meta.swapped:
1.04 options.py(347):         if self.swappable:
1.04 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
1.04 options.py(349):             if swapped_for:
1.04 options.py(350):                 try:
1.04 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
1.04 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
1.04 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.04 options.py(361):         return None
1.04 base.py(1258):             errors += [
1.04 base.py(1259):                 *cls._check_fields(**kwargs),
1.04 base.py(1336):         errors = []
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1338):             errors.extend(field.check(**kwargs))
1.04 base.py(1337):         for field in cls._meta.local_fields:
1.04 base.py(1339):         for field in cls._meta.local_many_to_many:
1.04 base.py(1340):             errors.extend(field.check(from_model=cls, **kwargs))
1.04 options.py(456):         def is_not_an_m2m_field(f):
1.04 options.py(459):         def is_not_a_generic_relation(f):
1.04 options.py(462):         def is_not_a_generic_foreign_key(f):
1.04 options.py(467):         return make_immutable_fields_list(
1.04 options.py(468):             "fields",
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(508):         return make_immutable_fields_list(
1.04 options.py(509):             "many_to_many",
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.04 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(785):         except KeyError:
1.04 options.py(786):             pass
1.04 options.py(788):         fields = []
1.04 options.py(791):         if include_parents is not False:
1.04 options.py(792):             for parent in self.parents:
1.04 options.py(806):         if reverse and not self.proxy:
1.04 options.py(810):             all_fields = self._relation_tree
1.04 options.py(811):             for field in all_fields:
1.04 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.04 options.py(815):                     fields.append(field.remote_field)
1.04 options.py(811):             for field in all_fields:
1.04 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.04 options.py(815):                     fields.append(field.remote_field)
1.04 options.py(811):             for field in all_fields:
1.04 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.04 options.py(815):                     fields.append(field.remote_field)
1.04 options.py(811):             for field in all_fields:
1.04 options.py(817):         if forward:
1.04 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(833):         self._get_fields_cache[cache_key] = fields
1.04 options.py(834):         return fields
1.04 options.py(525):         return make_immutable_fields_list(
1.04 options.py(526):             "related_objects",
1.04 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.04 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.04 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.04 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.04 options.py(456):         def is_not_an_m2m_field(f):
1.04 options.py(459):         def is_not_a_generic_relation(f):
1.04 options.py(462):         def is_not_a_generic_foreign_key(f):
1.04 options.py(467):         return make_immutable_fields_list(
1.04 options.py(468):             "fields",
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 base.py(1339):         for field in cls._meta.local_many_to_many:
1.04 base.py(1340):             errors.extend(field.check(from_model=cls, **kwargs))
1.04 options.py(456):         def is_not_an_m2m_field(f):
1.04 options.py(459):         def is_not_a_generic_relation(f):
1.04 options.py(462):         def is_not_a_generic_foreign_key(f):
1.04 options.py(467):         return make_immutable_fields_list(
1.04 options.py(468):             "fields",
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.04 options.py(457):             return not (f.is_relation and f.many_to_many)
1.04 options.py(460):             return not (f.is_relation and f.one_to_many)
1.04 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.04 options.py(469):             (f for f in self._get_fields(reverse=False)
1.04 base.py(1339):         for field in cls._meta.local_many_to_many:
1.04 base.py(1341):         return errors
1.04 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.04 base.py(1348):         errors = []
1.04 base.py(1349):         seen_intermediary_signatures = []
1.04 base.py(1351):         fields = cls._meta.local_many_to_many
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1359):         for f in fields:
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1360):             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1.04 base.py(1361):             if signature in seen_intermediary_signatures:
1.04 base.py(1372):                 seen_intermediary_signatures.append(signature)
1.04 base.py(1359):         for f in fields:
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1360):             signature = (f.remote_field.model, cls, f.remote_field.through, f.remote_field.through_fields)
1.04 base.py(1361):             if signature in seen_intermediary_signatures:
1.04 base.py(1372):                 seen_intermediary_signatures.append(signature)
1.04 base.py(1359):         for f in fields:
1.04 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.04 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.04 base.py(1373):         return errors
1.04 base.py(1261):                 *cls._check_long_column_names(),
1.04 base.py(1771):         errors = []
1.04 base.py(1772):         allowed_len = None
1.04 base.py(1773):         db_alias = None
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1780):             connection = connections[db]
1.04 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.04 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.04 base.py(1780):             connection = connections[db]
1.04 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.04 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.04 base.py(1776):         for db in settings.DATABASES:
1.04 base.py(1792):         if allowed_len is None:
1.04 base.py(1793):             return errors
1.04 base.py(1264):                 *cls._check_id_field(),
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.04 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.04 base.py(1390):             return []
1.04 base.py(1265):                 *cls._check_field_name_clashes(),
1.04 base.py(1395):         errors = []
1.04 base.py(1396):         used_fields = {}  # name or attname -> field
1.04 base.py(1399):         for parent in cls._meta.get_parent_list():
1.04 options.py(607):         result = OrderedSet(self.parents)
1.04 options.py(608):         for parent in self.parents:
1.04 options.py(611):         return list(result)
1.04 base.py(1421):         for parent in cls._meta.get_parent_list():
1.04 options.py(607):         result = OrderedSet(self.parents)
1.04 options.py(608):         for parent in self.parents:
1.04 options.py(611):         return list(result)
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.04 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.04 base.py(1433):             if clash and not id_conflict:
1.04 base.py(1444):             used_fields[f.name] = f
1.04 base.py(1445):             used_fields[f.attname] = f
1.04 base.py(1426):         for f in cls._meta.local_fields:
1.04 base.py(1447):         return errors
1.04 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.04 base.py(1476):         errors = []
1.04 base.py(1477):         model_name = cls.__name__
1.04 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.04 base.py(1487):         elif LOOKUP_SEP in model_name:
1.04 base.py(1496):         return errors
1.04 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.04 base.py(1500):         errors = []
1.04 base.py(1501):         property_names = cls._meta._property_names
1.04 options.py(839):         names = []
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(843):                 names.append(name)
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(843):                 names.append(name)
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(843):                 names.append(name)
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.04 options.py(842):             if isinstance(attr, property):
1.04 options.py(840):         for name in dir(self.model):
1.04 options.py(844):         return frozenset(names)
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.04 options.py(773):         topmost_call = seen_models is None
1.04 options.py(774):         if topmost_call:
1.04 options.py(775):             seen_models = set()
1.04 options.py(776):         seen_models.add(self.model)
1.04 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.04 options.py(781):         try:
1.04 options.py(784):             return self._get_fields_cache[cache_key]
1.04 base.py(1506):         for accessor in related_field_accessors:
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1507):             if accessor in property_names:
1.04 base.py(1506):         for accessor in related_field_accessors:
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1504):             if f.is_relation and f.related_model is not None
1.04 base.py(1507):             if accessor in property_names:
1.04 base.py(1506):         for accessor in related_field_accessors:
1.04 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.04 base.py(1516):         return errors
1.04 base.py(1268):                 *cls._check_single_primary_key(),
1.04 base.py(1520):         errors = []
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.04 base.py(1530):         return errors
1.04 base.py(1270):             errors.extend(clash_errors)
1.04 base.py(1273):             if not clash_errors:
1.04 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.04 base.py(1452):         used_column_names = []
1.04 base.py(1453):         errors = []
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1456):             _, column_name = f.get_attname_column()
1.04 base.py(1459):             if column_name and column_name in used_column_names:
1.04 base.py(1470):                 used_column_names.append(column_name)
1.04 base.py(1455):         for f in cls._meta.local_fields:
1.04 base.py(1472):         return errors
1.04 base.py(1275):             errors += [
1.04 base.py(1276):                 *cls._check_index_together(),
1.04 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.04 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1554):             errors = []
1.05 base.py(1555):             for fields in cls._meta.index_together:
1.05 base.py(1557):             return errors
1.05 base.py(1277):                 *cls._check_unique_together(),
1.05 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1581):             errors = []
1.05 base.py(1582):             for fields in cls._meta.unique_together:
1.05 base.py(1584):             return errors
1.05 base.py(1278):                 *cls._check_indexes(),
1.05 base.py(1589):         errors = []
1.05 base.py(1590):         for index in cls._meta.indexes:
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.05 base.py(1617):         from django.db import models
1.05 base.py(1621):         forward_fields_map = {}
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1627):         errors = []
1.05 base.py(1628):         for field_name in fields:
1.05 base.py(1663):         return errors
1.05 base.py(1613):         return errors
1.05 base.py(1279):                 *cls._check_ordering(),
1.05 base.py(1671):         if cls._meta._ordering_clash:
1.05 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.05 base.py(1681):             return []
1.05 base.py(1280):                 *cls._check_constraints(),
1.05 base.py(1840):         errors = []
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1862):         return errors
1.05 base.py(1283):         return errors
1.05 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.05 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.05 base.py(1288):         errors = []
1.05 base.py(1289):         if cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1310):         return errors
1.05 base.py(1314):         errors = []
1.05 base.py(1315):         if cls._meta.proxy:
1.05 base.py(1323):         return errors
1.05 base.py(1328):         errors = []
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1330):             errors.extend(manager.check(**kwargs))
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1331):         return errors
1.05 base.py(1257):         if not cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1258):             errors += [
1.05 base.py(1259):                 *cls._check_fields(**kwargs),
1.05 base.py(1336):         errors = []
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1339):         for field in cls._meta.local_many_to_many:
1.05 base.py(1341):         return errors
1.05 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.05 base.py(1348):         errors = []
1.05 base.py(1349):         seen_intermediary_signatures = []
1.05 base.py(1351):         fields = cls._meta.local_many_to_many
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1359):         for f in fields:
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1373):         return errors
1.05 base.py(1261):                 *cls._check_long_column_names(),
1.05 base.py(1771):         errors = []
1.05 base.py(1772):         allowed_len = None
1.05 base.py(1773):         db_alias = None
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1792):         if allowed_len is None:
1.05 base.py(1793):             return errors
1.05 base.py(1264):                 *cls._check_id_field(),
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.05 base.py(1390):             return []
1.05 base.py(1265):                 *cls._check_field_name_clashes(),
1.05 base.py(1395):         errors = []
1.05 base.py(1396):         used_fields = {}  # name or attname -> field
1.05 base.py(1399):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1421):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1447):         return errors
1.05 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.05 base.py(1476):         errors = []
1.05 base.py(1477):         model_name = cls.__name__
1.05 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.05 base.py(1487):         elif LOOKUP_SEP in model_name:
1.05 base.py(1496):         return errors
1.05 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.05 base.py(1500):         errors = []
1.05 base.py(1501):         property_names = cls._meta._property_names
1.05 options.py(839):         names = []
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(843):                 names.append(name)
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(844):         return frozenset(names)
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 base.py(1506):         for accessor in related_field_accessors:
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1516):         return errors
1.05 base.py(1268):                 *cls._check_single_primary_key(),
1.05 base.py(1520):         errors = []
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1530):         return errors
1.05 base.py(1270):             errors.extend(clash_errors)
1.05 base.py(1273):             if not clash_errors:
1.05 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.05 base.py(1452):         used_column_names = []
1.05 base.py(1453):         errors = []
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1472):         return errors
1.05 base.py(1275):             errors += [
1.05 base.py(1276):                 *cls._check_index_together(),
1.05 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.05 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1554):             errors = []
1.05 base.py(1555):             for fields in cls._meta.index_together:
1.05 base.py(1557):             return errors
1.05 base.py(1277):                 *cls._check_unique_together(),
1.05 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1581):             errors = []
1.05 base.py(1582):             for fields in cls._meta.unique_together:
1.05 base.py(1584):             return errors
1.05 base.py(1278):                 *cls._check_indexes(),
1.05 base.py(1589):         errors = []
1.05 base.py(1590):         for index in cls._meta.indexes:
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.05 base.py(1617):         from django.db import models
1.05 base.py(1621):         forward_fields_map = {}
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1627):         errors = []
1.05 base.py(1628):         for field_name in fields:
1.05 base.py(1663):         return errors
1.05 base.py(1613):         return errors
1.05 base.py(1279):                 *cls._check_ordering(),
1.05 base.py(1671):         if cls._meta._ordering_clash:
1.05 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.05 base.py(1683):         if not isinstance(cls._meta.ordering, (list, tuple)):
1.05 base.py(1692):         errors = []
1.05 base.py(1693):         fields = cls._meta.ordering
1.05 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.05 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.05 base.py(1702):         _fields = []
1.05 base.py(1703):         related_fields = []
1.05 base.py(1704):         for f in fields:
1.05 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.05 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.05 base.py(1705):             if LOOKUP_SEP in f:
1.05 base.py(1708):                 _fields.append(f)
1.05 base.py(1704):         for f in fields:
1.05 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.05 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.05 base.py(1709):         fields = _fields
1.05 base.py(1712):         for field in related_fields:
1.05 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.05 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.05 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.05 base.py(1742):         invalid_fields = []
1.05 base.py(1746):         opts = cls._meta
1.05 base.py(1747):         valid_fields = set(chain.from_iterable(
1.05 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.05 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.05 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 options.py(785):         except KeyError:
1.05 options.py(786):             pass
1.05 options.py(788):         fields = []
1.05 options.py(791):         if include_parents is not False:
1.05 options.py(792):             for parent in self.parents:
1.05 options.py(806):         if reverse and not self.proxy:
1.05 options.py(810):             all_fields = self._relation_tree
1.05 options.py(811):             for field in all_fields:
1.05 options.py(817):         if forward:
1.05 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(833):         self._get_fields_cache[cache_key] = fields
1.05 options.py(834):         return fields
1.05 options.py(525):         return make_immutable_fields_list(
1.05 options.py(526):             "related_objects",
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.05 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.05 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.05 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.05 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.05 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.05 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.05 base.py(1752):         invalid_fields.extend(fields - valid_fields)
1.05 base.py(1754):         for invalid_field in invalid_fields:
1.05 base.py(1763):         return errors
1.05 base.py(1280):                 *cls._check_constraints(),
1.05 base.py(1840):         errors = []
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1862):         return errors
1.05 base.py(1283):         return errors
1.05 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.05 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.05 base.py(1288):         errors = []
1.05 base.py(1289):         if cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1310):         return errors
1.05 base.py(1314):         errors = []
1.05 base.py(1315):         if cls._meta.proxy:
1.05 base.py(1323):         return errors
1.05 base.py(1328):         errors = []
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1330):             errors.extend(manager.check(**kwargs))
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1331):         return errors
1.05 base.py(1257):         if not cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1258):             errors += [
1.05 base.py(1259):                 *cls._check_fields(**kwargs),
1.05 base.py(1336):         errors = []
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1339):         for field in cls._meta.local_many_to_many:
1.05 base.py(1341):         return errors
1.05 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.05 base.py(1348):         errors = []
1.05 base.py(1349):         seen_intermediary_signatures = []
1.05 base.py(1351):         fields = cls._meta.local_many_to_many
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1359):         for f in fields:
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1373):         return errors
1.05 base.py(1261):                 *cls._check_long_column_names(),
1.05 base.py(1771):         errors = []
1.05 base.py(1772):         allowed_len = None
1.05 base.py(1773):         db_alias = None
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1792):         if allowed_len is None:
1.05 base.py(1793):             return errors
1.05 base.py(1264):                 *cls._check_id_field(),
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.05 base.py(1390):             return []
1.05 base.py(1265):                 *cls._check_field_name_clashes(),
1.05 base.py(1395):         errors = []
1.05 base.py(1396):         used_fields = {}  # name or attname -> field
1.05 base.py(1399):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1421):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1447):         return errors
1.05 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.05 base.py(1476):         errors = []
1.05 base.py(1477):         model_name = cls.__name__
1.05 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.05 base.py(1487):         elif LOOKUP_SEP in model_name:
1.05 base.py(1496):         return errors
1.05 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.05 base.py(1500):         errors = []
1.05 base.py(1501):         property_names = cls._meta._property_names
1.05 options.py(839):         names = []
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(843):                 names.append(name)
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(844):         return frozenset(names)
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 options.py(785):         except KeyError:
1.05 options.py(786):             pass
1.05 options.py(788):         fields = []
1.05 options.py(791):         if include_parents is not False:
1.05 options.py(792):             for parent in self.parents:
1.05 options.py(806):         if reverse and not self.proxy:
1.05 options.py(817):         if forward:
1.05 options.py(818):             fields += self.local_fields
1.05 options.py(819):             fields += self.local_many_to_many
1.05 options.py(825):             if topmost_call:
1.05 options.py(826):                 fields += self.private_fields
1.05 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(833):         self._get_fields_cache[cache_key] = fields
1.05 options.py(834):         return fields
1.05 base.py(1506):         for accessor in related_field_accessors:
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1504):             if f.is_relation and f.related_model is not None
1.05 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.05 base.py(1516):         return errors
1.05 base.py(1268):                 *cls._check_single_primary_key(),
1.05 base.py(1520):         errors = []
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.05 base.py(1530):         return errors
1.05 base.py(1270):             errors.extend(clash_errors)
1.05 base.py(1273):             if not clash_errors:
1.05 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.05 base.py(1452):         used_column_names = []
1.05 base.py(1453):         errors = []
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1456):             _, column_name = f.get_attname_column()
1.05 base.py(1459):             if column_name and column_name in used_column_names:
1.05 base.py(1470):                 used_column_names.append(column_name)
1.05 base.py(1455):         for f in cls._meta.local_fields:
1.05 base.py(1472):         return errors
1.05 base.py(1275):             errors += [
1.05 base.py(1276):                 *cls._check_index_together(),
1.05 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.05 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.05 base.py(1554):             errors = []
1.05 base.py(1555):             for fields in cls._meta.index_together:
1.05 base.py(1557):             return errors
1.05 base.py(1277):                 *cls._check_unique_together(),
1.05 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.05 base.py(1581):             errors = []
1.05 base.py(1582):             for fields in cls._meta.unique_together:
1.05 base.py(1584):             return errors
1.05 base.py(1278):                 *cls._check_indexes(),
1.05 base.py(1589):         errors = []
1.05 base.py(1590):         for index in cls._meta.indexes:
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.05 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.05 base.py(1617):         from django.db import models
1.05 base.py(1621):         forward_fields_map = {}
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1623):             forward_fields_map[field.name] = field
1.05 base.py(1624):             if hasattr(field, 'attname'):
1.05 base.py(1625):                 forward_fields_map[field.attname] = field
1.05 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.05 base.py(1627):         errors = []
1.05 base.py(1628):         for field_name in fields:
1.05 base.py(1663):         return errors
1.05 base.py(1613):         return errors
1.05 base.py(1279):                 *cls._check_ordering(),
1.05 base.py(1671):         if cls._meta._ordering_clash:
1.05 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.05 base.py(1681):             return []
1.05 base.py(1280):                 *cls._check_constraints(),
1.05 base.py(1840):         errors = []
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1844):             connection = connections[db]
1.05 base.py(1846):                 connection.features.supports_table_check_constraints or
1.05 base.py(1841):         for db in settings.DATABASES:
1.05 base.py(1862):         return errors
1.05 base.py(1283):         return errors
1.05 options.py(134):         return '%s.%s' % (self.app_label, self.object_name)
1.05 base.py(1256):         errors = [*cls._check_swappable(), *cls._check_model(), *cls._check_managers(**kwargs)]
1.05 base.py(1288):         errors = []
1.05 base.py(1289):         if cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1310):         return errors
1.05 base.py(1314):         errors = []
1.05 base.py(1315):         if cls._meta.proxy:
1.05 base.py(1323):         return errors
1.05 base.py(1328):         errors = []
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1330):             errors.extend(manager.check(**kwargs))
1.05 base.py(1329):         for manager in cls._meta.managers:
1.05 base.py(1331):         return errors
1.05 base.py(1257):         if not cls._meta.swapped:
1.05 options.py(347):         if self.swappable:
1.05 options.py(361):         return None
1.05 base.py(1258):             errors += [
1.05 base.py(1259):                 *cls._check_fields(**kwargs),
1.05 base.py(1336):         errors = []
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 options.py(508):         return make_immutable_fields_list(
1.05 options.py(509):             "many_to_many",
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(510):             (f for f in self._get_fields(reverse=False) if f.is_relation and f.many_to_many)
1.05 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 options.py(785):         except KeyError:
1.05 options.py(786):             pass
1.05 options.py(788):         fields = []
1.05 options.py(791):         if include_parents is not False:
1.05 options.py(792):             for parent in self.parents:
1.05 options.py(806):         if reverse and not self.proxy:
1.05 options.py(810):             all_fields = self._relation_tree
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(815):                     fields.append(field.remote_field)
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(815):                     fields.append(field.remote_field)
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(815):                     fields.append(field.remote_field)
1.05 options.py(811):             for field in all_fields:
1.05 options.py(817):         if forward:
1.05 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(833):         self._get_fields_cache[cache_key] = fields
1.05 options.py(834):         return fields
1.05 options.py(525):         return make_immutable_fields_list(
1.05 options.py(526):             "related_objects",
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.05 options.py(748):         if include_parents is False:
1.05 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 options.py(785):         except KeyError:
1.05 options.py(786):             pass
1.05 options.py(788):         fields = []
1.05 options.py(791):         if include_parents is not False:
1.05 options.py(792):             for parent in self.parents:
1.05 options.py(806):         if reverse and not self.proxy:
1.05 options.py(810):             all_fields = self._relation_tree
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(811):             for field in all_fields:
1.05 options.py(814):                 if include_hidden or not field.remote_field.hidden:
1.05 options.py(815):                     fields.append(field.remote_field)
1.05 options.py(811):             for field in all_fields:
1.05 options.py(817):         if forward:
1.05 options.py(818):             fields += self.local_fields
1.05 options.py(819):             fields += self.local_many_to_many
1.05 options.py(825):             if topmost_call:
1.05 options.py(826):                 fields += self.private_fields
1.05 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.05 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.05 options.py(833):         self._get_fields_cache[cache_key] = fields
1.05 options.py(834):         return fields
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 options.py(564):         try:
1.05 options.py(567):             return self._forward_fields_map[field_name]
1.05 options.py(748):         if include_parents is False:
1.05 options.py(750):         return self._get_fields(include_parents=include_parents, include_hidden=include_hidden)
1.05 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.05 options.py(773):         topmost_call = seen_models is None
1.05 options.py(774):         if topmost_call:
1.05 options.py(775):             seen_models = set()
1.05 options.py(776):         seen_models.add(self.model)
1.05 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.05 options.py(781):         try:
1.05 options.py(784):             return self._get_fields_cache[cache_key]
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1338):             errors.extend(field.check(**kwargs))
1.05 base.py(1337):         for field in cls._meta.local_fields:
1.05 base.py(1339):         for field in cls._meta.local_many_to_many:
1.05 base.py(1341):         return errors
1.05 base.py(1260):                 *cls._check_m2m_through_same_relationship(),
1.05 base.py(1348):         errors = []
1.05 base.py(1349):         seen_intermediary_signatures = []
1.05 base.py(1351):         fields = cls._meta.local_many_to_many
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1359):         for f in fields:
1.05 base.py(1357):         fields = (f for f in fields if isinstance(f.remote_field.through, ModelBase))
1.05 base.py(1354):         fields = (f for f in fields if isinstance(f.remote_field.model, ModelBase))
1.05 base.py(1373):         return errors
1.05 base.py(1261):                 *cls._check_long_column_names(),
1.05 base.py(1771):         errors = []
1.05 base.py(1772):         allowed_len = None
1.05 base.py(1773):         db_alias = None
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1778):             if not router.allow_migrate_model(db, cls):
1.05 base.py(1780):             connection = connections[db]
1.05 base.py(1781):             max_name_length = connection.ops.max_name_length()
1.05 base.py(1782):             if max_name_length is None or connection.features.truncates_names:
1.05 base.py(1776):         for db in settings.DATABASES:
1.05 base.py(1792):         if allowed_len is None:
1.05 base.py(1793):             return errors
1.05 base.py(1264):                 *cls._check_id_field(),
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1378):         fields = [f for f in cls._meta.local_fields if f.name == 'id' and f != cls._meta.pk]
1.05 base.py(1380):         if fields and not fields[0].primary_key and cls._meta.pk.name == 'id':
1.05 base.py(1390):             return []
1.05 base.py(1265):                 *cls._check_field_name_clashes(),
1.05 base.py(1395):         errors = []
1.05 base.py(1396):         used_fields = {}  # name or attname -> field
1.05 base.py(1399):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1421):         for parent in cls._meta.get_parent_list():
1.05 options.py(607):         result = OrderedSet(self.parents)
1.05 options.py(608):         for parent in self.parents:
1.05 options.py(611):         return list(result)
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1427):             clash = used_fields.get(f.name) or used_fields.get(f.attname) or None
1.05 base.py(1432):             id_conflict = f.name == "id" and clash and clash.name == "id" and clash.model == cls
1.05 base.py(1433):             if clash and not id_conflict:
1.05 base.py(1444):             used_fields[f.name] = f
1.05 base.py(1445):             used_fields[f.attname] = f
1.05 base.py(1426):         for f in cls._meta.local_fields:
1.05 base.py(1447):         return errors
1.05 base.py(1266):                 *cls._check_model_name_db_lookup_clashes(),
1.05 base.py(1476):         errors = []
1.05 base.py(1477):         model_name = cls.__name__
1.05 base.py(1478):         if model_name.startswith('_') or model_name.endswith('_'):
1.05 base.py(1487):         elif LOOKUP_SEP in model_name:
1.05 base.py(1496):         return errors
1.05 base.py(1267):                 *cls._check_property_name_related_field_accessor_clashes(),
1.05 base.py(1500):         errors = []
1.05 base.py(1501):         property_names = cls._meta._property_names
1.05 options.py(839):         names = []
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.05 options.py(842):             if isinstance(attr, property):
1.05 options.py(840):         for name in dir(self.model):
1.05 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(843):                 names.append(name)
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(841):             attr = inspect.getattr_static(self.model, name)
1.06 options.py(842):             if isinstance(attr, property):
1.06 options.py(840):         for name in dir(self.model):
1.06 options.py(844):         return frozenset(names)
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.06 options.py(773):         topmost_call = seen_models is None
1.06 options.py(774):         if topmost_call:
1.06 options.py(775):             seen_models = set()
1.06 options.py(776):         seen_models.add(self.model)
1.06 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.06 options.py(781):         try:
1.06 options.py(784):             return self._get_fields_cache[cache_key]
1.06 base.py(1506):         for accessor in related_field_accessors:
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1507):             if accessor in property_names:
1.06 base.py(1506):         for accessor in related_field_accessors:
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1507):             if accessor in property_names:
1.06 base.py(1506):         for accessor in related_field_accessors:
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1504):             if f.is_relation and f.related_model is not None
1.06 base.py(1503):             f.get_attname() for f in cls._meta._get_fields(reverse=False)
1.06 base.py(1516):         return errors
1.06 base.py(1268):                 *cls._check_single_primary_key(),
1.06 base.py(1520):         errors = []
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1521):         if sum(1 for f in cls._meta.local_fields if f.primary_key) > 1:
1.06 base.py(1530):         return errors
1.06 base.py(1270):             errors.extend(clash_errors)
1.06 base.py(1273):             if not clash_errors:
1.06 base.py(1274):                 errors.extend(cls._check_column_name_clashes())
1.06 base.py(1452):         used_column_names = []
1.06 base.py(1453):         errors = []
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1456):             _, column_name = f.get_attname_column()
1.06 base.py(1459):             if column_name and column_name in used_column_names:
1.06 base.py(1470):                 used_column_names.append(column_name)
1.06 base.py(1455):         for f in cls._meta.local_fields:
1.06 base.py(1472):         return errors
1.06 base.py(1275):             errors += [
1.06 base.py(1276):                 *cls._check_index_together(),
1.06 base.py(1535):         if not isinstance(cls._meta.index_together, (tuple, list)):
1.06 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.06 base.py(1544):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.index_together):
1.06 base.py(1554):             errors = []
1.06 base.py(1555):             for fields in cls._meta.index_together:
1.06 base.py(1557):             return errors
1.06 base.py(1277):                 *cls._check_unique_together(),
1.06 base.py(1562):         if not isinstance(cls._meta.unique_together, (tuple, list)):
1.06 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.06 base.py(1571):         elif any(not isinstance(fields, (tuple, list)) for fields in cls._meta.unique_together):
1.06 base.py(1581):             errors = []
1.06 base.py(1582):             for fields in cls._meta.unique_together:
1.06 base.py(1584):             return errors
1.06 base.py(1278):                 *cls._check_indexes(),
1.06 base.py(1589):         errors = []
1.06 base.py(1590):         for index in cls._meta.indexes:
1.06 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.06 base.py(1611):         fields = [field for index in cls._meta.indexes for field, _ in index.fields_orders]
1.06 base.py(1612):         errors.extend(cls._check_local_fields(fields, 'indexes'))
1.06 base.py(1617):         from django.db import models
1.06 base.py(1621):         forward_fields_map = {}
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.06 options.py(773):         topmost_call = seen_models is None
1.06 options.py(774):         if topmost_call:
1.06 options.py(775):             seen_models = set()
1.06 options.py(776):         seen_models.add(self.model)
1.06 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.06 options.py(781):         try:
1.06 options.py(784):             return self._get_fields_cache[cache_key]
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1623):             forward_fields_map[field.name] = field
1.06 base.py(1624):             if hasattr(field, 'attname'):
1.06 base.py(1625):                 forward_fields_map[field.attname] = field
1.06 base.py(1622):         for field in cls._meta._get_fields(reverse=False):
1.06 base.py(1627):         errors = []
1.06 base.py(1628):         for field_name in fields:
1.06 base.py(1663):         return errors
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
test_mti_field_order_bug (test_coverup_django__django-12325.PickingModelTest) ... 1.06 base.py(1613):         return errors
1.06 base.py(1279):                 *cls._check_ordering(),
1.06 base.py(1671):         if cls._meta._ordering_clash:
1.06 base.py(1680):         if cls._meta.order_with_respect_to or not cls._meta.ordering:
1.06 base.py(1683):         if not isinstance(cls._meta.ordering, (list, tuple)):
1.06 base.py(1692):         errors = []
1.06 base.py(1693):         fields = cls._meta.ordering
1.06 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.06 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.06 base.py(1702):         _fields = []
1.06 base.py(1703):         related_fields = []
1.06 base.py(1704):         for f in fields:
1.06 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.06 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.06 base.py(1705):             if LOOKUP_SEP in f:
1.06 base.py(1708):                 _fields.append(f)
1.06 base.py(1704):         for f in fields:
1.06 base.py(1699):         fields = ((f[1:] if f.startswith('-') else f) for f in fields)
1.06 base.py(1696):         fields = (f for f in fields if isinstance(f, str) and f != '?')
1.06 base.py(1709):         fields = _fields
1.06 base.py(1712):         for field in related_fields:
1.06 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.06 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.06 base.py(1739):         fields = {f for f in fields if f != 'pk'}
1.06 base.py(1742):         invalid_fields = []
1.06 base.py(1746):         opts = cls._meta
1.06 base.py(1747):         valid_fields = set(chain.from_iterable(
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 options.py(524):         all_related_fields = self._get_fields(forward=False, reverse=True, include_hidden=True)
1.06 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.06 options.py(773):         topmost_call = seen_models is None
1.06 options.py(774):         if topmost_call:
1.06 options.py(775):             seen_models = set()
1.06 options.py(776):         seen_models.add(self.model)
1.06 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.06 options.py(781):         try:
1.06 options.py(784):             return self._get_fields_cache[cache_key]
1.06 options.py(785):         except KeyError:
1.06 options.py(786):             pass
1.06 options.py(788):         fields = []
1.06 options.py(791):         if include_parents is not False:
1.06 options.py(792):             for parent in self.parents:
1.06 options.py(806):         if reverse and not self.proxy:
1.06 options.py(810):             all_fields = self._relation_tree
1.06 options.py(811):             for field in all_fields:
1.06 options.py(817):         if forward:
1.06 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.06 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.06 options.py(833):         self._get_fields_cache[cache_key] = fields
1.06 options.py(834):         return fields
1.06 options.py(525):         return make_immutable_fields_list(
1.06 options.py(526):             "related_objects",
1.06 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.06 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.06 options.py(527):             (obj for obj in all_related_fields if not obj.hidden or obj.field.many_to_many)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1749):             for f in chain(opts.fields, opts.related_objects)
1.06 base.py(1748):             (f.name, f.attname) if not (f.auto_created and not f.concrete) else (f.field.related_query_name(),)
1.06 base.py(1752):         invalid_fields.extend(fields - valid_fields)
1.06 base.py(1754):         for invalid_field in invalid_fields:
1.06 base.py(1763):         return errors
1.06 base.py(1280):                 *cls._check_constraints(),
1.06 base.py(1840):         errors = []
1.06 base.py(1841):         for db in settings.DATABASES:
1.06 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.06 base.py(1844):             connection = connections[db]
1.06 base.py(1846):                 connection.features.supports_table_check_constraints or
1.06 base.py(1841):         for db in settings.DATABASES:
1.06 base.py(1842):             if not router.allow_migrate_model(db, cls):
1.06 base.py(1844):             connection = connections[db]
1.06 base.py(1846):                 connection.features.supports_table_check_constraints or
1.06 base.py(1841):         for db in settings.DATABASES:
1.06 base.py(1862):         return errors
1.06 base.py(1283):         return errors
System check identified no issues (0 silenced).
1.06 base.py(75):         super_new = super().__new__
1.06 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
1.06 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
1.06 base.py(79):         parents = [b for b in bases if isinstance(b, ModelBase)]
1.06 base.py(80):         if not parents:
1.06 base.py(84):         module = attrs.pop('__module__')
1.06 base.py(85):         new_attrs = {'__module__': module}
1.06 base.py(86):         classcell = attrs.pop('__classcell__', None)
1.06 base.py(87):         if classcell is not None:
1.06 base.py(89):         attr_meta = attrs.pop('Meta', None)
1.06 base.py(93):         contributable_attrs = {}
1.06 base.py(94):         for obj_name, obj in list(attrs.items()):
1.06 base.py(95):             if _has_contribute_to_class(obj):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(98):                 new_attrs[obj_name] = obj
1.06 base.py(94):         for obj_name, obj in list(attrs.items()):
1.06 base.py(95):             if _has_contribute_to_class(obj):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(96):                 contributable_attrs[obj_name] = obj
1.06 base.py(94):         for obj_name, obj in list(attrs.items()):
1.06 base.py(95):             if _has_contribute_to_class(obj):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(96):                 contributable_attrs[obj_name] = obj
1.06 base.py(94):         for obj_name, obj in list(attrs.items()):
1.06 base.py(99):         new_class = super_new(cls, name, bases, new_attrs, **kwargs)
1.06 base.py(101):         abstract = getattr(attr_meta, 'abstract', False)
1.06 base.py(102):         meta = attr_meta or getattr(new_class, 'Meta', None)
1.06 base.py(103):         base_meta = getattr(new_class, '_meta', None)
1.06 base.py(105):         app_label = None
1.06 base.py(108):         app_config = apps.get_containing_app_config(module)
1.06 base.py(110):         if getattr(meta, 'app_label', None) is None:
1.06 base.py(122):         new_class.add_to_class('_meta', Options(meta, app_label))
1.06 options.py(76):         self._get_fields_cache = {}
1.06 options.py(77):         self.local_fields = []
1.06 options.py(78):         self.local_many_to_many = []
1.06 options.py(79):         self.private_fields = []
1.06 options.py(80):         self.local_managers = []
1.06 options.py(81):         self.base_manager_name = None
1.06 options.py(82):         self.default_manager_name = None
1.06 options.py(83):         self.model_name = None
1.06 options.py(84):         self.verbose_name = None
1.06 options.py(85):         self.verbose_name_plural = None
1.06 options.py(86):         self.db_table = ''
1.06 options.py(87):         self.ordering = []
1.06 options.py(88):         self._ordering_clash = False
1.06 options.py(89):         self.indexes = []
1.06 options.py(90):         self.constraints = []
1.06 options.py(91):         self.unique_together = []
1.06 options.py(92):         self.index_together = []
1.06 options.py(93):         self.select_on_save = False
1.06 options.py(94):         self.default_permissions = ('add', 'change', 'delete', 'view')
1.06 options.py(95):         self.permissions = []
1.06 options.py(96):         self.object_name = None
1.06 options.py(97):         self.app_label = app_label
1.06 options.py(98):         self.get_latest_by = None
1.06 options.py(99):         self.order_with_respect_to = None
1.06 options.py(100):         self.db_tablespace = settings.DEFAULT_TABLESPACE
1.06 options.py(101):         self.required_db_features = []
1.06 options.py(102):         self.required_db_vendor = None
1.06 options.py(103):         self.meta = meta
1.06 options.py(104):         self.pk = None
1.06 options.py(105):         self.auto_field = None
1.06 options.py(106):         self.abstract = False
1.06 options.py(107):         self.managed = True
1.06 options.py(108):         self.proxy = False
1.06 options.py(114):         self.proxy_for_model = None
1.06 options.py(118):         self.concrete_model = None
1.06 options.py(119):         self.swappable = None
1.06 options.py(120):         self.parents = {}
1.06 options.py(121):         self.auto_created = False
1.06 options.py(125):         self.related_fkey_lookups = []
1.06 options.py(128):         self.apps = self.default_apps
1.06 options.py(130):         self.default_related_name = None
1.06 base.py(325):         if _has_contribute_to_class(value):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(326):             value.contribute_to_class(cls, name)
1.06 options.py(150):         from django.db import connection
1.06 options.py(151):         from django.db.backends.utils import truncate_name
1.06 options.py(153):         cls._meta = self
1.06 options.py(154):         self.model = cls
1.06 options.py(156):         self.object_name = cls.__name__
1.06 options.py(157):         self.model_name = self.object_name.lower()
1.06 options.py(158):         self.verbose_name = camel_case_to_spaces(self.object_name)
1.06 options.py(162):         self.original_attrs = {}
1.06 options.py(165):         if self.meta:
1.06 options.py(166):             meta_attrs = self.meta.__dict__.copy()
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(171):                 if name.startswith('_'):
1.06 options.py(172):                     del meta_attrs[name]
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(171):                 if name.startswith('_'):
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(171):                 if name.startswith('_'):
1.06 options.py(172):                     del meta_attrs[name]
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(171):                 if name.startswith('_'):
1.06 options.py(172):                     del meta_attrs[name]
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(171):                 if name.startswith('_'):
1.06 options.py(172):                     del meta_attrs[name]
1.06 options.py(167):             for name in self.meta.__dict__:
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(175):                     setattr(self, attr_name, meta_attrs.pop(attr_name))
1.06 options.py(176):                     self.original_attrs[attr_name] = getattr(self, attr_name)
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(174):                 if attr_name in meta_attrs:
1.06 options.py(177):                 elif hasattr(self.meta, attr_name):
1.06 options.py(173):             for attr_name in DEFAULT_NAMES:
1.06 options.py(181):             self.unique_together = normalize_together(self.unique_together)
1.06 options.py(45):     try:
1.06 options.py(46):         if not option_together:
1.06 options.py(47):             return ()
1.06 options.py(182):             self.index_together = normalize_together(self.index_together)
1.06 options.py(45):     try:
1.06 options.py(46):         if not option_together:
1.06 options.py(47):             return ()
1.06 options.py(185):             if not getattr(cls._meta, 'abstract', False):
1.06 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
1.06 options.py(187):                     objs = getattr(self, attr_name, [])
1.06 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
1.06 options.py(212):         new_objs = []
1.06 options.py(213):         for obj in objs:
1.06 options.py(220):         return new_objs
1.06 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
1.06 options.py(187):                     objs = getattr(self, attr_name, [])
1.06 options.py(188):                     setattr(self, attr_name, self._format_names_with_class(cls, objs))
1.06 options.py(212):         new_objs = []
1.06 options.py(213):         for obj in objs:
1.06 options.py(220):         return new_objs
1.06 options.py(186):                 for attr_name in {'constraints', 'indexes'}:
1.06 options.py(192):             if self.verbose_name_plural is None:
1.06 options.py(193):                 self.verbose_name_plural = format_lazy('{}s', self.verbose_name)
1.06 options.py(196):             self._ordering_clash = bool(self.ordering and self.order_with_respect_to)
1.06 options.py(199):             if meta_attrs != {}:
1.06 options.py(203):         del self.meta
1.06 options.py(206):         if not self.db_table:
1.06 options.py(207):             self.db_table = "%s_%s" % (self.app_label, self.model_name)
1.06 options.py(208):             self.db_table = truncate_name(self.db_table, connection.ops.max_name_length())
1.06 base.py(123):         if not abstract:
1.06 base.py(124):             new_class.add_to_class(
1.06 base.py(125):                 'DoesNotExist',
1.06 base.py(126):                 subclass_exception(
1.06 base.py(127):                     'DoesNotExist',
1.06 base.py(128):                     tuple(
1.06 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(129):                         x.DoesNotExist for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(131):                     module,
1.06 base.py(132):                     attached_to=new_class))
1.06 base.py(61):     return type(name, bases, {
1.06 base.py(62):         '__module__': module,
1.06 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
1.06 base.py(325):         if _has_contribute_to_class(value):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(328):             setattr(cls, name, value)
1.06 base.py(133):             new_class.add_to_class(
1.06 base.py(134):                 'MultipleObjectsReturned',
1.06 base.py(135):                 subclass_exception(
1.06 base.py(136):                     'MultipleObjectsReturned',
1.06 base.py(137):                     tuple(
1.06 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(138):                         x.MultipleObjectsReturned for x in parents if hasattr(x, '_meta') and not x._meta.abstract
1.06 base.py(140):                     module,
1.06 base.py(141):                     attached_to=new_class))
1.06 base.py(61):     return type(name, bases, {
1.06 base.py(62):         '__module__': module,
1.06 base.py(63):         '__qualname__': '%s.%s' % (attached_to.__qualname__, name),
1.06 base.py(325):         if _has_contribute_to_class(value):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(328):             setattr(cls, name, value)
1.06 base.py(142):             if base_meta and not base_meta.abstract:
1.06 base.py(146):                 if not hasattr(meta, 'ordering'):
1.06 base.py(147):                     new_class._meta.ordering = base_meta.ordering
1.06 base.py(148):                 if not hasattr(meta, 'get_latest_by'):
1.06 base.py(149):                     new_class._meta.get_latest_by = base_meta.get_latest_by
1.06 base.py(151):         is_proxy = new_class._meta.proxy
1.06 base.py(155):         if is_proxy and base_meta and base_meta.swapped:
1.06 base.py(160):         for obj_name, obj in contributable_attrs.items():
1.06 base.py(161):             new_class.add_to_class(obj_name, obj)
1.06 base.py(325):         if _has_contribute_to_class(value):
1.06 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.06 base.py(326):             value.contribute_to_class(cls, name)
1.07 options.py(271):         if private:
1.07 options.py(273):         elif field.is_relation and field.many_to_many:
1.07 options.py(276):             bisect.insort(self.local_fields, field)
1.07 options.py(277):             self.setup_pk(field)
1.07 options.py(297):         if not self.pk and field.primary_key:
1.07 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
1.07 options.py(288):             try:
1.07 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
1.07 options.py(728):         if forward:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(292):             self._expire_cache()
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 base.py(160):         for obj_name, obj in contributable_attrs.items():
1.07 base.py(161):             new_class.add_to_class(obj_name, obj)
1.07 base.py(325):         if _has_contribute_to_class(value):
1.07 base.py(69):     return not inspect.isclass(value) and hasattr(value, 'contribute_to_class')
1.07 base.py(326):             value.contribute_to_class(cls, name)
1.07 options.py(271):         if private:
1.07 options.py(273):         elif field.is_relation and field.many_to_many:
1.07 options.py(276):             bisect.insort(self.local_fields, field)
1.07 options.py(277):             self.setup_pk(field)
1.07 options.py(297):         if not self.pk and field.primary_key:
1.07 options.py(287):         if field.is_relation and hasattr(field.remote_field, 'model') and field.remote_field.model:
1.07 options.py(288):             try:
1.07 options.py(289):                 field.remote_field.model._meta._expire_cache(forward=False)
1.07 options.py(728):         if forward:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(292):             self._expire_cache()
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 base.py(160):         for obj_name, obj in contributable_attrs.items():
1.07 base.py(164):         new_fields = chain(
1.07 base.py(165):             new_class._meta.local_fields,
1.07 base.py(166):             new_class._meta.local_many_to_many,
1.07 base.py(167):             new_class._meta.private_fields
1.07 base.py(169):         field_names = {f.name for f in new_fields}
1.07 base.py(169):         field_names = {f.name for f in new_fields}
1.07 base.py(169):         field_names = {f.name for f in new_fields}
1.07 base.py(169):         field_names = {f.name for f in new_fields}
1.07 base.py(172):         if is_proxy:
1.07 base.py(192):             new_class._meta.concrete_model = new_class
1.07 base.py(195):         parent_links = {}
1.07 base.py(196):         for base in reversed([new_class] + parents):
1.07 base.py(198):             if not hasattr(base, '_meta'):
1.07 base.py(201):             if base != new_class and not base._meta.abstract:
1.07 base.py(202):                 continue
1.07 base.py(196):         for base in reversed([new_class] + parents):
1.07 base.py(198):             if not hasattr(base, '_meta'):
1.07 base.py(201):             if base != new_class and not base._meta.abstract:
1.07 base.py(204):             for field in base._meta.local_fields:
1.07 base.py(205):                 if isinstance(field, OneToOneField):
1.07 base.py(206):                     related = resolve_relation(new_class, field.remote_field.model)
1.07 base.py(207):                     parent_links[make_model_tuple(related)] = field
1.07 base.py(204):             for field in base._meta.local_fields:
1.07 base.py(205):                 if isinstance(field, OneToOneField):
1.07 base.py(206):                     related = resolve_relation(new_class, field.remote_field.model)
1.07 base.py(207):                     parent_links[make_model_tuple(related)] = field
1.07 base.py(204):             for field in base._meta.local_fields:
1.07 base.py(196):         for base in reversed([new_class] + parents):
1.07 base.py(210):         inherited_attributes = set()
1.07 base.py(212):         for base in new_class.mro():
1.07 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
1.07 base.py(216):                 inherited_attributes.update(base.__dict__)
1.07 base.py(217):                 continue
1.07 base.py(212):         for base in new_class.mro():
1.07 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
1.07 base.py(219):             parent_fields = base._meta.local_fields + base._meta.local_many_to_many
1.07 base.py(220):             if not base._meta.abstract:
1.07 base.py(223):                 for field in parent_fields:
1.07 base.py(224):                     if field.name in field_names:
1.07 base.py(234):                         inherited_attributes.add(field.name)
1.07 base.py(223):                 for field in parent_fields:
1.07 base.py(237):                 base = base._meta.concrete_model
1.07 base.py(238):                 base_key = make_model_tuple(base)
1.07 base.py(239):                 if base_key in parent_links:
1.07 base.py(240):                     field = parent_links[base_key]
1.07 base.py(268):                 new_class._meta.parents[base] = field
1.07 base.py(291):             for field in base._meta.private_fields:
1.07 base.py(212):         for base in new_class.mro():
1.07 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
1.07 base.py(216):                 inherited_attributes.update(base.__dict__)
1.07 base.py(217):                 continue
1.07 base.py(212):         for base in new_class.mro():
1.07 base.py(213):             if base not in parents or not hasattr(base, '_meta'):
1.07 base.py(216):                 inherited_attributes.update(base.__dict__)
1.07 base.py(217):                 continue
1.07 base.py(212):         for base in new_class.mro():
1.07 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
1.07 base.py(310):         new_class._meta.indexes = [copy.deepcopy(idx) for idx in new_class._meta.indexes]
1.07 base.py(312):         if abstract:
1.07 base.py(320):         new_class._prepare()
1.07 base.py(332):         opts = cls._meta
1.07 base.py(333):         opts._prepare(cls)
1.07 options.py(223):         if self.order_with_respect_to:
1.07 options.py(239):             self.order_with_respect_to = None
1.07 options.py(241):         if self.pk is None:
1.07 options.py(242):             if self.parents:
1.07 options.py(245):                 field = next(iter(self.parents.values()))
1.07 options.py(249):                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
1.07 options.py(249):                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
1.07 options.py(249):                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
1.07 options.py(249):                 already_created = [fld for fld in self.local_fields if fld.name == field.name]
1.07 options.py(250):                 if already_created:
1.07 options.py(251):                     field = already_created[0]
1.07 options.py(252):                 field.primary_key = True
1.07 options.py(253):                 self.setup_pk(field)
1.07 options.py(297):         if not self.pk and field.primary_key:
1.07 options.py(298):             self.pk = field
1.07 options.py(299):             field.serialize = False
1.07 options.py(254):                 if not field.remote_field.parent_link:
1.07 base.py(335):         if opts.order_with_respect_to:
1.07 base.py(350):         if cls.__doc__ is None:
1.07 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
1.07 options.py(456):         def is_not_an_m2m_field(f):
1.07 options.py(459):         def is_not_a_generic_relation(f):
1.07 options.py(462):         def is_not_a_generic_foreign_key(f):
1.07 options.py(467):         return make_immutable_fields_list(
1.07 options.py(468):             "fields",
1.07 options.py(469):             (f for f in self._get_fields(reverse=False)
1.07 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.07 options.py(773):         topmost_call = seen_models is None
1.07 options.py(774):         if topmost_call:
1.07 options.py(775):             seen_models = set()
1.07 options.py(776):         seen_models.add(self.model)
1.07 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.07 options.py(781):         try:
1.07 options.py(784):             return self._get_fields_cache[cache_key]
1.07 options.py(785):         except KeyError:
1.07 options.py(786):             pass
1.07 options.py(788):         fields = []
1.07 options.py(791):         if include_parents is not False:
1.07 options.py(792):             for parent in self.parents:
1.07 options.py(796):                 if parent in seen_models:
1.07 options.py(798):                 if (parent._meta.concrete_model != self.concrete_model and
1.07 options.py(799):                         include_parents == PROXY_PARENTS):
1.07 options.py(801):                 for obj in parent._meta._get_fields(
1.07 options.py(802):                         forward=forward, reverse=reverse, include_parents=include_parents,
1.07 options.py(803):                         include_hidden=include_hidden, seen_models=seen_models):
1.07 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.07 options.py(773):         topmost_call = seen_models is None
1.07 options.py(774):         if topmost_call:
1.07 options.py(776):         seen_models.add(self.model)
1.07 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.07 options.py(781):         try:
1.07 options.py(784):             return self._get_fields_cache[cache_key]
1.07 options.py(785):         except KeyError:
1.07 options.py(786):             pass
1.07 options.py(788):         fields = []
1.07 options.py(791):         if include_parents is not False:
1.07 options.py(792):             for parent in self.parents:
1.07 options.py(806):         if reverse and not self.proxy:
1.07 options.py(817):         if forward:
1.07 options.py(818):             fields += self.local_fields
1.07 options.py(819):             fields += self.local_many_to_many
1.07 options.py(825):             if topmost_call:
1.07 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.07 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.07 options.py(833):         self._get_fields_cache[cache_key] = fields
1.07 options.py(834):         return fields
1.07 options.py(804):                     if not getattr(obj, 'parent_link', False) or obj.model == self.concrete_model:
1.07 options.py(805):                         fields.append(obj)
1.07 options.py(803):                         include_hidden=include_hidden, seen_models=seen_models):
1.07 options.py(792):             for parent in self.parents:
1.07 options.py(806):         if reverse and not self.proxy:
1.07 options.py(817):         if forward:
1.07 options.py(818):             fields += self.local_fields
1.07 options.py(819):             fields += self.local_many_to_many
1.07 options.py(825):             if topmost_call:
1.07 options.py(826):                 fields += self.private_fields
1.07 options.py(830):         fields = make_immutable_fields_list("get_fields()", fields)
1.07 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.07 options.py(833):         self._get_fields_cache[cache_key] = fields
1.07 options.py(834):         return fields
1.07 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.07 options.py(469):             (f for f in self._get_fields(reverse=False)
1.07 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.07 options.py(457):             return not (f.is_relation and f.many_to_many)
1.07 options.py(460):             return not (f.is_relation and f.one_to_many)
1.07 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.07 options.py(469):             (f for f in self._get_fields(reverse=False)
1.07 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.07 options.py(457):             return not (f.is_relation and f.many_to_many)
1.07 options.py(460):             return not (f.is_relation and f.one_to_many)
1.07 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.07 options.py(469):             (f for f in self._get_fields(reverse=False)
1.07 options.py(470):              if is_not_an_m2m_field(f) and is_not_a_generic_relation(f) and is_not_a_generic_foreign_key(f))
1.07 options.py(457):             return not (f.is_relation and f.many_to_many)
1.07 options.py(460):             return not (f.is_relation and f.one_to_many)
1.07 options.py(464):                 f.is_relation and f.many_to_one and not (hasattr(f.remote_field, 'model') and f.remote_field.model)
1.07 options.py(469):             (f for f in self._get_fields(reverse=False)
1.07 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
1.07 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
1.07 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
1.07 base.py(351):             cls.__doc__ = "%s(%s)" % (cls.__name__, ", ".join(f.name for f in opts.fields))
1.07 base.py(353):         get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(opts.label_lower)
1.07 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.07 base.py(354):         if get_absolute_url_override:
1.07 base.py(357):         if not opts.managers:
1.07 options.py(365):         managers = []
1.07 options.py(366):         seen_managers = set()
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(368):         for depth, base in enumerate(bases):
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(369):             for manager in base._meta.local_managers:
1.07 options.py(368):         for depth, base in enumerate(bases):
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(369):             for manager in base._meta.local_managers:
1.07 options.py(370):                 if manager.name in seen_managers:
1.07 options.py(373):                 manager = copy.copy(manager)
1.07 options.py(374):                 manager.model = self.model
1.07 options.py(375):                 seen_managers.add(manager.name)
1.07 options.py(376):                 managers.append((depth, manager.creation_counter, manager))
1.07 options.py(369):             for manager in base._meta.local_managers:
1.07 options.py(368):         for depth, base in enumerate(bases):
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(367):         bases = (b for b in self.model.mro() if hasattr(b, '_meta'))
1.07 options.py(378):         return make_immutable_fields_list(
1.07 options.py(379):             "managers",
1.07 options.py(380):             (m[2] for m in sorted(managers)),
1.07 options.py(62):     return ImmutableList(data, warning=IMMUTABLE_WARNING % name)
1.07 options.py(380):             (m[2] for m in sorted(managers)),
1.07 options.py(380):             (m[2] for m in sorted(managers)),
1.07 base.py(370):         for index in cls._meta.indexes:
1.07 base.py(374):         class_prepared.send(sender=cls)
1.07 base.py(321):         new_class._meta.apps.register_model(new_class._meta.app_label, new_class)
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(348):             swapped_for = getattr(settings, self.swappable, None)
1.07 options.py(349):             if swapped_for:
1.07 options.py(350):                 try:
1.07 options.py(351):                     swapped_label, swapped_object = swapped_for.split('.')
1.07 options.py(359):                 if '%s.%s' % (swapped_label, swapped_object.lower()) != self.label_lower:
1.07 options.py(138):         return '%s.%s' % (self.app_label, self.model_name)
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
FAIL

======================================================================
FAIL: test_mti_field_order_bug (test_coverup_django__django-12325.PickingModelTest)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "./tests/test_coverup_django__django-12325.py", line 30, in test_mti_field_order_bug
    assert False, "ImproperlyConfigured exception was not raised, indicating the bug is still present."
AssertionError: ImproperlyConfigured exception was not raised, indicating the bug is still present.

----------------------------------------------------------------------
Ran 1 test in 0.006s

FAILED (failures=1)
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 options.py(347):         if self.swappable:
1.07 options.py(361):         return None
1.07 options.py(728):         if forward:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(731):                     delattr(self, cache_key)
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(730):                 if cache_key in self.__dict__:
1.07 options.py(729):             for cache_key in self.FORWARD_PROPERTIES:
1.07 options.py(732):         if reverse and not self.abstract:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(734):                 if cache_key in self.__dict__:
1.07 options.py(735):                     delattr(self, cache_key)
1.07 options.py(733):             for cache_key in self.REVERSE_PROPERTIES:
1.07 options.py(736):         self._get_fields_cache = {}
1.07 base.py(322):         return new_class
1.07 options.py(564):         try:
1.07 options.py(567):             return self._forward_fields_map[field_name]
1.07 options.py(532):         res = {}
1.07 options.py(533):         fields = self._get_fields(reverse=False)
1.07 options.py(765):         if include_parents not in (True, False, PROXY_PARENTS):
1.07 options.py(773):         topmost_call = seen_models is None
1.07 options.py(774):         if topmost_call:
1.07 options.py(775):             seen_models = set()
1.07 options.py(776):         seen_models.add(self.model)
1.07 options.py(779):         cache_key = (forward, reverse, include_parents, include_hidden, topmost_call)
1.07 options.py(781):         try:
1.07 options.py(784):             return self._get_fields_cache[cache_key]
1.07 options.py(534):         for field in fields:
1.07 options.py(535):             res[field.name] = field
1.07 options.py(539):             try:
1.07 options.py(540):                 res[field.attname] = field
1.07 options.py(534):         for field in fields:
1.07 options.py(535):             res[field.name] = field
1.07 options.py(539):             try:
1.07 options.py(540):                 res[field.attname] = field
1.07 options.py(534):         for field in fields:
1.07 options.py(535):             res[field.name] = field
1.07 options.py(539):             try:
1.07 options.py(540):                 res[field.attname] = field
1.07 options.py(534):         for field in fields:
1.07 options.py(543):         return res
+ cat coverage.cover
{"/testbed/django/db/models/base.py": {"1": 1, "2": 1, "3": 1, "4": 1, "5": 1, "7": 1, "8": 1, "9": 1, "10": 1, "14": 1, "18": 1, "21": 1, "22": 1, "23": 1, "24": 1, "27": 1, "28": 1, "29": 1, "30": 1, "31": 1, "34": 1, "35": 1, "36": 1, "37": 1, "38": 1, "39": 1, "42": 2, "50": 1, "53": 1, "67": 1, "72": 2, "385": 2, "393": 2, "404": 2, "1871": 1, "1881": 1, "1888": 1, "1905": 1, "1915": 1, "43": 1, "46": 1, "44": 0, "47": 0, "61": 100, "62": 100, "63": 100, "69": 829, "74": 1, "324": 1, "330": 1, "376": 1, "380": 1, "75": 55, "79": 165, "80": 55, "81": 1, "84": 54, "85": 54, "86": 54, "87": 54, "88": 2, "89": 54, "93": 54, "94": 406, "95": 352, "96": 275, "98": 77, "99": 54, "101": 54, "102": 54, "103": 54, "105": 54, "108": 54, "110": 54, "111": 11, "112": 0, "113": 0, "114": 0, "116": 0, "120": 11, "122": 54, "123": 54, "124": 50, "125": 50, "126": 50, "127": 50, "128": 50, "129": 150, "130": 49, "131": 50, "132": 50, "133": 50, "134": 50, "135": 50, "136": 50, "137": 50, "138": 150, "139": 49, "140": 50, "141": 50, "142": 50, "146": 1, "147": 1, "148": 1, "149": 1, "151": 54, "155": 54, "156": 0, "160": 329, "161": 275, "164": 54, "165": 54, "166": 54, "167": 54, "169": 347, "172": 54, "173": 0, "174": 0, "175": 0, "176": 0, "177": 0, "178": 0, "179": 0, "182": 0, "183": 0, "184": 0, "185": 0, "186": 0, "187": 0, "188": 0, "189": 0, "190": 0, "192": 54, "195": 54, "196": 163, "198": 109, "199": 50, "201": 59, "202": 1, "204": 307, "205": 249, "206": 2, "207": 2, "210": 54, "212": 223, "213": 169, "216": 164, "217": 164, "219": 5, "220": 5, "223": 2, "224": 1, "225": 0, "226": 0, "228": 0, "229": 0, "230": 0, "234": 1, "237": 1, "238": 1, "239": 1, "240": 1, "241": 0, "242": 0, "243": 0, "244": 0, "245": 0, "246": 0, "247": 0, "248": 0, "251": 0, "252": 0, "253": 0, "256": 0, "257": 0, "258": 0, "264": 0, "265": 0, "267": 0, "268": 1, "270": 4, "273": 24, "274": 20, "275": 20, "276": 20, "277": 20, "278": 20, "281": 20, "282": 0, "283": 0, "284": 0, "287": 4, "291": 5, "292": 0, "293": 0, "294": 0, "295": 0, "297": 0, "298": 0, "299": 0, "303": 0, "304": 0, "305": 0, "306": 0, "310": 108, "312": 54, "316": 4, "317": 4, "318": 4, "320": 50, "321": 50, "322": 50, "325": 477, "326": 377, "328": 100, "332": 50, "333": 50, "335": 50, "336": 0, "337": 0, "344": 0, "345": 0, "346": 0, "347": 0, "350": 50, "351": 320, "353": 50, "354": 50, "355": 0, "357": 50, "358": 89, "359": 0, "360": 0, "361": 0, "363": 14, "364": 14, "365": 14, "370": 50, "371": 0, "372": 0, "374": 50, "378": 7, "382": 2, "386": 1, "387": 28, "388": 0, "389": 28, "390": 28, "395": 1, "400": 1, "401": 1, "406": 1, "505": 1, "518": 1, "521": 1, "524": 1, "534": 1, "539": 1, "545": 1, "549": 1, "567": 1, "571": 1, "577": 1, "579": 1, "588": 1, "649": 1, "667": 1, "751": 1, "754": 1, "802": 1, "804": 1, "833": 1, "896": 1, "923": 1, "933": 1, "944": 1, "946": 1, "952": 1, "968": 1, "983": 1, "988": 1, "997": 1, "1013": 1, "1072": 1, "1117": 1, "1146": 1, "1163": 1, "1193": 1, "1229": 1, "1254": 1, "1285": 1, "1312": 1, "1325": 1, "1333": 1, "1343": 1, "1375": 1, "1392": 1, "1449": 1, "1474": 1, "1498": 1, "1518": 1, "1532": 1, "1559": 1, "1586": 1, "1615": 1, "1665": 1, "1765": 1, "1838": 1, "408": 68, "409": 68, "410": 68, "411": 68, "413": 68, "416": 68, "422": 68, "424": 0, "426": 68, "427": 27, "432": 112, "433": 85, "434": 0, "435": 85, "438": 41, "439": 41, "440": 0, "441": 0, "442": 0, "443": 0, "448": 246, "449": 178, "451": 178, "452": 0, "453": 178, "454": 151, "455": 28, "457": 28, "458": 28, "459": 0, "460": 0, "462": 0, "463": 0, "464": 0, "466": 123, "467": 123, "468": 41, "473": 41, "475": 27, "477": 178, "482": 28, "483": 28, "485": 150, "486": 150, "488": 68, "489": 1, "490": 2, "491": 1, "494": 1, "495": 1, "496": 1, "497": 1, "498": 0, "499": 0, "500": 1, "501": 0, "502": 68, "503": 68, "507": 25, "508": 0, "510": 0, "511": 0, "513": 25, "514": 25, "515": 25, "516": 25, "519": 0, "522": 0, "525": 0, "526": 0, "527": 0, "528": 0, "529": 0, "530": 0, "531": 0, "532": 0, "535": 7, "536": 0, "537": 7, "540": 0, "541": 0, "542": 0, "543": 0, "547": 0, "550": 0, "551": 0, "552": 0, "553": 0, "554": 0, "556": 0, "557": 0, "560": 0, "562": 0, "563": 0, "565": 0, "568": 118, "569": 118, "572": 36, "573": 0, "574": 0, "575": 36, "583": 35, "584": 29, "585": 23, "603": 0, "604": 0, "606": 0, "607": 0, "608": 0, "609": 0, "610": 0, "611": 0, "612": 0, "613": 0, "614": 0, "615": 0, "616": 0, "618": 0, "619": 0, "622": 0, "623": 0, "624": 0, "625": 0, "626": 0, "627": 0, "629": 0, "631": 0, "632": 0, "633": 0, "634": 0, "636": 0, "637": 0, "639": 0, "640": 0, "643": 0, "644": 0, "645": 0, "647": 0, "628": 0, "660": 0, "661": 0, "662": 0, "663": 0, "664": 0, "679": 29, "682": 23, "683": 0, "684": 0, "685": 0, "692": 0, "694": 0, "695": 0, "696": 0, "697": 0, "698": 0, "700": 0, "703": 0, "706": 0, "707": 0, "709": 6, "710": 6, "711": 0, "713": 6, "714": 6, "718": 0, "719": 0, "721": 0, "722": 0, "724": 0, "725": 0, "726": 0, "728": 0, "729": 0, "731": 0, "733": 0, "734": 0, "736": 0, "740": 6, "741": 0, "742": 0, "743": 0, "744": 0, "745": 0, "746": 0, "747": 0, "749": 6, "750": 6, "764": 6, "765": 6, "766": 6, "767": 6, "769": 6, "770": 0, "771": 6, "772": 6, "773": 6, "774": 6, "775": 6, "778": 6, "779": 0, "781": 6, "782": 6, "783": 6, "784": 6, "785": 6, "786": 6, "787": 6, "788": 6, "791": 6, "793": 6, "796": 6, "797": 6, "798": 6, "799": 6, "806": 6, "807": 6, "808": 6, "810": 0, "811": 0, "812": 0, "813": 0, "814": 0, "815": 0, "816": 0, "818": 0, "819": 0, "821": 0, "822": 0, "828": 0, "829": 0, "830": 6, "838": 6, "839": 35, "841": 6, "842": 0, "845": 6, "846": 6, "847": 5, "848": 5, "849": 6, "850": 6, "851": 0, "852": 6, "855": 6, "856": 6, "857": 1, "858": 1, "859": 1, "861": 0, "863": 6, "864": 1, "865": 4, "866": 3, "867": 1, "868": 1, "869": 1, "870": 1, "871": 0, "872": 1, "873": 0, "874": 6, "875": 6, "878": 0, "879": 0, "880": 0, "881": 0, "882": 0, "883": 0, "885": 0, "886": 6, "887": 6, "888": 30, "890": 6, "891": 6, "892": 12, "893": 6, "894": 6, "843": 0, "901": 1, "902": 1, "908": 0, "909": 1, "911": 0, "919": 0, "921": 1, "928": 6, "929": 6, "930": 6, "934": 0, "935": 0, "936": 0, "937": 0, "940": 0, "941": 0, "942": 0, "947": 0, "948": 0, "950": 0, "953": 0, "954": 0, "955": 0, "956": 0, "957": 0, "958": 0, "959": 0, "960": 0, "961": 0, "963": 0, "964": 0, "965": 0, "966": 0, "969": 0, "970": 0, "971": 0, "972": 0, "973": 0, "974": 0, "975": 0, "976": 0, "977": 0, "979": 0, "980": 0, "981": 0, "984": 0, "985": 0, "986": 0, "995": 0, "1002": 0, "1004": 0, "1005": 0, "1007": 0, "1008": 0, "1010": 0, "1011": 0, "1021": 0, "1022": 0, "1023": 0, "1025": 0, "1026": 0, "1027": 0, "1028": 0, "1029": 0, "1030": 0, "1031": 0, "1033": 0, "1034": 0, "1035": 0, "1037": 0, "1039": 0, "1040": 0, "1041": 0, "1043": 0, "1044": 0, "1045": 0, "1048": 0, "1053": 0, "1054": 0, "1055": 0, "1057": 0, "1058": 0, "1059": 0, "1060": 0, "1061": 0, "1062": 0, "1063": 0, "1064": 0, "1065": 0, "1066": 0, "1067": 0, "1068": 0, "1069": 0, "1070": 0, "1073": 0, "1075": 0, "1079": 0, "1080": 0, "1081": 0, "1082": 0, "1084": 0, "1085": 0, "1087": 0, "1088": 0, "1090": 0, "1091": 0, "1094": 0, "1095": 0, "1097": 0, "1105": 0, "1106": 0, "1107": 0, "1108": 0, "1109": 0, "1110": 0, "1112": 0, "1113": 0, "1115": 0, "1118": 0, "1119": 0, "1120": 0, "1123": 0, "1124": 0, "1125": 0, "1126": 0, "1127": 0, "1128": 0, "1129": 0, "1131": 0, "1132": 0, "1134": 0, "1137": 0, "1138": 0, "1140": 0, "1141": 0, "1142": 0, "1144": 0, "1147": 0, "1148": 0, "1149": 0, "1150": 0, "1151": 0, "1153": 0, "1154": 0, "1155": 0, "1156": 0, "1157": 0, "1158": 0, "1159": 0, "1164": 0, "1167": 0, "1168": 0, "1169": 0, "1170": 0, "1174": 0, "1175": 0, "1176": 0, "1177": 0, "1178": 0, "1179": 0, "1180": 0, "1185": 0, "1186": 0, "1187": 0, "1188": 0, "1189": 0, "1190": 0, "1198": 0, "1199": 0, "1200": 0, "1202": 0, "1204": 0, "1205": 0, "1206": 0, "1207": 0, "1211": 0, "1212": 0, "1213": 0, "1214": 0, "1217": 0, "1218": 0, "1219": 0, "1220": 0, "1221": 0, "1222": 0, "1223": 0, "1224": 0, "1226": 0, "1227": 0, "1234": 0, "1235": 0, "1237": 0, "1238": 0, "1239": 0, "1240": 0, "1243": 0, "1244": 0, "1245": 0, "1246": 0, "1247": 0, "1248": 0, "1249": 0, "1251": 0, "1252": 0, "1256": 7, "1257": 7, "1258": 7, "1259": 7, "1260": 7, "1261": 7, "1264": 7, "1265": 7, "1266": 7, "1267": 7, "1268": 7, "1270": 7, "1273": 7, "1274": 7, "1275": 7, "1276": 7, "1277": 7, "1278": 7, "1279": 7, "1280": 7, "1283": 7, "1288": 7, "1289": 7, "1290": 0, "1291": 0, "1292": 0, "1293": 0, "1294": 0, "1295": 0, "1296": 0, "1299": 0, "1300": 0, "1301": 0, "1302": 0, "1303": 0, "1305": 0, "1307": 0, "1310": 7, "1314": 7, "1315": 7, "1316": 0, "1317": 0, "1318": 0, "1319": 0, "1320": 0, "1323": 7, "1328": 7, "1329": 14, "1330": 7, "1331": 7, "1336": 7, "1337": 41, "1338": 34, "1339": 10, "1340": 3, "1341": 7, "1348": 7, "1349": 7, "1351": 7, "1354": 17, "1357": 17, "1359": 10, "1360": 3, "1361": 3, "1362": 0, "1363": 0, "1364": 0, "1366": 0, "1367": 0, "1368": 0, "1372": 3, "1373": 7, "1378": 48, "1380": 7, "1382": 0, "1383": 0, "1385": 0, "1386": 0, "1390": 7, "1395": 7, "1396": 7, "1399": 7, "1400": 0, "1401": 0, "1402": 0, "1403": 0, "1404": 0, "1405": 0, "1408": 0, "1409": 0, "1411": 0, "1412": 0, "1415": 0, "1416": 0, "1421": 7, "1422": 0, "1423": 0, "1424": 0, "1426": 41, "1427": 34, "1432": 34, "1433": 34, "1434": 0, "1435": 0, "1436": 0, "1438": 0, "1440": 0, "1441": 0, "1444": 34, "1445": 34, "1447": 7, "1452": 7, "1453": 7, "1455": 41, "1456": 34, "1459": 34, "1460": 0, "1461": 0, "1462": 0, "1463": 0, "1464": 0, "1465": 0, "1466": 0, "1470": 34, "1472": 7, "1476": 7, "1477": 7, "1478": 7, "1479": 0, "1480": 0, "1481": 0, "1482": 0, "1483": 0, "1484": 0, "1487": 7, "1488": 0, "1489": 0, "1490": 0, "1491": 0, "1492": 0, "1493": 0, "1496": 7, "1500": 7, "1501": 7, "1503": 51, "1506": 13, "1507": 6, "1508": 0, "1509": 0, "1510": 0, "1511": 0, "1512": 0, "1513": 0, "1516": 7, "1504": 37, "1520": 7, "1521": 48, "1522": 0, "1523": 0, "1524": 0, "1526": 0, "1527": 0, "1530": 7, "1535": 7, "1537": 0, "1538": 0, "1539": 0, "1540": 0, "1544": 14, "1546": 0, "1547": 0, "1548": 0, "1549": 0, "1554": 7, "1555": 7, "1556": 0, "1557": 7, "1562": 7, "1564": 0, "1565": 0, "1566": 0, "1567": 0, "1571": 16, "1573": 0, "1574": 0, "1575": 0, "1576": 0, "1581": 7, "1582": 9, "1583": 2, "1584": 7, "1589": 7, "1590": 7, "1593": 0, "1594": 0, "1595": 0, "1596": 0, "1597": 0, "1598": 0, "1599": 0, "1602": 0, "1603": 0, "1604": 0, "1605": 0, "1606": 0, "1607": 0, "1608": 0, "1611": 14, "1612": 7, "1613": 7, "1617": 9, "1621": 9, "1622": 53, "1623": 44, "1624": 44, "1625": 44, "1627": 9, "1628": 13, "1629": 4, "1630": 4, "1631": 0, "1632": 0, "1633": 0, "1634": 0, "1635": 0, "1637": 0, "1638": 0, "1642": 4, "1643": 0, "1644": 0, "1645": 0, "1647": 0, "1649": 0, "1650": 0, "1653": 4, "1654": 0, "1655": 0, "1656": 0, "1657": 0, "1658": 0, "1659": 0, "1660": 0, "1663": 9, "1671": 7, "1673": 0, "1674": 0, "1675": 0, "1676": 0, "1680": 7, "1681": 4, "1683": 3, "1685": 0, "1686": 0, "1687": 0, "1688": 0, "1692": 3, "1693": 3, "1696": 11, "1699": 11, "1702": 3, "1703": 3, "1704": 8, "1705": 5, "1706": 2, "1708": 3, "1709": 3, "1712": 5, "1713": 2, "1714": 2, "1715": 6, "1716": 4, "1718": 4, "1719": 0, "1721": 4, "1722": 4, "1723": 2, "1725": 2, "1726": 0, "1727": 0, "1728": 0, "1729": 0, "1730": 0, "1731": 0, "1732": 0, "1733": 0, "1739": 9, "1742": 3, "1746": 3, "1747": 3, "1748": 23, "1749": 20, "1752": 3, "1754": 3, "1755": 0, "1756": 0, "1757": 0, "1758": 0, "1759": 0, "1760": 0, "1763": 3, "1771": 7, "1772": 7, "1773": 7, "1776": 21, "1778": 14, "1779": 0, "1780": 14, "1781": 14, "1782": 14, "1783": 0, "1785": 0, "1786": 0, "1787": 0, "1788": 0, "1789": 0, "1790": 0, "1792": 7, "1793": 7, "1795": 0, "1796": 0, "1800": 0, "1801": 0, "1802": 0, "1803": 0, "1805": 0, "1806": 0, "1807": 0, "1808": 0, "1812": 0, "1814": 0, "1815": 0, "1819": 0, "1820": 0, "1821": 0, "1822": 0, "1823": 0, "1824": 0, "1826": 0, "1828": 0, "1831": 0, "1832": 0, "1836": 0, "1840": 7, "1841": 21, "1842": 14, "1843": 0, "1844": 14, "1846": 14, "1847": 0, "1849": 0, "1850": 0, "1851": 0, "1852": 0, "1853": 0, "1855": 0, "1858": 0, "1859": 0, "1862": 7, "1872": 0, "1873": 0, "1874": 0, "1875": 0, "1876": 0, "1877": 0, "1878": 0, "1882": 0, "1883": 0, "1884": 0, "1885": 0, "1889": 0, "1890": 0, "1891": 0, "1892": 0, "1894": 0, "1895": 0, "1896": 0, "1897": 0, "1907": 0, "1908": 0, "1911": 0, "1912": 0}}
{"/testbed/django/db/models/options.py": {"1": 1, "2": 1, "3": 1, "4": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "19": 1, "21": 1, "24": 1, "35": 1, "39": 1, "61": 1, "65": 2, "45": 114, "46": 114, "47": 98, "48": 16, "49": 2, "50": 14, "51": 14, "52": 6, "54": 42, "55": 2, "58": 2, "62": 278, "67": 1, "68": 1, "69": 1, "71": 1, "73": 1, "75": 1, "132": 1, "136": 1, "140": 1, "145": 1, "149": 1, "210": 1, "222": 1, "262": 1, "266": 1, "296": 1, "301": 1, "310": 1, "313": 1, "316": 1, "332": 1, "338": 1, "363": 1, "383": 1, "387": 1, "415": 1, "439": 1, "473": 1, "486": 1, "499": 1, "513": 1, "530": 1, "545": 1, "560": 1, "585": 1, "602": 1, "613": 1, "633": 1, "663": 1, "685": 1, "721": 1, "725": 1, "738": 1, "753": 1, "836": 1, "846": 1, "76": 54, "77": 54, "78": 54, "79": 54, "80": 54, "81": 54, "82": 54, "83": 54, "84": 54, "85": 54, "86": 54, "87": 54, "88": 54, "89": 54, "90": 54, "91": 54, "92": 54, "93": 54, "94": 54, "95": 54, "96": 54, "97": 54, "98": 54, "99": 54, "100": 54, "101": 54, "102": 54, "103": 54, "104": 54, "105": 54, "106": 54, "107": 54, "108": 54, "114": 54, "118": 54, "119": 54, "120": 54, "121": 54, "125": 54, "128": 54, "130": 54, "134": 15, "138": 93, "143": 0, "147": 0, "150": 54, "151": 54, "153": 54, "154": 54, "156": 54, "157": 54, "158": 54, "162": 54, "165": 54, "166": 54, "167": 600, "171": 546, "172": 212, "173": 1458, "174": 1404, "175": 334, "176": 334, "177": 1070, "178": 6, "179": 6, "181": 54, "182": 54, "185": 54, "186": 150, "187": 100, "188": 100, "192": 54, "193": 11, "196": 54, "199": 54, "200": 0, "202": 0, "203": 54, "206": 54, "207": 21, "208": 21, "212": 100, "213": 100, "214": 0, "215": 0, "216": 0, "217": 0, "219": 0, "220": 100, "223": 50, "226": 0, "227": 0, "228": 0, "229": 0, "232": 0, "233": 0, "235": 0, "236": 0, "237": 0, "239": 50, "241": 50, "242": 15, "245": 1, "249": 4, "250": 1, "251": 1, "252": 1, "253": 1, "254": 1, "255": 0, "256": 0, "259": 14, "260": 14, "230": 0, "263": 50, "264": 50, "271": 273, "272": 0, "273": 273, "274": 10, "276": 263, "277": 263, "287": 273, "288": 44, "289": 44, "290": 16, "291": 16, "292": 44, "294": 229, "297": 264, "298": 51, "299": 51, "306": 0, "307": 0, "308": 0, "311": 0, "314": 1, "321": 12, "322": 0, "323": 12, "324": 5, "325": 12, "326": 0, "327": 12, "328": 0, "329": 0, "330": 12, "335": 56, "336": 56, "347": 345, "348": 43, "349": 43, "350": 43, "351": 43, "352": 0, "357": 0, "359": 43, "360": 0, "361": 345, "365": 61, "366": 61, "367": 314, "368": 131, "369": 119, "370": 49, "371": 2, "373": 47, "374": 47, "375": 47, "376": 47, "378": 61, "379": 61, "380": 169, "385": 12, "389": 2, "390": 2, "392": 6, "393": 4, "394": 0, "395": 0, "396": 0, "398": 2, "399": 0, "400": 0, "401": 0, "402": 0, "403": 0, "404": 0, "405": 0, "409": 2, "410": 2, "411": 2, "412": 2, "413": 2, "417": 2, "418": 2, "420": 0, "421": 0, "422": 0, "423": 0, "425": 2, "426": 0, "427": 0, "428": 0, "429": 0, "430": 0, "431": 0, "432": 0, "436": 2, "437": 2, "456": 59, "459": 59, "462": 59, "467": 59, "468": 59, "469": 406, "457": 288, "460": 282, "464": 282, "470": 288, "482": 7, "483": 50, "495": 5, "496": 36, "508": 6, "509": 6, "510": 46, "524": 6, "525": 6, "526": 6, "527": 24, "532": 22, "533": 22, "534": 136, "535": 114, "539": 114, "540": 114, "541": 0, "542": 0, "543": 22, "547": 1, "548": 1, "549": 2, "550": 1, "554": 1, "555": 1, "556": 1, "557": 1, "558": 1, "564": 147, "567": 147, "568": 5, "571": 5, "572": 0, "573": 0, "575": 0, "578": 5, "581": 5, "582": 5, "583": 5, "591": 0, "592": 0, "593": 0, "594": 0, "595": 0, "596": 0, "597": 0, "598": 0, "599": 0, "600": 0, "607": 29, "608": 29, "609": 0, "610": 0, "611": 29, "622": 0, "623": 0, "624": 0, "626": 0, "627": 0, "631": 0, "639": 0, "640": 0, "642": 0, "643": 0, "644": 0, "645": 0, "646": 0, "647": 0, "649": 0, "650": 0, "651": 0, "652": 0, "653": 0, "654": 0, "655": 0, "656": 0, "657": 0, "658": 0, "659": 0, "661": 0, "669": 0, "670": 0, "671": 0, "674": 0, "675": 0, "676": 0, "678": 0, "679": 0, "680": 0, "681": 0, "682": 0, "683": 0, "692": 6, "694": 6, "695": 50, "696": 44, "699": 44, "700": 0, "702": 295, "705": 74, "706": 30, "707": 30, "709": 50, "715": 44, "716": 44, "719": 6, "703": 207, "723": 6, "728": 448, "729": 4200, "730": 3780, "731": 131, "732": 448, "733": 852, "734": 639, "735": 35, "736": 448, "748": 12, "749": 0, "750": 12, "765": 169, "766": 0, "773": 169, "774": 169, "775": 168, "776": 169, "779": 169, "781": 169, "784": 169, "785": 134, "786": 134, "788": 134, "791": 134, "792": 91, "796": 1, "797": 0, "798": 1, "799": 1, "800": 0, "801": 1, "802": 1, "803": 2, "804": 1, "805": 1, "806": 134, "810": 18, "811": 40, "814": 22, "815": 20, "817": 134, "818": 127, "819": 127, "825": 127, "826": 126, "830": 134, "833": 134, "834": 134, "839": 8, "840": 732, "841": 724, "842": 724, "843": 12, "844": 8, "853": 11, "854": 7}}
+ git checkout 29c126bb349526b5f1cd78facbe9f25906f18563
Note: switching to '29c126bb349526b5f1cd78facbe9f25906f18563'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 29c126bb34 Fixed #31124 -- Fixed setting of get_FOO_display() when overriding inherited choices.
+ git apply /root/pre_state.patch
error: unrecognized input
