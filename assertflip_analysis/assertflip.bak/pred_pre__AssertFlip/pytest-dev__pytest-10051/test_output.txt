+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD aa55975c7d3f6c9f6d7f68accc41bb7cadf0eb9a
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit aa55975c7d3f6c9f6d7f68accc41bb7cadf0eb9a
Merge: 141c5e5a8 1e6a58736
Author: Bruno Oliveira <nicoddemus@gmail.com>
Date:   Thu Jun 23 21:47:39 2022 -0300

    Doc: Clear mailbox before deleting the user (#10068)

+ git diff aa55975c7d3f6c9f6d7f68accc41bb7cadf0eb9a
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: attrs>=19.2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (23.1.0)
Requirement already satisfied: iniconfig in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (2.0.0)
Requirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (23.1)
Requirement already satisfied: pluggy<2.0,>=0.12 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (0.13.1)
Requirement already satisfied: py>=1.8.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (1.11.0)
Requirement already satisfied: tomli>=1.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==7.2.0.dev157+gaa55975c7) (2.0.1)
Building wheels for collected packages: pytest
  Building editable for pytest (pyproject.toml): started
  Building editable for pytest (pyproject.toml): finished with status 'done'
  Created wheel for pytest: filename=pytest-7.2.0.dev157+gaa55975c7-0.editable-py3-none-any.whl size=5242 sha256=09302317f5edff708a5e17fc813eb72155612f858417ecb4c811d880a2d97b74
  Stored in directory: /tmp/pip-ephem-wheel-cache-ofam5k7y/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4
Successfully built pytest
Installing collected packages: pytest
  Attempting uninstall: pytest
    Found existing installation: pytest 7.2.0.dev157+gaa55975c7
    Uninstalling pytest-7.2.0.dev157+gaa55975c7:
      Successfully uninstalled pytest-7.2.0.dev157+gaa55975c7
Successfully installed pytest-7.2.0.dev157+gaa55975c7
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git apply -v -
Checking patch testing/test_coverup_pytest-dev__pytest-10051.py...
Applied patch testing/test_coverup_pytest-dev__pytest-10051.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(src/_pytest/logging\.py)' -m pytest -rA testing/test_coverup_pytest-dev__pytest-10051.py
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(src/_pytest/logging\\.py)']
0.18 logging.py(217):     group = parser.getgroup("logging")
0.18 logging.py(219):     def add_option_ini(option, dest, default=None, type=None, **kwargs):
0.18 logging.py(225):     add_option_ini(
0.18 logging.py(226):         "--log-level",
0.18 logging.py(227):         dest="log_level",
0.18 logging.py(228):         default=None,
0.18 logging.py(229):         metavar="LEVEL",
0.18 logging.py(231):             "Level of messages to catch/display."
0.18 logging.py(225):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(236):     add_option_ini(
0.18 logging.py(237):         "--log-format",
0.18 logging.py(238):         dest="log_format",
0.18 logging.py(239):         default=DEFAULT_LOG_FORMAT,
0.18 logging.py(240):         help="Log format used by the logging module",
0.18 logging.py(236):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(242):     add_option_ini(
0.18 logging.py(243):         "--log-date-format",
0.18 logging.py(244):         dest="log_date_format",
0.18 logging.py(245):         default=DEFAULT_LOG_DATE_FORMAT,
0.18 logging.py(246):         help="Log date format used by the logging module",
0.18 logging.py(242):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(248):     parser.addini(
0.18 logging.py(249):         "log_cli",
0.18 logging.py(250):         default=False,
0.18 logging.py(251):         type="bool",
0.18 logging.py(252):         help='Enable log display during test run (also known as "live logging")',
0.18 logging.py(248):     parser.addini(
0.18 logging.py(254):     add_option_ini(
0.18 logging.py(255):         "--log-cli-level", dest="log_cli_level", default=None, help="CLI logging level"
0.18 logging.py(254):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(257):     add_option_ini(
0.18 logging.py(258):         "--log-cli-format",
0.18 logging.py(259):         dest="log_cli_format",
0.18 logging.py(260):         default=None,
0.18 logging.py(261):         help="Log format used by the logging module",
0.18 logging.py(257):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(263):     add_option_ini(
0.18 logging.py(264):         "--log-cli-date-format",
0.18 logging.py(265):         dest="log_cli_date_format",
0.18 logging.py(266):         default=None,
0.18 logging.py(267):         help="Log date format used by the logging module",
0.18 logging.py(263):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(269):     add_option_ini(
0.18 logging.py(270):         "--log-file",
0.18 logging.py(271):         dest="log_file",
0.18 logging.py(272):         default=None,
0.18 logging.py(273):         help="Path to a file when logging will be written to",
0.18 logging.py(269):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(275):     add_option_ini(
0.18 logging.py(276):         "--log-file-level",
0.18 logging.py(277):         dest="log_file_level",
0.18 logging.py(278):         default=None,
0.18 logging.py(279):         help="Log file logging level",
0.18 logging.py(275):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(281):     add_option_ini(
0.18 logging.py(282):         "--log-file-format",
0.18 logging.py(283):         dest="log_file_format",
0.18 logging.py(284):         default=DEFAULT_LOG_FORMAT,
0.18 logging.py(285):         help="Log format used by the logging module",
0.18 logging.py(281):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(287):     add_option_ini(
0.18 logging.py(288):         "--log-file-date-format",
0.18 logging.py(289):         dest="log_file_date_format",
0.18 logging.py(290):         default=DEFAULT_LOG_DATE_FORMAT,
0.18 logging.py(291):         help="Log date format used by the logging module",
0.18 logging.py(287):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.18 logging.py(293):     add_option_ini(
0.18 logging.py(294):         "--log-auto-indent",
0.18 logging.py(295):         dest="log_auto_indent",
0.18 logging.py(296):         default=None,
0.18 logging.py(297):         help="Auto-indent multiline messages passed to the logging module. Accepts true|on, false|off or an integer.",
0.18 logging.py(293):     add_option_ini(
0.18 logging.py(220):         parser.addini(
0.18 logging.py(221):             dest, default=default, type=type, help="Default value for " + option
0.18 logging.py(220):         parser.addini(
0.18 logging.py(223):         group.addoption(option, dest=dest, **kwargs)
0.24 logging.py(529):     config.pluginmanager.register(LoggingPlugin(config), "logging-plugin")
0.24 logging.py(541):         self._config = config
0.24 logging.py(544):         self.formatter = self._create_formatter(
0.24 logging.py(545):             get_option_ini(config, "log_format"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(546):             get_option_ini(config, "log_date_format"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(547):             get_option_ini(config, "log_auto_indent"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(207):     for name in names:
0.24 logging.py(544):         self.formatter = self._create_formatter(
0.24 logging.py(596):         color = getattr(self._config.option, "color", "no")
0.24 logging.py(597):         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
0.24 logging.py(598):             log_format
0.24 logging.py(597):         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
0.24 logging.py(600):             formatter: logging.Formatter = ColoredLevelFormatter(
0.24 logging.py(601):                 create_terminal_writer(self._config), log_format, log_date_format
0.24 logging.py(600):             formatter: logging.Formatter = ColoredLevelFormatter(
0.24 logging.py(71):         super().__init__(*args, **kwargs)
0.24 logging.py(72):         self._terminalwriter = terminalwriter
0.24 logging.py(73):         self._original_fmt = self._style._fmt
0.24 logging.py(74):         self._level_to_fmt_mapping: Dict[int, str] = {}
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(606):         formatter._style = PercentStyleMultiline(
0.24 logging.py(607):             formatter._style._fmt, auto_indent=auto_indent
0.24 logging.py(606):         formatter._style = PercentStyleMultiline(
0.24 logging.py(124):         super().__init__(fmt)
0.24 logging.py(125):         self._auto_indent = self._get_auto_indent(auto_indent)
0.24 logging.py(160):         if auto_indent_option is None:
0.24 logging.py(161):             return 0
0.24 logging.py(610):         return formatter
0.24 logging.py(549):         self.log_level = get_log_level_for_setting(config, "log_level")
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(505):         log_level = config.getoption(setting_name)
0.24 logging.py(506):         if log_level is None:
0.24 logging.py(507):             log_level = config.getini(setting_name)
0.24 logging.py(508):         if log_level:
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(511):         return None
0.24 logging.py(550):         self.caplog_handler = LogCaptureHandler()
0.24 logging.py(336):         super().__init__(StringIO())
0.24 logging.py(337):         self.records: List[logging.LogRecord] = []
0.24 logging.py(551):         self.caplog_handler.setFormatter(self.formatter)
0.24 logging.py(552):         self.report_handler = LogCaptureHandler()
0.24 logging.py(336):         super().__init__(StringIO())
0.24 logging.py(337):         self.records: List[logging.LogRecord] = []
0.24 logging.py(553):         self.report_handler.setFormatter(self.formatter)
0.24 logging.py(556):         self.log_file_level = get_log_level_for_setting(config, "log_file_level")
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(505):         log_level = config.getoption(setting_name)
0.24 logging.py(506):         if log_level is None:
0.24 logging.py(507):             log_level = config.getini(setting_name)
0.24 logging.py(508):         if log_level:
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(511):         return None
0.24 logging.py(557):         log_file = get_option_ini(config, "log_file") or os.devnull
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(207):     for name in names:
0.24 logging.py(558):         if log_file != os.devnull:
0.24 logging.py(563):         self.log_file_handler = _FileHandler(log_file, mode="w", encoding="UTF-8")
0.24 logging.py(564):         log_file_format = get_option_ini(config, "log_file_format", "log_format")
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(565):         log_file_date_format = get_option_ini(
0.24 logging.py(566):             config, "log_file_date_format", "log_date_format"
0.24 logging.py(565):         log_file_date_format = get_option_ini(
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(569):         log_file_formatter = logging.Formatter(
0.24 logging.py(570):             log_file_format, datefmt=log_file_date_format
0.24 logging.py(569):         log_file_formatter = logging.Formatter(
0.24 logging.py(572):         self.log_file_handler.setFormatter(log_file_formatter)
0.24 logging.py(575):         self.log_cli_level = get_log_level_for_setting(
0.24 logging.py(576):             config, "log_cli_level", "log_level"
0.24 logging.py(575):         self.log_cli_level = get_log_level_for_setting(
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(505):         log_level = config.getoption(setting_name)
0.24 logging.py(506):         if log_level is None:
0.24 logging.py(507):             log_level = config.getini(setting_name)
0.24 logging.py(508):         if log_level:
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(505):         log_level = config.getoption(setting_name)
0.24 logging.py(506):         if log_level is None:
0.24 logging.py(507):             log_level = config.getini(setting_name)
0.24 logging.py(508):         if log_level:
0.24 logging.py(504):     for setting_name in setting_names:
0.24 logging.py(511):         return None
0.24 logging.py(578):         if self._log_cli_enabled():
0.24 logging.py(636):         enabled = self._config.getoption(
0.24 logging.py(637):             "--log-cli-level"
0.24 logging.py(636):         enabled = self._config.getoption(
0.24 logging.py(638):         ) is not None or self._config.getini("log_cli")
0.24 logging.py(636):         enabled = self._config.getoption(
0.24 logging.py(638):         ) is not None or self._config.getini("log_cli")
0.24 logging.py(636):         enabled = self._config.getoption(
0.24 logging.py(639):         if not enabled:
0.24 logging.py(640):             return False
0.24 logging.py(586):             self.log_cli_handler = _LiveLoggingNullHandler()
0.24 logging.py(587):         log_cli_formatter = self._create_formatter(
0.24 logging.py(588):             get_option_ini(config, "log_cli_format", "log_format"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(589):             get_option_ini(config, "log_cli_date_format", "log_date_format"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(212):             return ret
0.24 logging.py(590):             get_option_ini(config, "log_auto_indent"),
0.24 logging.py(207):     for name in names:
0.24 logging.py(208):         ret = config.getoption(name)  # 'default' arg won't work as expected
0.24 logging.py(209):         if ret is None:
0.24 logging.py(210):             ret = config.getini(name)
0.24 logging.py(211):         if ret:
0.24 logging.py(207):     for name in names:
0.24 logging.py(587):         log_cli_formatter = self._create_formatter(
0.24 logging.py(596):         color = getattr(self._config.option, "color", "no")
0.24 logging.py(597):         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
0.24 logging.py(598):             log_format
0.24 logging.py(597):         if color != "no" and ColoredLevelFormatter.LEVELNAME_FMT_REGEX.search(
0.24 logging.py(600):             formatter: logging.Formatter = ColoredLevelFormatter(
0.24 logging.py(601):                 create_terminal_writer(self._config), log_format, log_date_format
0.24 logging.py(600):             formatter: logging.Formatter = ColoredLevelFormatter(
0.24 logging.py(71):         super().__init__(*args, **kwargs)
0.24 logging.py(72):         self._terminalwriter = terminalwriter
0.24 logging.py(73):         self._original_fmt = self._style._fmt
0.24 logging.py(74):         self._level_to_fmt_mapping: Dict[int, str] = {}
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.24 logging.py(77):             self.add_color_level(level, *color_opts)
0.24 logging.py(93):         assert self._fmt is not None
0.24 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.24 logging.py(95):         if not levelname_fmt_match:
0.24 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.24 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(104):             formatted_levelname, **color_kwargs
0.24 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.24 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.24 logging.py(107):             colorized_formatted_levelname, self._fmt
0.25 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.25 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.25 logging.py(77):             self.add_color_level(level, *color_opts)
0.25 logging.py(93):         assert self._fmt is not None
0.25 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.25 logging.py(95):         if not levelname_fmt_match:
0.25 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.25 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.25 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.25 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.25 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(104):             formatted_levelname, **color_kwargs
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(104):             formatted_levelname, **color_kwargs
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.25 logging.py(107):             colorized_formatted_levelname, self._fmt
0.25 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.25 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.25 logging.py(77):             self.add_color_level(level, *color_opts)
0.25 logging.py(93):         assert self._fmt is not None
0.25 logging.py(94):         levelname_fmt_match = self.LEVELNAME_FMT_REGEX.search(self._fmt)
0.25 logging.py(95):         if not levelname_fmt_match:
0.25 logging.py(97):         levelname_fmt = levelname_fmt_match.group()
0.25 logging.py(99):         formatted_levelname = levelname_fmt % {"levelname": logging.getLevelName(level)}
0.25 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.25 logging.py(102):         color_kwargs = {name: True for name in color_opts}
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(104):             formatted_levelname, **color_kwargs
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(104):             formatted_levelname, **color_kwargs
0.25 logging.py(103):         colorized_formatted_levelname = self._terminalwriter.markup(
0.25 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.25 logging.py(107):             colorized_formatted_levelname, self._fmt
0.25 logging.py(106):         self._level_to_fmt_mapping[level] = self.LEVELNAME_FMT_REGEX.sub(
0.25 logging.py(76):         for level, color_opts in self.LOGLEVEL_COLOROPTS.items():
0.25 logging.py(606):         formatter._style = PercentStyleMultiline(
0.25 logging.py(607):             formatter._style._fmt, auto_indent=auto_indent
0.25 logging.py(606):         formatter._style = PercentStyleMultiline(
0.25 logging.py(124):         super().__init__(fmt)
0.25 logging.py(125):         self._auto_indent = self._get_auto_indent(auto_indent)
0.25 logging.py(160):         if auto_indent_option is None:
0.25 logging.py(161):             return 0
0.25 logging.py(610):         return formatter
0.25 logging.py(592):         self.log_cli_handler.setFormatter(log_cli_formatter)
0.25 logging.py(651):         self.log_cli_handler.set_when("sessionstart")
0.25 logging.py(822):         pass
0.25 logging.py(653):         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
0.25 logging.py(311):         self.handler = handler
0.25 logging.py(312):         self.level = level
0.25 logging.py(315):         root_logger = logging.getLogger()
0.25 logging.py(316):         if self.level is not None:
0.25 logging.py(318):         root_logger.addHandler(self.handler)
0.25 logging.py(319):         if self.level is not None:
0.25 logging.py(322):         return self.handler
0.25 logging.py(654):             with catching_logs(self.log_file_handler, level=self.log_file_level):
0.25 logging.py(311):         self.handler = handler
0.25 logging.py(312):         self.level = level
0.25 logging.py(315):         root_logger = logging.getLogger()
0.25 logging.py(316):         if self.level is not None:
0.25 logging.py(318):         root_logger.addHandler(self.handler)
0.25 logging.py(319):         if self.level is not None:
0.25 logging.py(322):         return self.handler
0.25 logging.py(655):                 yield
============================= test session starts ==============================
platform linux -- Python 3.9.23, pytest-7.2.0.dev157+gaa55975c7, pluggy-0.13.1
rootdir: /testbed, configfile: pyproject.toml
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.26 logging.py(659):         self.log_cli_handler.set_when("collection")
0.26 logging.py(822):         pass
0.26 logging.py(661):         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(662):             with catching_logs(self.log_file_handler, level=self.log_file_level):
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(663):                 yield
collected 1 item
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.26 logging.py(667):         if session.config.option.collectonly:
0.26 logging.py(671):         if self._log_cli_enabled() and self._config.getoption("verbose") < 1:
0.26 logging.py(636):         enabled = self._config.getoption(
0.26 logging.py(637):             "--log-cli-level"
0.26 logging.py(636):         enabled = self._config.getoption(
0.26 logging.py(638):         ) is not None or self._config.getini("log_cli")
0.26 logging.py(636):         enabled = self._config.getoption(
0.26 logging.py(638):         ) is not None or self._config.getini("log_cli")
0.26 logging.py(636):         enabled = self._config.getoption(
0.26 logging.py(639):         if not enabled:
0.26 logging.py(640):             return False
0.26 logging.py(675):         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(676):             with catching_logs(self.log_file_handler, level=self.log_file_level):
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(677):                 yield  # Run all the tests.
0.26 logging.py(681):         self.log_cli_handler.reset()
0.26 logging.py(819):         pass
0.26 logging.py(682):         self.log_cli_handler.set_when("start")
0.26 logging.py(822):         pass

testing/test_coverup_pytest-dev__pytest-10051.py 0.26 logging.py(709):         self.log_cli_handler.set_when("setup")
0.26 logging.py(822):         pass
0.26 logging.py(711):         empty: Dict[str, List[logging.LogRecord]] = {}
0.26 logging.py(712):         item.stash[caplog_records_key] = empty
0.26 logging.py(713):         yield from self._runtest_for(item, "setup")
0.26 logging.py(690):         with catching_logs(
0.26 logging.py(691):             self.caplog_handler,
0.26 logging.py(692):             level=self.log_level,
0.26 logging.py(690):         with catching_logs(
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(693):         ) as caplog_handler, catching_logs(
0.26 logging.py(694):             self.report_handler,
0.26 logging.py(695):             level=self.log_level,
0.26 logging.py(693):         ) as caplog_handler, catching_logs(
0.26 logging.py(311):         self.handler = handler
0.26 logging.py(312):         self.level = level
0.26 logging.py(690):         with catching_logs(
0.26 logging.py(315):         root_logger = logging.getLogger()
0.26 logging.py(316):         if self.level is not None:
0.26 logging.py(318):         root_logger.addHandler(self.handler)
0.26 logging.py(319):         if self.level is not None:
0.26 logging.py(322):         return self.handler
0.26 logging.py(696):         ) as report_handler:
0.26 logging.py(697):             caplog_handler.reset()
0.26 logging.py(345):         self.records = []
0.26 logging.py(346):         self.stream = StringIO()
0.26 logging.py(698):             report_handler.reset()
0.26 logging.py(345):         self.records = []
0.26 logging.py(346):         self.stream = StringIO()
0.26 logging.py(699):             item.stash[caplog_records_key][when] = caplog_handler.records
0.26 logging.py(700):             item.stash[caplog_handler_key] = caplog_handler
0.26 logging.py(702):             yield
0.26 logging.py(704):             log = report_handler.stream.getvalue().strip()
0.26 logging.py(705):             item.add_report_section(when, "log", log)
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.26 logging.py(325):         root_logger = logging.getLogger()
0.26 logging.py(326):         if self.level is not None:
0.26 logging.py(328):         root_logger.removeHandler(self.handler)
0.27 logging.py(686):         self.log_cli_handler.set_when("logreport")
0.27 logging.py(822):         pass
0.27 logging.py(717):         self.log_cli_handler.set_when("call")
0.27 logging.py(822):         pass
0.27 logging.py(719):         yield from self._runtest_for(item, "call")
0.27 logging.py(690):         with catching_logs(
0.27 logging.py(691):             self.caplog_handler,
0.27 logging.py(692):             level=self.log_level,
0.27 logging.py(690):         with catching_logs(
0.27 logging.py(311):         self.handler = handler
0.27 logging.py(312):         self.level = level
0.27 logging.py(315):         root_logger = logging.getLogger()
0.27 logging.py(316):         if self.level is not None:
0.27 logging.py(318):         root_logger.addHandler(self.handler)
0.27 logging.py(319):         if self.level is not None:
0.27 logging.py(322):         return self.handler
0.27 logging.py(693):         ) as caplog_handler, catching_logs(
0.27 logging.py(694):             self.report_handler,
0.27 logging.py(695):             level=self.log_level,
0.27 logging.py(693):         ) as caplog_handler, catching_logs(
0.27 logging.py(311):         self.handler = handler
0.27 logging.py(312):         self.level = level
0.27 logging.py(690):         with catching_logs(
0.27 logging.py(315):         root_logger = logging.getLogger()
0.27 logging.py(316):         if self.level is not None:
0.27 logging.py(318):         root_logger.addHandler(self.handler)
0.27 logging.py(319):         if self.level is not None:
0.27 logging.py(322):         return self.handler
0.27 logging.py(696):         ) as report_handler:
0.27 logging.py(697):             caplog_handler.reset()
0.27 logging.py(345):         self.records = []
0.27 logging.py(346):         self.stream = StringIO()
0.27 logging.py(698):             report_handler.reset()
0.27 logging.py(345):         self.records = []
0.27 logging.py(346):         self.stream = StringIO()
0.27 logging.py(699):             item.stash[caplog_records_key][when] = caplog_handler.records
0.27 logging.py(700):             item.stash[caplog_handler_key] = caplog_handler
0.27 logging.py(702):             yield
0.27 logging.py(704):             log = report_handler.stream.getvalue().strip()
0.27 logging.py(705):             item.add_report_section(when, "log", log)
0.27 logging.py(325):         root_logger = logging.getLogger()
0.27 logging.py(326):         if self.level is not None:
0.27 logging.py(328):         root_logger.removeHandler(self.handler)
0.27 logging.py(325):         root_logger = logging.getLogger()
0.27 logging.py(326):         if self.level is not None:
0.27 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(686):         self.log_cli_handler.set_when("logreport")
0.30 logging.py(822):         pass
F0.30 logging.py(723):         self.log_cli_handler.set_when("teardown")
0.30 logging.py(822):         pass
0.30 logging.py(725):         yield from self._runtest_for(item, "teardown")
0.30 logging.py(690):         with catching_logs(
0.30 logging.py(691):             self.caplog_handler,
0.30 logging.py(692):             level=self.log_level,
0.30 logging.py(690):         with catching_logs(
0.30 logging.py(311):         self.handler = handler
0.30 logging.py(312):         self.level = level
0.30 logging.py(315):         root_logger = logging.getLogger()
0.30 logging.py(316):         if self.level is not None:
0.30 logging.py(318):         root_logger.addHandler(self.handler)
0.30 logging.py(319):         if self.level is not None:
0.30 logging.py(322):         return self.handler
0.30 logging.py(693):         ) as caplog_handler, catching_logs(
0.30 logging.py(694):             self.report_handler,
0.30 logging.py(695):             level=self.log_level,
0.30 logging.py(693):         ) as caplog_handler, catching_logs(
0.30 logging.py(311):         self.handler = handler
0.30 logging.py(312):         self.level = level
0.30 logging.py(690):         with catching_logs(
0.30 logging.py(315):         root_logger = logging.getLogger()
0.30 logging.py(316):         if self.level is not None:
0.30 logging.py(318):         root_logger.addHandler(self.handler)
0.30 logging.py(319):         if self.level is not None:
0.30 logging.py(322):         return self.handler
0.30 logging.py(696):         ) as report_handler:
0.30 logging.py(697):             caplog_handler.reset()
0.30 logging.py(345):         self.records = []
0.30 logging.py(346):         self.stream = StringIO()
0.30 logging.py(698):             report_handler.reset()
0.30 logging.py(345):         self.records = []
0.30 logging.py(346):         self.stream = StringIO()
0.30 logging.py(699):             item.stash[caplog_records_key][when] = caplog_handler.records
0.30 logging.py(700):             item.stash[caplog_handler_key] = caplog_handler
0.30 logging.py(702):             yield
0.30 logging.py(704):             log = report_handler.stream.getvalue().strip()
0.30 logging.py(705):             item.add_report_section(when, "log", log)
0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(726):         del item.stash[caplog_records_key]
0.30 logging.py(727):         del item.stash[caplog_handler_key]
0.30 logging.py(686):         self.log_cli_handler.set_when("logreport")
0.30 logging.py(822):         pass
0.30 logging.py(731):         self.log_cli_handler.set_when("finish")
0.30 logging.py(822):         pass
                       [100%]0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(735):         self.log_cli_handler.set_when("sessionfinish")
0.30 logging.py(822):         pass
0.30 logging.py(737):         with catching_logs(self.log_cli_handler, level=self.log_cli_level):
0.30 logging.py(311):         self.handler = handler
0.30 logging.py(312):         self.level = level
0.30 logging.py(315):         root_logger = logging.getLogger()
0.30 logging.py(316):         if self.level is not None:
0.30 logging.py(318):         root_logger.addHandler(self.handler)
0.30 logging.py(319):         if self.level is not None:
0.30 logging.py(322):         return self.handler
0.30 logging.py(738):             with catching_logs(self.log_file_handler, level=self.log_file_level):
0.30 logging.py(311):         self.handler = handler
0.30 logging.py(312):         self.level = level
0.30 logging.py(315):         root_logger = logging.getLogger()
0.30 logging.py(316):         if self.level is not None:
0.30 logging.py(318):         root_logger.addHandler(self.handler)
0.30 logging.py(319):         if self.level is not None:
0.30 logging.py(322):         return self.handler
0.30 logging.py(739):                 yield


=================================== FAILURES ===================================
____________________________ test_caplog_clear_bug _____________________________

caplog = <_pytest.logging.LogCaptureFixture object at 0x7f2b060eb9d0>

    def test_caplog_clear_bug(caplog):
        def verify_consistency():
            # Assert that caplog.get_records("call") and caplog.records are the same
            assert caplog.get_records("call") == caplog.records
    
        # Initial consistency check
        verify_consistency()
    
        # Log a message
        logging.warning("test")
    
        # Consistency check after logging
        verify_consistency()
    
        # Clear the logs
        caplog.clear()
    
        # Consistency check after clear
>       verify_consistency()

testing/test_coverup_pytest-dev__pytest-10051.py:22: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

    def verify_consistency():
        # Assert that caplog.get_records("call") and caplog.records are the same
>       assert caplog.get_records("call") == caplog.records
E       assert [<LogRecord: ..., 13, "test">] == []
E         Left contains one more item: <LogRecord: root, 30, /testbed/testing/test_coverup_pytest-dev__pytest-10051.py, 13, "test">
E         Use -v to get more diff

testing/test_coverup_pytest-dev__pytest-10051.py:7: AssertionError
---------------------------- Captured stdout setup -----------------------------
0.26 logging.py(498):     result = LogCaptureFixture(request.node, _ispytest=True)
0.26 logging.py(362):         check_ispytest(_ispytest)
0.26 logging.py(363):         self._item = item
0.26 logging.py(364):         self._initial_handler_level: Optional[int] = None
0.26 logging.py(366):         self._initial_logger_levels: Dict[Optional[str], int] = {}
0.26 logging.py(499):     yield result
----------------------------- Captured stdout call -----------------------------
0.27 logging.py(399):         return self._item.stash[caplog_records_key].get(when, [])
0.27 logging.py(409):         return self.handler.records
0.27 logging.py(386):         return self._item.stash[caplog_handler_key]
0.27 logging.py(341):         self.records.append(record)
0.27 logging.py(342):         super().emit(record)
0.27 logging.py(111):         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
0.27 logging.py(112):         self._style._fmt = fmt
0.27 logging.py(113):         return super().format(record)
0.27 logging.py(183):         if "\n" in record.message:
0.27 logging.py(203):         return self._fmt % record.__dict__
0.27 logging.py(341):         self.records.append(record)
0.27 logging.py(342):         super().emit(record)
0.27 logging.py(111):         fmt = self._level_to_fmt_mapping.get(record.levelno, self._original_fmt)
0.27 logging.py(112):         self._style._fmt = fmt
0.27 logging.py(113):         return super().format(record)
0.27 logging.py(183):         if "\n" in record.message:
0.27 logging.py(203):         return self._fmt % record.__dict__
0.27 logging.py(399):         return self._item.stash[caplog_records_key].get(when, [])
0.27 logging.py(409):         return self.handler.records
0.27 logging.py(386):         return self._item.stash[caplog_handler_key]
0.27 logging.py(443):         self.handler.reset()
0.27 logging.py(386):         return self._item.stash[caplog_handler_key]
0.27 logging.py(345):         self.records = []
0.27 logging.py(346):         self.stream = StringIO()
0.27 logging.py(399):         return self._item.stash[caplog_records_key].get(when, [])
0.27 logging.py(409):         return self.handler.records
0.27 logging.py(386):         return self._item.stash[caplog_handler_key]
------------------------------ Captured log call -------------------------------
WARNING  root:test_coverup_pytest-dev__pytest-10051.py:13 test
--------------------------- Captured stdout teardown ---------------------------
0.30 logging.py(500):     result._finalize()
0.30 logging.py(374):         if self._initial_handler_level is not None:
0.30 logging.py(376):         for logger_name, level in self._initial_logger_levels.items():
=========================== short test summary info ============================
FAILED testing/test_coverup_pytest-dev__pytest-10051.py::test_caplog_clear_bug
============================== 1 failed in 0.05s ===============================
0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(325):         root_logger = logging.getLogger()
0.30 logging.py(326):         if self.level is not None:
0.30 logging.py(328):         root_logger.removeHandler(self.handler)
0.30 logging.py(745):         self.log_file_handler.close()
+ cat coverage.cover
{"/testbed/src/_pytest/logging.py": {"2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0, "10": 0, "11": 0, "12": 0, "13": 0, "14": 0, "15": 0, "16": 0, "17": 0, "18": 0, "19": 0, "21": 0, "22": 0, "23": 0, "24": 0, "25": 0, "26": 0, "27": 0, "28": 0, "29": 0, "30": 0, "31": 0, "32": 0, "33": 0, "34": 0, "35": 0, "36": 0, "38": 0, "39": 0, "41": 0, "44": 0, "45": 0, "46": 0, "47": 0, "48": 0, "51": 0, "55": 0, "116": 0, "206": 0, "215": 0, "301": 0, "305": 0, "331": 0, "357": 0, "358": 0, "486": 0, "487": 0, "503": 0, "527": 0, "528": 0, "532": 0, "748": 0, "756": 0, "815": 0, "52": 0, "60": 0, "61": 0, "62": 0, "63": 0, "64": 0, "65": 0, "66": 0, "59": 0, "68": 0, "70": 0, "79": 0, "110": 0, "71": 2, "72": 2, "73": 2, "74": 2, "76": 14, "77": 12, "93": 12, "94": 12, "95": 12, "96": 0, "97": 12, "99": 12, "102": 36, "103": 36, "104": 24, "106": 24, "107": 12, "111": 2, "112": 2, "113": 2, "123": 0, "127": 0, "128": 0, "182": 0, "124": 2, "125": 2, "160": 2, "161": 2, "162": 0, "163": 0, "164": 0, "166": 0, "167": 0, "168": 0, "169": 0, "170": 0, "171": 0, "172": 0, "173": 0, "174": 0, "175": 0, "176": 0, "177": 0, "178": 0, "180": 0, "183": 2, "184": 0, "186": 0, "188": 0, "190": 0, "191": 0, "192": 0, "194": 0, "195": 0, "196": 0, "200": 0, "201": 0, "202": 0, "203": 2, "207": 14, "208": 11, "209": 11, "210": 11, "211": 11, "212": 6, "217": 1, "219": 1, "225": 2, "226": 1, "227": 1, "228": 1, "229": 1, "231": 1, "236": 2, "237": 1, "238": 1, "239": 1, "240": 1, "242": 2, "243": 1, "244": 1, "245": 1, "246": 1, "248": 2, "249": 1, "250": 1, "251": 1, "252": 1, "254": 2, "255": 1, "257": 2, "258": 1, "259": 1, "260": 1, "261": 1, "263": 2, "264": 1, "265": 1, "266": 1, "267": 1, "269": 2, "270": 1, "271": 1, "272": 1, "273": 1, "275": 2, "276": 1, "277": 1, "278": 1, "279": 1, "281": 2, "282": 1, "283": 1, "284": 1, "285": 1, "287": 2, "288": 1, "289": 1, "290": 1, "291": 1, "293": 2, "294": 1, "295": 1, "296": 1, "297": 1, "220": 22, "221": 11, "223": 11, "308": 0, "310": 0, "314": 0, "324": 0, "311": 14, "312": 14, "315": 14, "316": 14, "317": 0, "318": 14, "319": 14, "320": 0, "321": 0, "322": 14, "325": 14, "326": 14, "327": 0, "328": 14, "334": 0, "339": 0, "344": 0, "348": 0, "336": 2, "337": 2, "341": 2, "342": 2, "345": 7, "346": 7, "349": 0, "354": 0, "361": 0, "368": 0, "380": 0, "381": 0, "388": 0, "401": 0, "402": 0, "406": 0, "407": 0, "411": 0, "412": 0, "422": 0, "423": 0, "441": 0, "445": 0, "463": 0, "464": 0, "465": 0, "466": 0, "362": 1, "363": 1, "364": 1, "366": 1, "374": 1, "375": 0, "376": 1, "377": 0, "378": 0, "386": 4, "399": 3, "404": 0, "409": 3, "420": 0, "439": 0, "443": 1, "455": 0, "457": 0, "458": 0, "459": 0, "460": 0, "461": 0, "474": 0, "475": 0, "476": 0, "477": 0, "478": 0, "479": 0, "480": 0, "482": 0, "483": 0, "498": 1, "499": 1, "500": 1, "504": 7, "505": 4, "506": 4, "507": 4, "508": 4, "509": 0, "511": 3, "513": 0, "514": 0, "515": 0, "516": 0, "517": 0, "519": 0, "520": 0, "522": 0, "523": 0, "529": 1, "535": 0, "594": 0, "612": 0, "634": 0, "649": 0, "650": 0, "657": 0, "658": 0, "665": 0, "666": 0, "679": 0, "680": 0, "684": 0, "685": 0, "688": 0, "707": 0, "708": 0, "715": 0, "716": 0, "721": 0, "722": 0, "729": 0, "730": 0, "733": 0, "734": 0, "741": 0, "742": 0, "541": 1, "544": 2, "545": 1, "546": 1, "547": 1, "549": 1, "550": 1, "551": 1, "552": 1, "553": 1, "556": 1, "557": 1, "558": 1, "559": 0, "560": 0, "561": 0, "563": 1, "564": 1, "565": 2, "566": 1, "569": 2, "570": 1, "572": 1, "575": 2, "576": 1, "578": 1, "579": 0, "580": 0, "584": 0, "582": 0, "586": 1, "587": 2, "588": 1, "589": 1, "590": 1, "592": 1, "596": 2, "597": 4, "598": 2, "600": 4, "601": 2, "604": 0, "606": 4, "607": 2, "610": 2, "620": 0, "622": 0, "623": 0, "625": 0, "626": 0, "629": 0, "630": 0, "631": 0, "632": 0, "636": 8, "637": 2, "638": 4, "639": 2, "640": 2, "642": 0, "643": 0, "645": 0, "647": 0, "651": 1, "653": 1, "654": 1, "655": 1, "659": 1, "661": 1, "662": 1, "663": 1, "667": 1, "668": 0, "669": 0, "671": 1, "673": 0, "675": 1, "676": 1, "677": 1, "681": 1, "682": 1, "686": 3, "690": 9, "691": 3, "692": 3, "693": 6, "694": 3, "695": 3, "696": 3, "697": 3, "698": 3, "699": 3, "700": 3, "702": 3, "704": 3, "705": 3, "709": 1, "711": 1, "712": 1, "713": 1, "717": 1, "719": 1, "723": 1, "725": 1, "726": 1, "727": 1, "731": 1, "735": 1, "737": 1, "738": 1, "739": 1, "745": 1, "751": 0, "753": 0, "767": 0, "771": 0, "772": 0, "773": 0, "769": 0, "780": 0, "784": 0, "791": 0, "810": 0, "774": 0, "775": 0, "776": 0, "777": 0, "778": 0, "782": 0, "786": 0, "787": 0, "788": 0, "789": 0, "794": 0, "793": 0, "795": 0, "792": 0, "797": 0, "798": 0, "799": 0, "800": 0, "801": 0, "802": 0, "803": 0, "804": 0, "805": 0, "806": 0, "807": 0, "808": 0, "812": 0, "818": 0, "821": 0, "824": 0, "819": 1, "822": 11, "826": 0}}
+ git checkout aa55975c7d3f6c9f6d7f68accc41bb7cadf0eb9a
Note: switching to 'aa55975c7d3f6c9f6d7f68accc41bb7cadf0eb9a'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at aa55975c7 Doc: Clear mailbox before deleting the user (#10068)
+ git apply /root/pre_state.patch
error: unrecognized input
