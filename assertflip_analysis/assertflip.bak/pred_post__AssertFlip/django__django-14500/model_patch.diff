diff --git a/dev/null b/tests/test_coverup_django__django-14500.py
new file mode 100644
index e69de29..e0726a5 100644
--- /dev/null
+++ b/tests/test_coverup_django__django-14500.py
@@ -0,0 +1,37 @@
+from django.test import TestCase
+from django.db import connection
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.recorder import MigrationRecorder
+from unittest.mock import MagicMock
+
+class SquashedMigrationUnapplyTest(TestCase):
+    def setUp(self):
+        # Set up the mock migration environment
+        self.executor = MigrationExecutor(connection)
+        self.recorder = MigrationRecorder(connection)
+        
+        # Mock squashed migration and its replaced migrations
+        self.squashed_migration = MagicMock()
+        self.squashed_migration.app_label = 'app'
+        self.squashed_migration.name = '0002_squashed'
+        self.squashed_migration.replaces = [('app', '0001_initial'), ('app', '0002_auto')]
+        
+        # Mark replaced migrations as applied
+        for app_label, name in self.squashed_migration.replaces:
+            self.recorder.record_applied(app_label, name)
+        
+        # Ensure squashed migration is initially marked as applied
+        self.recorder.record_applied(self.squashed_migration.app_label, self.squashed_migration.name)
+
+    def test_unapply_squashed_migration_with_replaced_present(self):
+        # Unapply the squashed migration with fake=True to avoid schema editor issues
+        self.executor.unapply_migration(None, self.squashed_migration, fake=True)
+        
+        # Check if the squashed migration is marked as unapplied
+        unapplied_migrations = self.recorder.applied_migrations()
+        
+        # Assert that the squashed migration is correctly not marked as unapplied
+        self.assertNotIn((self.squashed_migration.app_label, self.squashed_migration.name), unapplied_migrations)
+        
+        # Cleanup: Ensure no state pollution
+        self.recorder.flush()
