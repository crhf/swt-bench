+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD d65c9ca20ddf81ef91199e6d819f9d3506ef477c
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit d65c9ca20ddf81ef91199e6d819f9d3506ef477c
Merge: 52ffc5bc09 cdf56b3b67
Author: Tim Hoffmann <2836374+timhoffm@users.noreply.github.com>
Date:   Tue Jun 25 18:06:14 2019 +0200

    Merge pull request #14621 from meeseeksmachine/auto-backport-of-pr-14613-on-v3.1.x
    
    Backport PR #14613 on branch v3.1.x (Cleanup DateFormatter docstring.)

+ git diff d65c9ca20ddf81ef91199e6d819f9d3506ef477c
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: cycler>=0.10 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from matplotlib==3.1.0+257.gd65c9ca20d) (0.12.1)
Requirement already satisfied: kiwisolver>=1.0.1 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from matplotlib==3.1.0+257.gd65c9ca20d) (1.4.7)
Requirement already satisfied: pyparsing!=2.0.4,!=2.1.2,!=2.1.6,>=2.0.1 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from matplotlib==3.1.0+257.gd65c9ca20d) (3.1.4)
Requirement already satisfied: python-dateutil>=2.1 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from matplotlib==3.1.0+257.gd65c9ca20d) (2.9.0.post0)
Requirement already satisfied: numpy>=1.11 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from matplotlib==3.1.0+257.gd65c9ca20d) (1.24.4)
Requirement already satisfied: six>=1.5 in /opt/miniconda3/envs/testbed/lib/python3.8/site-packages (from python-dateutil>=2.1->matplotlib==3.1.0+257.gd65c9ca20d) (1.17.0)
Installing collected packages: matplotlib
  Attempting uninstall: matplotlib
    Found existing installation: matplotlib 3.1.0+257.gd65c9ca20d
    Uninstalling matplotlib-3.1.0+257.gd65c9ca20d:
      Successfully uninstalled matplotlib-3.1.0+257.gd65c9ca20d
  DEPRECATION: Legacy editable install of matplotlib==3.1.0+257.gd65c9ca20d from file:///testbed (setup.py develop) is deprecated. pip 25.0 will enforce this behaviour change. A possible replacement is to add a pyproject.toml or enable --use-pep517, and use setuptools >= 64. If the resulting installation is not behaving as expected, try using --config-settings editable_mode=compat. Please consult the setuptools documentation for more information. Discussion can be found at https://github.com/pypa/pip/issues/11457
  Running setup.py develop for matplotlib
Successfully installed matplotlib
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git apply -v -
Checking patch lib/matplotlib/axes/_base.py...
Hunk #1 succeeded at 3264 (offset 2 lines).
Hunk #2 succeeded at 3647 (offset 2 lines).
Checking patch lib/matplotlib/ticker.py...
Checking patch lib/mpl_toolkits/mplot3d/axes3d.py...
Applied patch lib/matplotlib/axes/_base.py cleanly.
Applied patch lib/matplotlib/ticker.py cleanly.
Applied patch lib/mpl_toolkits/mplot3d/axes3d.py cleanly.
+ git apply -v -
Checking patch lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py...
Applied patch lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(lib/matplotlib/ticker\.py|lib/mpl_toolkits/mplot3d/axes3d\.py|lib/matplotlib/axes/_base\.py)' -m pytest --no-header -rA -p no:cacheprovider lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py
Matplotlib is not built with the correct FreeType version to run tests.  Set local_freetype=True in setup.cfg and rebuild. Expect many image comparison failures below. Expected freetype version 2.6.1. Found freetype version 2.11.1. Freetype build type is not local
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(lib/matplotlib/ticker\\.py|lib/mpl_toolkits/mplot3d/axes3d\\.py|lib/matplotlib/axes/_base\\.py)']
============================= test session starts ==============================
collected 1 item

lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py .      [100%]

=============================== warnings summary ===============================
lib/matplotlib/__init__.py:200
lib/matplotlib/__init__.py:200
lib/matplotlib/__init__.py:200
lib/matplotlib/__init__.py:200
lib/matplotlib/__init__.py:200
  /testbed/lib/matplotlib/__init__.py:200: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    if LooseVersion(module.__version__) < minver:

../opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337
../opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337
../opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337
../opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337
../opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337
lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py::test_invert_axis_log_scale
  /opt/miniconda3/envs/testbed/lib/python3.8/site-packages/setuptools/_distutils/version.py:337: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    other = LooseVersion(other)

lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py::test_invert_axis_log_scale
  /testbed/lib/matplotlib/__init__.py:332: DeprecationWarning: distutils Version classes are deprecated. Use packaging.version instead.
    version = LooseVersion(match.group(1))

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
__________________________ test_invert_axis_log_scale __________________________
----------------------------- Captured stdout call -----------------------------
4.77 _base.py(460):         martist.Artist.__init__(self)
4.77 _base.py(461):         if isinstance(rect, mtransforms.Bbox):
4.77 _base.py(462):             self._position = rect
4.77 _base.py(465):         if self._position.width < 0 or self._position.height < 0:
4.77 _base.py(467):         self._originalPosition = self._position.frozen()
4.77 _base.py(468):         self.axes = self
4.77 _base.py(469):         self._aspect = 'auto'
4.77 _base.py(470):         self._adjustable = 'box'
4.77 _base.py(471):         self._anchor = 'C'
4.77 _base.py(472):         self._sharex = sharex
4.77 _base.py(473):         self._sharey = sharey
4.77 _base.py(474):         if sharex is not None:
4.77 _base.py(476):         if sharey is not None:
4.77 _base.py(478):         self.set_label(label)
4.77 _base.py(479):         self.set_figure(fig)
4.77 _base.py(612):         martist.Artist.set_figure(self, fig)
4.77 _base.py(614):         self.bbox = mtransforms.TransformedBbox(self._position,
4.77 _base.py(615):                                                 fig.transFigure)
4.77 _base.py(614):         self.bbox = mtransforms.TransformedBbox(self._position,
4.77 _base.py(617):         self.dataLim = mtransforms.Bbox.null()
4.77 _base.py(618):         self.viewLim = mtransforms.Bbox.unit()
4.77 _base.py(619):         self.transScale = mtransforms.TransformWrapper(
4.77 _base.py(620):             mtransforms.IdentityTransform())
4.77 _base.py(619):         self.transScale = mtransforms.TransformWrapper(
4.77 _base.py(622):         self._set_lim_and_transforms()
4.77 _base.py(637):         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
4.77 _base.py(642):         self.transScale = mtransforms.TransformWrapper(
4.77 _base.py(643):             mtransforms.IdentityTransform())
4.77 _base.py(642):         self.transScale = mtransforms.TransformWrapper(
4.77 _base.py(647):         self.transLimits = mtransforms.BboxTransformFrom(
4.77 _base.py(648):             mtransforms.TransformedBbox(self.viewLim, self.transScale))
4.77 _base.py(647):         self.transLimits = mtransforms.BboxTransformFrom(
4.77 _base.py(653):         self.transData = self.transScale + (self.transLimits + self.transAxes)
4.77 _base.py(655):         self._xaxis_transform = mtransforms.blended_transform_factory(
4.77 _base.py(656):             self.transData, self.transAxes)
4.77 _base.py(655):         self._xaxis_transform = mtransforms.blended_transform_factory(
4.77 _base.py(657):         self._yaxis_transform = mtransforms.blended_transform_factory(
4.77 _base.py(658):             self.transAxes, self.transData)
4.77 _base.py(657):         self._yaxis_transform = mtransforms.blended_transform_factory(
4.77 _base.py(481):         self.set_axes_locator(kwargs.get("axes_locator", None))
4.77 _base.py(906):         self._axes_locator = locator
4.77 _base.py(907):         self.stale = True
4.77 _base.py(483):         self.spines = self._gen_axes_spines()
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.77 _base.py(486):         self._init_axis()
4.77 _base.py(596):         self.xaxis = maxis.XAxis(self)
4.77 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.77 ticker.py(2665):             nbins = 9
4.77 ticker.py(2666):             steps = [1, 2, 5, 10]
4.77 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.77 ticker.py(1932):         if args:
4.77 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.77 ticker.py(1987):         if 'nbins' in kwargs:
4.77 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.77 ticker.py(1989):             if self._nbins != 'auto':
4.77 ticker.py(1990):                 self._nbins = int(self._nbins)
4.77 ticker.py(1991):         if 'symmetric' in kwargs:
4.77 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.77 ticker.py(1993):         if 'prune' in kwargs:
4.77 ticker.py(1994):             prune = kwargs.pop('prune')
4.77 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.77 ticker.py(1998):             self._prune = prune
4.77 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.77 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.77 ticker.py(2001):         if 'steps' in kwargs:
4.77 ticker.py(2002):             steps = kwargs.pop('steps')
4.77 ticker.py(2003):             if steps is None:
4.77 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.77 ticker.py(1947):         if not np.iterable(steps):
4.77 ticker.py(1950):         steps = np.asarray(steps)
4.77 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.77 ticker.py(1954):         if steps[0] != 1:
4.77 ticker.py(1956):         if steps[-1] != 10:
4.77 ticker.py(1958):         return steps
4.77 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.77 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.77 ticker.py(1966):         return np.hstack(flights)
4.77 ticker.py(2008):         if 'integer' in kwargs:
4.77 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.77 ticker.py(2010):         if kwargs:
4.77 ticker.py(224):         self.axis = axis
4.77 ticker.py(516):         if useOffset is None:
4.77 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.77 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.77 ticker.py(519):         self.set_useOffset(useOffset)
4.77 ticker.py(536):         if val in [True, False]:
4.77 ticker.py(537):             self.offset = 0
4.77 ticker.py(538):             self._useOffset = val
4.77 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.77 ticker.py(521):         if useMathText is None:
4.77 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.77 ticker.py(523):         self.set_useMathText(useMathText)
4.77 ticker.py(560):         if val is None:
4.77 ticker.py(563):             self._useMathText = val
4.77 ticker.py(524):         self.orderOfMagnitude = 0
4.77 ticker.py(525):         self.format = ''
4.77 ticker.py(526):         self._scientific = True
4.77 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.77 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(597):         self.spines['bottom'].register_axis(self.xaxis)
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(598):         self.spines['top'].register_axis(self.xaxis)
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(599):         self.yaxis = maxis.YAxis(self)
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(600):         self.spines['left'].register_axis(self.yaxis)
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(601):         self.spines['right'].register_axis(self.yaxis)
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 _base.py(602):         self._update_transScale()
4.78 _base.py(813):         self.transScale.set(
4.78 _base.py(814):             mtransforms.blended_transform_factory(
4.78 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.78 _base.py(814):             mtransforms.blended_transform_factory(
4.78 _base.py(813):         self.transScale.set(
4.78 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.78 _base.py(487):         if facecolor is None:
4.78 _base.py(488):             facecolor = rcParams['axes.facecolor']
4.78 _base.py(489):         self._facecolor = facecolor
4.78 _base.py(490):         self._frameon = frameon
4.78 _base.py(491):         self.set_axisbelow(rcParams['axes.axisbelow'])
4.78 _base.py(2731):         self._axisbelow = axisbelow = validate_axisbelow(b)
4.78 _base.py(2732):         if axisbelow is True:
4.78 _base.py(2734):         elif axisbelow is False:
4.78 _base.py(2735):             zorder = 2.5
4.78 _base.py(2740):         for axis in self._get_axis_list():
4.78 _base.py(2501):         return (self.xaxis, self.yaxis)
4.78 _base.py(2741):             axis.set_zorder(zorder)
4.78 _base.py(2740):         for axis in self._get_axis_list():
4.78 _base.py(2741):             axis.set_zorder(zorder)
4.78 _base.py(2740):         for axis in self._get_axis_list():
4.78 _base.py(2742):         self.stale = True
4.78 _base.py(493):         self._rasterization_zorder = None
4.78 _base.py(494):         self._connected = {}  # a dict from events to (id, func)
4.78 _base.py(495):         self.cla()
4.78 _base.py(965):         if hasattr(self, 'patch'):
4.78 _base.py(968):             patch_visible = True
4.78 _base.py(970):         xaxis_visible = self.xaxis.get_visible()
4.78 _base.py(971):         yaxis_visible = self.yaxis.get_visible()
4.78 _base.py(973):         self.xaxis.cla()
4.78 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.78 ticker.py(2665):             nbins = 9
4.78 ticker.py(2666):             steps = [1, 2, 5, 10]
4.78 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.78 ticker.py(1932):         if args:
4.78 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.78 ticker.py(1987):         if 'nbins' in kwargs:
4.78 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.78 ticker.py(1989):             if self._nbins != 'auto':
4.78 ticker.py(1990):                 self._nbins = int(self._nbins)
4.78 ticker.py(1991):         if 'symmetric' in kwargs:
4.78 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.78 ticker.py(1993):         if 'prune' in kwargs:
4.78 ticker.py(1994):             prune = kwargs.pop('prune')
4.78 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.78 ticker.py(1998):             self._prune = prune
4.78 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.78 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.78 ticker.py(2001):         if 'steps' in kwargs:
4.78 ticker.py(2002):             steps = kwargs.pop('steps')
4.78 ticker.py(2003):             if steps is None:
4.78 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.78 ticker.py(1947):         if not np.iterable(steps):
4.78 ticker.py(1950):         steps = np.asarray(steps)
4.78 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.78 ticker.py(1954):         if steps[0] != 1:
4.78 ticker.py(1956):         if steps[-1] != 10:
4.78 ticker.py(1958):         return steps
4.78 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.78 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.78 ticker.py(1966):         return np.hstack(flights)
4.78 ticker.py(2008):         if 'integer' in kwargs:
4.78 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.78 ticker.py(2010):         if kwargs:
4.78 ticker.py(300):         pass
4.78 ticker.py(224):         self.axis = axis
4.78 ticker.py(516):         if useOffset is None:
4.78 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.78 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.78 ticker.py(519):         self.set_useOffset(useOffset)
4.78 ticker.py(536):         if val in [True, False]:
4.78 ticker.py(537):             self.offset = 0
4.78 ticker.py(538):             self._useOffset = val
4.78 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.78 ticker.py(521):         if useMathText is None:
4.78 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.78 ticker.py(523):         self.set_useMathText(useMathText)
4.78 ticker.py(560):         if val is None:
4.78 ticker.py(563):             self._useMathText = val
4.78 ticker.py(524):         self.orderOfMagnitude = 0
4.78 ticker.py(525):         self.format = ''
4.78 ticker.py(526):         self._scientific = True
4.78 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.78 ticker.py(528):         if useLocale is None:
4.78 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.78 ticker.py(530):         self._useLocale = useLocale
4.78 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(974):         self.yaxis.cla()
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(976):         for name, spine in self.spines.items():
4.79 _base.py(977):             spine.cla()
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(976):         for name, spine in self.spines.items():
4.79 _base.py(977):             spine.cla()
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(976):         for name, spine in self.spines.items():
4.79 _base.py(977):             spine.cla()
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(976):         for name, spine in self.spines.items():
4.79 _base.py(977):             spine.cla()
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(976):         for name, spine in self.spines.items():
4.79 _base.py(979):         self.ignore_existing_data_limits = True
4.79 _base.py(980):         self.callbacks = cbook.CallbackRegistry()
4.79 _base.py(982):         if self._sharex is not None:
4.79 _base.py(992):             self.xaxis._set_scale('linear')
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(993):             try:
4.79 _base.py(994):                 self.set_xlim(0, 1)
4.79 _base.py(3229):         if right is None and np.iterable(left):
4.79 _base.py(3231):         if xmin is not None:
4.79 _base.py(3235):         if xmax is not None:
4.79 _base.py(3240):         self._process_unit_info(xdata=(left, right))
4.79 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.79 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.79 _base.py(2102):             if axis is None:
4.79 _base.py(2105):             if data is not None:
4.79 _base.py(2107):                 if not axis.have_units():
4.79 _base.py(2108):                     axis.update_units(data)
4.79 _base.py(2111):             if kwargs is not None:
4.79 _base.py(2123):             return kwargs
4.79 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.79 _base.py(2102):             if axis is None:
4.79 _base.py(2105):             if data is not None:
4.79 _base.py(2111):             if kwargs is not None:
4.79 _base.py(2123):             return kwargs
4.79 _base.py(2127):         return kwargs
4.79 _base.py(3241):         left = self._validate_converted_limits(left, self.convert_xunits)
4.79 _base.py(3154):         if limit is not None:
4.79 _base.py(3155):             converted_limit = convert(limit)
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3159):             return converted_limit
4.79 _base.py(3242):         right = self._validate_converted_limits(right, self.convert_xunits)
4.79 _base.py(3154):         if limit is not None:
4.79 _base.py(3155):             converted_limit = convert(limit)
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3159):             return converted_limit
4.79 _base.py(3244):         old_left, old_right = self.get_xlim()
4.79 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.79 _base.py(3245):         if left is None:
4.79 _base.py(3247):         if right is None:
4.79 _base.py(3250):         if self.get_xscale() == 'log':
4.79 _base.py(3297):         return self.xaxis.get_scale()
4.79 _base.py(3263):         if left == right:
4.79 _base.py(3267):         swapped = left > right
4.79 _base.py(3268):         left, right = self.xaxis.get_major_locator().nonsingular(left, right)
4.79 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.79 _base.py(3269):         left, right = self.xaxis.limit_range_for_scale(left, right)
4.79 _base.py(3270):         if swapped:
4.79 _base.py(3273):         self.viewLim.intervalx = (left, right)
4.79 _base.py(3274):         if auto is not None:
4.79 _base.py(3275):             self._autoscaleXon = bool(auto)
4.79 _base.py(3277):         if emit:
4.79 _base.py(3278):             self.callbacks.process('xlim_changed', self)
4.79 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.79 _base.py(3281):                 if other is not self:
4.79 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.79 _base.py(3286):         self.stale = True
4.79 _base.py(3287):         return left, right
4.79 _base.py(998):         if self._sharey is not None:
4.79 _base.py(1006):             self.yaxis._set_scale('linear')
4.79 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.79 ticker.py(2665):             nbins = 9
4.79 ticker.py(2666):             steps = [1, 2, 5, 10]
4.79 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.79 ticker.py(1932):         if args:
4.79 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.79 ticker.py(1987):         if 'nbins' in kwargs:
4.79 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.79 ticker.py(1989):             if self._nbins != 'auto':
4.79 ticker.py(1990):                 self._nbins = int(self._nbins)
4.79 ticker.py(1991):         if 'symmetric' in kwargs:
4.79 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.79 ticker.py(1993):         if 'prune' in kwargs:
4.79 ticker.py(1994):             prune = kwargs.pop('prune')
4.79 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.79 ticker.py(1998):             self._prune = prune
4.79 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.79 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.79 ticker.py(2001):         if 'steps' in kwargs:
4.79 ticker.py(2002):             steps = kwargs.pop('steps')
4.79 ticker.py(2003):             if steps is None:
4.79 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.79 ticker.py(1947):         if not np.iterable(steps):
4.79 ticker.py(1950):         steps = np.asarray(steps)
4.79 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.79 ticker.py(1954):         if steps[0] != 1:
4.79 ticker.py(1956):         if steps[-1] != 10:
4.79 ticker.py(1958):         return steps
4.79 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.79 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.79 ticker.py(1966):         return np.hstack(flights)
4.79 ticker.py(2008):         if 'integer' in kwargs:
4.79 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.79 ticker.py(2010):         if kwargs:
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(516):         if useOffset is None:
4.79 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.79 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.79 ticker.py(519):         self.set_useOffset(useOffset)
4.79 ticker.py(536):         if val in [True, False]:
4.79 ticker.py(537):             self.offset = 0
4.79 ticker.py(538):             self._useOffset = val
4.79 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.79 ticker.py(521):         if useMathText is None:
4.79 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.79 ticker.py(523):         self.set_useMathText(useMathText)
4.79 ticker.py(560):         if val is None:
4.79 ticker.py(563):             self._useMathText = val
4.79 ticker.py(524):         self.orderOfMagnitude = 0
4.79 ticker.py(525):         self.format = ''
4.79 ticker.py(526):         self._scientific = True
4.79 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.79 ticker.py(528):         if useLocale is None:
4.79 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.79 ticker.py(530):         self._useLocale = useLocale
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(224):         self.axis = axis
4.79 ticker.py(300):         pass
4.79 ticker.py(224):         self.axis = axis
4.79 _base.py(1007):             try:
4.79 _base.py(1008):                 self.set_ylim(0, 1)
4.79 _base.py(3610):         if top is None and np.iterable(bottom):
4.79 _base.py(3612):         if ymin is not None:
4.79 _base.py(3616):         if ymax is not None:
4.79 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.79 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.79 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.79 _base.py(2102):             if axis is None:
4.79 _base.py(2105):             if data is not None:
4.79 _base.py(2111):             if kwargs is not None:
4.79 _base.py(2123):             return kwargs
4.79 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.79 _base.py(2102):             if axis is None:
4.79 _base.py(2105):             if data is not None:
4.79 _base.py(2107):                 if not axis.have_units():
4.79 _base.py(2108):                     axis.update_units(data)
4.79 _base.py(2111):             if kwargs is not None:
4.79 _base.py(2123):             return kwargs
4.79 _base.py(2127):         return kwargs
4.79 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.79 _base.py(3154):         if limit is not None:
4.79 _base.py(3155):             converted_limit = convert(limit)
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.79 _base.py(3156):             if (isinstance(converted_limit, Real)
4.79 _base.py(3159):             return converted_limit
4.80 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.80 _base.py(3154):         if limit is not None:
4.80 _base.py(3155):             converted_limit = convert(limit)
4.80 _base.py(3156):             if (isinstance(converted_limit, Real)
4.80 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.80 _base.py(3156):             if (isinstance(converted_limit, Real)
4.80 _base.py(3159):             return converted_limit
4.80 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.80 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.80 _base.py(3627):         if bottom is None:
4.80 _base.py(3629):         if top is None:
4.80 _base.py(3632):         if self.get_yscale() == 'log':
4.80 _base.py(3680):         return self.yaxis.get_scale()
4.80 _base.py(3645):         if bottom == top:
4.80 _base.py(3650):         swapped = bottom > top
4.80 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.80 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.80 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.80 _base.py(3653):         if swapped:
4.80 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.80 _base.py(3657):         if auto is not None:
4.80 _base.py(3658):             self._autoscaleYon = bool(auto)
4.80 _base.py(3660):         if emit:
4.80 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.80 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.80 _base.py(3664):                 if other is not self:
4.80 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.80 _base.py(3669):         self.stale = True
4.80 _base.py(3670):         return bottom, top
4.80 _base.py(1012):         if rcParams['xtick.minor.visible']:
4.80 _base.py(1015):         if rcParams['ytick.minor.visible']:
4.80 _base.py(1018):         if self._sharex is None:
4.80 _base.py(1019):             self._autoscaleXon = True
4.80 _base.py(1020):         if self._sharey is None:
4.80 _base.py(1021):             self._autoscaleYon = True
4.80 _base.py(1022):         self._xmargin = rcParams['axes.xmargin']
4.80 _base.py(1023):         self._ymargin = rcParams['axes.ymargin']
4.80 _base.py(1024):         self._tight = None
4.80 _base.py(1025):         self._use_sticky_edges = True
4.80 _base.py(1026):         self._update_transScale()  # needed?
4.80 _base.py(813):         self.transScale.set(
4.80 _base.py(814):             mtransforms.blended_transform_factory(
4.80 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.80 _base.py(814):             mtransforms.blended_transform_factory(
4.80 _base.py(813):         self.transScale.set(
4.80 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.80 _base.py(1028):         self._get_lines = _process_plot_var_args(self)
4.80 _base.py(131):         self.axes = axes
4.80 _base.py(132):         self.command = command
4.80 _base.py(133):         self.set_prop_cycle()
4.80 _base.py(145):         if not (args or kwargs) or (len(args) == 1 and args[0] is None):
4.80 _base.py(146):             prop_cycler = rcParams['axes.prop_cycle']
4.80 _base.py(150):         self.prop_cycler = itertools.cycle(prop_cycler)
4.80 _base.py(152):         self._prop_keys = prop_cycler.keys
4.80 _base.py(1029):         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
4.80 _base.py(131):         self.axes = axes
4.80 _base.py(132):         self.command = command
4.80 _base.py(133):         self.set_prop_cycle()
4.80 _base.py(145):         if not (args or kwargs) or (len(args) == 1 and args[0] is None):
4.80 _base.py(146):             prop_cycler = rcParams['axes.prop_cycle']
4.80 _base.py(150):         self.prop_cycler = itertools.cycle(prop_cycler)
4.80 _base.py(152):         self._prop_keys = prop_cycler.keys
4.80 _base.py(1031):         self._gridOn = rcParams['axes.grid']
4.80 _base.py(1032):         self.lines = []
4.80 _base.py(1033):         self.patches = []
4.80 _base.py(1034):         self.texts = []
4.80 _base.py(1035):         self.tables = []
4.80 _base.py(1036):         self.artists = []
4.80 _base.py(1037):         self.images = []
4.80 _base.py(1038):         self._mouseover_set = _OrderedSet()
4.80 _base.py(1039):         self.child_axes = []
4.80 _base.py(1040):         self._current_image = None  # strictly for pyplot via _sci, _gci
4.80 _base.py(1041):         self.legend_ = None
4.80 _base.py(1042):         self.collections = []  # collection.Collection instances
4.80 _base.py(1043):         self.containers = []
4.80 _base.py(1045):         self.grid(False)  # Disable grid on init to use rcParameter
4.80 _base.py(2781):         if len(kwargs):
4.80 _base.py(2783):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.80 _base.py(2784):         if axis in ['x', 'both']:
4.80 _base.py(2785):             self.xaxis.grid(b, which=which, **kwargs)
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(678):         elif which == 'tick2':
4.80 _base.py(680):             return self.spines['top'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.80 _base.py(707):                                               self.figure.dpi_scale_trans),
4.80 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(708):                 "top", labels_align)
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(678):         elif which == 'tick2':
4.80 _base.py(680):             return self.spines['top'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.80 _base.py(733):                                               self.figure.dpi_scale_trans),
4.80 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(734):                 "bottom", labels_align)
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(678):         elif which == 'tick2':
4.80 _base.py(680):             return self.spines['top'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.80 _base.py(707):                                               self.figure.dpi_scale_trans),
4.80 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(708):                 "top", labels_align)
4.80 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.80 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(675):         elif which == 'tick1':
4.80 _base.py(678):         elif which == 'tick2':
4.80 _base.py(680):             return self.spines['top'].get_spine_transform()
4.80 _base.py(673):         if which == 'grid':
4.80 _base.py(674):             return self._xaxis_transform
4.80 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.80 _base.py(733):                                               self.figure.dpi_scale_trans),
4.80 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(734):                 "bottom", labels_align)
4.80 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.80 _base.py(2786):         if axis in ['y', 'both']:
4.80 _base.py(2787):             self.yaxis.grid(b, which=which, **kwargs)
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(753):             return self.spines['left'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(754):         elif which == 'tick2':
4.80 _base.py(756):             return self.spines['right'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(753):             return self.spines['left'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.80 _base.py(783):                                               self.figure.dpi_scale_trans),
4.80 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(784):                 labels_align, "right")
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(754):         elif which == 'tick2':
4.80 _base.py(756):             return self.spines['right'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.80 _base.py(809):                                               self.figure.dpi_scale_trans),
4.80 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.80 _base.py(810):                 labels_align, "left")
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(753):             return self.spines['left'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(754):         elif which == 'tick2':
4.80 _base.py(756):             return self.spines['right'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(753):             return self.spines['left'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.80 _base.py(783):                                               self.figure.dpi_scale_trans),
4.80 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(784):                 labels_align, "right")
4.80 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.80 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(751):         elif which == 'tick1':
4.80 _base.py(754):         elif which == 'tick2':
4.80 _base.py(756):             return self.spines['right'].get_spine_transform()
4.80 _base.py(749):         if which == 'grid':
4.80 _base.py(750):             return self._yaxis_transform
4.80 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.80 _base.py(809):                                               self.figure.dpi_scale_trans),
4.80 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.80 _base.py(810):                 labels_align, "left")
4.80 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.81 _base.py(1046):         self.grid(self._gridOn, which=rcParams['axes.grid.which'],
4.81 _base.py(1047):                   axis=rcParams['axes.grid.axis'])
4.81 _base.py(1046):         self.grid(self._gridOn, which=rcParams['axes.grid.which'],
4.81 _base.py(2781):         if len(kwargs):
4.81 _base.py(2783):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.81 _base.py(2784):         if axis in ['x', 'both']:
4.81 _base.py(2785):             self.xaxis.grid(b, which=which, **kwargs)
4.81 _base.py(2786):         if axis in ['y', 'both']:
4.81 _base.py(2787):             self.yaxis.grid(b, which=which, **kwargs)
4.81 _base.py(1048):         props = font_manager.FontProperties(
4.81 _base.py(1049):             size=rcParams['axes.titlesize'],
4.81 _base.py(1050):             weight=rcParams['axes.titleweight'])
4.81 _base.py(1048):         props = font_manager.FontProperties(
4.81 _base.py(1052):         self.title = mtext.Text(
4.81 _base.py(1053):             x=0.5, y=1.0, text='',
4.81 _base.py(1054):             fontproperties=props,
4.81 _base.py(1055):             verticalalignment='baseline',
4.81 _base.py(1056):             horizontalalignment='center',
4.81 _base.py(1052):         self.title = mtext.Text(
4.81 _base.py(1058):         self._left_title = mtext.Text(
4.81 _base.py(1059):             x=0.0, y=1.0, text='',
4.81 _base.py(1060):             fontproperties=props.copy(),
4.81 _base.py(1061):             verticalalignment='baseline',
4.81 _base.py(1062):             horizontalalignment='left', )
4.81 _base.py(1058):         self._left_title = mtext.Text(
4.81 _base.py(1063):         self._right_title = mtext.Text(
4.81 _base.py(1064):             x=1.0, y=1.0, text='',
4.81 _base.py(1065):             fontproperties=props.copy(),
4.81 _base.py(1066):             verticalalignment='baseline',
4.81 _base.py(1067):             horizontalalignment='right',
4.81 _base.py(1063):         self._right_title = mtext.Text(
4.81 _base.py(1069):         title_offset_points = rcParams['axes.titlepad']
4.81 _base.py(1072):         self._set_title_offset_trans(title_offset_points)
4.81 _base.py(1138):         self.titleOffsetTrans = mtransforms.ScaledTranslation(
4.81 _base.py(1139):                 0.0, title_offset_points / 72,
4.81 _base.py(1140):                 self.figure.dpi_scale_trans)
4.81 _base.py(1138):         self.titleOffsetTrans = mtransforms.ScaledTranslation(
4.81 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.81 _base.py(1143):             _title.set_clip_box(None)
4.81 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.81 _base.py(1143):             _title.set_clip_box(None)
4.81 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.81 _base.py(1143):             _title.set_clip_box(None)
4.81 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1074):         self._autotitlepos = None
4.81 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1077):             self._set_artist_props(_title)
4.81 _base.py(917):         a.set_figure(self.figure)
4.81 _base.py(918):         if not a.is_transform_set():
4.81 _base.py(921):         a.axes = self
4.81 _base.py(922):         if a.mouseover:
4.81 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1077):             self._set_artist_props(_title)
4.81 _base.py(917):         a.set_figure(self.figure)
4.81 _base.py(918):         if not a.is_transform_set():
4.81 _base.py(921):         a.axes = self
4.81 _base.py(922):         if a.mouseover:
4.81 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1077):             self._set_artist_props(_title)
4.81 _base.py(917):         a.set_figure(self.figure)
4.81 _base.py(918):         if not a.is_transform_set():
4.81 _base.py(921):         a.axes = self
4.81 _base.py(922):         if a.mouseover:
4.81 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.81 _base.py(1082):         self.patch = self._gen_axes_patch()
4.81 _base.py(940):         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
4.81 _base.py(1083):         self.patch.set_figure(self.figure)
4.81 _base.py(1084):         self.patch.set_facecolor(self._facecolor)
4.81 _base.py(1085):         self.patch.set_edgecolor('None')
4.81 _base.py(1086):         self.patch.set_linewidth(0)
4.81 _base.py(1087):         self.patch.set_transform(self.transAxes)
4.81 _base.py(1089):         self.set_axis_on()
4.81 _base.py(3033):         self.axison = True
4.81 _base.py(3034):         self.stale = True
4.81 _base.py(1091):         self.xaxis.set_clip_path(self.patch)
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(675):         elif which == 'tick1':
4.81 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(674):             return self._xaxis_transform
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(675):         elif which == 'tick1':
4.81 _base.py(678):         elif which == 'tick2':
4.81 _base.py(680):             return self.spines['top'].get_spine_transform()
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(674):             return self._xaxis_transform
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(674):             return self._xaxis_transform
4.81 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.81 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(675):         elif which == 'tick1':
4.81 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(674):             return self._xaxis_transform
4.81 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.81 _base.py(707):                                               self.figure.dpi_scale_trans),
4.81 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.81 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.81 _base.py(708):                 "top", labels_align)
4.81 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.81 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.81 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(675):         elif which == 'tick1':
4.81 _base.py(678):         elif which == 'tick2':
4.81 _base.py(680):             return self.spines['top'].get_spine_transform()
4.81 _base.py(673):         if which == 'grid':
4.81 _base.py(674):             return self._xaxis_transform
4.81 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.81 _base.py(733):                                               self.figure.dpi_scale_trans),
4.81 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.81 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.81 _base.py(734):                 "bottom", labels_align)
4.81 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.81 _base.py(1092):         self.yaxis.set_clip_path(self.patch)
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(751):         elif which == 'tick1':
4.81 _base.py(753):             return self.spines['left'].get_spine_transform()
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(750):             return self._yaxis_transform
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(751):         elif which == 'tick1':
4.81 _base.py(754):         elif which == 'tick2':
4.81 _base.py(756):             return self.spines['right'].get_spine_transform()
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(750):             return self._yaxis_transform
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(750):             return self._yaxis_transform
4.81 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.81 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(751):         elif which == 'tick1':
4.81 _base.py(753):             return self.spines['left'].get_spine_transform()
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(750):             return self._yaxis_transform
4.81 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.81 _base.py(783):                                               self.figure.dpi_scale_trans),
4.81 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.81 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.81 _base.py(784):                 labels_align, "right")
4.81 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.81 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.81 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(751):         elif which == 'tick1':
4.81 _base.py(754):         elif which == 'tick2':
4.81 _base.py(756):             return self.spines['right'].get_spine_transform()
4.81 _base.py(749):         if which == 'grid':
4.81 _base.py(750):             return self._yaxis_transform
4.81 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.81 _base.py(809):                                               self.figure.dpi_scale_trans),
4.81 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.81 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.81 _base.py(810):                 labels_align, "left")
4.81 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.81 _base.py(1094):         self._shared_x_axes.clean()
4.81 _base.py(1095):         self._shared_y_axes.clean()
4.81 _base.py(1096):         if self._sharex:
4.81 _base.py(1100):         if self._sharey:
4.81 _base.py(1104):         self.stale = True
4.81 _base.py(498):         self.fmt_xdata = None
4.81 _base.py(499):         self.fmt_ydata = None
4.81 _base.py(501):         self.set_navigate(True)
4.81 _base.py(3925):         self._navigate = b
4.81 _base.py(502):         self.set_navigate_mode(None)
4.81 _base.py(3941):         self._navigate_mode = b
4.81 _base.py(504):         if xscale:
4.81 _base.py(506):         if yscale:
4.81 _base.py(509):         self.update(kwargs)
4.81 _base.py(511):         if self.xaxis is not None:
4.81 _base.py(512):             self._xcid = self.xaxis.callbacks.connect(
4.81 _base.py(513):                 'units finalize', lambda: self._on_units_changed(scalex=True))
4.81 _base.py(512):             self._xcid = self.xaxis.callbacks.connect(
4.81 _base.py(515):         if self.yaxis is not None:
4.81 _base.py(516):             self._ycid = self.yaxis.callbacks.connect(
4.81 _base.py(517):                 'units finalize', lambda: self._on_units_changed(scaley=True))
4.81 _base.py(516):             self._ycid = self.yaxis.callbacks.connect(
4.81 _base.py(519):         self.tick_params(
4.81 _base.py(520):             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
4.81 _base.py(521):             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
4.81 _base.py(522):             labeltop=(rcParams['xtick.labeltop'] and
4.81 _base.py(524):             labelbottom=(rcParams['xtick.labelbottom'] and
4.81 _base.py(525):                          rcParams['xtick.minor.bottom']),
4.81 _base.py(526):             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
4.81 _base.py(527):             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
4.81 _base.py(528):             labelleft=(rcParams['ytick.labelleft'] and
4.81 _base.py(529):                        rcParams['ytick.minor.left']),
4.81 _base.py(530):             labelright=(rcParams['ytick.labelright'] and
4.81 _base.py(532):             which='minor')
4.81 _base.py(519):         self.tick_params(
4.81 _base.py(3002):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.81 _base.py(3003):         if axis in ['x', 'both']:
4.81 _base.py(3004):             xkw = dict(kwargs)
4.81 _base.py(3005):             xkw.pop('left', None)
4.81 _base.py(3006):             xkw.pop('right', None)
4.81 _base.py(3007):             xkw.pop('labelleft', None)
4.81 _base.py(3008):             xkw.pop('labelright', None)
4.81 _base.py(3009):             self.xaxis.set_tick_params(**xkw)
4.81 _base.py(3010):         if axis in ['y', 'both']:
4.81 _base.py(3011):             ykw = dict(kwargs)
4.81 _base.py(3012):             ykw.pop('top', None)
4.81 _base.py(3013):             ykw.pop('bottom', None)
4.81 _base.py(3014):             ykw.pop('labeltop', None)
4.81 _base.py(3015):             ykw.pop('labelbottom', None)
4.81 _base.py(3016):             self.yaxis.set_tick_params(**ykw)
4.81 _base.py(534):         self.tick_params(
4.81 _base.py(535):             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
4.81 _base.py(536):             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
4.81 _base.py(537):             labeltop=(rcParams['xtick.labeltop'] and
4.81 _base.py(539):             labelbottom=(rcParams['xtick.labelbottom'] and
4.81 _base.py(540):                          rcParams['xtick.major.bottom']),
4.81 _base.py(541):             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
4.81 _base.py(542):             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
4.81 _base.py(543):             labelleft=(rcParams['ytick.labelleft'] and
4.81 _base.py(544):                        rcParams['ytick.major.left']),
4.81 _base.py(545):             labelright=(rcParams['ytick.labelright'] and
4.81 _base.py(547):             which='major')
4.81 _base.py(534):         self.tick_params(
4.81 _base.py(3002):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.81 _base.py(3003):         if axis in ['x', 'both']:
4.81 _base.py(3004):             xkw = dict(kwargs)
4.81 _base.py(3005):             xkw.pop('left', None)
4.81 _base.py(3006):             xkw.pop('right', None)
4.81 _base.py(3007):             xkw.pop('labelleft', None)
4.81 _base.py(3008):             xkw.pop('labelright', None)
4.81 _base.py(3009):             self.xaxis.set_tick_params(**xkw)
4.82 _base.py(3010):         if axis in ['y', 'both']:
4.82 _base.py(3011):             ykw = dict(kwargs)
4.82 _base.py(3012):             ykw.pop('top', None)
4.82 _base.py(3013):             ykw.pop('bottom', None)
4.82 _base.py(3014):             ykw.pop('labeltop', None)
4.82 _base.py(3015):             ykw.pop('labelbottom', None)
4.82 _base.py(3016):             self.yaxis.set_tick_params(**ykw)
4.82 _base.py(549):         self._layoutbox = None
4.82 _base.py(550):         self._poslayoutbox = None
4.82 _base.py(156):         if self.axes.xaxis is not None and self.axes.yaxis is not None:
4.82 _base.py(157):             xunits = kwargs.pop('xunits', self.axes.xaxis.units)
4.82 _base.py(158):             if self.axes.name == 'polar':
4.82 _base.py(160):             if xunits != self.axes.xaxis.units:
4.82 _base.py(162):             yunits = kwargs.pop('yunits', self.axes.yaxis.units)
4.82 _base.py(163):             if self.axes.name == 'polar':
4.82 _base.py(165):             if yunits != self.axes.yaxis.units:
4.82 _base.py(168):         for pos_only in "xy":
4.82 _base.py(169):             if pos_only in kwargs:
4.82 _base.py(168):         for pos_only in "xy":
4.82 _base.py(169):             if pos_only in kwargs:
4.82 _base.py(168):         for pos_only in "xy":
4.82 _base.py(173):         if not args:
4.82 _base.py(177):         data = kwargs.pop("data", None)
4.82 _base.py(178):         if data is not None:
4.82 _base.py(220):         while args:
4.82 _base.py(221):             this, args = args[:2], args[2:]
4.82 _base.py(222):             if args and isinstance(args[0], str):
4.82 _base.py(225):             yield from self._plot_args(this, kwargs)
4.82 _base.py(364):         ret = []
4.82 _base.py(365):         if len(tup) > 1 and isinstance(tup[-1], str):
4.82 _base.py(368):         elif len(tup) == 3:
4.82 _base.py(371):             linestyle, marker, color = None, None, None
4.82 _base.py(376):         if any(v is None for v in tup):
4.82 _base.py(376):         if any(v is None for v in tup):
4.82 _base.py(376):         if any(v is None for v in tup):
4.82 _base.py(376):         if any(v is None for v in tup):
4.82 _base.py(379):         kw = {}
4.82 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.82 _base.py(381):                         (linestyle, marker, color)):
4.82 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.82 _base.py(382):             if v is not None:
4.82 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.82 _base.py(382):             if v is not None:
4.82 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.82 _base.py(382):             if v is not None:
4.82 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.82 _base.py(385):         if len(tup) == 2:
4.82 _base.py(386):             x = _check_1d(tup[0])
4.82 _base.py(387):             y = _check_1d(tup[-1])
4.82 _base.py(391):         x, y = self._xy_from_xy(x, y)
4.82 _base.py(242):         if self.axes.xaxis is not None and self.axes.yaxis is not None:
4.82 _base.py(243):             bx = self.axes.xaxis.update_units(x)
4.82 _base.py(244):             by = self.axes.yaxis.update_units(y)
4.82 _base.py(246):             if self.command != 'plot':
4.82 _base.py(266):         x = _check_1d(x)
4.82 _base.py(267):         y = _check_1d(y)
4.82 _base.py(268):         if x.shape[0] != y.shape[0]:
4.82 _base.py(271):         if x.ndim > 2 or y.ndim > 2:
4.82 _base.py(275):         if x.ndim == 1:
4.82 _base.py(276):             x = x[:, np.newaxis]
4.82 _base.py(277):         if y.ndim == 1:
4.82 _base.py(278):             y = y[:, np.newaxis]
4.82 _base.py(279):         return x, y
4.82 _base.py(393):         if self.command == 'plot':
4.82 _base.py(394):             func = self._makeline
4.82 _base.py(399):         ncx, ncy = x.shape[1], y.shape[1]
4.82 _base.py(400):         if ncx > 1 and ncy > 1 and ncx != ncy:
4.82 _base.py(404):         for j in range(max(ncx, ncy)):
4.82 _base.py(405):             seg = func(x[:, j % ncx], y[:, j % ncy], kw, kwargs)
4.82 _base.py(309):         kw = {**kw, **kwargs}  # Don't modify the original kw.
4.82 _base.py(310):         default_dict = self._getdefaults(set(), kw)
4.82 _base.py(288):         prop_keys = self._prop_keys - ignore
4.82 _base.py(289):         if any(kw.get(k, None) is None for k in prop_keys):
4.82 _base.py(289):         if any(kw.get(k, None) is None for k in prop_keys):
4.82 _base.py(292):             default_dict = next(self.prop_cycler).copy()
4.82 _base.py(293):             for p in ignore:
4.82 _base.py(297):         return default_dict
4.82 _base.py(311):         self._setdefaults(default_dict, kw)
4.82 _base.py(304):         for k in defaults:
4.82 _base.py(305):             if kw.get(k, None) is None:
4.82 _base.py(306):                 kw[k] = defaults[k]
4.82 _base.py(304):         for k in defaults:
4.82 _base.py(312):         seg = mlines.Line2D(x, y, **kw)
4.82 _base.py(313):         return seg
4.82 _base.py(406):             ret.append(seg)
4.82 _base.py(404):         for j in range(max(ncx, ncy)):
4.82 _base.py(407):         return ret
4.82 _base.py(220):         while args:
4.82 _base.py(1898):         self._set_artist_props(line)
4.82 _base.py(917):         a.set_figure(self.figure)
4.82 _base.py(918):         if not a.is_transform_set():
4.82 _base.py(919):             a.set_transform(self.transData)
4.82 _base.py(921):         a.axes = self
4.82 _base.py(922):         if a.mouseover:
4.82 _base.py(1899):         if line.get_clip_path() is None:
4.82 _base.py(1900):             line.set_clip_path(self.patch)
4.82 _base.py(1902):         self._update_line_limits(line)
4.82 _base.py(1924):         path = line.get_path()
4.82 _base.py(1925):         if path.vertices.size == 0:
4.82 _base.py(1928):         line_trans = line.get_transform()
4.82 _base.py(1930):         if line_trans == self.transData:
4.82 _base.py(1931):             data_path = path
4.82 _base.py(1955):         if data_path.vertices.size > 0:
4.82 _base.py(1956):             updatex, updatey = line_trans.contains_branch_seperately(
4.82 _base.py(1957):                 self.transData)
4.82 _base.py(1956):             updatex, updatey = line_trans.contains_branch_seperately(
4.82 _base.py(1958):             self.dataLim.update_from_path(data_path,
4.82 _base.py(1959):                                           self.ignore_existing_data_limits,
4.82 _base.py(1960):                                           updatex=updatex,
4.82 _base.py(1961):                                           updatey=updatey)
4.82 _base.py(1958):             self.dataLim.update_from_path(data_path,
4.82 _base.py(1962):             self.ignore_existing_data_limits = False
4.82 _base.py(1903):         if not line.get_label():
4.82 _base.py(1904):             line.set_label('_line%d' % len(self.lines))
4.82 _base.py(1905):         self.lines.append(line)
4.82 _base.py(1906):         line._remove_method = self.lines.remove
4.82 _base.py(1907):         self.stale = True
4.82 _base.py(1908):         return line
4.82 _base.py(2409):         if tight is not None:
4.82 _base.py(2412):         if self.use_sticky_edges and (
4.82 _base.py(2200):         return self._use_sticky_edges
4.82 _base.py(2413):                 (self._xmargin and scalex and self._autoscaleXon) or
4.82 _base.py(2412):         if self.use_sticky_edges and (
4.82 _base.py(2414):                 (self._ymargin and scaley and self._autoscaleYon)):
4.82 _base.py(2412):         if self.use_sticky_edges and (
4.82 _base.py(2423):             x_stickies, y_stickies = [], []
4.82 _base.py(2425):         def handle_single_axis(scale, autoscaleon, shared_axes, interval,
4.82 _base.py(2493):         handle_single_axis(
4.82 _base.py(2494):             scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',
4.82 _base.py(2495):             'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)
4.82 _base.py(2493):         handle_single_axis(
4.82 _base.py(2428):             if not (scale and autoscaleon):
4.82 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2435):             if len(finite_dl):
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.82 _base.py(2440):                                 (d not in finite_dl))]
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.82 _base.py(2443):                                 (d not in finite_dl))]
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2445):                 dl = finite_dl
4.82 _base.py(2446):                 dl.extend(x_finite)
4.82 _base.py(2447):                 dl.extend(y_finite)
4.82 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.82 _base.py(2451):             vl = None
4.82 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.82 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.82 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.82 _base.py(2461):             locator = axis.get_major_locator()
4.82 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.82 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.82 _base.py(2466):             minpos = getattr(bb, minpos)
4.82 _base.py(2467):             transform = axis.get_transform()
4.82 _base.py(2468):             inverse_trans = transform.inverted()
4.82 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.82 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.82 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.82 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.82 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.82 _base.py(2477):                 delta = (x1t - x0t) * margin
4.82 _base.py(2482):             if do_lower_margin:
4.82 _base.py(2483):                 x0t -= delta
4.82 _base.py(2484):             if do_upper_margin:
4.82 _base.py(2485):                 x1t += delta
4.82 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.82 _base.py(2488):             if not self._tight:
4.82 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.82 ticker.py(2098):         if self._symmetric:
4.82 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.82 ticker.py(2103):             dmin, dmax, expander=1e-12, tiny=1e-13)
4.82 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.82 ticker.py(2105):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.82 ticker.py(2106):             return self._raw_ticks(dmin, dmax)[[0, -1]]
4.82 ticker.py(2023):         if self._nbins == 'auto':
4.82 ticker.py(2030):             nbins = self._nbins
4.82 ticker.py(2032):         scale, offset = scale_range(vmin, vmax, nbins)
4.82 ticker.py(1829):     dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.
4.82 ticker.py(1830):     meanv = (vmax + vmin) / 2
4.82 ticker.py(1831):     if abs(meanv) / dv < threshold:
4.82 ticker.py(1832):         offset = 0
4.82 ticker.py(1835):     scale = 10 ** (math.log10(dv / n) // 1)
4.82 ticker.py(1836):     return scale, offset
4.82 ticker.py(2033):         _vmin = vmin - offset
4.82 ticker.py(2034):         _vmax = vmax - offset
4.82 ticker.py(2035):         raw_step = (_vmax - _vmin) / nbins
4.82 ticker.py(2036):         steps = self._extended_steps * scale
4.82 ticker.py(2037):         if self._integer:
4.82 ticker.py(2042):         istep = np.nonzero(steps >= raw_step)[0][0]
4.82 ticker.py(2045):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.82 ticker.py(2046):             for istep in range(istep, len(steps)):
4.82 ticker.py(2047):                 step = steps[istep]
4.82 ticker.py(2048):                 best_vmin = (_vmin // step) * step
4.82 ticker.py(2049):                 best_vmax = best_vmin + step * nbins
4.82 ticker.py(2050):                 if best_vmax >= _vmax:
4.82 ticker.py(2051):                     break
4.82 ticker.py(2054):         for istep in reversed(range(istep + 1)):
4.82 ticker.py(2055):             step = steps[istep]
4.82 ticker.py(2057):             if (self._integer and
4.82 ticker.py(2060):             best_vmin = (_vmin // step) * step
4.82 ticker.py(2066):             edge = _Edge_integer(step, offset)
4.82 ticker.py(1852):         if step <= 0:
4.82 ticker.py(1854):         self.step = step
4.82 ticker.py(1855):         self._offset = abs(offset)
4.82 ticker.py(2067):             low = edge.le(_vmin - best_vmin)
4.82 ticker.py(1869):         d, m = divmod(x, self.step)
4.82 ticker.py(1870):         if self.closeto(m / self.step, 1):
4.82 ticker.py(1859):         if self._offset > 0:
4.82 ticker.py(1864):             tol = 1e-10
4.82 ticker.py(1865):         return abs(ms - edge) < tol
4.82 ticker.py(1872):         return d
4.82 ticker.py(2068):             high = edge.ge(_vmax - best_vmin)
4.82 ticker.py(1876):         d, m = divmod(x, self.step)
4.82 ticker.py(1877):         if self.closeto(m / self.step, 0):
4.82 ticker.py(1859):         if self._offset > 0:
4.82 ticker.py(1864):             tol = 1e-10
4.82 ticker.py(1865):         return abs(ms - edge) < tol
4.82 ticker.py(1879):         return (d + 1)
4.82 ticker.py(2069):             ticks = np.arange(low, high + 1) * step + best_vmin
4.82 ticker.py(2071):             nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()
4.82 ticker.py(2072):             if nticks >= self._min_n_ticks:
4.82 ticker.py(2073):                 break
4.82 ticker.py(2074):         return ticks + offset
4.82 _base.py(2490):             set_bound(x0, x1)
4.82 _base.py(3099):         if upper is None and np.iterable(lower):
4.82 _base.py(3102):         old_lower, old_upper = self.get_xbound()
4.82 _base.py(3074):         left, right = self.get_xlim()
4.82 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.82 _base.py(3075):         if left < right:
4.82 _base.py(3076):             return left, right
4.82 _base.py(3104):         if lower is None:
4.82 _base.py(3106):         if upper is None:
4.82 _base.py(3109):         if self.xaxis_inverted():
4.82 _base.py(3062):         return self.xaxis.get_inverted()
4.82 _base.py(3115):             if lower < upper:
4.82 _base.py(3116):                 self.set_xlim(lower, upper, auto=None)
4.82 _base.py(3229):         if right is None and np.iterable(left):
4.82 _base.py(3231):         if xmin is not None:
4.82 _base.py(3235):         if xmax is not None:
4.82 _base.py(3240):         self._process_unit_info(xdata=(left, right))
4.82 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.82 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.82 _base.py(2102):             if axis is None:
4.82 _base.py(2105):             if data is not None:
4.82 _base.py(2107):                 if not axis.have_units():
4.82 _base.py(2108):                     axis.update_units(data)
4.82 _base.py(2111):             if kwargs is not None:
4.82 _base.py(2123):             return kwargs
4.82 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.82 _base.py(2102):             if axis is None:
4.82 _base.py(2105):             if data is not None:
4.82 _base.py(2111):             if kwargs is not None:
4.82 _base.py(2123):             return kwargs
4.82 _base.py(2127):         return kwargs
4.82 _base.py(3241):         left = self._validate_converted_limits(left, self.convert_xunits)
4.82 _base.py(3154):         if limit is not None:
4.82 _base.py(3155):             converted_limit = convert(limit)
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3159):             return converted_limit
4.82 _base.py(3242):         right = self._validate_converted_limits(right, self.convert_xunits)
4.82 _base.py(3154):         if limit is not None:
4.82 _base.py(3155):             converted_limit = convert(limit)
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3159):             return converted_limit
4.82 _base.py(3244):         old_left, old_right = self.get_xlim()
4.82 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.82 _base.py(3245):         if left is None:
4.82 _base.py(3247):         if right is None:
4.82 _base.py(3250):         if self.get_xscale() == 'log':
4.82 _base.py(3297):         return self.xaxis.get_scale()
4.82 _base.py(3263):         if left == right:
4.82 _base.py(3267):         swapped = left > right
4.82 _base.py(3268):         left, right = self.xaxis.get_major_locator().nonsingular(left, right)
4.82 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.82 _base.py(3269):         left, right = self.xaxis.limit_range_for_scale(left, right)
4.82 _base.py(3270):         if swapped:
4.82 _base.py(3273):         self.viewLim.intervalx = (left, right)
4.82 _base.py(3274):         if auto is not None:
4.82 _base.py(3277):         if emit:
4.82 _base.py(3278):             self.callbacks.process('xlim_changed', self)
4.82 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.82 _base.py(3281):                 if other is not self:
4.82 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.82 _base.py(3286):         self.stale = True
4.82 _base.py(3287):         return left, right
4.82 _base.py(2496):         handle_single_axis(
4.82 _base.py(2497):             scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',
4.82 _base.py(2498):             'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)
4.82 _base.py(2496):         handle_single_axis(
4.82 _base.py(2428):             if not (scale and autoscaleon):
4.82 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.82 _base.py(2435):             if len(finite_dl):
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.82 _base.py(2440):                                 (d not in finite_dl))]
4.82 _base.py(2438):                 x_finite = [d for d in dl
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.82 _base.py(2443):                                 (d not in finite_dl))]
4.82 _base.py(2441):                 y_finite = [d for d in dl
4.82 _base.py(2445):                 dl = finite_dl
4.82 _base.py(2446):                 dl.extend(x_finite)
4.82 _base.py(2447):                 dl.extend(y_finite)
4.82 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.82 _base.py(2451):             vl = None
4.82 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.82 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.82 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.82 _base.py(2461):             locator = axis.get_major_locator()
4.82 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.82 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.82 _base.py(2466):             minpos = getattr(bb, minpos)
4.82 _base.py(2467):             transform = axis.get_transform()
4.82 _base.py(2468):             inverse_trans = transform.inverted()
4.82 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.82 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.82 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.82 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.82 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.82 _base.py(2477):                 delta = (x1t - x0t) * margin
4.82 _base.py(2482):             if do_lower_margin:
4.82 _base.py(2483):                 x0t -= delta
4.82 _base.py(2484):             if do_upper_margin:
4.82 _base.py(2485):                 x1t += delta
4.82 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.82 _base.py(2488):             if not self._tight:
4.82 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.82 ticker.py(2098):         if self._symmetric:
4.82 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.82 ticker.py(2103):             dmin, dmax, expander=1e-12, tiny=1e-13)
4.82 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.82 ticker.py(2105):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.82 ticker.py(2106):             return self._raw_ticks(dmin, dmax)[[0, -1]]
4.82 ticker.py(2023):         if self._nbins == 'auto':
4.82 ticker.py(2030):             nbins = self._nbins
4.82 ticker.py(2032):         scale, offset = scale_range(vmin, vmax, nbins)
4.82 ticker.py(1829):     dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.
4.82 ticker.py(1830):     meanv = (vmax + vmin) / 2
4.82 ticker.py(1831):     if abs(meanv) / dv < threshold:
4.82 ticker.py(1832):         offset = 0
4.82 ticker.py(1835):     scale = 10 ** (math.log10(dv / n) // 1)
4.82 ticker.py(1836):     return scale, offset
4.82 ticker.py(2033):         _vmin = vmin - offset
4.82 ticker.py(2034):         _vmax = vmax - offset
4.82 ticker.py(2035):         raw_step = (_vmax - _vmin) / nbins
4.82 ticker.py(2036):         steps = self._extended_steps * scale
4.82 ticker.py(2037):         if self._integer:
4.82 ticker.py(2042):         istep = np.nonzero(steps >= raw_step)[0][0]
4.82 ticker.py(2045):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.82 ticker.py(2046):             for istep in range(istep, len(steps)):
4.82 ticker.py(2047):                 step = steps[istep]
4.82 ticker.py(2048):                 best_vmin = (_vmin // step) * step
4.82 ticker.py(2049):                 best_vmax = best_vmin + step * nbins
4.82 ticker.py(2050):                 if best_vmax >= _vmax:
4.82 ticker.py(2051):                     break
4.82 ticker.py(2054):         for istep in reversed(range(istep + 1)):
4.82 ticker.py(2055):             step = steps[istep]
4.82 ticker.py(2057):             if (self._integer and
4.82 ticker.py(2060):             best_vmin = (_vmin // step) * step
4.82 ticker.py(2066):             edge = _Edge_integer(step, offset)
4.82 ticker.py(1852):         if step <= 0:
4.82 ticker.py(1854):         self.step = step
4.82 ticker.py(1855):         self._offset = abs(offset)
4.82 ticker.py(2067):             low = edge.le(_vmin - best_vmin)
4.82 ticker.py(1869):         d, m = divmod(x, self.step)
4.82 ticker.py(1870):         if self.closeto(m / self.step, 1):
4.82 ticker.py(1859):         if self._offset > 0:
4.82 ticker.py(1864):             tol = 1e-10
4.82 ticker.py(1865):         return abs(ms - edge) < tol
4.82 ticker.py(1872):         return d
4.82 ticker.py(2068):             high = edge.ge(_vmax - best_vmin)
4.82 ticker.py(1876):         d, m = divmod(x, self.step)
4.82 ticker.py(1877):         if self.closeto(m / self.step, 0):
4.82 ticker.py(1859):         if self._offset > 0:
4.82 ticker.py(1864):             tol = 1e-10
4.82 ticker.py(1865):         return abs(ms - edge) < tol
4.82 ticker.py(1878):             return d
4.82 ticker.py(2069):             ticks = np.arange(low, high + 1) * step + best_vmin
4.82 ticker.py(2071):             nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()
4.82 ticker.py(2072):             if nticks >= self._min_n_ticks:
4.82 ticker.py(2073):                 break
4.82 ticker.py(2074):         return ticks + offset
4.82 _base.py(2490):             set_bound(x0, x1)
4.82 _base.py(3499):         if upper is None and np.iterable(lower):
4.82 _base.py(3502):         old_lower, old_upper = self.get_ybound()
4.82 _base.py(3474):         bottom, top = self.get_ylim()
4.82 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.82 _base.py(3475):         if bottom < top:
4.82 _base.py(3476):             return bottom, top
4.82 _base.py(3504):         if lower is None:
4.82 _base.py(3506):         if upper is None:
4.82 _base.py(3509):         if self.yaxis_inverted():
4.82 _base.py(3462):         return self.yaxis.get_inverted()
4.82 _base.py(3515):             if lower < upper:
4.82 _base.py(3516):                 self.set_ylim(lower, upper, auto=None)
4.82 _base.py(3610):         if top is None and np.iterable(bottom):
4.82 _base.py(3612):         if ymin is not None:
4.82 _base.py(3616):         if ymax is not None:
4.82 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.82 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.82 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.82 _base.py(2102):             if axis is None:
4.82 _base.py(2105):             if data is not None:
4.82 _base.py(2111):             if kwargs is not None:
4.82 _base.py(2123):             return kwargs
4.82 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.82 _base.py(2102):             if axis is None:
4.82 _base.py(2105):             if data is not None:
4.82 _base.py(2107):                 if not axis.have_units():
4.82 _base.py(2108):                     axis.update_units(data)
4.82 _base.py(2111):             if kwargs is not None:
4.82 _base.py(2123):             return kwargs
4.82 _base.py(2127):         return kwargs
4.82 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.82 _base.py(3154):         if limit is not None:
4.82 _base.py(3155):             converted_limit = convert(limit)
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3159):             return converted_limit
4.82 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.82 _base.py(3154):         if limit is not None:
4.82 _base.py(3155):             converted_limit = convert(limit)
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.82 _base.py(3156):             if (isinstance(converted_limit, Real)
4.82 _base.py(3159):             return converted_limit
4.82 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.82 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.82 _base.py(3627):         if bottom is None:
4.82 _base.py(3629):         if top is None:
4.82 _base.py(3632):         if self.get_yscale() == 'log':
4.82 _base.py(3680):         return self.yaxis.get_scale()
4.82 _base.py(3645):         if bottom == top:
4.82 _base.py(3650):         swapped = bottom > top
4.82 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.82 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.82 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.82 _base.py(3653):         if swapped:
4.82 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.83 _base.py(3657):         if auto is not None:
4.83 _base.py(3660):         if emit:
4.83 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3664):                 if other is not self:
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3669):         self.stale = True
4.83 _base.py(3670):         return bottom, top
4.83 _base.py(3708):         g = self.get_shared_y_axes()
4.83 _base.py(4485):         return self._shared_y_axes
4.83 _base.py(3709):         for ax in g.get_siblings(self):
4.83 _base.py(3710):             ax.yaxis._set_scale(value, **kwargs)
4.83 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.83 ticker.py(2665):             nbins = 9
4.83 ticker.py(2666):             steps = [1, 2, 5, 10]
4.83 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.83 ticker.py(1932):         if args:
4.83 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.83 ticker.py(1987):         if 'nbins' in kwargs:
4.83 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.83 ticker.py(1989):             if self._nbins != 'auto':
4.83 ticker.py(1990):                 self._nbins = int(self._nbins)
4.83 ticker.py(1991):         if 'symmetric' in kwargs:
4.83 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.83 ticker.py(1993):         if 'prune' in kwargs:
4.83 ticker.py(1994):             prune = kwargs.pop('prune')
4.83 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.83 ticker.py(1998):             self._prune = prune
4.83 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.83 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.83 ticker.py(2001):         if 'steps' in kwargs:
4.83 ticker.py(2002):             steps = kwargs.pop('steps')
4.83 ticker.py(2003):             if steps is None:
4.83 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.83 ticker.py(1947):         if not np.iterable(steps):
4.83 ticker.py(1950):         steps = np.asarray(steps)
4.83 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.83 ticker.py(1954):         if steps[0] != 1:
4.83 ticker.py(1956):         if steps[-1] != 10:
4.83 ticker.py(1958):         return steps
4.83 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.83 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.83 ticker.py(1966):         return np.hstack(flights)
4.83 ticker.py(2008):         if 'integer' in kwargs:
4.83 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.83 ticker.py(2010):         if kwargs:
4.83 ticker.py(300):         pass
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(516):         if useOffset is None:
4.83 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.83 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.83 ticker.py(519):         self.set_useOffset(useOffset)
4.83 ticker.py(536):         if val in [True, False]:
4.83 ticker.py(537):             self.offset = 0
4.83 ticker.py(538):             self._useOffset = val
4.83 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.83 ticker.py(521):         if useMathText is None:
4.83 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.83 ticker.py(523):         self.set_useMathText(useMathText)
4.83 ticker.py(560):         if val is None:
4.83 ticker.py(563):             self._useMathText = val
4.83 ticker.py(524):         self.orderOfMagnitude = 0
4.83 ticker.py(525):         self.format = ''
4.83 ticker.py(526):         self._scientific = True
4.83 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.83 ticker.py(528):         if useLocale is None:
4.83 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.83 ticker.py(530):         self._useLocale = useLocale
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(300):         pass
4.83 ticker.py(224):         self.axis = axis
4.83 _base.py(3711):             ax._update_transScale()
4.83 _base.py(813):         self.transScale.set(
4.83 _base.py(814):             mtransforms.blended_transform_factory(
4.83 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.83 _base.py(814):             mtransforms.blended_transform_factory(
4.83 _base.py(813):         self.transScale.set(
4.83 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.83 _base.py(817):             try:
4.83 _base.py(818):                 line._transformed_path.invalidate()
4.83 _base.py(819):             except AttributeError:
4.83 _base.py(820):                 pass
4.83 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.83 _base.py(3712):             ax.stale = True
4.83 _base.py(3709):         for ax in g.get_siblings(self):
4.83 _base.py(3713):         self.autoscale_view(scalex=False)
4.83 _base.py(2409):         if tight is not None:
4.83 _base.py(2412):         if self.use_sticky_edges and (
4.83 _base.py(2200):         return self._use_sticky_edges
4.83 _base.py(2413):                 (self._xmargin and scalex and self._autoscaleXon) or
4.83 _base.py(2412):         if self.use_sticky_edges and (
4.83 _base.py(2414):                 (self._ymargin and scaley and self._autoscaleYon)):
4.83 _base.py(2412):         if self.use_sticky_edges and (
4.83 _base.py(2423):             x_stickies, y_stickies = [], []
4.83 _base.py(2425):         def handle_single_axis(scale, autoscaleon, shared_axes, interval,
4.83 _base.py(2493):         handle_single_axis(
4.83 _base.py(2494):             scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',
4.83 _base.py(2495):             'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)
4.83 _base.py(2493):         handle_single_axis(
4.83 _base.py(2428):             if not (scale and autoscaleon):
4.83 _base.py(2429):                 return  # nothing to do...
4.83 _base.py(2496):         handle_single_axis(
4.83 _base.py(2497):             scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',
4.83 _base.py(2498):             'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)
4.83 _base.py(2496):         handle_single_axis(
4.83 _base.py(2428):             if not (scale and autoscaleon):
4.83 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.83 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.83 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.83 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.83 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.83 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.83 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.83 _base.py(2435):             if len(finite_dl):
4.83 _base.py(2438):                 x_finite = [d for d in dl
4.83 _base.py(2438):                 x_finite = [d for d in dl
4.83 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.83 _base.py(2440):                                 (d not in finite_dl))]
4.83 _base.py(2438):                 x_finite = [d for d in dl
4.83 _base.py(2441):                 y_finite = [d for d in dl
4.83 _base.py(2441):                 y_finite = [d for d in dl
4.83 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.83 _base.py(2443):                                 (d not in finite_dl))]
4.83 _base.py(2441):                 y_finite = [d for d in dl
4.83 _base.py(2445):                 dl = finite_dl
4.83 _base.py(2446):                 dl.extend(x_finite)
4.83 _base.py(2447):                 dl.extend(y_finite)
4.83 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.83 _base.py(2451):             vl = None
4.83 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.83 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.83 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.83 _base.py(2461):             locator = axis.get_major_locator()
4.83 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.83 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.83 _base.py(2466):             minpos = getattr(bb, minpos)
4.83 _base.py(2467):             transform = axis.get_transform()
4.83 _base.py(2468):             inverse_trans = transform.inverted()
4.83 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.83 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.83 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.83 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.83 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.83 _base.py(2477):                 delta = (x1t - x0t) * margin
4.83 _base.py(2482):             if do_lower_margin:
4.83 _base.py(2483):                 x0t -= delta
4.83 _base.py(2484):             if do_upper_margin:
4.83 _base.py(2485):                 x1t += delta
4.83 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.83 _base.py(2488):             if not self._tight:
4.83 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.83 ticker.py(2098):         if self._symmetric:
4.83 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.83 ticker.py(2103):             dmin, dmax, expander=1e-12, tiny=1e-13)
4.83 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.83 ticker.py(2105):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.83 ticker.py(2106):             return self._raw_ticks(dmin, dmax)[[0, -1]]
4.83 ticker.py(2023):         if self._nbins == 'auto':
4.83 ticker.py(2030):             nbins = self._nbins
4.83 ticker.py(2032):         scale, offset = scale_range(vmin, vmax, nbins)
4.83 ticker.py(1829):     dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.
4.83 ticker.py(1830):     meanv = (vmax + vmin) / 2
4.83 ticker.py(1831):     if abs(meanv) / dv < threshold:
4.83 ticker.py(1832):         offset = 0
4.83 ticker.py(1835):     scale = 10 ** (math.log10(dv / n) // 1)
4.83 ticker.py(1836):     return scale, offset
4.83 ticker.py(2033):         _vmin = vmin - offset
4.83 ticker.py(2034):         _vmax = vmax - offset
4.83 ticker.py(2035):         raw_step = (_vmax - _vmin) / nbins
4.83 ticker.py(2036):         steps = self._extended_steps * scale
4.83 ticker.py(2037):         if self._integer:
4.83 ticker.py(2042):         istep = np.nonzero(steps >= raw_step)[0][0]
4.83 ticker.py(2045):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.83 ticker.py(2046):             for istep in range(istep, len(steps)):
4.83 ticker.py(2047):                 step = steps[istep]
4.83 ticker.py(2048):                 best_vmin = (_vmin // step) * step
4.83 ticker.py(2049):                 best_vmax = best_vmin + step * nbins
4.83 ticker.py(2050):                 if best_vmax >= _vmax:
4.83 ticker.py(2051):                     break
4.83 ticker.py(2054):         for istep in reversed(range(istep + 1)):
4.83 ticker.py(2055):             step = steps[istep]
4.83 ticker.py(2057):             if (self._integer and
4.83 ticker.py(2060):             best_vmin = (_vmin // step) * step
4.83 ticker.py(2066):             edge = _Edge_integer(step, offset)
4.83 ticker.py(1852):         if step <= 0:
4.83 ticker.py(1854):         self.step = step
4.83 ticker.py(1855):         self._offset = abs(offset)
4.83 ticker.py(2067):             low = edge.le(_vmin - best_vmin)
4.83 ticker.py(1869):         d, m = divmod(x, self.step)
4.83 ticker.py(1870):         if self.closeto(m / self.step, 1):
4.83 ticker.py(1859):         if self._offset > 0:
4.83 ticker.py(1864):             tol = 1e-10
4.83 ticker.py(1865):         return abs(ms - edge) < tol
4.83 ticker.py(1872):         return d
4.83 ticker.py(2068):             high = edge.ge(_vmax - best_vmin)
4.83 ticker.py(1876):         d, m = divmod(x, self.step)
4.83 ticker.py(1877):         if self.closeto(m / self.step, 0):
4.83 ticker.py(1859):         if self._offset > 0:
4.83 ticker.py(1864):             tol = 1e-10
4.83 ticker.py(1865):         return abs(ms - edge) < tol
4.83 ticker.py(1878):             return d
4.83 ticker.py(2069):             ticks = np.arange(low, high + 1) * step + best_vmin
4.83 ticker.py(2071):             nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()
4.83 ticker.py(2072):             if nticks >= self._min_n_ticks:
4.83 ticker.py(2073):                 break
4.83 ticker.py(2074):         return ticks + offset
4.83 _base.py(2490):             set_bound(x0, x1)
4.83 _base.py(3499):         if upper is None and np.iterable(lower):
4.83 _base.py(3502):         old_lower, old_upper = self.get_ybound()
4.83 _base.py(3474):         bottom, top = self.get_ylim()
4.83 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.83 _base.py(3475):         if bottom < top:
4.83 _base.py(3476):             return bottom, top
4.83 _base.py(3504):         if lower is None:
4.83 _base.py(3506):         if upper is None:
4.83 _base.py(3509):         if self.yaxis_inverted():
4.83 _base.py(3462):         return self.yaxis.get_inverted()
4.83 _base.py(3515):             if lower < upper:
4.83 _base.py(3516):                 self.set_ylim(lower, upper, auto=None)
4.83 _base.py(3610):         if top is None and np.iterable(bottom):
4.83 _base.py(3612):         if ymin is not None:
4.83 _base.py(3616):         if ymax is not None:
4.83 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.83 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.83 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.83 _base.py(2102):             if axis is None:
4.83 _base.py(2105):             if data is not None:
4.83 _base.py(2111):             if kwargs is not None:
4.83 _base.py(2123):             return kwargs
4.83 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.83 _base.py(2102):             if axis is None:
4.83 _base.py(2105):             if data is not None:
4.83 _base.py(2107):                 if not axis.have_units():
4.83 _base.py(2108):                     axis.update_units(data)
4.83 _base.py(2111):             if kwargs is not None:
4.83 _base.py(2123):             return kwargs
4.83 _base.py(2127):         return kwargs
4.83 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.83 _base.py(3154):         if limit is not None:
4.83 _base.py(3155):             converted_limit = convert(limit)
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3159):             return converted_limit
4.83 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.83 _base.py(3154):         if limit is not None:
4.83 _base.py(3155):             converted_limit = convert(limit)
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3159):             return converted_limit
4.83 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.83 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.83 _base.py(3627):         if bottom is None:
4.83 _base.py(3629):         if top is None:
4.83 _base.py(3632):         if self.get_yscale() == 'log':
4.83 _base.py(3680):         return self.yaxis.get_scale()
4.83 _base.py(3645):         if bottom == top:
4.83 _base.py(3650):         swapped = bottom > top
4.83 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.83 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.83 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.83 _base.py(3653):         if swapped:
4.83 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.83 _base.py(3657):         if auto is not None:
4.83 _base.py(3660):         if emit:
4.83 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3664):                 if other is not self:
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3669):         self.stale = True
4.83 _base.py(3670):         return bottom, top
4.83 _base.py(3610):         if top is None and np.iterable(bottom):
4.83 _base.py(3612):         if ymin is not None:
4.83 _base.py(3616):         if ymax is not None:
4.83 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.83 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.83 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.83 _base.py(2102):             if axis is None:
4.83 _base.py(2105):             if data is not None:
4.83 _base.py(2111):             if kwargs is not None:
4.83 _base.py(2123):             return kwargs
4.83 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.83 _base.py(2102):             if axis is None:
4.83 _base.py(2105):             if data is not None:
4.83 _base.py(2107):                 if not axis.have_units():
4.83 _base.py(2108):                     axis.update_units(data)
4.83 _base.py(2111):             if kwargs is not None:
4.83 _base.py(2123):             return kwargs
4.83 _base.py(2127):         return kwargs
4.83 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.83 _base.py(3154):         if limit is not None:
4.83 _base.py(3155):             converted_limit = convert(limit)
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3159):             return converted_limit
4.83 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.83 _base.py(3154):         if limit is not None:
4.83 _base.py(3155):             converted_limit = convert(limit)
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.83 _base.py(3156):             if (isinstance(converted_limit, Real)
4.83 _base.py(3159):             return converted_limit
4.83 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.83 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.83 _base.py(3627):         if bottom is None:
4.83 _base.py(3629):         if top is None:
4.83 _base.py(3632):         if self.get_yscale() == 'log':
4.83 _base.py(3680):         return self.yaxis.get_scale()
4.83 _base.py(3645):         if bottom == top:
4.83 _base.py(3650):         swapped = bottom > top
4.83 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.83 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.83 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.83 _base.py(3653):         if swapped:
4.83 _base.py(3654):             bottom, top = top, bottom
4.83 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.83 _base.py(3657):         if auto is not None:
4.83 _base.py(3658):             self._autoscaleYon = bool(auto)
4.83 _base.py(3660):         if emit:
4.83 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3664):                 if other is not self:
4.83 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.83 _base.py(3669):         self.stale = True
4.83 _base.py(3670):         return bottom, top
4.83 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.83 _base.py(460):         martist.Artist.__init__(self)
4.83 _base.py(461):         if isinstance(rect, mtransforms.Bbox):
4.83 _base.py(462):             self._position = rect
4.83 _base.py(465):         if self._position.width < 0 or self._position.height < 0:
4.83 _base.py(467):         self._originalPosition = self._position.frozen()
4.83 _base.py(468):         self.axes = self
4.83 _base.py(469):         self._aspect = 'auto'
4.83 _base.py(470):         self._adjustable = 'box'
4.83 _base.py(471):         self._anchor = 'C'
4.83 _base.py(472):         self._sharex = sharex
4.83 _base.py(473):         self._sharey = sharey
4.83 _base.py(474):         if sharex is not None:
4.83 _base.py(476):         if sharey is not None:
4.83 _base.py(478):         self.set_label(label)
4.83 _base.py(479):         self.set_figure(fig)
4.83 _base.py(612):         martist.Artist.set_figure(self, fig)
4.83 _base.py(614):         self.bbox = mtransforms.TransformedBbox(self._position,
4.83 _base.py(615):                                                 fig.transFigure)
4.83 _base.py(614):         self.bbox = mtransforms.TransformedBbox(self._position,
4.83 _base.py(617):         self.dataLim = mtransforms.Bbox.null()
4.83 _base.py(618):         self.viewLim = mtransforms.Bbox.unit()
4.83 _base.py(619):         self.transScale = mtransforms.TransformWrapper(
4.83 _base.py(620):             mtransforms.IdentityTransform())
4.83 _base.py(619):         self.transScale = mtransforms.TransformWrapper(
4.83 _base.py(622):         self._set_lim_and_transforms()
4.83 _base.py(637):         self.transAxes = mtransforms.BboxTransformTo(self.bbox)
4.83 _base.py(642):         self.transScale = mtransforms.TransformWrapper(
4.83 _base.py(643):             mtransforms.IdentityTransform())
4.83 _base.py(642):         self.transScale = mtransforms.TransformWrapper(
4.83 _base.py(647):         self.transLimits = mtransforms.BboxTransformFrom(
4.83 _base.py(648):             mtransforms.TransformedBbox(self.viewLim, self.transScale))
4.83 _base.py(647):         self.transLimits = mtransforms.BboxTransformFrom(
4.83 _base.py(653):         self.transData = self.transScale + (self.transLimits + self.transAxes)
4.83 _base.py(655):         self._xaxis_transform = mtransforms.blended_transform_factory(
4.83 _base.py(656):             self.transData, self.transAxes)
4.83 _base.py(655):         self._xaxis_transform = mtransforms.blended_transform_factory(
4.83 _base.py(657):         self._yaxis_transform = mtransforms.blended_transform_factory(
4.83 _base.py(658):             self.transAxes, self.transData)
4.83 _base.py(657):         self._yaxis_transform = mtransforms.blended_transform_factory(
4.83 _base.py(481):         self.set_axes_locator(kwargs.get("axes_locator", None))
4.83 _base.py(906):         self._axes_locator = locator
4.83 _base.py(907):         self.stale = True
4.83 _base.py(483):         self.spines = self._gen_axes_spines()
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(958):                            for side in ['left', 'right', 'bottom', 'top'])
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(957):         return OrderedDict((side, mspines.Spine.linear_spine(self, side))
4.83 _base.py(486):         self._init_axis()
4.83 _base.py(596):         self.xaxis = maxis.XAxis(self)
4.83 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.83 ticker.py(2665):             nbins = 9
4.83 ticker.py(2666):             steps = [1, 2, 5, 10]
4.83 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.83 ticker.py(1932):         if args:
4.83 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.83 ticker.py(1987):         if 'nbins' in kwargs:
4.83 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.83 ticker.py(1989):             if self._nbins != 'auto':
4.83 ticker.py(1990):                 self._nbins = int(self._nbins)
4.83 ticker.py(1991):         if 'symmetric' in kwargs:
4.83 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.83 ticker.py(1993):         if 'prune' in kwargs:
4.83 ticker.py(1994):             prune = kwargs.pop('prune')
4.83 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.83 ticker.py(1998):             self._prune = prune
4.83 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.83 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.83 ticker.py(2001):         if 'steps' in kwargs:
4.83 ticker.py(2002):             steps = kwargs.pop('steps')
4.83 ticker.py(2003):             if steps is None:
4.83 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.83 ticker.py(1947):         if not np.iterable(steps):
4.83 ticker.py(1950):         steps = np.asarray(steps)
4.83 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.83 ticker.py(1954):         if steps[0] != 1:
4.83 ticker.py(1956):         if steps[-1] != 10:
4.83 ticker.py(1958):         return steps
4.83 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.83 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.83 ticker.py(1966):         return np.hstack(flights)
4.83 ticker.py(2008):         if 'integer' in kwargs:
4.83 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.83 ticker.py(2010):         if kwargs:
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(516):         if useOffset is None:
4.83 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.83 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.83 ticker.py(519):         self.set_useOffset(useOffset)
4.83 ticker.py(536):         if val in [True, False]:
4.83 ticker.py(537):             self.offset = 0
4.83 ticker.py(538):             self._useOffset = val
4.83 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.83 ticker.py(521):         if useMathText is None:
4.83 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.83 ticker.py(523):         self.set_useMathText(useMathText)
4.83 ticker.py(560):         if val is None:
4.83 ticker.py(563):             self._useMathText = val
4.83 ticker.py(524):         self.orderOfMagnitude = 0
4.83 ticker.py(525):         self.format = ''
4.83 ticker.py(526):         self._scientific = True
4.83 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.83 ticker.py(528):         if useLocale is None:
4.83 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.83 ticker.py(530):         self._useLocale = useLocale
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(300):         pass
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.83 ticker.py(2665):             nbins = 9
4.83 ticker.py(2666):             steps = [1, 2, 5, 10]
4.83 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.83 ticker.py(1932):         if args:
4.83 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.83 ticker.py(1987):         if 'nbins' in kwargs:
4.83 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.83 ticker.py(1989):             if self._nbins != 'auto':
4.83 ticker.py(1990):                 self._nbins = int(self._nbins)
4.83 ticker.py(1991):         if 'symmetric' in kwargs:
4.83 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.83 ticker.py(1993):         if 'prune' in kwargs:
4.83 ticker.py(1994):             prune = kwargs.pop('prune')
4.83 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.83 ticker.py(1998):             self._prune = prune
4.83 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.83 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.83 ticker.py(2001):         if 'steps' in kwargs:
4.83 ticker.py(2002):             steps = kwargs.pop('steps')
4.83 ticker.py(2003):             if steps is None:
4.83 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.83 ticker.py(1947):         if not np.iterable(steps):
4.83 ticker.py(1950):         steps = np.asarray(steps)
4.83 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.83 ticker.py(1954):         if steps[0] != 1:
4.83 ticker.py(1956):         if steps[-1] != 10:
4.83 ticker.py(1958):         return steps
4.83 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.83 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.83 ticker.py(1966):         return np.hstack(flights)
4.83 ticker.py(2008):         if 'integer' in kwargs:
4.83 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.83 ticker.py(2010):         if kwargs:
4.83 ticker.py(300):         pass
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(516):         if useOffset is None:
4.83 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.83 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.83 ticker.py(519):         self.set_useOffset(useOffset)
4.83 ticker.py(536):         if val in [True, False]:
4.83 ticker.py(537):             self.offset = 0
4.83 ticker.py(538):             self._useOffset = val
4.83 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.83 ticker.py(521):         if useMathText is None:
4.83 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.83 ticker.py(523):         self.set_useMathText(useMathText)
4.83 ticker.py(560):         if val is None:
4.83 ticker.py(563):             self._useMathText = val
4.83 ticker.py(524):         self.orderOfMagnitude = 0
4.83 ticker.py(525):         self.format = ''
4.83 ticker.py(526):         self._scientific = True
4.83 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.83 ticker.py(528):         if useLocale is None:
4.83 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.83 ticker.py(530):         self._useLocale = useLocale
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(224):         self.axis = axis
4.83 ticker.py(300):         pass
4.83 ticker.py(224):         self.axis = axis
4.83 _base.py(597):         self.spines['bottom'].register_axis(self.xaxis)
4.83 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.83 ticker.py(2665):             nbins = 9
4.83 ticker.py(2666):             steps = [1, 2, 5, 10]
4.83 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.83 ticker.py(1932):         if args:
4.83 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.83 ticker.py(1987):         if 'nbins' in kwargs:
4.83 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.83 ticker.py(1989):             if self._nbins != 'auto':
4.83 ticker.py(1990):                 self._nbins = int(self._nbins)
4.83 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(598):         self.spines['top'].register_axis(self.xaxis)
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(599):         self.yaxis = maxis.YAxis(self)
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(600):         self.spines['left'].register_axis(self.yaxis)
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(601):         self.spines['right'].register_axis(self.yaxis)
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(602):         self._update_transScale()
4.84 _base.py(813):         self.transScale.set(
4.84 _base.py(814):             mtransforms.blended_transform_factory(
4.84 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.84 _base.py(814):             mtransforms.blended_transform_factory(
4.84 _base.py(813):         self.transScale.set(
4.84 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.84 _base.py(487):         if facecolor is None:
4.84 _base.py(488):             facecolor = rcParams['axes.facecolor']
4.84 _base.py(489):         self._facecolor = facecolor
4.84 _base.py(490):         self._frameon = frameon
4.84 _base.py(491):         self.set_axisbelow(rcParams['axes.axisbelow'])
4.84 _base.py(2731):         self._axisbelow = axisbelow = validate_axisbelow(b)
4.84 _base.py(2732):         if axisbelow is True:
4.84 _base.py(2734):         elif axisbelow is False:
4.84 _base.py(2735):             zorder = 2.5
4.84 _base.py(2740):         for axis in self._get_axis_list():
4.84 _base.py(2501):         return (self.xaxis, self.yaxis)
4.84 _base.py(2741):             axis.set_zorder(zorder)
4.84 _base.py(2740):         for axis in self._get_axis_list():
4.84 _base.py(2741):             axis.set_zorder(zorder)
4.84 _base.py(2740):         for axis in self._get_axis_list():
4.84 _base.py(2742):         self.stale = True
4.84 _base.py(493):         self._rasterization_zorder = None
4.84 _base.py(494):         self._connected = {}  # a dict from events to (id, func)
4.84 _base.py(495):         self.cla()
4.84 _base.py(965):         if hasattr(self, 'patch'):
4.84 _base.py(968):             patch_visible = True
4.84 _base.py(970):         xaxis_visible = self.xaxis.get_visible()
4.84 _base.py(971):         yaxis_visible = self.yaxis.get_visible()
4.84 _base.py(973):         self.xaxis.cla()
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(974):         self.yaxis.cla()
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(976):         for name, spine in self.spines.items():
4.84 _base.py(977):             spine.cla()
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(976):         for name, spine in self.spines.items():
4.84 _base.py(977):             spine.cla()
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.84 ticker.py(1932):         if args:
4.84 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.84 ticker.py(1987):         if 'nbins' in kwargs:
4.84 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.84 ticker.py(1989):             if self._nbins != 'auto':
4.84 ticker.py(1990):                 self._nbins = int(self._nbins)
4.84 ticker.py(1991):         if 'symmetric' in kwargs:
4.84 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.84 ticker.py(1993):         if 'prune' in kwargs:
4.84 ticker.py(1994):             prune = kwargs.pop('prune')
4.84 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.84 ticker.py(1998):             self._prune = prune
4.84 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.84 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.84 ticker.py(2001):         if 'steps' in kwargs:
4.84 ticker.py(2002):             steps = kwargs.pop('steps')
4.84 ticker.py(2003):             if steps is None:
4.84 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.84 ticker.py(1947):         if not np.iterable(steps):
4.84 ticker.py(1950):         steps = np.asarray(steps)
4.84 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.84 ticker.py(1954):         if steps[0] != 1:
4.84 ticker.py(1956):         if steps[-1] != 10:
4.84 ticker.py(1958):         return steps
4.84 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.84 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.84 ticker.py(1966):         return np.hstack(flights)
4.84 ticker.py(2008):         if 'integer' in kwargs:
4.84 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.84 ticker.py(2010):         if kwargs:
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(516):         if useOffset is None:
4.84 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.84 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.84 ticker.py(519):         self.set_useOffset(useOffset)
4.84 ticker.py(536):         if val in [True, False]:
4.84 ticker.py(537):             self.offset = 0
4.84 ticker.py(538):             self._useOffset = val
4.84 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.84 ticker.py(521):         if useMathText is None:
4.84 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.84 ticker.py(523):         self.set_useMathText(useMathText)
4.84 ticker.py(560):         if val is None:
4.84 ticker.py(563):             self._useMathText = val
4.84 ticker.py(524):         self.orderOfMagnitude = 0
4.84 ticker.py(525):         self.format = ''
4.84 ticker.py(526):         self._scientific = True
4.84 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.84 ticker.py(528):         if useLocale is None:
4.84 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.84 ticker.py(530):         self._useLocale = useLocale
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(224):         self.axis = axis
4.84 ticker.py(300):         pass
4.84 ticker.py(224):         self.axis = axis
4.84 _base.py(976):         for name, spine in self.spines.items():
4.84 _base.py(977):             spine.cla()
4.84 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.84 ticker.py(2665):             nbins = 9
4.84 ticker.py(2666):             steps = [1, 2, 5, 10]
4.84 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.85 ticker.py(1932):         if args:
4.85 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.85 ticker.py(1987):         if 'nbins' in kwargs:
4.85 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.85 ticker.py(1989):             if self._nbins != 'auto':
4.85 ticker.py(1990):                 self._nbins = int(self._nbins)
4.85 ticker.py(1991):         if 'symmetric' in kwargs:
4.85 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.85 ticker.py(1993):         if 'prune' in kwargs:
4.85 ticker.py(1994):             prune = kwargs.pop('prune')
4.85 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.85 ticker.py(1998):             self._prune = prune
4.85 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.85 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.85 ticker.py(2001):         if 'steps' in kwargs:
4.85 ticker.py(2002):             steps = kwargs.pop('steps')
4.85 ticker.py(2003):             if steps is None:
4.85 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.85 ticker.py(1947):         if not np.iterable(steps):
4.85 ticker.py(1950):         steps = np.asarray(steps)
4.85 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.85 ticker.py(1954):         if steps[0] != 1:
4.85 ticker.py(1956):         if steps[-1] != 10:
4.85 ticker.py(1958):         return steps
4.85 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.85 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.85 ticker.py(1966):         return np.hstack(flights)
4.85 ticker.py(2008):         if 'integer' in kwargs:
4.85 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.85 ticker.py(2010):         if kwargs:
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(516):         if useOffset is None:
4.85 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.85 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.85 ticker.py(519):         self.set_useOffset(useOffset)
4.85 ticker.py(536):         if val in [True, False]:
4.85 ticker.py(537):             self.offset = 0
4.85 ticker.py(538):             self._useOffset = val
4.85 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.85 ticker.py(521):         if useMathText is None:
4.85 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.85 ticker.py(523):         self.set_useMathText(useMathText)
4.85 ticker.py(560):         if val is None:
4.85 ticker.py(563):             self._useMathText = val
4.85 ticker.py(524):         self.orderOfMagnitude = 0
4.85 ticker.py(525):         self.format = ''
4.85 ticker.py(526):         self._scientific = True
4.85 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.85 ticker.py(528):         if useLocale is None:
4.85 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.85 ticker.py(530):         self._useLocale = useLocale
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 _base.py(976):         for name, spine in self.spines.items():
4.85 _base.py(977):             spine.cla()
4.85 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.85 ticker.py(2665):             nbins = 9
4.85 ticker.py(2666):             steps = [1, 2, 5, 10]
4.85 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.85 ticker.py(1932):         if args:
4.85 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.85 ticker.py(1987):         if 'nbins' in kwargs:
4.85 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.85 ticker.py(1989):             if self._nbins != 'auto':
4.85 ticker.py(1990):                 self._nbins = int(self._nbins)
4.85 ticker.py(1991):         if 'symmetric' in kwargs:
4.85 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.85 ticker.py(1993):         if 'prune' in kwargs:
4.85 ticker.py(1994):             prune = kwargs.pop('prune')
4.85 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.85 ticker.py(1998):             self._prune = prune
4.85 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.85 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.85 ticker.py(2001):         if 'steps' in kwargs:
4.85 ticker.py(2002):             steps = kwargs.pop('steps')
4.85 ticker.py(2003):             if steps is None:
4.85 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.85 ticker.py(1947):         if not np.iterable(steps):
4.85 ticker.py(1950):         steps = np.asarray(steps)
4.85 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.85 ticker.py(1954):         if steps[0] != 1:
4.85 ticker.py(1956):         if steps[-1] != 10:
4.85 ticker.py(1958):         return steps
4.85 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.85 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.85 ticker.py(1966):         return np.hstack(flights)
4.85 ticker.py(2008):         if 'integer' in kwargs:
4.85 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.85 ticker.py(2010):         if kwargs:
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(516):         if useOffset is None:
4.85 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.85 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.85 ticker.py(519):         self.set_useOffset(useOffset)
4.85 ticker.py(536):         if val in [True, False]:
4.85 ticker.py(537):             self.offset = 0
4.85 ticker.py(538):             self._useOffset = val
4.85 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.85 ticker.py(521):         if useMathText is None:
4.85 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.85 ticker.py(523):         self.set_useMathText(useMathText)
4.85 ticker.py(560):         if val is None:
4.85 ticker.py(563):             self._useMathText = val
4.85 ticker.py(524):         self.orderOfMagnitude = 0
4.85 ticker.py(525):         self.format = ''
4.85 ticker.py(526):         self._scientific = True
4.85 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.85 ticker.py(528):         if useLocale is None:
4.85 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.85 ticker.py(530):         self._useLocale = useLocale
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 _base.py(976):         for name, spine in self.spines.items():
4.85 _base.py(979):         self.ignore_existing_data_limits = True
4.85 _base.py(980):         self.callbacks = cbook.CallbackRegistry()
4.85 _base.py(982):         if self._sharex is not None:
4.85 _base.py(992):             self.xaxis._set_scale('linear')
4.85 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.85 ticker.py(2665):             nbins = 9
4.85 ticker.py(2666):             steps = [1, 2, 5, 10]
4.85 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.85 ticker.py(1932):         if args:
4.85 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.85 ticker.py(1987):         if 'nbins' in kwargs:
4.85 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.85 ticker.py(1989):             if self._nbins != 'auto':
4.85 ticker.py(1990):                 self._nbins = int(self._nbins)
4.85 ticker.py(1991):         if 'symmetric' in kwargs:
4.85 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.85 ticker.py(1993):         if 'prune' in kwargs:
4.85 ticker.py(1994):             prune = kwargs.pop('prune')
4.85 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.85 ticker.py(1998):             self._prune = prune
4.85 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.85 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.85 ticker.py(2001):         if 'steps' in kwargs:
4.85 ticker.py(2002):             steps = kwargs.pop('steps')
4.85 ticker.py(2003):             if steps is None:
4.85 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.85 ticker.py(1947):         if not np.iterable(steps):
4.85 ticker.py(1950):         steps = np.asarray(steps)
4.85 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.85 ticker.py(1954):         if steps[0] != 1:
4.85 ticker.py(1956):         if steps[-1] != 10:
4.85 ticker.py(1958):         return steps
4.85 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.85 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.85 ticker.py(1966):         return np.hstack(flights)
4.85 ticker.py(2008):         if 'integer' in kwargs:
4.85 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.85 ticker.py(2010):         if kwargs:
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(516):         if useOffset is None:
4.85 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.85 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.85 ticker.py(519):         self.set_useOffset(useOffset)
4.85 ticker.py(536):         if val in [True, False]:
4.85 ticker.py(537):             self.offset = 0
4.85 ticker.py(538):             self._useOffset = val
4.85 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.85 ticker.py(521):         if useMathText is None:
4.85 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.85 ticker.py(523):         self.set_useMathText(useMathText)
4.85 ticker.py(560):         if val is None:
4.85 ticker.py(563):             self._useMathText = val
4.85 ticker.py(524):         self.orderOfMagnitude = 0
4.85 ticker.py(525):         self.format = ''
4.85 ticker.py(526):         self._scientific = True
4.85 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.85 ticker.py(528):         if useLocale is None:
4.85 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.85 ticker.py(530):         self._useLocale = useLocale
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 _base.py(993):             try:
4.85 _base.py(994):                 self.set_xlim(0, 1)
4.85 _base.py(3229):         if right is None and np.iterable(left):
4.85 _base.py(3231):         if xmin is not None:
4.85 _base.py(3235):         if xmax is not None:
4.85 _base.py(3240):         self._process_unit_info(xdata=(left, right))
4.85 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.85 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.85 _base.py(2102):             if axis is None:
4.85 _base.py(2105):             if data is not None:
4.85 _base.py(2107):                 if not axis.have_units():
4.85 _base.py(2108):                     axis.update_units(data)
4.85 _base.py(2111):             if kwargs is not None:
4.85 _base.py(2123):             return kwargs
4.85 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.85 _base.py(2102):             if axis is None:
4.85 _base.py(2105):             if data is not None:
4.85 _base.py(2111):             if kwargs is not None:
4.85 _base.py(2123):             return kwargs
4.85 _base.py(2127):         return kwargs
4.85 _base.py(3241):         left = self._validate_converted_limits(left, self.convert_xunits)
4.85 _base.py(3154):         if limit is not None:
4.85 _base.py(3155):             converted_limit = convert(limit)
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3159):             return converted_limit
4.85 _base.py(3242):         right = self._validate_converted_limits(right, self.convert_xunits)
4.85 _base.py(3154):         if limit is not None:
4.85 _base.py(3155):             converted_limit = convert(limit)
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3159):             return converted_limit
4.85 _base.py(3244):         old_left, old_right = self.get_xlim()
4.85 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.85 _base.py(3245):         if left is None:
4.85 _base.py(3247):         if right is None:
4.85 _base.py(3250):         if self.get_xscale() == 'log':
4.85 _base.py(3297):         return self.xaxis.get_scale()
4.85 _base.py(3263):         if left == right:
4.85 _base.py(3267):         swapped = left > right
4.85 _base.py(3268):         left, right = self.xaxis.get_major_locator().nonsingular(left, right)
4.85 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.85 _base.py(3269):         left, right = self.xaxis.limit_range_for_scale(left, right)
4.85 _base.py(3270):         if swapped:
4.85 _base.py(3273):         self.viewLim.intervalx = (left, right)
4.85 _base.py(3274):         if auto is not None:
4.85 _base.py(3275):             self._autoscaleXon = bool(auto)
4.85 _base.py(3277):         if emit:
4.85 _base.py(3278):             self.callbacks.process('xlim_changed', self)
4.85 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.85 _base.py(3281):                 if other is not self:
4.85 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.85 _base.py(3286):         self.stale = True
4.85 _base.py(3287):         return left, right
4.85 _base.py(998):         if self._sharey is not None:
4.85 _base.py(1006):             self.yaxis._set_scale('linear')
4.85 ticker.py(2664):         if rcParams['_internal.classic_mode']:
4.85 ticker.py(2665):             nbins = 9
4.85 ticker.py(2666):             steps = [1, 2, 5, 10]
4.85 ticker.py(2670):         MaxNLocator.__init__(self, nbins=nbins, steps=steps)
4.85 ticker.py(1932):         if args:
4.85 ticker.py(1943):         self.set_params(**{**self.default_params, **kwargs})
4.85 ticker.py(1987):         if 'nbins' in kwargs:
4.85 ticker.py(1988):             self._nbins = kwargs.pop('nbins')
4.85 ticker.py(1989):             if self._nbins != 'auto':
4.85 ticker.py(1990):                 self._nbins = int(self._nbins)
4.85 ticker.py(1991):         if 'symmetric' in kwargs:
4.85 ticker.py(1992):             self._symmetric = kwargs.pop('symmetric')
4.85 ticker.py(1993):         if 'prune' in kwargs:
4.85 ticker.py(1994):             prune = kwargs.pop('prune')
4.85 ticker.py(1995):             if prune is not None and prune not in ['upper', 'lower', 'both']:
4.85 ticker.py(1998):             self._prune = prune
4.85 ticker.py(1999):         if 'min_n_ticks' in kwargs:
4.85 ticker.py(2000):             self._min_n_ticks = max(1, kwargs.pop('min_n_ticks'))
4.85 ticker.py(2001):         if 'steps' in kwargs:
4.85 ticker.py(2002):             steps = kwargs.pop('steps')
4.85 ticker.py(2003):             if steps is None:
4.85 ticker.py(2006):                 self._steps = self._validate_steps(steps)
4.85 ticker.py(1947):         if not np.iterable(steps):
4.85 ticker.py(1950):         steps = np.asarray(steps)
4.85 ticker.py(1951):         if np.any(np.diff(steps) <= 0) or steps[-1] > 10 or steps[0] < 1:
4.85 ticker.py(1954):         if steps[0] != 1:
4.85 ticker.py(1956):         if steps[-1] != 10:
4.85 ticker.py(1958):         return steps
4.85 ticker.py(2007):             self._extended_steps = self._staircase(self._steps)
4.85 ticker.py(1965):         flights = (0.1 * steps[:-1], steps, 10 * steps[1])
4.85 ticker.py(1966):         return np.hstack(flights)
4.85 ticker.py(2008):         if 'integer' in kwargs:
4.85 ticker.py(2009):             self._integer = kwargs.pop('integer')
4.85 ticker.py(2010):         if kwargs:
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(516):         if useOffset is None:
4.85 ticker.py(517):             useOffset = rcParams['axes.formatter.useoffset']
4.85 ticker.py(518):         self._offset_threshold = rcParams['axes.formatter.offset_threshold']
4.85 ticker.py(519):         self.set_useOffset(useOffset)
4.85 ticker.py(536):         if val in [True, False]:
4.85 ticker.py(537):             self.offset = 0
4.85 ticker.py(538):             self._useOffset = val
4.85 ticker.py(520):         self._usetex = rcParams['text.usetex']
4.85 ticker.py(521):         if useMathText is None:
4.85 ticker.py(522):             useMathText = rcParams['axes.formatter.use_mathtext']
4.85 ticker.py(523):         self.set_useMathText(useMathText)
4.85 ticker.py(560):         if val is None:
4.85 ticker.py(563):             self._useMathText = val
4.85 ticker.py(524):         self.orderOfMagnitude = 0
4.85 ticker.py(525):         self.format = ''
4.85 ticker.py(526):         self._scientific = True
4.85 ticker.py(527):         self._powerlimits = rcParams['axes.formatter.limits']
4.85 ticker.py(528):         if useLocale is None:
4.85 ticker.py(529):             useLocale = rcParams['axes.formatter.use_locale']
4.85 ticker.py(530):         self._useLocale = useLocale
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(224):         self.axis = axis
4.85 ticker.py(300):         pass
4.85 ticker.py(224):         self.axis = axis
4.85 _base.py(1007):             try:
4.85 _base.py(1008):                 self.set_ylim(0, 1)
4.85 _base.py(3610):         if top is None and np.iterable(bottom):
4.85 _base.py(3612):         if ymin is not None:
4.85 _base.py(3616):         if ymax is not None:
4.85 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.85 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.85 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.85 _base.py(2102):             if axis is None:
4.85 _base.py(2105):             if data is not None:
4.85 _base.py(2111):             if kwargs is not None:
4.85 _base.py(2123):             return kwargs
4.85 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.85 _base.py(2102):             if axis is None:
4.85 _base.py(2105):             if data is not None:
4.85 _base.py(2107):                 if not axis.have_units():
4.85 _base.py(2108):                     axis.update_units(data)
4.85 _base.py(2111):             if kwargs is not None:
4.85 _base.py(2123):             return kwargs
4.85 _base.py(2127):         return kwargs
4.85 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.85 _base.py(3154):         if limit is not None:
4.85 _base.py(3155):             converted_limit = convert(limit)
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3159):             return converted_limit
4.85 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.85 _base.py(3154):         if limit is not None:
4.85 _base.py(3155):             converted_limit = convert(limit)
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.85 _base.py(3156):             if (isinstance(converted_limit, Real)
4.85 _base.py(3159):             return converted_limit
4.85 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.85 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.85 _base.py(3627):         if bottom is None:
4.85 _base.py(3629):         if top is None:
4.85 _base.py(3632):         if self.get_yscale() == 'log':
4.85 _base.py(3680):         return self.yaxis.get_scale()
4.85 _base.py(3645):         if bottom == top:
4.85 _base.py(3650):         swapped = bottom > top
4.85 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.85 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.85 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.85 _base.py(3653):         if swapped:
4.85 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.85 _base.py(3657):         if auto is not None:
4.85 _base.py(3658):             self._autoscaleYon = bool(auto)
4.85 _base.py(3660):         if emit:
4.85 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.85 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.85 _base.py(3664):                 if other is not self:
4.85 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.85 _base.py(3669):         self.stale = True
4.85 _base.py(3670):         return bottom, top
4.85 _base.py(1012):         if rcParams['xtick.minor.visible']:
4.85 _base.py(1015):         if rcParams['ytick.minor.visible']:
4.85 _base.py(1018):         if self._sharex is None:
4.85 _base.py(1019):             self._autoscaleXon = True
4.85 _base.py(1020):         if self._sharey is None:
4.85 _base.py(1021):             self._autoscaleYon = True
4.85 _base.py(1022):         self._xmargin = rcParams['axes.xmargin']
4.85 _base.py(1023):         self._ymargin = rcParams['axes.ymargin']
4.85 _base.py(1024):         self._tight = None
4.85 _base.py(1025):         self._use_sticky_edges = True
4.85 _base.py(1026):         self._update_transScale()  # needed?
4.85 _base.py(813):         self.transScale.set(
4.85 _base.py(814):             mtransforms.blended_transform_factory(
4.85 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.85 _base.py(814):             mtransforms.blended_transform_factory(
4.85 _base.py(813):         self.transScale.set(
4.85 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.85 _base.py(1028):         self._get_lines = _process_plot_var_args(self)
4.85 _base.py(131):         self.axes = axes
4.85 _base.py(132):         self.command = command
4.85 _base.py(133):         self.set_prop_cycle()
4.85 _base.py(145):         if not (args or kwargs) or (len(args) == 1 and args[0] is None):
4.85 _base.py(146):             prop_cycler = rcParams['axes.prop_cycle']
4.85 _base.py(150):         self.prop_cycler = itertools.cycle(prop_cycler)
4.85 _base.py(152):         self._prop_keys = prop_cycler.keys
4.85 _base.py(1029):         self._get_patches_for_fill = _process_plot_var_args(self, 'fill')
4.85 _base.py(131):         self.axes = axes
4.85 _base.py(132):         self.command = command
4.85 _base.py(133):         self.set_prop_cycle()
4.85 _base.py(145):         if not (args or kwargs) or (len(args) == 1 and args[0] is None):
4.85 _base.py(146):             prop_cycler = rcParams['axes.prop_cycle']
4.85 _base.py(150):         self.prop_cycler = itertools.cycle(prop_cycler)
4.85 _base.py(152):         self._prop_keys = prop_cycler.keys
4.85 _base.py(1031):         self._gridOn = rcParams['axes.grid']
4.85 _base.py(1032):         self.lines = []
4.85 _base.py(1033):         self.patches = []
4.85 _base.py(1034):         self.texts = []
4.85 _base.py(1035):         self.tables = []
4.85 _base.py(1036):         self.artists = []
4.85 _base.py(1037):         self.images = []
4.85 _base.py(1038):         self._mouseover_set = _OrderedSet()
4.85 _base.py(1039):         self.child_axes = []
4.85 _base.py(1040):         self._current_image = None  # strictly for pyplot via _sci, _gci
4.85 _base.py(1041):         self.legend_ = None
4.85 _base.py(1042):         self.collections = []  # collection.Collection instances
4.85 _base.py(1043):         self.containers = []
4.85 _base.py(1045):         self.grid(False)  # Disable grid on init to use rcParameter
4.85 _base.py(2781):         if len(kwargs):
4.85 _base.py(2783):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.85 _base.py(2784):         if axis in ['x', 'both']:
4.85 _base.py(2785):             self.xaxis.grid(b, which=which, **kwargs)
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(678):         elif which == 'tick2':
4.85 _base.py(680):             return self.spines['top'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.85 _base.py(707):                                               self.figure.dpi_scale_trans),
4.85 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(708):                 "top", labels_align)
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(678):         elif which == 'tick2':
4.85 _base.py(680):             return self.spines['top'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.85 _base.py(733):                                               self.figure.dpi_scale_trans),
4.85 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(734):                 "bottom", labels_align)
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(678):         elif which == 'tick2':
4.85 _base.py(680):             return self.spines['top'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.85 _base.py(707):                                               self.figure.dpi_scale_trans),
4.85 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(708):                 "top", labels_align)
4.85 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.85 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(675):         elif which == 'tick1':
4.85 _base.py(678):         elif which == 'tick2':
4.85 _base.py(680):             return self.spines['top'].get_spine_transform()
4.85 _base.py(673):         if which == 'grid':
4.85 _base.py(674):             return self._xaxis_transform
4.85 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.85 _base.py(733):                                               self.figure.dpi_scale_trans),
4.85 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(734):                 "bottom", labels_align)
4.85 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.85 _base.py(2786):         if axis in ['y', 'both']:
4.85 _base.py(2787):             self.yaxis.grid(b, which=which, **kwargs)
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(751):         elif which == 'tick1':
4.85 _base.py(753):             return self.spines['left'].get_spine_transform()
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(750):             return self._yaxis_transform
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(750):             return self._yaxis_transform
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(751):         elif which == 'tick1':
4.85 _base.py(754):         elif which == 'tick2':
4.85 _base.py(756):             return self.spines['right'].get_spine_transform()
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(750):             return self._yaxis_transform
4.85 _base.py(749):         if which == 'grid':
4.85 _base.py(750):             return self._yaxis_transform
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(753):             return self.spines['left'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(783):                                               self.figure.dpi_scale_trans),
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(784):                 labels_align, "right")
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(754):         elif which == 'tick2':
4.86 _base.py(756):             return self.spines['right'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(809):                                               self.figure.dpi_scale_trans),
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(810):                 labels_align, "left")
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(753):             return self.spines['left'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(754):         elif which == 'tick2':
4.86 _base.py(756):             return self.spines['right'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(753):             return self.spines['left'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(783):                                               self.figure.dpi_scale_trans),
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(784):                 labels_align, "right")
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(754):         elif which == 'tick2':
4.86 _base.py(756):             return self.spines['right'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(809):                                               self.figure.dpi_scale_trans),
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(810):                 labels_align, "left")
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(1046):         self.grid(self._gridOn, which=rcParams['axes.grid.which'],
4.86 _base.py(1047):                   axis=rcParams['axes.grid.axis'])
4.86 _base.py(1046):         self.grid(self._gridOn, which=rcParams['axes.grid.which'],
4.86 _base.py(2781):         if len(kwargs):
4.86 _base.py(2783):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.86 _base.py(2784):         if axis in ['x', 'both']:
4.86 _base.py(2785):             self.xaxis.grid(b, which=which, **kwargs)
4.86 _base.py(2786):         if axis in ['y', 'both']:
4.86 _base.py(2787):             self.yaxis.grid(b, which=which, **kwargs)
4.86 _base.py(1048):         props = font_manager.FontProperties(
4.86 _base.py(1049):             size=rcParams['axes.titlesize'],
4.86 _base.py(1050):             weight=rcParams['axes.titleweight'])
4.86 _base.py(1048):         props = font_manager.FontProperties(
4.86 _base.py(1052):         self.title = mtext.Text(
4.86 _base.py(1053):             x=0.5, y=1.0, text='',
4.86 _base.py(1054):             fontproperties=props,
4.86 _base.py(1055):             verticalalignment='baseline',
4.86 _base.py(1056):             horizontalalignment='center',
4.86 _base.py(1052):         self.title = mtext.Text(
4.86 _base.py(1058):         self._left_title = mtext.Text(
4.86 _base.py(1059):             x=0.0, y=1.0, text='',
4.86 _base.py(1060):             fontproperties=props.copy(),
4.86 _base.py(1061):             verticalalignment='baseline',
4.86 _base.py(1062):             horizontalalignment='left', )
4.86 _base.py(1058):         self._left_title = mtext.Text(
4.86 _base.py(1063):         self._right_title = mtext.Text(
4.86 _base.py(1064):             x=1.0, y=1.0, text='',
4.86 _base.py(1065):             fontproperties=props.copy(),
4.86 _base.py(1066):             verticalalignment='baseline',
4.86 _base.py(1067):             horizontalalignment='right',
4.86 _base.py(1063):         self._right_title = mtext.Text(
4.86 _base.py(1069):         title_offset_points = rcParams['axes.titlepad']
4.86 _base.py(1072):         self._set_title_offset_trans(title_offset_points)
4.86 _base.py(1138):         self.titleOffsetTrans = mtransforms.ScaledTranslation(
4.86 _base.py(1139):                 0.0, title_offset_points / 72,
4.86 _base.py(1140):                 self.figure.dpi_scale_trans)
4.86 _base.py(1138):         self.titleOffsetTrans = mtransforms.ScaledTranslation(
4.86 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.86 _base.py(1143):             _title.set_clip_box(None)
4.86 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.86 _base.py(1143):             _title.set_clip_box(None)
4.86 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1142):             _title.set_transform(self.transAxes + self.titleOffsetTrans)
4.86 _base.py(1143):             _title.set_clip_box(None)
4.86 _base.py(1141):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1074):         self._autotitlepos = None
4.86 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1077):             self._set_artist_props(_title)
4.86 _base.py(917):         a.set_figure(self.figure)
4.86 _base.py(918):         if not a.is_transform_set():
4.86 _base.py(921):         a.axes = self
4.86 _base.py(922):         if a.mouseover:
4.86 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1077):             self._set_artist_props(_title)
4.86 _base.py(917):         a.set_figure(self.figure)
4.86 _base.py(918):         if not a.is_transform_set():
4.86 _base.py(921):         a.axes = self
4.86 _base.py(922):         if a.mouseover:
4.86 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1077):             self._set_artist_props(_title)
4.86 _base.py(917):         a.set_figure(self.figure)
4.86 _base.py(918):         if not a.is_transform_set():
4.86 _base.py(921):         a.axes = self
4.86 _base.py(922):         if a.mouseover:
4.86 _base.py(1076):         for _title in (self.title, self._left_title, self._right_title):
4.86 _base.py(1082):         self.patch = self._gen_axes_patch()
4.86 _base.py(940):         return mpatches.Rectangle((0.0, 0.0), 1.0, 1.0)
4.86 _base.py(1083):         self.patch.set_figure(self.figure)
4.86 _base.py(1084):         self.patch.set_facecolor(self._facecolor)
4.86 _base.py(1085):         self.patch.set_edgecolor('None')
4.86 _base.py(1086):         self.patch.set_linewidth(0)
4.86 _base.py(1087):         self.patch.set_transform(self.transAxes)
4.86 _base.py(1089):         self.set_axis_on()
4.86 _base.py(3033):         self.axison = True
4.86 _base.py(3034):         self.stale = True
4.86 _base.py(1091):         self.xaxis.set_clip_path(self.patch)
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(675):         elif which == 'tick1':
4.86 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(674):             return self._xaxis_transform
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(675):         elif which == 'tick1':
4.86 _base.py(678):         elif which == 'tick2':
4.86 _base.py(680):             return self.spines['top'].get_spine_transform()
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(674):             return self._xaxis_transform
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(674):             return self._xaxis_transform
4.86 _base.py(704):         labels_align = rcParams["xtick.alignment"]
4.86 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(675):         elif which == 'tick1':
4.86 _base.py(677):             return self.spines['bottom'].get_spine_transform()
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(674):             return self._xaxis_transform
4.86 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.86 _base.py(707):                                               self.figure.dpi_scale_trans),
4.86 _base.py(706):                 mtransforms.ScaledTranslation(0, -1 * pad_points / 72,
4.86 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.86 _base.py(708):                 "top", labels_align)
4.86 _base.py(705):         return (self.get_xaxis_transform(which='tick1') +
4.86 _base.py(730):         labels_align = rcParams["xtick.alignment"]
4.86 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(675):         elif which == 'tick1':
4.86 _base.py(678):         elif which == 'tick2':
4.86 _base.py(680):             return self.spines['top'].get_spine_transform()
4.86 _base.py(673):         if which == 'grid':
4.86 _base.py(674):             return self._xaxis_transform
4.86 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.86 _base.py(733):                                               self.figure.dpi_scale_trans),
4.86 _base.py(732):                 mtransforms.ScaledTranslation(0, pad_points / 72,
4.86 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.86 _base.py(734):                 "bottom", labels_align)
4.86 _base.py(731):         return (self.get_xaxis_transform(which='tick2') +
4.86 _base.py(1092):         self.yaxis.set_clip_path(self.patch)
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(753):             return self.spines['left'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(754):         elif which == 'tick2':
4.86 _base.py(756):             return self.spines['right'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(780):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(753):             return self.spines['left'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(783):                                               self.figure.dpi_scale_trans),
4.86 _base.py(782):                 mtransforms.ScaledTranslation(-1 * pad_points / 72, 0,
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(784):                 labels_align, "right")
4.86 _base.py(781):         return (self.get_yaxis_transform(which='tick1') +
4.86 _base.py(806):         labels_align = rcParams["ytick.alignment"]
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(751):         elif which == 'tick1':
4.86 _base.py(754):         elif which == 'tick2':
4.86 _base.py(756):             return self.spines['right'].get_spine_transform()
4.86 _base.py(749):         if which == 'grid':
4.86 _base.py(750):             return self._yaxis_transform
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(809):                                               self.figure.dpi_scale_trans),
4.86 _base.py(808):                 mtransforms.ScaledTranslation(pad_points / 72, 0,
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(810):                 labels_align, "left")
4.86 _base.py(807):         return (self.get_yaxis_transform(which='tick2') +
4.86 _base.py(1094):         self._shared_x_axes.clean()
4.86 _base.py(1095):         self._shared_y_axes.clean()
4.86 _base.py(1096):         if self._sharex:
4.86 _base.py(1100):         if self._sharey:
4.86 _base.py(1104):         self.stale = True
4.86 _base.py(498):         self.fmt_xdata = None
4.86 _base.py(499):         self.fmt_ydata = None
4.86 _base.py(501):         self.set_navigate(True)
4.86 _base.py(3925):         self._navigate = b
4.86 _base.py(502):         self.set_navigate_mode(None)
4.86 _base.py(3941):         self._navigate_mode = b
4.86 _base.py(504):         if xscale:
4.86 _base.py(506):         if yscale:
4.86 _base.py(509):         self.update(kwargs)
4.86 _base.py(511):         if self.xaxis is not None:
4.86 _base.py(512):             self._xcid = self.xaxis.callbacks.connect(
4.86 _base.py(513):                 'units finalize', lambda: self._on_units_changed(scalex=True))
4.86 _base.py(512):             self._xcid = self.xaxis.callbacks.connect(
4.86 _base.py(515):         if self.yaxis is not None:
4.86 _base.py(516):             self._ycid = self.yaxis.callbacks.connect(
4.86 _base.py(517):                 'units finalize', lambda: self._on_units_changed(scaley=True))
4.86 _base.py(516):             self._ycid = self.yaxis.callbacks.connect(
4.86 _base.py(519):         self.tick_params(
4.86 _base.py(520):             top=rcParams['xtick.top'] and rcParams['xtick.minor.top'],
4.86 _base.py(521):             bottom=rcParams['xtick.bottom'] and rcParams['xtick.minor.bottom'],
4.86 _base.py(522):             labeltop=(rcParams['xtick.labeltop'] and
4.86 _base.py(524):             labelbottom=(rcParams['xtick.labelbottom'] and
4.86 _base.py(525):                          rcParams['xtick.minor.bottom']),
4.86 _base.py(526):             left=rcParams['ytick.left'] and rcParams['ytick.minor.left'],
4.86 _base.py(527):             right=rcParams['ytick.right'] and rcParams['ytick.minor.right'],
4.86 _base.py(528):             labelleft=(rcParams['ytick.labelleft'] and
4.86 _base.py(529):                        rcParams['ytick.minor.left']),
4.86 _base.py(530):             labelright=(rcParams['ytick.labelright'] and
4.86 _base.py(532):             which='minor')
4.86 _base.py(519):         self.tick_params(
4.86 _base.py(3002):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.86 _base.py(3003):         if axis in ['x', 'both']:
4.86 _base.py(3004):             xkw = dict(kwargs)
4.86 _base.py(3005):             xkw.pop('left', None)
4.86 _base.py(3006):             xkw.pop('right', None)
4.86 _base.py(3007):             xkw.pop('labelleft', None)
4.86 _base.py(3008):             xkw.pop('labelright', None)
4.86 _base.py(3009):             self.xaxis.set_tick_params(**xkw)
4.86 _base.py(3010):         if axis in ['y', 'both']:
4.86 _base.py(3011):             ykw = dict(kwargs)
4.86 _base.py(3012):             ykw.pop('top', None)
4.86 _base.py(3013):             ykw.pop('bottom', None)
4.86 _base.py(3014):             ykw.pop('labeltop', None)
4.86 _base.py(3015):             ykw.pop('labelbottom', None)
4.86 _base.py(3016):             self.yaxis.set_tick_params(**ykw)
4.86 _base.py(534):         self.tick_params(
4.86 _base.py(535):             top=rcParams['xtick.top'] and rcParams['xtick.major.top'],
4.86 _base.py(536):             bottom=rcParams['xtick.bottom'] and rcParams['xtick.major.bottom'],
4.86 _base.py(537):             labeltop=(rcParams['xtick.labeltop'] and
4.86 _base.py(539):             labelbottom=(rcParams['xtick.labelbottom'] and
4.86 _base.py(540):                          rcParams['xtick.major.bottom']),
4.86 _base.py(541):             left=rcParams['ytick.left'] and rcParams['ytick.major.left'],
4.86 _base.py(542):             right=rcParams['ytick.right'] and rcParams['ytick.major.right'],
4.86 _base.py(543):             labelleft=(rcParams['ytick.labelleft'] and
4.86 _base.py(544):                        rcParams['ytick.major.left']),
4.86 _base.py(545):             labelright=(rcParams['ytick.labelright'] and
4.86 _base.py(547):             which='major')
4.86 _base.py(534):         self.tick_params(
4.86 _base.py(3002):         cbook._check_in_list(['x', 'y', 'both'], axis=axis)
4.86 _base.py(3003):         if axis in ['x', 'both']:
4.86 _base.py(3004):             xkw = dict(kwargs)
4.86 _base.py(3005):             xkw.pop('left', None)
4.86 _base.py(3006):             xkw.pop('right', None)
4.86 _base.py(3007):             xkw.pop('labelleft', None)
4.86 _base.py(3008):             xkw.pop('labelright', None)
4.86 _base.py(3009):             self.xaxis.set_tick_params(**xkw)
4.86 _base.py(3010):         if axis in ['y', 'both']:
4.86 _base.py(3011):             ykw = dict(kwargs)
4.86 _base.py(3012):             ykw.pop('top', None)
4.86 _base.py(3013):             ykw.pop('bottom', None)
4.86 _base.py(3014):             ykw.pop('labeltop', None)
4.86 _base.py(3015):             ykw.pop('labelbottom', None)
4.87 _base.py(3016):             self.yaxis.set_tick_params(**ykw)
4.87 _base.py(549):         self._layoutbox = None
4.87 _base.py(550):         self._poslayoutbox = None
4.87 _base.py(156):         if self.axes.xaxis is not None and self.axes.yaxis is not None:
4.87 _base.py(157):             xunits = kwargs.pop('xunits', self.axes.xaxis.units)
4.87 _base.py(158):             if self.axes.name == 'polar':
4.87 _base.py(160):             if xunits != self.axes.xaxis.units:
4.87 _base.py(162):             yunits = kwargs.pop('yunits', self.axes.yaxis.units)
4.87 _base.py(163):             if self.axes.name == 'polar':
4.87 _base.py(165):             if yunits != self.axes.yaxis.units:
4.87 _base.py(168):         for pos_only in "xy":
4.87 _base.py(169):             if pos_only in kwargs:
4.87 _base.py(168):         for pos_only in "xy":
4.87 _base.py(169):             if pos_only in kwargs:
4.87 _base.py(168):         for pos_only in "xy":
4.87 _base.py(173):         if not args:
4.87 _base.py(177):         data = kwargs.pop("data", None)
4.87 _base.py(178):         if data is not None:
4.87 _base.py(220):         while args:
4.87 _base.py(221):             this, args = args[:2], args[2:]
4.87 _base.py(222):             if args and isinstance(args[0], str):
4.87 _base.py(225):             yield from self._plot_args(this, kwargs)
4.87 _base.py(364):         ret = []
4.87 _base.py(365):         if len(tup) > 1 and isinstance(tup[-1], str):
4.87 _base.py(368):         elif len(tup) == 3:
4.87 _base.py(371):             linestyle, marker, color = None, None, None
4.87 _base.py(376):         if any(v is None for v in tup):
4.87 _base.py(376):         if any(v is None for v in tup):
4.87 _base.py(376):         if any(v is None for v in tup):
4.87 _base.py(376):         if any(v is None for v in tup):
4.87 _base.py(379):         kw = {}
4.87 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.87 _base.py(381):                         (linestyle, marker, color)):
4.87 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.87 _base.py(382):             if v is not None:
4.87 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.87 _base.py(382):             if v is not None:
4.87 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.87 _base.py(382):             if v is not None:
4.87 _base.py(380):         for k, v in zip(('linestyle', 'marker', 'color'),
4.87 _base.py(385):         if len(tup) == 2:
4.87 _base.py(386):             x = _check_1d(tup[0])
4.87 _base.py(387):             y = _check_1d(tup[-1])
4.87 _base.py(391):         x, y = self._xy_from_xy(x, y)
4.87 _base.py(242):         if self.axes.xaxis is not None and self.axes.yaxis is not None:
4.87 _base.py(243):             bx = self.axes.xaxis.update_units(x)
4.87 _base.py(244):             by = self.axes.yaxis.update_units(y)
4.87 _base.py(246):             if self.command != 'plot':
4.87 _base.py(266):         x = _check_1d(x)
4.87 _base.py(267):         y = _check_1d(y)
4.87 _base.py(268):         if x.shape[0] != y.shape[0]:
4.87 _base.py(271):         if x.ndim > 2 or y.ndim > 2:
4.87 _base.py(275):         if x.ndim == 1:
4.87 _base.py(276):             x = x[:, np.newaxis]
4.87 _base.py(277):         if y.ndim == 1:
4.87 _base.py(278):             y = y[:, np.newaxis]
4.87 _base.py(279):         return x, y
4.87 _base.py(393):         if self.command == 'plot':
4.87 _base.py(394):             func = self._makeline
4.87 _base.py(399):         ncx, ncy = x.shape[1], y.shape[1]
4.87 _base.py(400):         if ncx > 1 and ncy > 1 and ncx != ncy:
4.87 _base.py(404):         for j in range(max(ncx, ncy)):
4.87 _base.py(405):             seg = func(x[:, j % ncx], y[:, j % ncy], kw, kwargs)
4.87 _base.py(309):         kw = {**kw, **kwargs}  # Don't modify the original kw.
4.87 _base.py(310):         default_dict = self._getdefaults(set(), kw)
4.87 _base.py(288):         prop_keys = self._prop_keys - ignore
4.87 _base.py(289):         if any(kw.get(k, None) is None for k in prop_keys):
4.87 _base.py(289):         if any(kw.get(k, None) is None for k in prop_keys):
4.87 _base.py(292):             default_dict = next(self.prop_cycler).copy()
4.87 _base.py(293):             for p in ignore:
4.87 _base.py(297):         return default_dict
4.87 _base.py(311):         self._setdefaults(default_dict, kw)
4.87 _base.py(304):         for k in defaults:
4.87 _base.py(305):             if kw.get(k, None) is None:
4.87 _base.py(306):                 kw[k] = defaults[k]
4.87 _base.py(304):         for k in defaults:
4.87 _base.py(312):         seg = mlines.Line2D(x, y, **kw)
4.87 _base.py(313):         return seg
4.87 _base.py(406):             ret.append(seg)
4.87 _base.py(404):         for j in range(max(ncx, ncy)):
4.87 _base.py(407):         return ret
4.87 _base.py(220):         while args:
4.87 _base.py(1898):         self._set_artist_props(line)
4.87 _base.py(917):         a.set_figure(self.figure)
4.87 _base.py(918):         if not a.is_transform_set():
4.87 _base.py(919):             a.set_transform(self.transData)
4.87 _base.py(921):         a.axes = self
4.87 _base.py(922):         if a.mouseover:
4.87 _base.py(1899):         if line.get_clip_path() is None:
4.87 _base.py(1900):             line.set_clip_path(self.patch)
4.87 _base.py(1902):         self._update_line_limits(line)
4.87 _base.py(1924):         path = line.get_path()
4.87 _base.py(1925):         if path.vertices.size == 0:
4.87 _base.py(1928):         line_trans = line.get_transform()
4.87 _base.py(1930):         if line_trans == self.transData:
4.87 _base.py(1931):             data_path = path
4.87 _base.py(1955):         if data_path.vertices.size > 0:
4.87 _base.py(1956):             updatex, updatey = line_trans.contains_branch_seperately(
4.87 _base.py(1957):                 self.transData)
4.87 _base.py(1956):             updatex, updatey = line_trans.contains_branch_seperately(
4.87 _base.py(1958):             self.dataLim.update_from_path(data_path,
4.87 _base.py(1959):                                           self.ignore_existing_data_limits,
4.87 _base.py(1960):                                           updatex=updatex,
4.87 _base.py(1961):                                           updatey=updatey)
4.87 _base.py(1958):             self.dataLim.update_from_path(data_path,
4.87 _base.py(1962):             self.ignore_existing_data_limits = False
4.87 _base.py(1903):         if not line.get_label():
4.87 _base.py(1904):             line.set_label('_line%d' % len(self.lines))
4.87 _base.py(1905):         self.lines.append(line)
4.87 _base.py(1906):         line._remove_method = self.lines.remove
4.87 _base.py(1907):         self.stale = True
4.87 _base.py(1908):         return line
4.87 _base.py(2409):         if tight is not None:
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2200):         return self._use_sticky_edges
4.87 _base.py(2413):                 (self._xmargin and scalex and self._autoscaleXon) or
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2414):                 (self._ymargin and scaley and self._autoscaleYon)):
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2423):             x_stickies, y_stickies = [], []
4.87 _base.py(2425):         def handle_single_axis(scale, autoscaleon, shared_axes, interval,
4.87 _base.py(2493):         handle_single_axis(
4.87 _base.py(2494):             scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',
4.87 _base.py(2495):             'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)
4.87 _base.py(2493):         handle_single_axis(
4.87 _base.py(2428):             if not (scale and autoscaleon):
4.87 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2435):             if len(finite_dl):
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.87 _base.py(2440):                                 (d not in finite_dl))]
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.87 _base.py(2443):                                 (d not in finite_dl))]
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2445):                 dl = finite_dl
4.87 _base.py(2446):                 dl.extend(x_finite)
4.87 _base.py(2447):                 dl.extend(y_finite)
4.87 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.87 _base.py(2451):             vl = None
4.87 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.87 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.87 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.87 _base.py(2461):             locator = axis.get_major_locator()
4.87 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.87 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.87 _base.py(2466):             minpos = getattr(bb, minpos)
4.87 _base.py(2467):             transform = axis.get_transform()
4.87 _base.py(2468):             inverse_trans = transform.inverted()
4.87 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.87 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.87 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.87 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.87 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.87 _base.py(2477):                 delta = (x1t - x0t) * margin
4.87 _base.py(2482):             if do_lower_margin:
4.87 _base.py(2483):                 x0t -= delta
4.87 _base.py(2484):             if do_upper_margin:
4.87 _base.py(2485):                 x1t += delta
4.87 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.87 _base.py(2488):             if not self._tight:
4.87 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.87 ticker.py(2098):         if self._symmetric:
4.87 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.87 ticker.py(2103):             dmin, dmax, expander=1e-12, tiny=1e-13)
4.87 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.87 ticker.py(2105):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.87 ticker.py(2106):             return self._raw_ticks(dmin, dmax)[[0, -1]]
4.87 ticker.py(2023):         if self._nbins == 'auto':
4.87 ticker.py(2030):             nbins = self._nbins
4.87 ticker.py(2032):         scale, offset = scale_range(vmin, vmax, nbins)
4.87 ticker.py(1829):     dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.
4.87 ticker.py(1830):     meanv = (vmax + vmin) / 2
4.87 ticker.py(1831):     if abs(meanv) / dv < threshold:
4.87 ticker.py(1832):         offset = 0
4.87 ticker.py(1835):     scale = 10 ** (math.log10(dv / n) // 1)
4.87 ticker.py(1836):     return scale, offset
4.87 ticker.py(2033):         _vmin = vmin - offset
4.87 ticker.py(2034):         _vmax = vmax - offset
4.87 ticker.py(2035):         raw_step = (_vmax - _vmin) / nbins
4.87 ticker.py(2036):         steps = self._extended_steps * scale
4.87 ticker.py(2037):         if self._integer:
4.87 ticker.py(2042):         istep = np.nonzero(steps >= raw_step)[0][0]
4.87 ticker.py(2045):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.87 ticker.py(2046):             for istep in range(istep, len(steps)):
4.87 ticker.py(2047):                 step = steps[istep]
4.87 ticker.py(2048):                 best_vmin = (_vmin // step) * step
4.87 ticker.py(2049):                 best_vmax = best_vmin + step * nbins
4.87 ticker.py(2050):                 if best_vmax >= _vmax:
4.87 ticker.py(2051):                     break
4.87 ticker.py(2054):         for istep in reversed(range(istep + 1)):
4.87 ticker.py(2055):             step = steps[istep]
4.87 ticker.py(2057):             if (self._integer and
4.87 ticker.py(2060):             best_vmin = (_vmin // step) * step
4.87 ticker.py(2066):             edge = _Edge_integer(step, offset)
4.87 ticker.py(1852):         if step <= 0:
4.87 ticker.py(1854):         self.step = step
4.87 ticker.py(1855):         self._offset = abs(offset)
4.87 ticker.py(2067):             low = edge.le(_vmin - best_vmin)
4.87 ticker.py(1869):         d, m = divmod(x, self.step)
4.87 ticker.py(1870):         if self.closeto(m / self.step, 1):
4.87 ticker.py(1859):         if self._offset > 0:
4.87 ticker.py(1864):             tol = 1e-10
4.87 ticker.py(1865):         return abs(ms - edge) < tol
4.87 ticker.py(1872):         return d
4.87 ticker.py(2068):             high = edge.ge(_vmax - best_vmin)
4.87 ticker.py(1876):         d, m = divmod(x, self.step)
4.87 ticker.py(1877):         if self.closeto(m / self.step, 0):
4.87 ticker.py(1859):         if self._offset > 0:
4.87 ticker.py(1864):             tol = 1e-10
4.87 ticker.py(1865):         return abs(ms - edge) < tol
4.87 ticker.py(1879):         return (d + 1)
4.87 ticker.py(2069):             ticks = np.arange(low, high + 1) * step + best_vmin
4.87 ticker.py(2071):             nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()
4.87 ticker.py(2072):             if nticks >= self._min_n_ticks:
4.87 ticker.py(2073):                 break
4.87 ticker.py(2074):         return ticks + offset
4.87 _base.py(2490):             set_bound(x0, x1)
4.87 _base.py(3099):         if upper is None and np.iterable(lower):
4.87 _base.py(3102):         old_lower, old_upper = self.get_xbound()
4.87 _base.py(3074):         left, right = self.get_xlim()
4.87 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.87 _base.py(3075):         if left < right:
4.87 _base.py(3076):             return left, right
4.87 _base.py(3104):         if lower is None:
4.87 _base.py(3106):         if upper is None:
4.87 _base.py(3109):         if self.xaxis_inverted():
4.87 _base.py(3062):         return self.xaxis.get_inverted()
4.87 _base.py(3115):             if lower < upper:
4.87 _base.py(3116):                 self.set_xlim(lower, upper, auto=None)
4.87 _base.py(3229):         if right is None and np.iterable(left):
4.87 _base.py(3231):         if xmin is not None:
4.87 _base.py(3235):         if xmax is not None:
4.87 _base.py(3240):         self._process_unit_info(xdata=(left, right))
4.87 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.87 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.87 _base.py(2102):             if axis is None:
4.87 _base.py(2105):             if data is not None:
4.87 _base.py(2107):                 if not axis.have_units():
4.87 _base.py(2108):                     axis.update_units(data)
4.87 _base.py(2111):             if kwargs is not None:
4.87 _base.py(2123):             return kwargs
4.87 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.87 _base.py(2102):             if axis is None:
4.87 _base.py(2105):             if data is not None:
4.87 _base.py(2111):             if kwargs is not None:
4.87 _base.py(2123):             return kwargs
4.87 _base.py(2127):         return kwargs
4.87 _base.py(3241):         left = self._validate_converted_limits(left, self.convert_xunits)
4.87 _base.py(3154):         if limit is not None:
4.87 _base.py(3155):             converted_limit = convert(limit)
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3159):             return converted_limit
4.87 _base.py(3242):         right = self._validate_converted_limits(right, self.convert_xunits)
4.87 _base.py(3154):         if limit is not None:
4.87 _base.py(3155):             converted_limit = convert(limit)
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3159):             return converted_limit
4.87 _base.py(3244):         old_left, old_right = self.get_xlim()
4.87 _base.py(3141):         return tuple(self.viewLim.intervalx)
4.87 _base.py(3245):         if left is None:
4.87 _base.py(3247):         if right is None:
4.87 _base.py(3250):         if self.get_xscale() == 'log':
4.87 _base.py(3297):         return self.xaxis.get_scale()
4.87 _base.py(3263):         if left == right:
4.87 _base.py(3267):         swapped = left > right
4.87 _base.py(3268):         left, right = self.xaxis.get_major_locator().nonsingular(left, right)
4.87 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.87 _base.py(3269):         left, right = self.xaxis.limit_range_for_scale(left, right)
4.87 _base.py(3270):         if swapped:
4.87 _base.py(3273):         self.viewLim.intervalx = (left, right)
4.87 _base.py(3274):         if auto is not None:
4.87 _base.py(3277):         if emit:
4.87 _base.py(3278):             self.callbacks.process('xlim_changed', self)
4.87 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.87 _base.py(3281):                 if other is not self:
4.87 _base.py(3280):             for other in self._shared_x_axes.get_siblings(self):
4.87 _base.py(3286):         self.stale = True
4.87 _base.py(3287):         return left, right
4.87 _base.py(2496):         handle_single_axis(
4.87 _base.py(2497):             scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',
4.87 _base.py(2498):             'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)
4.87 _base.py(2496):         handle_single_axis(
4.87 _base.py(2428):             if not (scale and autoscaleon):
4.87 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2435):             if len(finite_dl):
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.87 _base.py(2440):                                 (d not in finite_dl))]
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.87 _base.py(2443):                                 (d not in finite_dl))]
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2445):                 dl = finite_dl
4.87 _base.py(2446):                 dl.extend(x_finite)
4.87 _base.py(2447):                 dl.extend(y_finite)
4.87 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.87 _base.py(2451):             vl = None
4.87 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.87 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.87 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.87 _base.py(2461):             locator = axis.get_major_locator()
4.87 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.87 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.87 _base.py(2466):             minpos = getattr(bb, minpos)
4.87 _base.py(2467):             transform = axis.get_transform()
4.87 _base.py(2468):             inverse_trans = transform.inverted()
4.87 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.87 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.87 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.87 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.87 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.87 _base.py(2477):                 delta = (x1t - x0t) * margin
4.87 _base.py(2482):             if do_lower_margin:
4.87 _base.py(2483):                 x0t -= delta
4.87 _base.py(2484):             if do_upper_margin:
4.87 _base.py(2485):                 x1t += delta
4.87 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.87 _base.py(2488):             if not self._tight:
4.87 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.87 ticker.py(2098):         if self._symmetric:
4.87 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.87 ticker.py(2103):             dmin, dmax, expander=1e-12, tiny=1e-13)
4.87 ticker.py(2102):         dmin, dmax = mtransforms.nonsingular(
4.87 ticker.py(2105):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.87 ticker.py(2106):             return self._raw_ticks(dmin, dmax)[[0, -1]]
4.87 ticker.py(2023):         if self._nbins == 'auto':
4.87 ticker.py(2030):             nbins = self._nbins
4.87 ticker.py(2032):         scale, offset = scale_range(vmin, vmax, nbins)
4.87 ticker.py(1829):     dv = abs(vmax - vmin)  # > 0 as nonsingular is called before.
4.87 ticker.py(1830):     meanv = (vmax + vmin) / 2
4.87 ticker.py(1831):     if abs(meanv) / dv < threshold:
4.87 ticker.py(1832):         offset = 0
4.87 ticker.py(1835):     scale = 10 ** (math.log10(dv / n) // 1)
4.87 ticker.py(1836):     return scale, offset
4.87 ticker.py(2033):         _vmin = vmin - offset
4.87 ticker.py(2034):         _vmax = vmax - offset
4.87 ticker.py(2035):         raw_step = (_vmax - _vmin) / nbins
4.87 ticker.py(2036):         steps = self._extended_steps * scale
4.87 ticker.py(2037):         if self._integer:
4.87 ticker.py(2042):         istep = np.nonzero(steps >= raw_step)[0][0]
4.87 ticker.py(2045):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.87 ticker.py(2046):             for istep in range(istep, len(steps)):
4.87 ticker.py(2047):                 step = steps[istep]
4.87 ticker.py(2048):                 best_vmin = (_vmin // step) * step
4.87 ticker.py(2049):                 best_vmax = best_vmin + step * nbins
4.87 ticker.py(2050):                 if best_vmax >= _vmax:
4.87 ticker.py(2051):                     break
4.87 ticker.py(2054):         for istep in reversed(range(istep + 1)):
4.87 ticker.py(2055):             step = steps[istep]
4.87 ticker.py(2057):             if (self._integer and
4.87 ticker.py(2060):             best_vmin = (_vmin // step) * step
4.87 ticker.py(2066):             edge = _Edge_integer(step, offset)
4.87 ticker.py(1852):         if step <= 0:
4.87 ticker.py(1854):         self.step = step
4.87 ticker.py(1855):         self._offset = abs(offset)
4.87 ticker.py(2067):             low = edge.le(_vmin - best_vmin)
4.87 ticker.py(1869):         d, m = divmod(x, self.step)
4.87 ticker.py(1870):         if self.closeto(m / self.step, 1):
4.87 ticker.py(1859):         if self._offset > 0:
4.87 ticker.py(1864):             tol = 1e-10
4.87 ticker.py(1865):         return abs(ms - edge) < tol
4.87 ticker.py(1872):         return d
4.87 ticker.py(2068):             high = edge.ge(_vmax - best_vmin)
4.87 ticker.py(1876):         d, m = divmod(x, self.step)
4.87 ticker.py(1877):         if self.closeto(m / self.step, 0):
4.87 ticker.py(1859):         if self._offset > 0:
4.87 ticker.py(1864):             tol = 1e-10
4.87 ticker.py(1865):         return abs(ms - edge) < tol
4.87 ticker.py(1878):             return d
4.87 ticker.py(2069):             ticks = np.arange(low, high + 1) * step + best_vmin
4.87 ticker.py(2071):             nticks = ((ticks <= _vmax) & (ticks >= _vmin)).sum()
4.87 ticker.py(2072):             if nticks >= self._min_n_ticks:
4.87 ticker.py(2073):                 break
4.87 ticker.py(2074):         return ticks + offset
4.87 _base.py(2490):             set_bound(x0, x1)
4.87 _base.py(3499):         if upper is None and np.iterable(lower):
4.87 _base.py(3502):         old_lower, old_upper = self.get_ybound()
4.87 _base.py(3474):         bottom, top = self.get_ylim()
4.87 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.87 _base.py(3475):         if bottom < top:
4.87 _base.py(3476):             return bottom, top
4.87 _base.py(3504):         if lower is None:
4.87 _base.py(3506):         if upper is None:
4.87 _base.py(3509):         if self.yaxis_inverted():
4.87 _base.py(3462):         return self.yaxis.get_inverted()
4.87 _base.py(3515):             if lower < upper:
4.87 _base.py(3516):                 self.set_ylim(lower, upper, auto=None)
4.87 _base.py(3610):         if top is None and np.iterable(bottom):
4.87 _base.py(3612):         if ymin is not None:
4.87 _base.py(3616):         if ymax is not None:
4.87 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.87 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.87 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.87 _base.py(2102):             if axis is None:
4.87 _base.py(2105):             if data is not None:
4.87 _base.py(2111):             if kwargs is not None:
4.87 _base.py(2123):             return kwargs
4.87 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.87 _base.py(2102):             if axis is None:
4.87 _base.py(2105):             if data is not None:
4.87 _base.py(2107):                 if not axis.have_units():
4.87 _base.py(2108):                     axis.update_units(data)
4.87 _base.py(2111):             if kwargs is not None:
4.87 _base.py(2123):             return kwargs
4.87 _base.py(2127):         return kwargs
4.87 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.87 _base.py(3154):         if limit is not None:
4.87 _base.py(3155):             converted_limit = convert(limit)
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3159):             return converted_limit
4.87 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.87 _base.py(3154):         if limit is not None:
4.87 _base.py(3155):             converted_limit = convert(limit)
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.87 _base.py(3156):             if (isinstance(converted_limit, Real)
4.87 _base.py(3159):             return converted_limit
4.87 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.87 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.87 _base.py(3627):         if bottom is None:
4.87 _base.py(3629):         if top is None:
4.87 _base.py(3632):         if self.get_yscale() == 'log':
4.87 _base.py(3680):         return self.yaxis.get_scale()
4.87 _base.py(3645):         if bottom == top:
4.87 _base.py(3650):         swapped = bottom > top
4.87 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.87 ticker.py(1525):         return mtransforms.nonsingular(v0, v1, expander=.05)
4.87 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.87 _base.py(3653):         if swapped:
4.87 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.87 _base.py(3657):         if auto is not None:
4.87 _base.py(3660):         if emit:
4.87 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.87 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.87 _base.py(3664):                 if other is not self:
4.87 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.87 _base.py(3669):         self.stale = True
4.87 _base.py(3670):         return bottom, top
4.87 _base.py(3708):         g = self.get_shared_y_axes()
4.87 _base.py(4485):         return self._shared_y_axes
4.87 _base.py(3709):         for ax in g.get_siblings(self):
4.87 _base.py(3710):             ax.yaxis._set_scale(value, **kwargs)
4.87 ticker.py(2224):         if numticks is None:
4.87 ticker.py(2225):             if rcParams['_internal.classic_mode']:
4.87 ticker.py(2226):                 numticks = 15
4.87 ticker.py(2229):         self.base(base)
4.87 ticker.py(2252):         self._base = float(base)
4.87 ticker.py(2230):         self.subs(subs)
4.87 ticker.py(2258):         if subs is None:  # consistency with previous bad API
4.87 ticker.py(2260):         elif isinstance(subs, str):
4.87 ticker.py(2266):             self._subs = np.asarray(subs, dtype=float)
4.87 ticker.py(2231):         self.numdecs = numdecs
4.87 ticker.py(2232):         self.numticks = numticks
4.87 ticker.py(300):         pass
4.87 ticker.py(224):         self.axis = axis
4.87 ticker.py(901):         self._base = float(base)
4.87 ticker.py(902):         self.labelOnlyBase = labelOnlyBase
4.87 ticker.py(903):         if minor_thresholds is None:
4.87 ticker.py(904):             if rcParams['_internal.classic_mode']:
4.87 ticker.py(905):                 minor_thresholds = (0, 0)
4.87 ticker.py(908):         self.minor_thresholds = minor_thresholds
4.87 ticker.py(909):         self._sublabels = None
4.87 ticker.py(910):         self._linthresh = linthresh
4.87 ticker.py(224):         self.axis = axis
4.87 ticker.py(2224):         if numticks is None:
4.87 ticker.py(2225):             if rcParams['_internal.classic_mode']:
4.87 ticker.py(2226):                 numticks = 15
4.87 ticker.py(2229):         self.base(base)
4.87 ticker.py(2252):         self._base = float(base)
4.87 ticker.py(2230):         self.subs(subs)
4.87 ticker.py(2258):         if subs is None:  # consistency with previous bad API
4.87 ticker.py(2259):             self._subs = 'auto'
4.87 ticker.py(2231):         self.numdecs = numdecs
4.87 ticker.py(2232):         self.numticks = numticks
4.87 ticker.py(300):         pass
4.87 ticker.py(224):         self.axis = axis
4.87 ticker.py(901):         self._base = float(base)
4.87 ticker.py(902):         self.labelOnlyBase = labelOnlyBase
4.87 ticker.py(903):         if minor_thresholds is None:
4.87 ticker.py(904):             if rcParams['_internal.classic_mode']:
4.87 ticker.py(905):                 minor_thresholds = (0, 0)
4.87 ticker.py(908):         self.minor_thresholds = minor_thresholds
4.87 ticker.py(909):         self._sublabels = None
4.87 ticker.py(910):         self._linthresh = linthresh
4.87 ticker.py(224):         self.axis = axis
4.87 _base.py(3711):             ax._update_transScale()
4.87 _base.py(813):         self.transScale.set(
4.87 _base.py(814):             mtransforms.blended_transform_factory(
4.87 _base.py(815):                 self.xaxis.get_transform(), self.yaxis.get_transform()))
4.87 _base.py(814):             mtransforms.blended_transform_factory(
4.87 _base.py(813):         self.transScale.set(
4.87 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.87 _base.py(817):             try:
4.87 _base.py(818):                 line._transformed_path.invalidate()
4.87 _base.py(819):             except AttributeError:
4.87 _base.py(820):                 pass
4.87 _base.py(816):         for line in getattr(self, "lines", []):  # Not set during init.
4.87 _base.py(3712):             ax.stale = True
4.87 _base.py(3709):         for ax in g.get_siblings(self):
4.87 _base.py(3713):         self.autoscale_view(scalex=False)
4.87 _base.py(2409):         if tight is not None:
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2200):         return self._use_sticky_edges
4.87 _base.py(2413):                 (self._xmargin and scalex and self._autoscaleXon) or
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2414):                 (self._ymargin and scaley and self._autoscaleYon)):
4.87 _base.py(2412):         if self.use_sticky_edges and (
4.87 _base.py(2423):             x_stickies, y_stickies = [], []
4.87 _base.py(2425):         def handle_single_axis(scale, autoscaleon, shared_axes, interval,
4.87 _base.py(2493):         handle_single_axis(
4.87 _base.py(2494):             scalex, self._autoscaleXon, self._shared_x_axes, 'intervalx',
4.87 _base.py(2495):             'minposx', self.xaxis, self._xmargin, x_stickies, self.set_xbound)
4.87 _base.py(2493):         handle_single_axis(
4.87 _base.py(2428):             if not (scale and autoscaleon):
4.87 _base.py(2429):                 return  # nothing to do...
4.87 _base.py(2496):         handle_single_axis(
4.87 _base.py(2497):             scaley, self._autoscaleYon, self._shared_y_axes, 'intervaly',
4.87 _base.py(2498):             'minposy', self.yaxis, self._ymargin, y_stickies, self.set_ybound)
4.87 _base.py(2496):         handle_single_axis(
4.87 _base.py(2428):             if not (scale and autoscaleon):
4.87 _base.py(2431):             shared = shared_axes.get_siblings(self)
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2432):             dl = [ax.dataLim for ax in shared]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2434):             finite_dl = [d for d in dl if np.isfinite(d).all()]
4.87 _base.py(2435):             if len(finite_dl):
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2439):                             if (np.isfinite(d.intervalx).all() and
4.87 _base.py(2440):                                 (d not in finite_dl))]
4.87 _base.py(2438):                 x_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2442):                             if (np.isfinite(d.intervaly).all() and
4.87 _base.py(2443):                                 (d not in finite_dl))]
4.87 _base.py(2441):                 y_finite = [d for d in dl
4.87 _base.py(2445):                 dl = finite_dl
4.87 _base.py(2446):                 dl.extend(x_finite)
4.87 _base.py(2447):                 dl.extend(y_finite)
4.87 _base.py(2449):             bb = mtransforms.BboxBase.union(dl)
4.88 _base.py(2451):             vl = None
4.88 _base.py(2452):             if not np.isfinite(bb.intervalx).all():
4.88 _base.py(2455):             if not np.isfinite(bb.intervaly).all():
4.88 _base.py(2460):             x0, x1 = getattr(bb, interval)
4.88 _base.py(2461):             locator = axis.get_major_locator()
4.88 _base.py(2462):             x0, x1 = locator.nonsingular(x0, x1)
4.88 ticker.py(2379):         if not np.isfinite(vmin) or not np.isfinite(vmax):
4.88 ticker.py(2382):         if vmin > vmax:
4.88 ticker.py(2384):         if vmax <= 0:
4.88 ticker.py(2390):         minpos = self.axis.get_minpos()
4.88 ticker.py(2391):         if not np.isfinite(minpos):
4.88 ticker.py(2393):         if vmin <= 0:
4.88 ticker.py(2395):         if vmin == vmax:
4.88 ticker.py(2398):         return vmin, vmax
4.88 _base.py(2466):             minpos = getattr(bb, minpos)
4.88 _base.py(2467):             transform = axis.get_transform()
4.88 _base.py(2468):             inverse_trans = transform.inverted()
4.88 _base.py(2471):             do_lower_margin = not np.any(np.isclose(x0, stickies))
4.88 _base.py(2472):             do_upper_margin = not np.any(np.isclose(x1, stickies))
4.88 _base.py(2473):             x0, x1 = axis._scale.limit_range_for_scale(x0, x1, minpos)
4.88 _base.py(2474):             x0t, x1t = transform.transform([x0, x1])
4.88 _base.py(2476):             if np.isfinite(x1t) and np.isfinite(x0t):
4.88 _base.py(2477):                 delta = (x1t - x0t) * margin
4.88 _base.py(2482):             if do_lower_margin:
4.88 _base.py(2483):                 x0t -= delta
4.88 _base.py(2484):             if do_upper_margin:
4.88 _base.py(2485):                 x1t += delta
4.88 _base.py(2486):             x0, x1 = inverse_trans.transform([x0t, x1t])
4.88 _base.py(2488):             if not self._tight:
4.88 _base.py(2489):                 x0, x1 = locator.view_limits(x0, x1)
4.88 ticker.py(2364):         b = self._base
4.88 ticker.py(2366):         vmin, vmax = self.nonsingular(vmin, vmax)
4.88 ticker.py(2379):         if not np.isfinite(vmin) or not np.isfinite(vmax):
4.88 ticker.py(2382):         if vmin > vmax:
4.88 ticker.py(2384):         if vmax <= 0:
4.88 ticker.py(2390):         minpos = self.axis.get_minpos()
4.88 ticker.py(2391):         if not np.isfinite(minpos):
4.88 ticker.py(2393):         if vmin <= 0:
4.88 ticker.py(2395):         if vmin == vmax:
4.88 ticker.py(2398):         return vmin, vmax
4.88 ticker.py(2368):         if self.axis.axes.name == 'polar':
4.88 ticker.py(2372):         if rcParams['axes.autolimit_mode'] == 'round_numbers':
4.88 ticker.py(2373):             vmin = _decade_less_equal(vmin, self._base)
4.88 ticker.py(2152):     return (x if x == 0 else
4.88 ticker.py(2153):             -_decade_greater_equal(-x, base) if x < 0 else
4.88 ticker.py(2154):             base ** np.floor(np.log(x) / np.log(base)))
4.88 ticker.py(2152):     return (x if x == 0 else
4.88 ticker.py(2374):             vmax = _decade_greater_equal(vmax, self._base)
4.88 ticker.py(2163):     return (x if x == 0 else
4.88 ticker.py(2164):             -_decade_less_equal(-x, base) if x < 0 else
4.88 ticker.py(2165):             base ** np.ceil(np.log(x) / np.log(base)))
4.88 ticker.py(2163):     return (x if x == 0 else
4.88 ticker.py(2376):         return vmin, vmax
4.88 _base.py(2490):             set_bound(x0, x1)
4.88 _base.py(3499):         if upper is None and np.iterable(lower):
4.88 _base.py(3502):         old_lower, old_upper = self.get_ybound()
4.88 _base.py(3474):         bottom, top = self.get_ylim()
4.88 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.88 _base.py(3475):         if bottom < top:
4.88 _base.py(3476):             return bottom, top
4.88 _base.py(3504):         if lower is None:
4.88 _base.py(3506):         if upper is None:
4.88 _base.py(3509):         if self.yaxis_inverted():
4.88 _base.py(3462):         return self.yaxis.get_inverted()
4.88 _base.py(3515):             if lower < upper:
4.88 _base.py(3516):                 self.set_ylim(lower, upper, auto=None)
4.88 _base.py(3610):         if top is None and np.iterable(bottom):
4.88 _base.py(3612):         if ymin is not None:
4.88 _base.py(3616):         if ymax is not None:
4.88 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.88 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.88 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.88 _base.py(2102):             if axis is None:
4.88 _base.py(2105):             if data is not None:
4.88 _base.py(2111):             if kwargs is not None:
4.88 _base.py(2123):             return kwargs
4.88 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.88 _base.py(2102):             if axis is None:
4.88 _base.py(2105):             if data is not None:
4.88 _base.py(2107):                 if not axis.have_units():
4.88 _base.py(2108):                     axis.update_units(data)
4.88 _base.py(2111):             if kwargs is not None:
4.88 _base.py(2123):             return kwargs
4.88 _base.py(2127):         return kwargs
4.88 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.88 _base.py(3154):         if limit is not None:
4.88 _base.py(3155):             converted_limit = convert(limit)
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3159):             return converted_limit
4.88 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.88 _base.py(3154):         if limit is not None:
4.88 _base.py(3155):             converted_limit = convert(limit)
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3159):             return converted_limit
4.88 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.88 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.88 _base.py(3627):         if bottom is None:
4.88 _base.py(3629):         if top is None:
4.88 _base.py(3632):         if self.get_yscale() == 'log':
4.88 _base.py(3680):         return self.yaxis.get_scale()
4.88 _base.py(3633):             if bottom <= 0:
4.88 _base.py(3639):             if top <= 0:
4.88 _base.py(3645):         if bottom == top:
4.88 _base.py(3650):         swapped = bottom > top
4.88 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.88 ticker.py(2379):         if not np.isfinite(vmin) or not np.isfinite(vmax):
4.88 ticker.py(2382):         if vmin > vmax:
4.88 ticker.py(2384):         if vmax <= 0:
4.88 ticker.py(2390):         minpos = self.axis.get_minpos()
4.88 ticker.py(2391):         if not np.isfinite(minpos):
4.88 ticker.py(2393):         if vmin <= 0:
4.88 ticker.py(2395):         if vmin == vmax:
4.88 ticker.py(2398):         return vmin, vmax
4.88 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.88 _base.py(3653):         if swapped:
4.88 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.88 _base.py(3657):         if auto is not None:
4.88 _base.py(3660):         if emit:
4.88 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.88 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.88 _base.py(3664):                 if other is not self:
4.88 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.88 _base.py(3669):         self.stale = True
4.88 _base.py(3670):         return bottom, top
4.88 _base.py(3610):         if top is None and np.iterable(bottom):
4.88 _base.py(3612):         if ymin is not None:
4.88 _base.py(3616):         if ymax is not None:
4.88 _base.py(3621):         self._process_unit_info(ydata=(bottom, top))
4.88 _base.py(2100):         def _process_single_axis(data, axis, unit_name, kwargs):
4.88 _base.py(2125):         kwargs = _process_single_axis(xdata, self.xaxis, 'xunits', kwargs)
4.88 _base.py(2102):             if axis is None:
4.88 _base.py(2105):             if data is not None:
4.88 _base.py(2111):             if kwargs is not None:
4.88 _base.py(2123):             return kwargs
4.88 _base.py(2126):         kwargs = _process_single_axis(ydata, self.yaxis, 'yunits', kwargs)
4.88 _base.py(2102):             if axis is None:
4.88 _base.py(2105):             if data is not None:
4.88 _base.py(2107):                 if not axis.have_units():
4.88 _base.py(2108):                     axis.update_units(data)
4.88 _base.py(2111):             if kwargs is not None:
4.88 _base.py(2123):             return kwargs
4.88 _base.py(2127):         return kwargs
4.88 _base.py(3622):         bottom = self._validate_converted_limits(bottom, self.convert_yunits)
4.88 _base.py(3154):         if limit is not None:
4.88 _base.py(3155):             converted_limit = convert(limit)
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3159):             return converted_limit
4.88 _base.py(3623):         top = self._validate_converted_limits(top, self.convert_yunits)
4.88 _base.py(3154):         if limit is not None:
4.88 _base.py(3155):             converted_limit = convert(limit)
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3157):                     and not np.isfinite(converted_limit)):
4.88 _base.py(3156):             if (isinstance(converted_limit, Real)
4.88 _base.py(3159):             return converted_limit
4.88 _base.py(3625):         old_bottom, old_top = self.get_ylim()
4.88 _base.py(3541):         return tuple(self.viewLim.intervaly)
4.88 _base.py(3627):         if bottom is None:
4.88 _base.py(3629):         if top is None:
4.88 _base.py(3632):         if self.get_yscale() == 'log':
4.88 _base.py(3680):         return self.yaxis.get_scale()
4.88 _base.py(3633):             if bottom <= 0:
4.88 _base.py(3639):             if top <= 0:
4.88 _base.py(3645):         if bottom == top:
4.88 _base.py(3650):         swapped = bottom > top
4.88 _base.py(3651):         bottom, top = self.yaxis.get_major_locator().nonsingular(bottom, top)
4.88 ticker.py(2379):         if not np.isfinite(vmin) or not np.isfinite(vmax):
4.88 ticker.py(2382):         if vmin > vmax:
4.88 ticker.py(2383):             vmin, vmax = vmax, vmin
4.88 ticker.py(2384):         if vmax <= 0:
4.88 ticker.py(2390):         minpos = self.axis.get_minpos()
4.88 ticker.py(2391):         if not np.isfinite(minpos):
4.88 ticker.py(2393):         if vmin <= 0:
4.88 ticker.py(2395):         if vmin == vmax:
4.88 ticker.py(2398):         return vmin, vmax
4.88 _base.py(3652):         bottom, top = self.yaxis.limit_range_for_scale(bottom, top)
4.88 _base.py(3653):         if swapped:
4.88 _base.py(3654):             bottom, top = top, bottom
4.88 _base.py(3656):         self.viewLim.intervaly = (bottom, top)
4.88 _base.py(3657):         if auto is not None:
4.88 _base.py(3658):             self._autoscaleYon = bool(auto)
4.88 _base.py(3660):         if emit:
4.88 _base.py(3661):             self.callbacks.process('ylim_changed', self)
4.88 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.88 _base.py(3664):                 if other is not self:
4.88 _base.py(3663):             for other in self._shared_y_axes.get_siblings(self):
4.88 _base.py(3669):         self.stale = True
4.88 _base.py(3670):         return bottom, top
4.88 _base.py(3541):         return tuple(self.viewLim.intervaly)
=========================== short test summary info ============================
PASSED lib/matplotlib/tests/test_coverup_matplotlib__matplotlib-14623.py::test_invert_axis_log_scale
======================== 1 passed, 12 warnings in 4.39s ========================
+ cat coverage.cover
{"/testbed/lib/matplotlib/ticker.py": {"167": 1, "168": 1, "169": 1, "170": 1, "171": 1, "172": 1, "173": 1, "174": 1, "176": 1, "178": 1, "190": 1, "194": 2, "220": 2, "241": 2, "303": 2, "331": 2, "342": 2, "374": 2, "394": 2, "413": 2, "434": 2, "499": 2, "839": 2, "1068": 2, "1084": 2, "1149": 2, "1169": 2, "1194": 2, "1351": 2, "1467": 2, "1570": 2, "1599": 2, "1643": 2, "1663": 2, "1736": 1, "1737": 1, "1741": 2, "1742": 1, "1783": 2, "1828": 1, "1839": 2, "1882": 2, "2111": 1, "2112": 1, "2120": 1, "2121": 1, "2129": 1, "2137": 1, "2146": 1, "2157": 1, "2168": 1, "2182": 1, "2196": 1, "2200": 2, "2401": 2, "2561": 2, "2653": 2, "2673": 2, "2734": 2, "191": 0, "195": 1, "200": 1, "203": 1, "206": 1, "209": 1, "212": 1, "215": 1, "196": 0, "197": 0, "198": 0, "201": 0, "204": 0, "207": 0, "210": 0, "213": 0, "217": 0, "221": 1, "223": 1, "226": 1, "230": 1, "233": 1, "236": 1, "224": 136, "227": 0, "228": 0, "231": 0, "234": 0, "237": 0, "238": 0, "247": 1, "249": 1, "256": 1, "261": 1, "268": 1, "276": 1, "279": 1, "282": 1, "298": 1, "254": 0, "258": 0, "259": 0, "266": 0, "274": 0, "277": 0, "280": 0, "296": 0, "300": 64, "313": 1, "317": 1, "314": 0, "315": 0, "324": 0, "325": 0, "326": 0, "328": 0, "335": 1, "339": 0, "346": 1, "353": 1, "367": 1, "370": 1, "350": 0, "351": 0, "362": 0, "363": 0, "365": 0, "368": 0, "371": 0, "382": 1, "385": 1, "383": 0, "391": 0, "401": 1, "404": 1, "402": 0, "410": 0, "421": 1, "424": 1, "422": 0, "431": 0, "439": 1, "466": 1, "467": 1, "445": 0, "447": 0, "448": 0, "449": 0, "450": 0, "451": 0, "452": 0, "453": 0, "454": 0, "455": 0, "456": 0, "457": 0, "458": 0, "459": 0, "460": 0, "461": 0, "463": 0, "464": 0, "472": 0, "473": 0, "475": 0, "476": 0, "477": 0, "478": 0, "479": 0, "480": 0, "481": 0, "482": 0, "483": 0, "484": 0, "486": 0, "487": 0, "488": 0, "489": 0, "490": 0, "491": 0, "492": 0, "493": 0, "495": 0, "496": 0, "511": 1, "532": 1, "535": 1, "543": 1, "545": 1, "548": 1, "554": 1, "556": 1, "559": 1, "565": 1, "567": 1, "576": 1, "592": 1, "602": 1, "625": 1, "634": 1, "645": 1, "677": 1, "688": 1, "727": 1, "764": 1, "799": 1, "800": 1, "809": 1, "516": 33, "517": 33, "518": 33, "519": 33, "520": 33, "521": 33, "522": 33, "523": 33, "524": 33, "525": 33, "526": 33, "527": 33, "528": 33, "529": 33, "530": 33, "533": 0, "536": 33, "537": 33, "538": 33, "540": 0, "541": 0, "546": 0, "549": 0, "550": 0, "552": 0, "557": 0, "560": 33, "561": 0, "563": 33, "571": 0, "572": 0, "574": 0, "580": 0, "581": 0, "583": 0, "584": 0, "585": 0, "586": 0, "587": 0, "589": 0, "590": 0, "600": 0, "621": 0, "622": 0, "623": 0, "629": 0, "630": 0, "632": 0, "638": 0, "639": 0, "641": 0, "642": 0, "643": 0, "649": 0, "650": 0, "651": 0, "652": 0, "653": 0, "654": 0, "655": 0, "656": 0, "657": 0, "658": 0, "659": 0, "660": 0, "661": 0, "663": 0, "664": 0, "665": 0, "666": 0, "667": 0, "668": 0, "669": 0, "670": 0, "671": 0, "673": 0, "675": 0, "681": 0, "682": 0, "683": 0, "684": 0, "685": 0, "686": 0, "689": 0, "691": 0, "692": 0, "693": 0, "694": 0, "695": 0, "696": 0, "697": 0, "700": 0, "701": 0, "702": 0, "705": 0, "706": 0, "711": 0, "712": 0, "714": 0, "719": 0, "722": 0, "724": 0, "723": 0, "725": 0, "713": 0, "720": 0, "731": 0, "732": 0, "733": 0, "734": 0, "736": 0, "737": 0, "739": 0, "740": 0, "741": 0, "742": 0, "743": 0, "744": 0, "745": 0, "746": 0, "747": 0, "749": 0, "750": 0, "752": 0, "753": 0, "754": 0, "756": 0, "757": 0, "758": 0, "759": 0, "760": 0, "762": 0, "766": 0, "768": 0, "770": 0, "771": 0, "772": 0, "774": 0, "775": 0, "777": 0, "778": 0, "779": 0, "781": 0, "782": 0, "784": 0, "786": 0, "787": 0, "788": 0, "789": 0, "791": 0, "792": 0, "793": 0, "794": 0, "795": 0, "796": 0, "797": 0, "801": 0, "802": 0, "803": 0, "804": 0, "805": 0, "807": 0, "811": 0, "812": 0, "813": 0, "815": 0, "816": 0, "817": 0, "818": 0, "819": 0, "820": 0, "821": 0, "822": 0, "823": 0, "825": 0, "826": 0, "827": 0, "828": 0, "829": 0, "831": 0, "833": 0, "834": 0, "835": 0, "836": 0, "897": 1, "912": 1, "922": 1, "934": 1, "994": 1, "1003": 1, "1028": 1, "1035": 1, "1041": 1, "1042": 1, "1045": 1, "901": 2, "902": 2, "903": 2, "904": 2, "905": 2, "907": 0, "908": 2, "909": 2, "910": 2, "920": 0, "932": 0, "941": 0, "942": 0, "943": 0, "946": 0, "947": 0, "948": 0, "949": 0, "950": 0, "951": 0, "953": 0, "954": 0, "955": 0, "957": 0, "961": 0, "962": 0, "964": 0, "965": 0, "968": 0, "969": 0, "970": 0, "971": 0, "972": 0, "973": 0, "974": 0, "976": 0, "977": 0, "978": 0, "980": 0, "982": 0, "983": 0, "987": 0, "988": 0, "992": 0, "995": 0, "996": 0, "997": 0, "998": 0, "1000": 0, "1001": 0, "1007": 0, "1008": 0, "1010": 0, "1011": 0, "1013": 0, "1014": 0, "1015": 0, "1016": 0, "1018": 0, "1019": 0, "1020": 0, "1021": 0, "1023": 0, "1024": 0, "1025": 0, "1026": 0, "1029": 0, "1030": 0, "1031": 0, "1032": 0, "1033": 0, "1039": 0, "1043": 0, "1047": 0, "1048": 0, "1049": 0, "1050": 0, "1051": 0, "1052": 0, "1053": 0, "1054": 0, "1055": 0, "1056": 0, "1057": 0, "1058": 0, "1059": 0, "1060": 0, "1062": 0, "1064": 0, "1065": 0, "1072": 1, "1073": 0, "1074": 0, "1075": 0, "1076": 0, "1077": 0, "1079": 0, "1080": 0, "1081": 0, "1089": 1, "1097": 1, "1091": 0, "1092": 0, "1094": 0, "1095": 0, "1103": 0, "1104": 0, "1106": 0, "1107": 0, "1108": 0, "1110": 0, "1112": 0, "1113": 0, "1114": 0, "1117": 0, "1118": 0, "1119": 0, "1120": 0, "1121": 0, "1122": 0, "1124": 0, "1125": 0, "1126": 0, "1127": 0, "1130": 0, "1131": 0, "1133": 0, "1135": 0, "1136": 0, "1137": 0, "1139": 0, "1140": 0, "1141": 0, "1142": 0, "1143": 0, "1144": 0, "1146": 0, "1154": 1, "1156": 0, "1157": 0, "1158": 0, "1159": 0, "1160": 0, "1161": 0, "1162": 0, "1163": 0, "1165": 0, "1166": 0, "1173": 1, "1189": 1, "1174": 0, "1175": 0, "1176": 0, "1177": 0, "1178": 0, "1179": 0, "1181": 0, "1183": 0, "1184": 0, "1186": 0, "1187": 0, "1191": 0, "1202": 1, "1203": 1, "1204": 1, "1205": 1, "1206": 1, "1207": 1, "1208": 1, "1209": 1, "1210": 1, "1211": 1, "1212": 1, "1213": 1, "1214": 1, "1215": 1, "1216": 1, "1217": 1, "1218": 1, "1201": 1, "1221": 2, "1222": 1, "1263": 1, "1266": 1, "1272": 1, "1274": 1, "1277": 1, "1283": 1, "1285": 1, "1291": 1, "1298": 1, "1257": 0, "1258": 0, "1259": 0, "1260": 0, "1261": 0, "1264": 0, "1267": 0, "1268": 0, "1270": 0, "1275": 0, "1278": 0, "1279": 0, "1281": 0, "1289": 0, "1292": 0, "1294": 0, "1295": 0, "1296": 0, "1313": 0, "1314": 0, "1316": 0, "1317": 0, "1318": 0, "1320": 0, "1321": 0, "1323": 0, "1327": 0, "1329": 0, "1331": 0, "1335": 0, "1336": 0, "1337": 0, "1338": 0, "1340": 0, "1341": 0, "1342": 0, "1343": 0, "1345": 0, "1346": 0, "1348": 0, "1377": 1, "1383": 1, "1392": 1, "1439": 1, "1442": 1, "1443": 1, "1462": 1, "1463": 1, "1378": 0, "1379": 0, "1380": 0, "1381": 0, "1387": 0, "1388": 0, "1390": 0, "1417": 0, "1418": 0, "1420": 0, "1421": 0, "1422": 0, "1428": 0, "1429": 0, "1430": 0, "1431": 0, "1432": 0, "1434": 0, "1435": 0, "1437": 0, "1440": 0, "1451": 0, "1452": 0, "1453": 0, "1454": 0, "1458": 0, "1459": 0, "1460": 0, "1464": 0, "1480": 1, "1482": 1, "1499": 1, "1508": 1, "1514": 1, "1523": 1, "1527": 1, "1535": 1, "1539": 1, "1556": 1, "1565": 1, "1497": 0, "1504": 0, "1505": 0, "1506": 0, "1512": 0, "1517": 0, "1518": 0, "1520": 0, "1521": 0, "1525": 15, "1533": 0, "1537": 0, "1541": 0, "1542": 0, "1544": 0, "1545": 0, "1546": 0, "1547": 0, "1549": 0, "1550": 0, "1552": 0, "1553": 0, "1554": 0, "1559": 0, "1560": 0, "1561": 0, "1562": 0, "1563": 0, "1567": 0, "1577": 1, "1582": 1, "1589": 1, "1594": 1, "1579": 0, "1580": 0, "1584": 0, "1585": 0, "1586": 0, "1587": 0, "1591": 0, "1592": 0, "1595": 0, "1596": 0, "1610": 1, "1614": 1, "1619": 1, "1622": 1, "1611": 0, "1612": 0, "1616": 0, "1617": 0, "1620": 0, "1632": 0, "1633": 0, "1634": 0, "1635": 0, "1636": 0, "1637": 0, "1638": 0, "1639": 0, "1640": 0, "1648": 1, "1651": 1, "1649": 0, "1660": 0, "1673": 1, "1683": 1, "1690": 1, "1695": 1, "1712": 1, "1715": 1, "1677": 0, "1678": 0, "1679": 0, "1681": 0, "1685": 0, "1686": 0, "1687": 0, "1688": 0, "1692": 0, "1693": 0, "1696": 0, "1697": 0, "1698": 0, "1700": 0, "1701": 0, "1703": 0, "1704": 0, "1706": 0, "1707": 0, "1708": 0, "1710": 0, "1713": 0, "1718": 0, "1719": 0, "1721": 0, "1722": 0, "1723": 0, "1725": 0, "1726": 0, "1727": 0, "1728": 0, "1729": 0, "1730": 0, "1731": 0, "1733": 0, "1738": 0, "1744": 1, "1749": 1, "1756": 1, "1764": 1, "1772": 1, "1779": 1, "1745": 0, "1746": 0, "1747": 0, "1751": 0, "1752": 0, "1753": 0, "1754": 0, "1758": 0, "1759": 0, "1761": 0, "1762": 0, "1766": 0, "1767": 0, "1769": 0, "1770": 0, "1774": 0, "1775": 0, "1776": 0, "1777": 0, "1780": 0, "1788": 1, "1791": 1, "1796": 1, "1801": 1, "1810": 1, "1789": 0, "1793": 0, "1794": 0, "1798": 0, "1799": 0, "1802": 0, "1803": 0, "1804": 0, "1805": 0, "1806": 0, "1807": 0, "1808": 0, "1815": 0, "1816": 0, "1817": 0, "1818": 0, "1819": 0, "1820": 0, "1822": 0, "1823": 0, "1825": 0, "1829": 5, "1830": 5, "1831": 5, "1832": 5, "1834": 0, "1835": 5, "1836": 5, "1846": 1, "1857": 1, "1867": 1, "1874": 1, "1852": 5, "1853": 0, "1854": 5, "1855": 5, "1859": 10, "1860": 0, "1861": 0, "1862": 0, "1864": 10, "1865": 10, "1869": 5, "1870": 5, "1871": 0, "1872": 5, "1876": 5, "1877": 5, "1878": 3, "1879": 2, "1886": 2, "1887": 1, "1888": 1, "1889": 1, "1890": 1, "1891": 1, "1893": 1, "1945": 1, "1946": 1, "1960": 1, "1961": 1, "1968": 1, "2016": 1, "2076": 1, "2080": 1, "2097": 1, "1932": 33, "1933": 0, "1934": 0, "1935": 0, "1939": 0, "1940": 0, "1941": 0, "1942": 0, "1943": 33, "1947": 33, "1948": 0, "1950": 33, "1951": 33, "1952": 0, "1954": 33, "1955": 0, "1956": 33, "1957": 0, "1958": 33, "1965": 33, "1966": 33, "1987": 33, "1988": 33, "1989": 33, "1990": 33, "1991": 33, "1992": 33, "1993": 33, "1994": 33, "1995": 33, "1996": 0, "1997": 0, "1998": 33, "1999": 33, "2000": 33, "2001": 33, "2002": 33, "2003": 33, "2004": 0, "2006": 33, "2007": 33, "2008": 33, "2009": 33, "2010": 33, "2011": 0, "2012": 0, "2013": 0, "2023": 5, "2024": 0, "2025": 0, "2026": 0, "2028": 0, "2030": 5, "2032": 5, "2033": 5, "2034": 5, "2035": 5, "2036": 5, "2037": 5, "2039": 0, "2040": 0, "2042": 5, "2045": 5, "2046": 5, "2047": 5, "2048": 5, "2049": 5, "2050": 5, "2051": 5, "2054": 5, "2055": 5, "2057": 5, "2058": 0, "2059": 0, "2060": 5, "2066": 5, "2067": 5, "2068": 5, "2069": 5, "2071": 5, "2072": 5, "2073": 5, "2074": 5, "2077": 0, "2078": 0, "2081": 0, "2082": 0, "2083": 0, "2084": 0, "2085": 0, "2086": 0, "2088": 0, "2089": 0, "2090": 0, "2091": 0, "2092": 0, "2093": 0, "2094": 0, "2095": 0, "2098": 5, "2099": 0, "2100": 0, "2102": 10, "2103": 5, "2105": 5, "2106": 5, "2108": 0, "2114": 0, "2115": 0, "2116": 0, "2117": 0, "2123": 0, "2124": 0, "2125": 0, "2126": 0, "2130": 0, "2131": 0, "2132": 0, "2133": 0, "2134": 0, "2138": 0, "2139": 0, "2140": 0, "2141": 0, "2142": 0, "2143": 0, "2152": 2, "2153": 1, "2154": 1, "2163": 2, "2164": 1, "2165": 1, "2174": 0, "2175": 0, "2176": 0, "2177": 0, "2178": 0, "2179": 0, "2188": 0, "2189": 0, "2190": 0, "2191": 0, "2192": 0, "2193": 0, "2197": 0, "2205": 1, "2234": 1, "2248": 1, "2254": 1, "2268": 1, "2273": 1, "2362": 1, "2378": 1, "2224": 2, "2225": 2, "2226": 2, "2228": 0, "2229": 2, "2230": 2, "2231": 2, "2232": 2, "2236": 0, "2237": 0, "2238": 0, "2239": 0, "2240": 0, "2241": 0, "2242": 0, "2243": 0, "2252": 2, "2258": 2, "2259": 1, "2260": 1, "2261": 0, "2262": 0, "2263": 0, "2264": 0, "2266": 1, "2270": 0, "2271": 0, "2274": 0, "2275": 0, "2276": 0, "2278": 0, "2280": 0, "2282": 0, "2284": 0, "2285": 0, "2286": 0, "2287": 0, "2289": 0, "2291": 0, "2292": 0, "2293": 0, "2295": 0, "2296": 0, "2297": 0, "2300": 0, "2302": 0, "2303": 0, "2304": 0, "2305": 0, "2307": 0, "2309": 0, "2310": 0, "2311": 0, "2312": 0, "2313": 0, "2315": 0, "2317": 0, "2319": 0, "2323": 0, "2322": 0, "2324": 0, "2328": 0, "2330": 0, "2331": 0, "2333": 0, "2334": 0, "2335": 0, "2336": 0, "2337": 0, "2340": 0, "2342": 0, "2343": 0, "2344": 0, "2345": 0, "2347": 0, "2349": 0, "2351": 0, "2352": 0, "2353": 0, "2354": 0, "2358": 0, "2360": 0, "2364": 1, "2366": 1, "2368": 1, "2369": 0, "2370": 0, "2372": 1, "2373": 1, "2374": 1, "2376": 1, "2379": 4, "2380": 0, "2382": 4, "2383": 1, "2384": 4, "2385": 0, "2386": 0, "2388": 0, "2390": 4, "2391": 4, "2392": 0, "2393": 4, "2394": 0, "2395": 4, "2396": 0, "2397": 0, "2398": 4, "2406": 1, "2425": 1, "2432": 1, "2438": 1, "2544": 1, "2410": 0, "2411": 0, "2412": 0, "2413": 0, "2414": 0, "2415": 0, "2417": 0, "2419": 0, "2420": 0, "2422": 0, "2423": 0, "2427": 0, "2428": 0, "2429": 0, "2430": 0, "2435": 0, "2436": 0, "2439": 0, "2440": 0, "2442": 0, "2443": 0, "2465": 0, "2466": 0, "2467": 0, "2468": 0, "2469": 0, "2470": 0, "2471": 0, "2472": 0, "2473": 0, "2474": 0, "2475": 0, "2476": 0, "2478": 0, "2479": 0, "2480": 0, "2481": 0, "2482": 0, "2484": 0, "2486": 0, "2488": 0, "2494": 0, "2495": 0, "2496": 0, "2498": 0, "2500": 0, "2502": 0, "2503": 0, "2504": 0, "2506": 0, "2508": 0, "2510": 0, "2511": 0, "2512": 0, "2513": 0, "2515": 0, "2516": 0, "2517": 0, "2518": 0, "2520": 0, "2521": 0, "2523": 0, "2524": 0, "2527": 0, "2528": 0, "2530": 0, "2532": 0, "2533": 0, "2534": 0, "2535": 0, "2536": 0, "2538": 0, "2540": 0, "2542": 0, "2489": 0, "2490": 0, "2491": 0, "2546": 0, "2547": 0, "2548": 0, "2550": 0, "2551": 0, "2552": 0, "2553": 0, "2554": 0, "2555": 0, "2557": 0, "2558": 0, "2566": 1, "2572": 1, "2577": 1, "2582": 1, "2622": 1, "2570": 0, "2574": 0, "2575": 0, "2579": 0, "2580": 0, "2584": 0, "2585": 0, "2587": 0, "2588": 0, "2589": 0, "2591": 0, "2592": 0, "2595": 0, "2596": 0, "2597": 0, "2598": 0, "2599": 0, "2600": 0, "2601": 0, "2602": 0, "2603": 0, "2604": 0, "2608": 0, "2609": 0, "2610": 0, "2611": 0, "2612": 0, "2613": 0, "2614": 0, "2615": 0, "2616": 0, "2617": 0, "2618": 0, "2620": 0, "2623": 0, "2624": 0, "2625": 0, "2627": 0, "2628": 0, "2631": 0, "2632": 0, "2633": 0, "2634": 0, "2636": 0, "2643": 0, "2644": 0, "2645": 0, "2646": 0, "2647": 0, "2648": 0, "2650": 0, "2659": 1, "2664": 33, "2665": 33, "2666": 33, "2668": 0, "2669": 0, "2670": 33, "2678": 1, "2688": 1, "2729": 1, "2686": 0, "2690": 0, "2691": 0, "2693": 0, "2695": 0, "2696": 0, "2697": 0, "2698": 0, "2703": 0, "2705": 0, "2707": 0, "2709": 0, "2710": 0, "2712": 0, "2714": 0, "2716": 0, "2718": 0, "2719": 0, "2720": 0, "2722": 0, "2723": 0, "2724": 0, "2725": 0, "2727": 0, "2730": 0, "2731": 0, "2740": 1, "2743": 1, "2748": 1, "2752": 1, "2759": 1, "2766": 1, "2741": 0, "2745": 0, "2746": 0, "2749": 0, "2750": 0, "2754": 0, "2755": 0, "2756": 0, "2757": 0, "2762": 0, "2763": 0, "2764": 0, "2768": 0, "2769": 0, "2770": 0, "2773": 0, "2774": 0, "2775": 0, "2776": 0, "2778": 0, "2779": 0, "2784": 0, "2785": 0, "2786": 0, "2787": 0, "2789": 0, "2790": 0, "2792": 0}}
{"/testbed/lib/matplotlib/axes/_base.py": {"1": 1, "2": 1, "3": 1, "4": 1, "5": 1, "6": 1, "7": 1, "9": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "18": 1, "19": 1, "20": 1, "21": 1, "22": 1, "23": 1, "24": 1, "25": 1, "26": 1, "27": 1, "29": 1, "32": 1, "118": 2, "410": 2, "50": 0, "51": 0, "52": 0, "55": 0, "56": 0, "59": 0, "60": 0, "61": 0, "62": 0, "64": 0, "66": 0, "69": 0, "70": 0, "71": 0, "73": 0, "74": 0, "75": 0, "76": 0, "77": 0, "78": 0, "79": 0, "80": 0, "81": 0, "82": 0, "83": 0, "84": 0, "85": 0, "86": 0, "87": 0, "88": 0, "89": 0, "90": 0, "91": 0, "92": 0, "93": 0, "94": 0, "95": 0, "96": 0, "97": 0, "98": 0, "99": 0, "100": 0, "101": 0, "102": 0, "103": 0, "105": 0, "106": 0, "108": 0, "109": 0, "110": 0, "111": 0, "112": 0, "113": 0, "115": 0, "130": 1, "135": 1, "139": 1, "143": 1, "154": 1, "227": 1, "233": 1, "237": 1, "241": 1, "281": 1, "299": 1, "308": 1, "315": 1, "363": 1, "131": 4, "132": 4, "133": 4, "137": 0, "140": 0, "141": 0, "145": 4, "146": 4, "148": 0, "150": 4, "152": 4, "156": 2, "157": 2, "158": 2, "159": 0, "160": 2, "161": 0, "162": 2, "163": 2, "164": 0, "165": 2, "166": 0, "168": 6, "169": 4, "170": 0, "171": 0, "173": 2, "174": 0, "177": 2, "178": 2, "179": 0, "180": 0, "181": 0, "182": 0, "191": 0, "192": 0, "193": 0, "194": 0, "196": 0, "197": 0, "198": 0, "201": 0, "202": 0, "203": 0, "205": 0, "206": 0, "207": 0, "209": 0, "210": 0, "213": 0, "214": 0, "215": 0, "216": 0, "220": 4, "221": 2, "222": 2, "223": 0, "224": 0, "225": 2, "229": 0, "230": 0, "231": 0, "234": 0, "235": 0, "238": 0, "239": 0, "242": 2, "243": 2, "244": 2, "246": 2, "259": 0, "260": 0, "261": 0, "262": 0, "266": 2, "267": 2, "268": 2, "269": 0, "270": 0, "271": 2, "272": 0, "273": 0, "275": 2, "276": 2, "277": 2, "278": 2, "279": 2, "288": 2, "289": 4, "292": 2, "293": 2, "294": 0, "296": 0, "297": 2, "304": 4, "305": 2, "306": 2, "309": 2, "310": 2, "311": 2, "312": 2, "313": 2, "316": 0, "317": 0, "327": 0, "328": 0, "330": 0, "331": 0, "332": 0, "338": 0, "339": 0, "347": 0, "350": 0, "354": 0, "356": 0, "357": 0, "358": 0, "359": 0, "360": 0, "361": 0, "364": 2, "365": 2, "366": 0, "367": 0, "368": 2, "369": 0, "371": 2, "376": 8, "377": 0, "379": 2, "380": 10, "381": 2, "382": 6, "383": 0, "385": 2, "386": 2, "387": 2, "389": 0, "391": 2, "393": 2, "394": 2, "396": 0, "397": 0, "399": 2, "400": 2, "401": 0, "402": 0, "404": 4, "405": 2, "406": 2, "407": 2, "411": 1, "413": 1, "414": 1, "415": 1, "417": 1, "428": 1, "421": 0, "552": 1, "566": 1, "576": 1, "594": 1, "604": 1, "624": 1, "660": 1, "684": 1, "710": 1, "736": 1, "760": 1, "786": 1, "812": 1, "822": 1, "846": 1, "871": 1, "887": 1, "898": 1, "909": 1, "915": 1, "925": 1, "942": 1, "960": 1, "1106": 1, "1107": 1, "1108": 1, "1111": 1, "1115": 1, "1118": 1, "1120": 1, "1131": 1, "1133": 1, "1145": 1, "1219": 1, "1222": 1, "1301": 1, "1304": 1, "1345": 1, "1358": 1, "1414": 1, "1430": 1, "1446": 1, "1597": 1, "1741": 1, "1745": 1, "1749": 1, "1753": 1, "1757": 1, "1762": 1, "1767": 1, "1771": 1, "1776": 1, "1783": 1, "1798": 1, "1805": 1, "1819": 1, "1840": 1, "1858": 1, "1878": 1, "1890": 1, "1894": 1, "1910": 1, "1920": 1, "1964": 1, "1976": 1, "2002": 1, "2012": 1, "2023": 1, "2032": 1, "2061": 1, "2086": 1, "2097": 1, "2129": 1, "2136": 1, "2142": 1, "2148": 1, "2154": 1, "2165": 1, "2175": 1, "2185": 1, "2186": 1, "2202": 1, "2203": 1, "2207": 1, "2229": 1, "2251": 1, "2328": 1, "2339": 1, "2343": 1, "2388": 1, "2500": 1, "2503": 1, "2573": 1, "2574": 1, "2652": 1, "2663": 1, "2674": 1, "2679": 1, "2683": 1, "2694": 1, "2708": 1, "2744": 1, "2745": 1, "2789": 2, "2790": 1, "2877": 1, "2918": 1, "3018": 1, "3027": 1, "3038": 1, "3050": 1, "3064": 1, "3080": 1, "3120": 1, "3143": 1, "3161": 2, "3162": 1, "3289": 1, "3299": 1, "3333": 1, "3337": 1, "3354": 1, "3366": 1, "3378": 1, "3402": 1, "3438": 1, "3450": 1, "3464": 1, "3480": 1, "3520": 1, "3543": 2, "3544": 1, "3672": 1, "3682": 1, "3715": 1, "3719": 1, "3735": 1, "3747": 1, "3759": 1, "3783": 1, "3817": 1, "3830": 1, "3841": 1, "3851": 1, "3861": 1, "3873": 1, "3892": 1, "3899": 1, "3905": 1, "3911": 1, "3917": 1, "3927": 1, "3933": 1, "3943": 1, "3961": 1, "3978": 1, "3977": 0, "4140": 1, "4164": 1, "4176": 1, "4250": 1, "4268": 1, "4274": 1, "4281": 1, "4305": 1, "4304": 0, "4405": 1, "4419": 1, "4449": 1, "4479": 1, "4483": 1, "418": 0, "419": 0, "460": 2, "461": 2, "462": 2, "464": 0, "465": 2, "466": 0, "467": 2, "468": 2, "469": 2, "470": 2, "471": 2, "472": 2, "473": 2, "474": 2, "475": 0, "476": 2, "477": 0, "478": 2, "479": 2, "481": 2, "483": 2, "486": 2, "487": 2, "488": 2, "489": 2, "490": 2, "491": 2, "493": 2, "494": 2, "495": 2, "498": 2, "499": 2, "501": 2, "502": 2, "504": 2, "505": 0, "506": 2, "507": 0, "509": 2, "511": 2, "512": 4, "513": 2, "515": 2, "516": 4, "517": 2, "519": 4, "520": 2, "521": 2, "522": 2, "523": 0, "524": 2, "525": 2, "526": 2, "527": 2, "528": 2, "529": 2, "530": 2, "531": 0, "532": 2, "534": 4, "535": 2, "536": 2, "537": 2, "538": 0, "539": 2, "540": 2, "541": 2, "542": 2, "543": 2, "544": 2, "545": 2, "546": 0, "547": 2, "549": 2, "550": 2, "555": 0, "556": 0, "557": 0, "559": 0, "561": 0, "563": 0, "562": 0, "564": 0, "568": 0, "570": 0, "571": 0, "572": 0, "573": 0, "574": 0, "592": 0, "596": 2, "597": 2, "598": 2, "599": 2, "600": 2, "601": 2, "602": 2, "612": 2, "614": 4, "615": 2, "617": 2, "618": 2, "619": 4, "620": 2, "622": 2, "637": 2, "642": 4, "643": 2, "647": 4, "648": 2, "653": 2, "655": 4, "656": 2, "657": 4, "658": 2, "673": 58, "674": 34, "675": 24, "677": 12, "678": 12, "680": 12, "682": 0, "704": 6, "705": 18, "706": 12, "707": 6, "708": 6, "730": 6, "731": 18, "732": 12, "733": 6, "734": 6, "749": 58, "750": 34, "751": 24, "753": 12, "754": 12, "756": 12, "758": 0, "780": 6, "781": 18, "782": 12, "783": 6, "784": 6, "806": 6, "807": 18, "808": 12, "809": 6, "810": 6, "813": 12, "814": 12, "815": 6, "816": 8, "817": 2, "818": 2, "819": 2, "820": 2, "838": 0, "839": 0, "841": 0, "842": 0, "843": 0, "844": 0, "865": 0, "868": 0, "869": 0, "878": 0, "879": 0, "880": 0, "881": 0, "882": 0, "883": 0, "884": 0, "885": 0, "894": 0, "895": 0, "896": 0, "906": 2, "907": 2, "913": 0, "917": 8, "918": 8, "919": 2, "921": 8, "922": 8, "923": 0, "940": 2, "957": 22, "958": 10, "965": 2, "966": 0, "968": 2, "970": 2, "971": 2, "973": 2, "974": 2, "976": 10, "977": 8, "979": 2, "980": 2, "982": 2, "985": 0, "986": 0, "987": 0, "988": 0, "989": 0, "990": 0, "992": 2, "993": 2, "994": 2, "995": 0, "996": 0, "998": 2, "999": 0, "1000": 0, "1001": 0, "1002": 0, "1003": 0, "1004": 0, "1006": 2, "1007": 2, "1008": 2, "1009": 0, "1010": 0, "1012": 2, "1013": 0, "1015": 2, "1016": 0, "1018": 2, "1019": 2, "1020": 2, "1021": 2, "1022": 2, "1023": 2, "1024": 2, "1025": 2, "1026": 2, "1028": 2, "1029": 2, "1031": 2, "1032": 2, "1033": 2, "1034": 2, "1035": 2, "1036": 2, "1037": 2, "1038": 2, "1039": 2, "1040": 2, "1041": 2, "1042": 2, "1043": 2, "1045": 2, "1046": 4, "1047": 2, "1048": 4, "1049": 2, "1050": 2, "1052": 4, "1053": 2, "1054": 2, "1055": 2, "1056": 2, "1058": 4, "1059": 2, "1060": 2, "1061": 2, "1062": 2, "1063": 4, "1064": 2, "1065": 2, "1066": 2, "1067": 2, "1069": 2, "1072": 2, "1074": 2, "1076": 8, "1077": 6, "1082": 2, "1083": 2, "1084": 2, "1085": 2, "1086": 2, "1087": 2, "1089": 2, "1091": 2, "1092": 2, "1094": 2, "1095": 2, "1096": 2, "1097": 0, "1098": 0, "1100": 2, "1101": 0, "1102": 0, "1104": 2, "1109": 0, "1113": 0, "1117": 0, "1128": 0, "1129": 0, "1130": 0, "1138": 4, "1139": 2, "1140": 2, "1141": 8, "1142": 6, "1143": 6, "1208": 0, "1209": 0, "1212": 0, "1213": 0, "1215": 0, "1216": 0, "1217": 0, "1220": 0, "1275": 0, "1276": 0, "1277": 0, "1279": 0, "1280": 0, "1281": 0, "1284": 0, "1285": 0, "1286": 0, "1288": 0, "1290": 0, "1291": 0, "1293": 0, "1294": 0, "1295": 0, "1297": 0, "1298": 0, "1299": 0, "1302": 0, "1335": 0, "1336": 0, "1337": 0, "1338": 0, "1340": 0, "1341": 0, "1342": 0, "1343": 0, "1356": 0, "1401": 0, "1402": 0, "1403": 0, "1404": 0, "1405": 0, "1406": 0, "1408": 0, "1409": 0, "1410": 0, "1412": 0, "1422": 0, "1423": 0, "1425": 0, "1426": 0, "1428": 0, "1438": 0, "1439": 0, "1441": 0, "1442": 0, "1444": 0, "1470": 0, "1471": 0, "1473": 0, "1475": 0, "1476": 0, "1477": 0, "1478": 0, "1479": 0, "1480": 0, "1481": 0, "1482": 0, "1483": 0, "1484": 0, "1485": 0, "1486": 0, "1487": 0, "1489": 0, "1491": 0, "1493": 0, "1494": 0, "1495": 0, "1497": 0, "1498": 0, "1500": 0, "1502": 0, "1503": 0, "1504": 0, "1505": 0, "1506": 0, "1508": 0, "1509": 0, "1511": 0, "1512": 0, "1513": 0, "1514": 0, "1515": 0, "1519": 0, "1521": 0, "1522": 0, "1524": 0, "1525": 0, "1526": 0, "1528": 0, "1529": 0, "1531": 0, "1532": 0, "1533": 0, "1535": 0, "1537": 0, "1538": 0, "1540": 0, "1541": 0, "1542": 0, "1543": 0, "1544": 0, "1545": 0, "1547": 0, "1548": 0, "1549": 0, "1551": 0, "1552": 0, "1553": 0, "1554": 0, "1555": 0, "1556": 0, "1559": 0, "1560": 0, "1562": 0, "1563": 0, "1565": 0, "1566": 0, "1570": 0, "1571": 0, "1573": 0, "1574": 0, "1575": 0, "1577": 0, "1578": 0, "1580": 0, "1581": 0, "1582": 0, "1583": 0, "1584": 0, "1585": 0, "1587": 0, "1589": 0, "1590": 0, "1591": 0, "1592": 0, "1593": 0, "1595": 0, "1653": 0, "1654": 0, "1655": 0, "1656": 0, "1658": 0, "1660": 0, "1661": 0, "1662": 0, "1663": 0, "1664": 0, "1665": 0, "1666": 0, "1668": 0, "1669": 0, "1670": 0, "1672": 0, "1673": 0, "1674": 0, "1676": 0, "1677": 0, "1678": 0, "1679": 0, "1680": 0, "1681": 0, "1682": 0, "1683": 0, "1684": 0, "1685": 0, "1686": 0, "1687": 0, "1688": 0, "1689": 0, "1690": 0, "1691": 0, "1692": 0, "1693": 0, "1694": 0, "1695": 0, "1696": 0, "1697": 0, "1699": 0, "1700": 0, "1701": 0, "1702": 0, "1703": 0, "1705": 0, "1706": 0, "1707": 0, "1708": 0, "1709": 0, "1710": 0, "1711": 0, "1712": 0, "1713": 0, "1715": 0, "1716": 0, "1717": 0, "1718": 0, "1719": 0, "1720": 0, "1721": 0, "1723": 0, "1724": 0, "1725": 0, "1726": 0, "1728": 0, "1729": 0, "1730": 0, "1731": 0, "1733": 0, "1734": 0, "1736": 0, "1737": 0, "1739": 0, "1743": 0, "1747": 0, "1751": 0, "1755": 0, "1759": 0, "1760": 0, "1764": 0, "1765": 0, "1769": 0, "1773": 0, "1774": 0, "1778": 0, "1779": 0, "1790": 0, "1791": 0, "1792": 0, "1793": 0, "1794": 0, "1796": 0, "1803": 0, "1814": 0, "1815": 0, "1816": 0, "1817": 0, "1813": 0, "1832": 0, "1833": 0, "1834": 0, "1835": 0, "1836": 0, "1837": 0, "1838": 0, "1850": 0, "1851": 0, "1853": 0, "1854": 0, "1855": 0, "1856": 0, "1862": 0, "1863": 0, "1864": 0, "1865": 0, "1866": 0, "1867": 0, "1869": 0, "1870": 0, "1872": 0, "1873": 0, "1875": 0, "1876": 0, "1882": 0, "1883": 0, "1884": 0, "1885": 0, "1886": 0, "1887": 0, "1888": 0, "1891": 0, "1892": 0, "1898": 2, "1899": 2, "1900": 2, "1902": 2, "1903": 2, "1904": 2, "1905": 2, "1906": 2, "1907": 2, "1908": 2, "1914": 0, "1915": 0, "1916": 0, "1917": 0, "1918": 0, "1924": 2, "1925": 2, "1926": 0, "1928": 2, "1930": 2, "1931": 2, "1933": 0, "1936": 0, "1941": 0, "1942": 0, "1943": 0, "1944": 0, "1946": 0, "1953": 0, "1955": 2, "1956": 4, "1957": 2, "1958": 4, "1959": 2, "1960": 2, "1961": 2, "1962": 2, "1968": 0, "1969": 0, "1970": 0, "1971": 0, "1972": 0, "1973": 0, "1974": 0, "1986": 0, "1987": 0, "1988": 0, "1989": 0, "1990": 0, "1991": 0, "1992": 0, "1993": 0, "1994": 0, "1995": 0, "1997": 0, "1998": 0, "1999": 0, "2000": 0, "2006": 0, "2007": 0, "2008": 0, "2009": 0, "2010": 0, "2016": 0, "2017": 0, "2018": 0, "2019": 0, "2020": 0, "2021": 0, "2029": 0, "2030": 0, "2045": 0, "2046": 0, "2047": 0, "2049": 0, "2050": 0, "2051": 0, "2053": 0, "2054": 0, "2055": 0, "2057": 0, "2058": 0, "2059": 0, "2079": 0, "2080": 0, "2081": 0, "2082": 0, "2083": 0, "2084": 0, "2095": 0, "2100": 12, "2125": 12, "2126": 12, "2127": 12, "2102": 24, "2103": 0, "2105": 24, "2107": 12, "2108": 12, "2111": 24, "2112": 0, "2113": 0, "2114": 0, "2115": 0, "2117": 0, "2118": 0, "2121": 0, "2122": 0, "2123": 24, "2134": 0, "2140": 0, "2146": 0, "2152": 0, "2162": 0, "2163": 0, "2173": 0, "2183": 0, "2200": 4, "2204": 0, "2224": 0, "2225": 0, "2226": 0, "2227": 0, "2246": 0, "2247": 0, "2248": 0, "2249": 0, "2303": 0, "2304": 0, "2306": 0, "2307": 0, "2308": 0, "2309": 0, "2310": 0, "2311": 0, "2314": 0, "2315": 0, "2316": 0, "2317": 0, "2319": 0, "2320": 0, "2321": 0, "2322": 0, "2324": 0, "2325": 0, "2336": 0, "2337": 0, "2341": 0, "2370": 0, "2371": 0, "2372": 0, "2374": 0, "2375": 0, "2376": 0, "2377": 0, "2378": 0, "2379": 0, "2380": 0, "2381": 0, "2382": 0, "2383": 0, "2384": 0, "2385": 0, "2386": 0, "2409": 4, "2410": 0, "2412": 12, "2413": 4, "2414": 4, "2415": 0, "2416": 0, "2417": 0, "2418": 0, "2419": 0, "2420": 0, "2421": 0, "2423": 4, "2425": 4, "2493": 8, "2494": 4, "2495": 4, "2496": 8, "2497": 4, "2498": 4, "2428": 8, "2429": 2, "2431": 6, "2432": 18, "2434": 18, "2435": 6, "2438": 18, "2441": 18, "2445": 6, "2446": 6, "2447": 6, "2449": 6, "2451": 6, "2452": 6, "2453": 0, "2454": 0, "2455": 6, "2456": 0, "2457": 0, "2458": 0, "2459": 0, "2460": 6, "2461": 6, "2462": 6, "2466": 6, "2467": 6, "2468": 6, "2471": 6, "2472": 6, "2473": 6, "2474": 6, "2476": 6, "2477": 6, "2480": 0, "2482": 6, "2483": 6, "2484": 6, "2485": 6, "2486": 6, "2488": 6, "2489": 6, "2490": 6, "2439": 6, "2440": 6, "2442": 6, "2443": 6, "2501": 2, "2509": 0, "2510": 0, "2511": 0, "2513": 0, "2515": 0, "2516": 0, "2517": 0, "2518": 0, "2519": 0, "2520": 0, "2521": 0, "2522": 0, "2523": 0, "2525": 0, "2526": 0, "2527": 0, "2528": 0, "2530": 0, "2532": 0, "2534": 0, "2535": 0, "2536": 0, "2537": 0, "2538": 0, "2539": 0, "2541": 0, "2542": 0, "2543": 0, "2544": 0, "2545": 0, "2546": 0, "2547": 0, "2548": 0, "2549": 0, "2551": 0, "2552": 0, "2553": 0, "2555": 0, "2556": 0, "2557": 0, "2558": 0, "2559": 0, "2562": 0, "2563": 0, "2564": 0, "2565": 0, "2566": 0, "2567": 0, "2569": 0, "2570": 0, "2576": 0, "2577": 0, "2579": 0, "2580": 0, "2581": 0, "2582": 0, "2583": 0, "2586": 0, "2589": 0, "2590": 0, "2591": 0, "2592": 0, "2594": 0, "2596": 0, "2597": 0, "2603": 0, "2604": 0, "2605": 0, "2607": 0, "2609": 0, "2610": 0, "2611": 0, "2613": 0, "2614": 0, "2615": 0, "2616": 0, "2618": 0, "2619": 0, "2621": 0, "2625": 0, "2627": 0, "2628": 0, "2629": 0, "2630": 0, "2632": 0, "2635": 0, "2639": 0, "2640": 0, "2642": 0, "2643": 0, "2644": 0, "2645": 0, "2647": 0, "2649": 0, "2650": 0, "2620": 0, "2631": 0, "2633": 0, "2658": 0, "2659": 0, "2661": 0, "2669": 0, "2670": 0, "2672": 0, "2675": 0, "2681": 0, "2691": 0, "2692": 0, "2706": 0, "2731": 2, "2732": 2, "2733": 0, "2734": 2, "2735": 2, "2736": 0, "2737": 0, "2739": 0, "2740": 6, "2741": 4, "2742": 2, "2781": 4, "2782": 0, "2783": 4, "2784": 4, "2785": 4, "2786": 4, "2787": 4, "2831": 0, "2832": 0, "2833": 0, "2834": 0, "2835": 0, "2836": 0, "2837": 0, "2838": 0, "2839": 0, "2840": 0, "2841": 0, "2842": 0, "2843": 0, "2844": 0, "2846": 0, "2847": 0, "2848": 0, "2849": 0, "2850": 0, "2851": 0, "2852": 0, "2853": 0, "2854": 0, "2855": 0, "2856": 0, "2857": 0, "2858": 0, "2859": 0, "2860": 0, "2861": 0, "2862": 0, "2863": 0, "2864": 0, "2865": 0, "2866": 0, "2867": 0, "2868": 0, "2869": 0, "2870": 0, "2871": 0, "2872": 0, "2873": 0, "2874": 0, "2875": 0, "2910": 0, "2911": 0, "2912": 0, "2913": 0, "2914": 0, "2915": 0, "2916": 0, "3002": 4, "3003": 4, "3004": 4, "3005": 4, "3006": 4, "3007": 4, "3008": 4, "3009": 4, "3010": 4, "3011": 4, "3012": 4, "3013": 4, "3014": 4, "3015": 4, "3016": 4, "3024": 0, "3025": 0, "3033": 2, "3034": 2, "3048": 0, "3062": 2, "3074": 2, "3075": 2, "3076": 2, "3078": 0, "3099": 2, "3100": 0, "3102": 2, "3104": 2, "3105": 0, "3106": 2, "3107": 0, "3109": 2, "3110": 0, "3111": 0, "3113": 0, "3115": 2, "3116": 2, "3118": 0, "3141": 6, "3154": 24, "3155": 24, "3156": 48, "3157": 24, "3158": 0, "3159": 24, "3229": 4, "3230": 0, "3231": 4, "3232": 0, "3233": 0, "3234": 0, "3235": 4, "3236": 0, "3237": 0, "3238": 0, "3240": 4, "3241": 4, "3242": 4, "3244": 4, "3245": 4, "3246": 0, "3247": 4, "3248": 0, "3250": 4, "3251": 0, "3252": 0, "3253": 0, "3256": 0, "3257": 0, "3258": 0, "3259": 0, "3262": 0, "3263": 4, "3264": 0, "3265": 0, "3267": 4, "3268": 4, "3269": 4, "3270": 4, "3271": 0, "3273": 4, "3274": 4, "3275": 2, "3277": 4, "3278": 4, "3280": 8, "3281": 4, "3282": 0, "3283": 0, "3284": 0, "3285": 0, "3286": 4, "3287": 4, "3297": 4, "3325": 0, "3326": 0, "3327": 0, "3328": 0, "3329": 0, "3331": 0, "3335": 0, "3350": 0, "3351": 0, "3352": 0, "3363": 0, "3364": 0, "3375": 0, "3376": 0, "3398": 0, "3399": 0, "3400": 0, "3431": 0, "3432": 0, "3433": 0, "3434": 0, "3435": 0, "3436": 0, "3448": 0, "3462": 4, "3474": 4, "3475": 4, "3476": 4, "3478": 0, "3499": 4, "3500": 0, "3502": 4, "3504": 4, "3505": 0, "3506": 4, "3507": 0, "3509": 4, "3510": 0, "3511": 0, "3513": 0, "3515": 4, "3516": 4, "3518": 0, "3541": 14, "3610": 8, "3611": 0, "3612": 8, "3613": 0, "3614": 0, "3615": 0, "3616": 8, "3617": 0, "3618": 0, "3619": 0, "3621": 8, "3622": 8, "3623": 8, "3625": 8, "3627": 8, "3628": 0, "3629": 8, "3630": 0, "3632": 8, "3633": 2, "3634": 0, "3635": 0, "3638": 0, "3639": 2, "3640": 0, "3641": 0, "3644": 0, "3645": 8, "3646": 0, "3647": 0, "3650": 8, "3651": 8, "3652": 8, "3653": 8, "3654": 2, "3656": 8, "3657": 8, "3658": 4, "3660": 8, "3661": 8, "3663": 16, "3664": 8, "3665": 0, "3666": 0, "3667": 0, "3668": 0, "3669": 8, "3670": 8, "3680": 8, "3708": 2, "3709": 4, "3710": 2, "3711": 2, "3712": 2, "3713": 2, "3717": 0, "3732": 0, "3733": 0, "3744": 0, "3745": 0, "3756": 0, "3757": 0, "3779": 0, "3780": 0, "3781": 0, "3812": 0, "3813": 0, "3814": 0, "3815": 0, "3828": 0, "3839": 0, "3848": 0, "3849": 0, "3858": 0, "3859": 0, "3863": 0, "3864": 0, "3866": 0, "3867": 0, "3868": 0, "3870": 0, "3871": 0, "3880": 0, "3881": 0, "3882": 0, "3883": 0, "3884": 0, "3885": 0, "3886": 0, "3887": 0, "3888": 0, "3890": 0, "3894": 0, "3895": 0, "3903": 0, "3909": 0, "3915": 0, "3925": 2, "3931": 0, "3941": 2, "3957": 0, "3958": 0, "3959": 0, "3973": 0, "3974": 0, "3975": 0, "4014": 0, "4015": 0, "4017": 0, "4019": 0, "4022": 0, "4023": 0, "4026": 0, "4027": 0, "4029": 0, "4030": 0, "4033": 0, "4034": 0, "4035": 0, "4038": 0, "4039": 0, "4040": 0, "4041": 0, "4042": 0, "4043": 0, "4045": 0, "4046": 0, "4047": 0, "4049": 0, "4050": 0, "4052": 0, "4055": 0, "4058": 0, "4059": 0, "4060": 0, "4062": 0, "4063": 0, "4065": 0, "4066": 0, "4067": 0, "4069": 0, "4070": 0, "4071": 0, "4072": 0, "4073": 0, "4075": 0, "4076": 0, "4078": 0, "4079": 0, "4080": 0, "4081": 0, "4082": 0, "4084": 0, "4085": 0, "4087": 0, "4088": 0, "4089": 0, "4091": 0, "4092": 0, "4093": 0, "4094": 0, "4095": 0, "4097": 0, "4098": 0, "4100": 0, "4101": 0, "4102": 0, "4103": 0, "4104": 0, "4106": 0, "4107": 0, "4108": 0, "4109": 0, "4110": 0, "4112": 0, "4113": 0, "4114": 0, "4115": 0, "4116": 0, "4117": 0, "4118": 0, "4120": 0, "4121": 0, "4122": 0, "4123": 0, "4124": 0, "4125": 0, "4126": 0, "4128": 0, "4129": 0, "4130": 0, "4132": 0, "4133": 0, "4134": 0, "4135": 0, "4137": 0, "4138": 0, "4156": 0, "4157": 0, "4158": 0, "4159": 0, "4160": 0, "4161": 0, "4162": 0, "4174": 0, "4195": 0, "4216": 0, "4217": 0, "4218": 0, "4219": 0, "4220": 0, "4221": 0, "4222": 0, "4223": 0, "4224": 0, "4225": 0, "4226": 0, "4227": 0, "4228": 0, "4229": 0, "4230": 0, "4231": 0, "4232": 0, "4233": 0, "4234": 0, "4235": 0, "4236": 0, "4237": 0, "4238": 0, "4239": 0, "4241": 0, "4243": 0, "4244": 0, "4246": 0, "4247": 0, "4248": 0, "4196": 0, "4197": 0, "4198": 0, "4200": 0, "4201": 0, "4202": 0, "4203": 0, "4204": 0, "4205": 0, "4206": 0, "4207": 0, "4208": 0, "4209": 0, "4210": 0, "4211": 0, "4213": 0, "4214": 0, "4253": 0, "4254": 0, "4255": 0, "4256": 0, "4257": 0, "4258": 0, "4259": 0, "4260": 0, "4252": 0, "4261": 0, "4262": 0, "4263": 0, "4264": 0, "4265": 0, "4270": 0, "4271": 0, "4272": 0, "4279": 0, "4290": 0, "4292": 0, "4294": 0, "4295": 0, "4297": 0, "4298": 0, "4299": 0, "4301": 0, "4302": 0, "4344": 0, "4346": 0, "4347": 0, "4349": 0, "4350": 0, "4351": 0, "4352": 0, "4354": 0, "4356": 0, "4357": 0, "4358": 0, "4359": 0, "4361": 0, "4362": 0, "4363": 0, "4365": 0, "4366": 0, "4367": 0, "4369": 0, "4370": 0, "4371": 0, "4372": 0, "4373": 0, "4374": 0, "4375": 0, "4377": 0, "4379": 0, "4380": 0, "4381": 0, "4383": 0, "4387": 0, "4388": 0, "4389": 0, "4390": 0, "4391": 0, "4394": 0, "4395": 0, "4396": 0, "4397": 0, "4398": 0, "4399": 0, "4400": 0, "4401": 0, "4403": 0, "4411": 0, "4412": 0, "4413": 0, "4414": 0, "4415": 0, "4416": 0, "4417": 0, "4439": 0, "4440": 0, "4441": 0, "4442": 0, "4443": 0, "4444": 0, "4445": 0, "4446": 0, "4447": 0, "4470": 0, "4471": 0, "4472": 0, "4473": 0, "4474": 0, "4475": 0, "4476": 0, "4477": 0, "4481": 0, "4485": 2}}
+ git checkout d65c9ca20ddf81ef91199e6d819f9d3506ef477c
Note: switching to 'd65c9ca20ddf81ef91199e6d819f9d3506ef477c'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at d65c9ca20d Merge pull request #14621 from meeseeksmachine/auto-backport-of-pr-14613-on-v3.1.x
M	lib/matplotlib/axes/_base.py
M	lib/matplotlib/ticker.py
M	lib/mpl_toolkits/mplot3d/axes3d.py
+ git apply /root/pre_state.patch
error: unrecognized input
