+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 14d026cccb144c6877294ba4cd4e03ebf0842498
+ sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen
+ locale-gen
Generating locales (this might take a while)...
  en_US.UTF-8... done
Generation complete.
+ export LANG=en_US.UTF-8
+ LANG=en_US.UTF-8
+ export LANGUAGE=en_US:en
+ LANGUAGE=en_US:en
+ export LC_ALL=en_US.UTF-8
+ LC_ALL=en_US.UTF-8
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 14d026cccb144c6877294ba4cd4e03ebf0842498
Author: Mariusz Felisiak <felisiak.mariusz@gmail.com>
Date:   Wed Jun 19 10:44:53 2019 +0200

    Fixed #30572 -- Prevented values()/values_list() on combined queryset from mutating the list of columns in querysets.

diff --git a/django/db/models/sql/compiler.py b/django/db/models/sql/compiler.py
index a44adfc760..a791908caf 100644
--- a/django/db/models/sql/compiler.py
+++ b/django/db/models/sql/compiler.py
@@ -426,6 +426,7 @@ class SQLCompiler:
                 # must have the same columns list. Set the selects defined on
                 # the query on all combined queries, if not already set.
                 if not compiler.query.values_select and self.query.values_select:
+                    compiler.query = compiler.query.clone()
                     compiler.query.set_values((
                         *self.query.extra_select,
                         *self.query.values_select,
diff --git a/tests/queries/test_qs_combinators.py b/tests/queries/test_qs_combinators.py
index 3902db59e2..227972e8c4 100644
--- a/tests/queries/test_qs_combinators.py
+++ b/tests/queries/test_qs_combinators.py
@@ -123,6 +123,9 @@ class QuerySetSetOperationTests(TestCase):
         self.assertEqual(reserved_name['order'], 2)
         reserved_name = qs1.union(qs1).values_list('name', 'order', 'id').get()
         self.assertEqual(reserved_name[:2], ('a', 2))
+        # List of columns can be changed.
+        reserved_name = qs1.union(qs1).values_list('order').get()
+        self.assertEqual(reserved_name, (2,))
 
     def test_union_with_two_annotated_values_list(self):
         qs1 = Number.objects.filter(num=1).annotate(
+ git diff 14d026cccb144c6877294ba4cd4e03ebf0842498
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
Requirement already satisfied: pytz in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190619084453) (2025.2)
Requirement already satisfied: sqlparse in /opt/miniconda3/envs/testbed/lib/python3.6/site-packages (from Django==3.0.dev20190619084453) (0.4.4)
Installing collected packages: Django
  Attempting uninstall: Django
    Found existing installation: Django 3.0.dev20190619084453
    Uninstalling Django-3.0.dev20190619084453:
      Successfully uninstalled Django-3.0.dev20190619084453
  Running setup.py develop for Django
Successfully installed Django-3.0.dev20190619084453
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv
+ git apply -v -
Checking patch django/db/models/sql/compiler.py...
Checking patch django/db/models/sql/query.py...
Applied patch django/db/models/sql/compiler.py cleanly.
Applied patch django/db/models/sql/query.py cleanly.
+ git apply -v -
Checking patch tests/test_coverup_django__django-10554.py...
Applied patch tests/test_coverup_django__django-10554.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(django/db/models/sql/compiler\.py|django/db/models/sql/query\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_coverup_django__django-10554
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(django/db/models/sql/compiler\\.py|django/db/models/sql/query\\.py)']
0.35 query.py(8): """
0.35 query.py(9): import difflib
0.35 query.py(10): import functools
0.35 query.py(11): import inspect
0.35 query.py(12): import sys
0.35 query.py(13): import warnings
0.35 query.py(14): from collections import Counter, namedtuple
0.35 query.py(15): from collections.abc import Iterator, Mapping
0.35 query.py(16): from itertools import chain, count, product
0.35 query.py(17): from string import ascii_uppercase
0.35 query.py(19): from django.core.exceptions import (
0.35 query.py(22): from django.db import DEFAULT_DB_ALIAS, NotSupportedError, connections
0.35 query.py(23): from django.db.models.aggregates import Count
0.35 query.py(24): from django.db.models.constants import LOOKUP_SEP
0.35 query.py(25): from django.db.models.expressions import (
0.35 query.py(28): from django.db.models.fields import Field
0.35 query.py(29): from django.db.models.fields.related_lookups import MultiColSource
0.35 query.py(30): from django.db.models.lookups import Lookup
0.35 query.py(31): from django.db.models.query_utils import (
0.35 query.py(34): from django.db.models.sql.constants import (
0.35 query.py(37): from django.db.models.sql.datastructures import (
0.35 query.py(40): from django.db.models.sql.where import (
0.35 query.py(43): from django.utils.deprecation import RemovedInDjango40Warning
0.35 query.py(44): from django.utils.functional import cached_property
0.35 query.py(45): from django.utils.tree import Node
0.35 query.py(47): __all__ = ['Query', 'RawQuery']
0.35 query.py(50): def get_field_names_from_opts(opts):
0.35 query.py(57): def get_children_from_q(q):
0.35 query.py(65): JoinInfo = namedtuple(
0.35 query.py(66):     'JoinInfo',
0.35 query.py(67):     ('final_field', 'targets', 'opts', 'joins', 'path', 'transform_function')
0.35 query.py(71): def _get_col(target, field, alias, simple_col):
0.35 query.py(77): class RawQuery:
0.35 query.py(77): class RawQuery:
0.35 query.py(78):     """A single raw SQL query."""
0.35 query.py(80):     def __init__(self, sql, using, params=None):
0.35 query.py(92):     def chain(self, using):
0.35 query.py(95):     def clone(self, using):
0.35 query.py(98):     def get_columns(self):
0.35 query.py(105):     def __iter__(self):
0.35 query.py(117):     def __repr__(self):
0.35 query.py(120):     @property
0.35 query.py(124):     def __str__(self):
0.35 query.py(127):     def _execute_query(self):
0.35 query.py(145): class Query(BaseExpression):
0.35 query.py(145): class Query(BaseExpression):
0.35 query.py(146):     """A single SQL query."""
0.35 query.py(148):     alias_prefix = 'T'
0.35 query.py(149):     subq_aliases = frozenset([alias_prefix])
0.35 query.py(151):     compiler = 'SQLCompiler'
0.35 query.py(153):     def __init__(self, model, where=WhereNode):
0.35 query.py(237):     @property
0.35 query.py(244):     @property
0.35 query.py(248):     @cached_property
0.35 query.py(253):     def __str__(self):
0.35 query.py(264):     def sql_with_params(self):
0.35 query.py(271):     def __deepcopy__(self, memo):
0.35 query.py(277):     def get_compiler(self, using=None, connection=None):
0.35 query.py(284):     def get_meta(self):
0.35 query.py(292):     def clone(self):
0.35 query.py(338):     def chain(self, klass=None):
0.35 query.py(353):     def relabeled_clone(self, change_map):
0.35 query.py(358):     def rewrite_cols(self, annotation, col_cnt):
0.35 query.py(410):     def get_aggregation(self, using, added_aggregate_names):
0.35 query.py(506):     def get_count(self, using):
0.35 query.py(517):     def has_filters(self):
0.35 query.py(520):     def has_results(self, using):
0.35 query.py(532):     def explain(self, using, format=None, **options):
0.35 query.py(540):     def combine(self, rhs, connector):
0.35 query.py(641):     def deferred_to_data(self, target, callback):
0.35 query.py(727):     def table_alias(self, table_name, create=False, filtered_relation=None):
0.35 query.py(752):     def ref_alias(self, alias):
0.35 query.py(756):     def unref_alias(self, alias, amount=1):
0.35 query.py(760):     def promote_joins(self, aliases):
0.35 query.py(794):     def demote_joins(self, aliases):
0.35 query.py(813):     def reset_refcounts(self, to_counts):
0.35 query.py(822):     def change_aliases(self, change_map):
0.35 query.py(858):     def bump_prefix(self, outer_query):
0.35 query.py(907):     def get_initial_alias(self):
0.35 query.py(919):     def count_active_tables(self):
0.35 query.py(927):     def join(self, join, reuse=None, reuse_with_filtered_relation=False):
0.35 query.py(975):     def join_parent_model(self, opts, model, alias, seen):
0.35 query.py(1008):     def add_annotation(self, annotation, alias, is_summary=False):
0.35 query.py(1015):     def resolve_expression(self, query, *args, **kwargs):
0.35 query.py(1043):     def as_sql(self, compiler, connection):
0.35 query.py(1049):     def resolve_lookup_value(self, value, can_reuse, allow_joins, simple_col):
0.35 query.py(1069):     def solve_lookup_type(self, lookup):
0.35 query.py(1087):     def check_query_object_type(self, value, opts, field):
0.35 query.py(1098):     def check_related_objects(self, field, value, opts):
0.35 query.py(1118):     def build_lookup(self, lookups, lhs, rhs):
0.35 query.py(1163):     def try_transform(self, lhs, name):
0.35 query.py(1185):                      reuse_with_filtered_relation=False, simple_col=False):
0.35 query.py(1304):     def add_filter(self, filter_clause):
0.35 query.py(1307):     def add_q(self, q_object):
0.35 query.py(1324):     def build_where(self, q_object):
0.35 query.py(1329):                simple_col=False):
0.35 query.py(1355):     def build_filtered_relation_q(self, q_object, reuse, branch_negated=False, current_negated=False):
0.35 query.py(1377):     def add_filtered_relation(self, filtered_relation, alias):
0.35 query.py(1390):     def names_to_path(self, names, opts, allow_many=True, fail_on_missing=False):
0.35 query.py(1487):                     reuse_with_filtered_relation=False):
0.35 query.py(1588):     def trim_joins(self, targets, joins, path):
0.35 query.py(1616):     def resolve_ref(self, name, allow_joins=True, reuse=None, summarize=False, simple_col=False):
0.35 query.py(1645):     def split_exclude(self, filter_expr, can_reuse, names_with_path):
0.35 query.py(1716):     def set_empty(self):
0.35 query.py(1719):     def is_empty(self):
0.35 query.py(1722):     def set_limits(self, low=None, high=None):
0.35 query.py(1745):     def clear_limits(self):
0.35 query.py(1749):     def has_limit_one(self):
0.35 query.py(1752):     def can_filter(self):
0.35 query.py(1760):     def clear_select_clause(self):
0.35 query.py(1768):     def clear_select_fields(self):
0.35 query.py(1777):     def add_select_col(self, col):
0.35 query.py(1781):     def set_select(self, cols):
0.35 query.py(1785):     def add_distinct_fields(self, *field_names):
0.35 query.py(1792):     def add_fields(self, field_names, allow_m2m=True):
0.35 query.py(1830):     def add_ordering(self, *ordering):
0.35 query.py(1855):     def clear_ordering(self, force_empty):
0.35 query.py(1865):     def set_group_by(self):
0.35 query.py(1892):     def add_select_related(self, fields):
0.35 query.py(1908):     def add_extra(self, select, select_params, where, params, tables, order_by):
0.35 query.py(1940):     def clear_deferred_loading(self):
0.35 query.py(1944):     def add_deferred_loading(self, field_names):
0.35 query.py(1964):     def add_immediate_loading(self, field_names):
0.35 query.py(1988):     def get_loaded_field_names(self):
0.35 query.py(2007):     def get_loaded_field_names_cb(self, target, model, fields):
0.35 query.py(2011):     def set_annotation_mask(self, names):
0.35 query.py(2019):     def append_annotation_mask(self, names):
0.35 query.py(2023):     def set_extra_mask(self, names):
0.35 query.py(2034):     def set_values(self, fields):
0.35 query.py(2069):     @property
0.35 query.py(2088):     @property
0.35 query.py(2103):     def trim_start(self, names_with_path):
0.35 query.py(2177):     def is_nullable(self, field):
0.35 query.py(2196): def get_order_dir(field, default='ASC'):
0.35 query.py(2210): def add_to_dict(data, key, value):
0.35 query.py(2221): def is_reverse_o2o(field):
0.35 query.py(2229): class JoinPromoter:
0.35 query.py(2229): class JoinPromoter:
0.35 query.py(2233):     """
0.35 query.py(2235):     def __init__(self, connector, num_children, negated):
0.35 query.py(2250):     def add_votes(self, votes):
0.35 query.py(2257):     def update_join_types(self, query):
Testing against Django installed in '/testbed/django'
Skipping setup of unused database(s): other.
Operations to perform:
  Synchronize unmigrated apps: auth, contenttypes, messages, sessions, staticfiles
  Apply all migrations: admin, sites
Synchronizing apps without migrations:
  Creating tables...
    Creating table django_content_type
    Creating table auth_permission
    Creating table auth_group
    Creating table auth_user
    Creating table django_session
    Running deferred SQL...
Running migrations:
  Applying admin.0001_initial...0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(343):         obj = self.clone()
0.67 query.py(297):         obj = Empty()
0.67 query.py(298):         obj.__class__ = self.__class__
0.67 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.67 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.67 query.py(303):         obj.alias_map = self.alias_map.copy()
0.67 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.67 query.py(305):         obj.table_map = self.table_map.copy()
0.67 query.py(306):         obj.where = self.where.clone()
0.67 query.py(307):         obj.annotations = self.annotations.copy()
0.67 query.py(308):         if self.annotation_select_mask is None:
0.67 query.py(309):             obj.annotation_select_mask = None
0.67 query.py(317):         obj._annotation_select_cache = None
0.67 query.py(318):         obj.extra = self.extra.copy()
0.67 query.py(319):         if self.extra_select_mask is None:
0.67 query.py(320):             obj.extra_select_mask = None
0.67 query.py(323):         if self._extra_select_cache is None:
0.67 query.py(324):             obj._extra_select_cache = None
0.67 query.py(327):         if 'subq_aliases' in self.__dict__:
0.67 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.67 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.67 query.py(332):         try:
0.67 query.py(333):             del obj.base_table
0.67 query.py(334):         except AttributeError:
0.67 query.py(335):             pass
0.67 query.py(336):         return obj
0.67 query.py(344):         if klass and obj.__class__ != klass:
0.67 query.py(346):         if not obj.filter_is_sticky:
0.67 query.py(347):             obj.used_aliases = set()
0.67 query.py(348):         obj.filter_is_sticky = False
0.67 query.py(349):         if hasattr(obj, '_setup_query'):
0.67 query.py(351):         return obj
0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(154):         self.model = model
0.67 query.py(155):         self.alias_refcount = {}
0.67 query.py(161):         self.alias_map = {}
0.67 query.py(165):         self.external_aliases = set()
0.67 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.67 query.py(167):         self.default_cols = True
0.67 query.py(168):         self.default_ordering = True
0.67 query.py(169):         self.standard_ordering = True
0.67 query.py(170):         self.used_aliases = set()
0.67 query.py(171):         self.filter_is_sticky = False
0.67 query.py(172):         self.subquery = False
0.67 query.py(180):         self.select = ()
0.67 query.py(181):         self.where = where()
0.67 query.py(182):         self.where_class = where
0.67 query.py(189):         self.group_by = None
0.67 query.py(190):         self.order_by = ()
0.67 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.67 query.py(192):         self.distinct = False
0.67 query.py(193):         self.distinct_fields = ()
0.67 query.py(194):         self.select_for_update = False
0.67 query.py(195):         self.select_for_update_nowait = False
0.67 query.py(196):         self.select_for_update_skip_locked = False
0.67 query.py(197):         self.select_for_update_of = ()
0.67 query.py(199):         self.select_related = False
0.67 query.py(201):         self.max_depth = 5
0.67 query.py(205):         self.values_select = ()
0.67 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.67 query.py(209):         self.annotation_select_mask = None
0.67 query.py(210):         self._annotation_select_cache = None
0.67 query.py(213):         self.combinator = None
0.67 query.py(214):         self.combinator_all = False
0.67 query.py(215):         self.combined_queries = ()
0.67 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.67 query.py(220):         self.extra_select_mask = None
0.67 query.py(221):         self._extra_select_cache = None
0.67 query.py(223):         self.extra_tables = ()
0.67 query.py(224):         self.extra_order_by = ()
0.67 query.py(229):         self.deferred_loading = (frozenset(), True)
0.67 query.py(231):         self._filtered_relations = {}
0.67 query.py(233):         self.explain_query = False
0.67 query.py(234):         self.explain_format = None
0.67 query.py(235):         self.explain_options = {}
0.67 query.py(278):         if using is None and connection is None:
0.67 query.py(280):         if using:
0.67 query.py(281):             connection = connections[using]
0.67 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.68 compiler.py(1): import collections
0.68 compiler.py(2): import re
0.68 compiler.py(3): import warnings
0.68 compiler.py(4): from itertools import chain
0.68 compiler.py(6): from django.core.exceptions import EmptyResultSet, FieldError
0.68 compiler.py(7): from django.db.models.constants import LOOKUP_SEP
0.68 compiler.py(8): from django.db.models.expressions import OrderBy, Random, RawSQL, Ref, Value
0.68 compiler.py(9): from django.db.models.functions import Cast
0.68 compiler.py(10): from django.db.models.query_utils import QueryWrapper, select_related_descend
0.68 compiler.py(11): from django.db.models.sql.constants import (
0.68 compiler.py(14): from django.db.models.sql.query import Query, get_order_dir
0.68 compiler.py(15): from django.db.transaction import TransactionManagementError
0.68 compiler.py(16): from django.db.utils import DatabaseError, NotSupportedError
0.68 compiler.py(17): from django.utils.deprecation import RemovedInDjango31Warning
0.68 compiler.py(18): from django.utils.hashable import make_hashable
0.68 compiler.py(20): FORCE = object()
0.68 compiler.py(23): class SQLCompiler:
0.68 compiler.py(23): class SQLCompiler:
0.68 compiler.py(24):     def __init__(self, query, connection, using):
0.68 compiler.py(40):     def setup_query(self):
0.68 compiler.py(46):     def pre_sql_setup(self):
0.68 compiler.py(60):     def get_group_by(self, select, order_by):
0.68 compiler.py(138):     def collapse_group_by(self, expressions, having):
0.68 compiler.py(184):     def get_select(self):
0.68 compiler.py(254):     def get_order_by(self):
0.68 compiler.py(378):     def get_extra_select(self, order_by, select):
0.68 compiler.py(388):     def quote_name_unless_alias(self, name):
0.68 compiler.py(405):     def compile(self, node, select_format=False):
0.68 compiler.py(415):     def get_combinator_sql(self, combinator, all):
0.68 compiler.py(470):     def as_sql(self, with_limits=True, with_col_aliases=False):
0.68 compiler.py(632):     def get_default_columns(self, start_alias=None, opts=None, from_parent=None):
0.68 compiler.py(676):     def get_distinct(self):
0.68 compiler.py(701):                            already_seen=None):
0.68 compiler.py(731):     def _setup_joins(self, pieces, opts, alias):
0.68 compiler.py(744):     def get_from_clause(self):
0.68 compiler.py(779):                                requested=None, restricted=None):
0.68 compiler.py(953):     def get_select_for_update_of_arguments(self):
0.68 compiler.py(1012):     def deferred_to_columns(self):
0.68 compiler.py(1022):     def get_converters(self, expressions):
0.68 compiler.py(1032):     def apply_converters(self, rows, converters):
0.68 compiler.py(1043):     def results_iter(self, results=None, tuple_expected=False, chunked_fetch=False,
0.68 compiler.py(1044):                      chunk_size=GET_ITERATOR_CHUNK_SIZE):
0.68 compiler.py(1057):     def has_results(self):
0.68 compiler.py(1067):     def execute_sql(self, result_type=MULTI, chunked_fetch=False, chunk_size=GET_ITERATOR_CHUNK_SIZE):
0.68 compiler.py(1134):     def as_subquery_condition(self, alias, columns, compiler):
0.68 compiler.py(1147):     def explain_query(self):
0.68 compiler.py(1158): class SQLInsertCompiler(SQLCompiler):
0.68 compiler.py(1158): class SQLInsertCompiler(SQLCompiler):
0.68 compiler.py(1159):     return_id = False
0.68 compiler.py(1161):     def field_as_sql(self, field, val):
0.68 compiler.py(1193):     def prepare_value(self, field, value):
0.68 compiler.py(1222):     def pre_save_val(self, field, obj):
0.68 compiler.py(1231):     def assemble_as_sql(self, fields, value_rows):
0.68 compiler.py(1266):     def as_sql(self):
0.68 compiler.py(1328):     def execute_sql(self, return_id=False):
0.68 compiler.py(1349): class SQLDeleteCompiler(SQLCompiler):
0.68 compiler.py(1349): class SQLDeleteCompiler(SQLCompiler):
0.68 compiler.py(1350):     def as_sql(self):
0.68 compiler.py(1365): class SQLUpdateCompiler(SQLCompiler):
0.68 compiler.py(1365): class SQLUpdateCompiler(SQLCompiler):
0.68 compiler.py(1366):     def as_sql(self):
0.68 compiler.py(1429):     def execute_sql(self, result_type):
0.68 compiler.py(1450):     def pre_sql_setup(self):
0.68 compiler.py(1493): class SQLAggregateCompiler(SQLCompiler):
0.68 compiler.py(1493): class SQLAggregateCompiler(SQLCompiler):
0.68 compiler.py(1494):     def as_sql(self):
0.68 compiler.py(1513): def cursor_iter(cursor, sentinel, col_count, itersize):
0.68 compiler.py(25):         self.query = query
0.68 compiler.py(26):         self.connection = connection
0.68 compiler.py(27):         self.using = using
0.68 compiler.py(28):         self.quote_cache = {'*': '*'}
0.68 compiler.py(33):         self.select = None
0.68 compiler.py(34):         self.annotation_col_map = None
0.68 compiler.py(35):         self.klass_info = None
0.68 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.68 compiler.py(38):         self._meta_ordering = None
0.68 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.68 compiler.py(1333):         self.return_id = return_id
0.68 compiler.py(1334):         with self.connection.cursor() as cursor:
0.68 compiler.py(1335):             for sql, params in self.as_sql():
0.68 compiler.py(1269):         qn = self.connection.ops.quote_name
0.68 compiler.py(1270):         opts = self.query.get_meta()
0.68 query.py(290):         return self.model._meta
0.68 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.68 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.68 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.68 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.68 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.68 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.68 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.68 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.68 compiler.py(1276):         if self.query.fields:
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1279):                 for obj in self.query.objs
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1279):                 for obj in self.query.objs
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1227):         if self.query.raw:
0.68 compiler.py(1229):         return field.pre_save(obj, add=True)
0.68 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.68 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.68 compiler.py(1220):         return value
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1227):         if self.query.raw:
0.68 compiler.py(1229):         return field.pre_save(obj, add=True)
0.68 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.68 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.68 compiler.py(1220):         return value
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1227):         if self.query.raw:
0.68 compiler.py(1229):         return field.pre_save(obj, add=True)
0.68 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.68 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.68 compiler.py(1220):         return value
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.68 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.68 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.68 compiler.py(1243):         if not value_rows:
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1250):             for row in value_rows
0.68 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.68 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.68 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1250):             for row in value_rows
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1170):         if field is None:
0.68 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.68 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.68 compiler.py(1182):             sql, params = '%s', [val]
0.68 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.68 compiler.py(1191):         return sql, params
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1170):         if field is None:
0.68 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.68 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.68 compiler.py(1182):             sql, params = '%s', [val]
0.68 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.68 compiler.py(1191):         return sql, params
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1170):         if field is None:
0.68 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.68 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.68 compiler.py(1182):             sql, params = '%s', [val]
0.68 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.68 compiler.py(1191):         return sql, params
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.68 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.68 compiler.py(1264):         return placeholder_rows, param_rows
0.68 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.68 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.68 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.68 compiler.py(1315):         if can_bulk:
0.68 compiler.py(1321):             if ignore_conflicts_suffix_sql:
0.68 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.68 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.68 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.68 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.68 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.68 compiler.py(1336):                 cursor.execute(sql, params)
0.68 compiler.py(1335):             for sql, params in self.as_sql():
0.68 compiler.py(1337):             if not return_id:
0.68 compiler.py(1339):             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
0.68 compiler.py(1341):             if self.connection.features.can_return_columns_from_insert:
0.68 compiler.py(1344):             return self.connection.ops.last_insert_id(
0.68 compiler.py(1345):                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
0.68 query.py(290):         return self.model._meta
0.68 query.py(290):         return self.model._meta
 OK
  Applying admin.0002_logentry_remove_auto_add...0.68 query.py(154):         self.model = model
0.68 query.py(155):         self.alias_refcount = {}
0.68 query.py(161):         self.alias_map = {}
0.68 query.py(165):         self.external_aliases = set()
0.68 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.68 query.py(167):         self.default_cols = True
0.68 query.py(168):         self.default_ordering = True
0.68 query.py(169):         self.standard_ordering = True
0.68 query.py(170):         self.used_aliases = set()
0.68 query.py(171):         self.filter_is_sticky = False
0.68 query.py(172):         self.subquery = False
0.68 query.py(180):         self.select = ()
0.68 query.py(181):         self.where = where()
0.68 query.py(182):         self.where_class = where
0.68 query.py(189):         self.group_by = None
0.68 query.py(190):         self.order_by = ()
0.68 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.68 query.py(192):         self.distinct = False
0.68 query.py(193):         self.distinct_fields = ()
0.68 query.py(194):         self.select_for_update = False
0.68 query.py(195):         self.select_for_update_nowait = False
0.68 query.py(196):         self.select_for_update_skip_locked = False
0.68 query.py(197):         self.select_for_update_of = ()
0.68 query.py(199):         self.select_related = False
0.68 query.py(201):         self.max_depth = 5
0.68 query.py(205):         self.values_select = ()
0.68 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.68 query.py(209):         self.annotation_select_mask = None
0.68 query.py(210):         self._annotation_select_cache = None
0.68 query.py(213):         self.combinator = None
0.68 query.py(214):         self.combinator_all = False
0.68 query.py(215):         self.combined_queries = ()
0.68 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.68 query.py(220):         self.extra_select_mask = None
0.68 query.py(221):         self._extra_select_cache = None
0.68 query.py(223):         self.extra_tables = ()
0.68 query.py(224):         self.extra_order_by = ()
0.68 query.py(229):         self.deferred_loading = (frozenset(), True)
0.68 query.py(231):         self._filtered_relations = {}
0.68 query.py(233):         self.explain_query = False
0.68 query.py(234):         self.explain_format = None
0.68 query.py(235):         self.explain_options = {}
0.68 query.py(343):         obj = self.clone()
0.68 query.py(297):         obj = Empty()
0.68 query.py(298):         obj.__class__ = self.__class__
0.68 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.68 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.68 query.py(303):         obj.alias_map = self.alias_map.copy()
0.68 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.68 query.py(305):         obj.table_map = self.table_map.copy()
0.68 query.py(306):         obj.where = self.where.clone()
0.68 query.py(307):         obj.annotations = self.annotations.copy()
0.68 query.py(308):         if self.annotation_select_mask is None:
0.68 query.py(309):             obj.annotation_select_mask = None
0.68 query.py(317):         obj._annotation_select_cache = None
0.68 query.py(318):         obj.extra = self.extra.copy()
0.68 query.py(319):         if self.extra_select_mask is None:
0.68 query.py(320):             obj.extra_select_mask = None
0.68 query.py(323):         if self._extra_select_cache is None:
0.68 query.py(324):             obj._extra_select_cache = None
0.68 query.py(327):         if 'subq_aliases' in self.__dict__:
0.68 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.68 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.68 query.py(332):         try:
0.68 query.py(333):             del obj.base_table
0.68 query.py(334):         except AttributeError:
0.68 query.py(335):             pass
0.68 query.py(336):         return obj
0.68 query.py(344):         if klass and obj.__class__ != klass:
0.68 query.py(346):         if not obj.filter_is_sticky:
0.68 query.py(347):             obj.used_aliases = set()
0.68 query.py(348):         obj.filter_is_sticky = False
0.68 query.py(349):         if hasattr(obj, '_setup_query'):
0.68 query.py(351):         return obj
0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(278):         if using is None and connection is None:
0.69 query.py(280):         if using:
0.69 query.py(281):             connection = connections[using]
0.69 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.69 compiler.py(25):         self.query = query
0.69 compiler.py(26):         self.connection = connection
0.69 compiler.py(27):         self.using = using
0.69 compiler.py(28):         self.quote_cache = {'*': '*'}
0.69 compiler.py(33):         self.select = None
0.69 compiler.py(34):         self.annotation_col_map = None
0.69 compiler.py(35):         self.klass_info = None
0.69 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.69 compiler.py(38):         self._meta_ordering = None
0.69 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.69 compiler.py(1333):         self.return_id = return_id
0.69 compiler.py(1334):         with self.connection.cursor() as cursor:
0.69 compiler.py(1335):             for sql, params in self.as_sql():
0.69 compiler.py(1269):         qn = self.connection.ops.quote_name
0.69 compiler.py(1270):         opts = self.query.get_meta()
0.69 query.py(290):         return self.model._meta
0.69 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.69 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.69 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1276):         if self.query.fields:
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1279):                 for obj in self.query.objs
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1279):                 for obj in self.query.objs
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.69 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.69 compiler.py(1243):         if not value_rows:
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1250):             for row in value_rows
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1250):             for row in value_rows
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1264):         return placeholder_rows, param_rows
0.69 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.69 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.69 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.69 compiler.py(1315):         if can_bulk:
0.69 compiler.py(1321):             if ignore_conflicts_suffix_sql:
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1336):                 cursor.execute(sql, params)
0.69 compiler.py(1335):             for sql, params in self.as_sql():
0.69 compiler.py(1337):             if not return_id:
0.69 compiler.py(1339):             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
0.69 compiler.py(1341):             if self.connection.features.can_return_columns_from_insert:
0.69 compiler.py(1344):             return self.connection.ops.last_insert_id(
0.69 compiler.py(1345):                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
0.69 query.py(290):         return self.model._meta
0.69 query.py(290):         return self.model._meta
 OK
  Applying admin.0003_logentry_add_action_flag_choices...0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(343):         obj = self.clone()
0.69 query.py(297):         obj = Empty()
0.69 query.py(298):         obj.__class__ = self.__class__
0.69 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.69 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.69 query.py(303):         obj.alias_map = self.alias_map.copy()
0.69 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.69 query.py(305):         obj.table_map = self.table_map.copy()
0.69 query.py(306):         obj.where = self.where.clone()
0.69 query.py(307):         obj.annotations = self.annotations.copy()
0.69 query.py(308):         if self.annotation_select_mask is None:
0.69 query.py(309):             obj.annotation_select_mask = None
0.69 query.py(317):         obj._annotation_select_cache = None
0.69 query.py(318):         obj.extra = self.extra.copy()
0.69 query.py(319):         if self.extra_select_mask is None:
0.69 query.py(320):             obj.extra_select_mask = None
0.69 query.py(323):         if self._extra_select_cache is None:
0.69 query.py(324):             obj._extra_select_cache = None
0.69 query.py(327):         if 'subq_aliases' in self.__dict__:
0.69 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.69 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.69 query.py(332):         try:
0.69 query.py(333):             del obj.base_table
0.69 query.py(334):         except AttributeError:
0.69 query.py(335):             pass
0.69 query.py(336):         return obj
0.69 query.py(344):         if klass and obj.__class__ != klass:
0.69 query.py(346):         if not obj.filter_is_sticky:
0.69 query.py(347):             obj.used_aliases = set()
0.69 query.py(348):         obj.filter_is_sticky = False
0.69 query.py(349):         if hasattr(obj, '_setup_query'):
0.69 query.py(351):         return obj
0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(154):         self.model = model
0.69 query.py(155):         self.alias_refcount = {}
0.69 query.py(161):         self.alias_map = {}
0.69 query.py(165):         self.external_aliases = set()
0.69 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.69 query.py(167):         self.default_cols = True
0.69 query.py(168):         self.default_ordering = True
0.69 query.py(169):         self.standard_ordering = True
0.69 query.py(170):         self.used_aliases = set()
0.69 query.py(171):         self.filter_is_sticky = False
0.69 query.py(172):         self.subquery = False
0.69 query.py(180):         self.select = ()
0.69 query.py(181):         self.where = where()
0.69 query.py(182):         self.where_class = where
0.69 query.py(189):         self.group_by = None
0.69 query.py(190):         self.order_by = ()
0.69 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.69 query.py(192):         self.distinct = False
0.69 query.py(193):         self.distinct_fields = ()
0.69 query.py(194):         self.select_for_update = False
0.69 query.py(195):         self.select_for_update_nowait = False
0.69 query.py(196):         self.select_for_update_skip_locked = False
0.69 query.py(197):         self.select_for_update_of = ()
0.69 query.py(199):         self.select_related = False
0.69 query.py(201):         self.max_depth = 5
0.69 query.py(205):         self.values_select = ()
0.69 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.69 query.py(209):         self.annotation_select_mask = None
0.69 query.py(210):         self._annotation_select_cache = None
0.69 query.py(213):         self.combinator = None
0.69 query.py(214):         self.combinator_all = False
0.69 query.py(215):         self.combined_queries = ()
0.69 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.69 query.py(220):         self.extra_select_mask = None
0.69 query.py(221):         self._extra_select_cache = None
0.69 query.py(223):         self.extra_tables = ()
0.69 query.py(224):         self.extra_order_by = ()
0.69 query.py(229):         self.deferred_loading = (frozenset(), True)
0.69 query.py(231):         self._filtered_relations = {}
0.69 query.py(233):         self.explain_query = False
0.69 query.py(234):         self.explain_format = None
0.69 query.py(235):         self.explain_options = {}
0.69 query.py(278):         if using is None and connection is None:
0.69 query.py(280):         if using:
0.69 query.py(281):             connection = connections[using]
0.69 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.69 compiler.py(25):         self.query = query
0.69 compiler.py(26):         self.connection = connection
0.69 compiler.py(27):         self.using = using
0.69 compiler.py(28):         self.quote_cache = {'*': '*'}
0.69 compiler.py(33):         self.select = None
0.69 compiler.py(34):         self.annotation_col_map = None
0.69 compiler.py(35):         self.klass_info = None
0.69 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.69 compiler.py(38):         self._meta_ordering = None
0.69 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.69 compiler.py(1333):         self.return_id = return_id
0.69 compiler.py(1334):         with self.connection.cursor() as cursor:
0.69 compiler.py(1335):             for sql, params in self.as_sql():
0.69 compiler.py(1269):         qn = self.connection.ops.quote_name
0.69 compiler.py(1270):         opts = self.query.get_meta()
0.69 query.py(290):         return self.model._meta
0.69 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.69 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.69 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.69 compiler.py(1276):         if self.query.fields:
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1279):                 for obj in self.query.objs
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1279):                 for obj in self.query.objs
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1227):         if self.query.raw:
0.69 compiler.py(1229):         return field.pre_save(obj, add=True)
0.69 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.69 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.69 compiler.py(1220):         return value
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.69 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.69 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.69 compiler.py(1243):         if not value_rows:
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1250):             for row in value_rows
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1250):             for row in value_rows
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1170):         if field is None:
0.69 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.69 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.69 compiler.py(1182):             sql, params = '%s', [val]
0.69 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.69 compiler.py(1191):         return sql, params
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.69 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.69 compiler.py(1264):         return placeholder_rows, param_rows
0.69 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.69 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.69 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.69 compiler.py(1315):         if can_bulk:
0.69 compiler.py(1321):             if ignore_conflicts_suffix_sql:
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.69 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.69 compiler.py(1336):                 cursor.execute(sql, params)
0.69 compiler.py(1335):             for sql, params in self.as_sql():
0.69 compiler.py(1337):             if not return_id:
0.69 compiler.py(1339):             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
0.69 compiler.py(1341):             if self.connection.features.can_return_columns_from_insert:
0.69 compiler.py(1344):             return self.connection.ops.last_insert_id(
0.69 compiler.py(1345):                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
0.69 query.py(290):         return self.model._meta
0.69 query.py(290):         return self.model._meta
 OK
  Applying sites.0001_initial...0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 compiler.py(25):         self.query = query
0.70 compiler.py(26):         self.connection = connection
0.70 compiler.py(27):         self.using = using
0.70 compiler.py(28):         self.quote_cache = {'*': '*'}
0.70 compiler.py(33):         self.select = None
0.70 compiler.py(34):         self.annotation_col_map = None
0.70 compiler.py(35):         self.klass_info = None
0.70 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.70 compiler.py(38):         self._meta_ordering = None
0.70 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.70 compiler.py(1333):         self.return_id = return_id
0.70 compiler.py(1334):         with self.connection.cursor() as cursor:
0.70 compiler.py(1335):             for sql, params in self.as_sql():
0.70 compiler.py(1269):         qn = self.connection.ops.quote_name
0.70 compiler.py(1270):         opts = self.query.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.70 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.70 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1276):         if self.query.fields:
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1279):                 for obj in self.query.objs
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1279):                 for obj in self.query.objs
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.70 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.70 compiler.py(1243):         if not value_rows:
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1250):             for row in value_rows
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1250):             for row in value_rows
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1264):         return placeholder_rows, param_rows
0.70 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.70 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.70 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.70 compiler.py(1315):         if can_bulk:
0.70 compiler.py(1321):             if ignore_conflicts_suffix_sql:
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1336):                 cursor.execute(sql, params)
0.70 compiler.py(1335):             for sql, params in self.as_sql():
0.70 compiler.py(1337):             if not return_id:
0.70 compiler.py(1339):             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
0.70 compiler.py(1341):             if self.connection.features.can_return_columns_from_insert:
0.70 compiler.py(1344):             return self.connection.ops.last_insert_id(
0.70 compiler.py(1345):                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
0.70 query.py(290):         return self.model._meta
0.70 query.py(290):         return self.model._meta
 OK
  Applying sites.0002_alter_domain_unique...0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 compiler.py(25):         self.query = query
0.70 compiler.py(26):         self.connection = connection
0.70 compiler.py(27):         self.using = using
0.70 compiler.py(28):         self.quote_cache = {'*': '*'}
0.70 compiler.py(33):         self.select = None
0.70 compiler.py(34):         self.annotation_col_map = None
0.70 compiler.py(35):         self.klass_info = None
0.70 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.70 compiler.py(38):         self._meta_ordering = None
0.70 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.70 compiler.py(1333):         self.return_id = return_id
0.70 compiler.py(1334):         with self.connection.cursor() as cursor:
0.70 compiler.py(1335):             for sql, params in self.as_sql():
0.70 compiler.py(1269):         qn = self.connection.ops.quote_name
0.70 compiler.py(1270):         opts = self.query.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.70 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.70 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.70 compiler.py(1276):         if self.query.fields:
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1279):                 for obj in self.query.objs
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1279):                 for obj in self.query.objs
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1227):         if self.query.raw:
0.70 compiler.py(1229):         return field.pre_save(obj, add=True)
0.70 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.70 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.70 compiler.py(1220):         return value
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.70 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.70 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.70 compiler.py(1243):         if not value_rows:
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1250):             for row in value_rows
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1250):             for row in value_rows
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1170):         if field is None:
0.70 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.70 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.70 compiler.py(1182):             sql, params = '%s', [val]
0.70 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.70 compiler.py(1191):         return sql, params
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.70 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.70 compiler.py(1264):         return placeholder_rows, param_rows
0.70 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.70 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.70 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.70 compiler.py(1315):         if can_bulk:
0.70 compiler.py(1321):             if ignore_conflicts_suffix_sql:
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1325):                 for p, vals in zip(placeholder_rows, param_rows)
0.70 compiler.py(1324):                 (" ".join(result + ["VALUES (%s)" % ", ".join(p)]), vals)
0.70 compiler.py(1336):                 cursor.execute(sql, params)
0.70 compiler.py(1335):             for sql, params in self.as_sql():
0.70 compiler.py(1337):             if not return_id:
0.70 compiler.py(1339):             if self.connection.features.can_return_rows_from_bulk_insert and len(self.query.objs) > 1:
0.70 compiler.py(1341):             if self.connection.features.can_return_columns_from_insert:
0.70 compiler.py(1344):             return self.connection.ops.last_insert_id(
0.70 compiler.py(1345):                 cursor, self.query.get_meta().db_table, self.query.get_meta().pk.column
0.70 query.py(290):         return self.model._meta
0.70 query.py(290):         return self.model._meta
 OK
0.70 query.py(154):         self.model = model
0.70 query.py(155):         self.alias_refcount = {}
0.70 query.py(161):         self.alias_map = {}
0.70 query.py(165):         self.external_aliases = set()
0.70 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.70 query.py(167):         self.default_cols = True
0.70 query.py(168):         self.default_ordering = True
0.70 query.py(169):         self.standard_ordering = True
0.70 query.py(170):         self.used_aliases = set()
0.70 query.py(171):         self.filter_is_sticky = False
0.70 query.py(172):         self.subquery = False
0.70 query.py(180):         self.select = ()
0.70 query.py(181):         self.where = where()
0.70 query.py(182):         self.where_class = where
0.70 query.py(189):         self.group_by = None
0.70 query.py(190):         self.order_by = ()
0.70 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.70 query.py(192):         self.distinct = False
0.70 query.py(193):         self.distinct_fields = ()
0.70 query.py(194):         self.select_for_update = False
0.70 query.py(195):         self.select_for_update_nowait = False
0.70 query.py(196):         self.select_for_update_skip_locked = False
0.70 query.py(197):         self.select_for_update_of = ()
0.70 query.py(199):         self.select_related = False
0.70 query.py(201):         self.max_depth = 5
0.70 query.py(205):         self.values_select = ()
0.70 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.70 query.py(209):         self.annotation_select_mask = None
0.70 query.py(210):         self._annotation_select_cache = None
0.70 query.py(213):         self.combinator = None
0.70 query.py(214):         self.combinator_all = False
0.70 query.py(215):         self.combined_queries = ()
0.70 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.70 query.py(220):         self.extra_select_mask = None
0.70 query.py(221):         self._extra_select_cache = None
0.70 query.py(223):         self.extra_tables = ()
0.70 query.py(224):         self.extra_order_by = ()
0.70 query.py(229):         self.deferred_loading = (frozenset(), True)
0.70 query.py(231):         self._filtered_relations = {}
0.70 query.py(233):         self.explain_query = False
0.70 query.py(234):         self.explain_format = None
0.70 query.py(235):         self.explain_options = {}
0.70 query.py(343):         obj = self.clone()
0.70 query.py(297):         obj = Empty()
0.70 query.py(298):         obj.__class__ = self.__class__
0.70 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.70 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.70 query.py(303):         obj.alias_map = self.alias_map.copy()
0.70 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.70 query.py(305):         obj.table_map = self.table_map.copy()
0.70 query.py(306):         obj.where = self.where.clone()
0.70 query.py(307):         obj.annotations = self.annotations.copy()
0.70 query.py(308):         if self.annotation_select_mask is None:
0.70 query.py(309):             obj.annotation_select_mask = None
0.70 query.py(317):         obj._annotation_select_cache = None
0.70 query.py(318):         obj.extra = self.extra.copy()
0.70 query.py(319):         if self.extra_select_mask is None:
0.70 query.py(320):             obj.extra_select_mask = None
0.70 query.py(323):         if self._extra_select_cache is None:
0.70 query.py(324):             obj._extra_select_cache = None
0.70 query.py(327):         if 'subq_aliases' in self.__dict__:
0.70 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.70 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.70 query.py(332):         try:
0.70 query.py(333):             del obj.base_table
0.70 query.py(334):         except AttributeError:
0.70 query.py(335):             pass
0.70 query.py(336):         return obj
0.70 query.py(344):         if klass and obj.__class__ != klass:
0.70 query.py(346):         if not obj.filter_is_sticky:
0.70 query.py(347):             obj.used_aliases = set()
0.70 query.py(348):         obj.filter_is_sticky = False
0.70 query.py(349):         if hasattr(obj, '_setup_query'):
0.70 query.py(351):         return obj
0.70 query.py(278):         if using is None and connection is None:
0.70 query.py(280):         if using:
0.70 query.py(281):             connection = connections[using]
0.70 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.70 compiler.py(25):         self.query = query
0.70 compiler.py(26):         self.connection = connection
0.70 compiler.py(27):         self.using = using
0.70 compiler.py(28):         self.quote_cache = {'*': '*'}
0.70 compiler.py(33):         self.select = None
0.70 compiler.py(34):         self.annotation_col_map = None
0.70 compiler.py(35):         self.klass_info = None
0.70 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.70 compiler.py(38):         self._meta_ordering = None
0.70 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.70 compiler.py(1081):         try:
0.70 compiler.py(1082):             sql, params = self.as_sql()
0.70 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.70 compiler.py(479):         try:
0.70 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.70 compiler.py(52):         self.setup_query()
0.70 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.70 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.70 compiler.py(42):             self.query.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.70 query.py(290):         return self.model._meta
0.70 query.py(943):         if reuse_with_filtered_relation and reuse:
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(950):                 a for a, j in self.alias_map.items()
0.70 query.py(953):         if reuse_aliases:
0.70 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.70 query.py(735):         alias_list = self.table_map.get(table_name)
0.70 query.py(736):         if not create and alias_list:
0.70 query.py(742):         if alias_list:
0.70 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.70 query.py(748):             self.table_map[table_name] = [alias]
0.70 query.py(749):         self.alias_refcount[alias] = 1
0.70 query.py(750):         return alias, True
0.70 query.py(965):         if join.join_type:
0.70 query.py(971):         join.table_alias = alias
0.70 query.py(972):         self.alias_map[alias] = join
0.70 query.py(973):         return alias
0.70 query.py(917):         return alias
0.70 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.70 compiler.py(202):         select = []
0.70 compiler.py(203):         klass_info = None
0.70 compiler.py(204):         annotations = {}
0.70 compiler.py(205):         select_idx = 0
0.70 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.70 compiler.py(211):         if self.query.default_cols:
0.70 compiler.py(212):             cols = self.get_default_columns()
0.70 compiler.py(644):         result = []
0.70 compiler.py(645):         if opts is None:
0.70 compiler.py(646):             opts = self.query.get_meta()
0.70 query.py(290):         return self.model._meta
0.70 compiler.py(647):         only_load = self.deferred_to_columns()
0.70 compiler.py(1018):         columns = {}
0.70 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.70 query.py(655):         field_names, defer = self.deferred_loading
0.70 query.py(656):         if not field_names:
0.70 query.py(657):             return
0.70 compiler.py(1020):         return columns
0.70 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.70 query.py(912):         if self.alias_map:
0.70 query.py(913):             alias = self.base_table
0.70 query.py(250):         for alias in self.alias_map:
0.70 query.py(251):             return alias
0.70 query.py(914):             self.ref_alias(alias)
0.70 query.py(754):         self.alias_refcount[alias] += 1
0.70 query.py(917):         return alias
0.70 compiler.py(652):         seen_models = {None: start_alias}
0.70 compiler.py(654):         for field in opts.concrete_fields:
0.70 compiler.py(655):             model = field.model._meta.concrete_model
0.70 compiler.py(658):             if model == opts.model:
0.70 compiler.py(659):                 model = None
0.70 compiler.py(660):             if from_parent and model is not None and issubclass(
0.70 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.70 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.70 compiler.py(671):                                                  seen_models)
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 compiler.py(672):             column = field.get_col(alias)
0.70 compiler.py(673):             result.append(column)
0.70 compiler.py(654):         for field in opts.concrete_fields:
0.70 compiler.py(655):             model = field.model._meta.concrete_model
0.70 compiler.py(658):             if model == opts.model:
0.70 compiler.py(659):                 model = None
0.70 compiler.py(660):             if from_parent and model is not None and issubclass(
0.70 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.70 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.70 compiler.py(671):                                                  seen_models)
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 compiler.py(672):             column = field.get_col(alias)
0.70 compiler.py(673):             result.append(column)
0.70 compiler.py(654):         for field in opts.concrete_fields:
0.70 compiler.py(655):             model = field.model._meta.concrete_model
0.70 compiler.py(658):             if model == opts.model:
0.70 compiler.py(659):                 model = None
0.70 compiler.py(660):             if from_parent and model is not None and issubclass(
0.70 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.70 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.70 compiler.py(671):                                                  seen_models)
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 compiler.py(672):             column = field.get_col(alias)
0.70 compiler.py(673):             result.append(column)
0.70 compiler.py(654):         for field in opts.concrete_fields:
0.70 compiler.py(655):             model = field.model._meta.concrete_model
0.70 compiler.py(658):             if model == opts.model:
0.70 compiler.py(659):                 model = None
0.70 compiler.py(660):             if from_parent and model is not None and issubclass(
0.70 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.70 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.70 compiler.py(671):                                                  seen_models)
0.70 query.py(984):         if model in seen:
0.70 query.py(985):             return seen[model]
0.70 compiler.py(672):             column = field.get_col(alias)
0.70 compiler.py(673):             result.append(column)
0.70 compiler.py(654):         for field in opts.concrete_fields:
0.70 compiler.py(674):         return result
0.70 compiler.py(217):         if cols:
0.70 compiler.py(218):             select_list = []
0.70 compiler.py(219):             for col in cols:
0.70 compiler.py(220):                 select_list.append(select_idx)
0.70 compiler.py(221):                 select.append((col, None))
0.70 compiler.py(222):                 select_idx += 1
0.70 compiler.py(219):             for col in cols:
0.70 compiler.py(220):                 select_list.append(select_idx)
0.70 compiler.py(221):                 select.append((col, None))
0.70 compiler.py(222):                 select_idx += 1
0.70 compiler.py(219):             for col in cols:
0.70 compiler.py(220):                 select_list.append(select_idx)
0.70 compiler.py(221):                 select.append((col, None))
0.70 compiler.py(222):                 select_idx += 1
0.70 compiler.py(219):             for col in cols:
0.70 compiler.py(220):                 select_list.append(select_idx)
0.70 compiler.py(221):                 select.append((col, None))
0.70 compiler.py(222):                 select_idx += 1
0.70 compiler.py(219):             for col in cols:
0.70 compiler.py(224):                 'model': self.query.model,
0.70 compiler.py(225):                 'select_fields': select_list,
0.70 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.70 query.py(2075):         if self._annotation_select_cache is not None:
0.70 query.py(2077):         elif not self.annotations:
0.70 query.py(2078):             return {}
0.70 compiler.py(232):         if self.query.select_related:
0.70 compiler.py(244):         ret = []
0.70 compiler.py(245):         for col, alias in select:
0.70 compiler.py(246):             try:
0.70 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.70 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.70 compiler.py(407):         if vendor_impl:
0.70 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.70 compiler.py(397):                 name in self.query.extra_select or (
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.70 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.70 compiler.py(402):         self.quote_cache[name] = r
0.70 compiler.py(403):         return r
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.70 compiler.py(397):                 name in self.query.extra_select or (
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.70 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.70 compiler.py(402):         self.quote_cache[name] = r
0.70 compiler.py(403):         return r
0.70 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.70 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.70 compiler.py(251):             ret.append((col, (sql, params), alias))
0.70 compiler.py(245):         for col, alias in select:
0.70 compiler.py(246):             try:
0.70 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.70 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.70 compiler.py(407):         if vendor_impl:
0.70 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(395):             return self.quote_cache[name]
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.70 compiler.py(397):                 name in self.query.extra_select or (
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.70 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.70 compiler.py(402):         self.quote_cache[name] = r
0.70 compiler.py(403):         return r
0.70 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.70 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.70 compiler.py(251):             ret.append((col, (sql, params), alias))
0.70 compiler.py(245):         for col, alias in select:
0.70 compiler.py(246):             try:
0.70 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.70 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.70 compiler.py(407):         if vendor_impl:
0.70 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(395):             return self.quote_cache[name]
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.70 compiler.py(397):                 name in self.query.extra_select or (
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.70 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.70 compiler.py(402):         self.quote_cache[name] = r
0.70 compiler.py(403):         return r
0.70 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.70 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.70 compiler.py(251):             ret.append((col, (sql, params), alias))
0.70 compiler.py(245):         for col, alias in select:
0.70 compiler.py(246):             try:
0.70 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.70 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.70 compiler.py(407):         if vendor_impl:
0.70 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(395):             return self.quote_cache[name]
0.70 compiler.py(394):         if name in self.quote_cache:
0.70 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.70 compiler.py(397):                 name in self.query.extra_select or (
0.70 query.py(2090):         if self._extra_select_cache is not None:
0.70 query.py(2092):         if not self.extra:
0.70 query.py(2093):             return {}
0.70 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.70 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.70 compiler.py(402):         self.quote_cache[name] = r
0.70 compiler.py(403):         return r
0.70 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.70 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.70 compiler.py(251):             ret.append((col, (sql, params), alias))
0.70 compiler.py(245):         for col, alias in select:
0.70 compiler.py(252):         return ret, klass_info, annotations
0.70 compiler.py(44):         self.col_count = len(self.select)
0.70 compiler.py(53):         order_by = self.get_order_by()
0.70 compiler.py(263):         if self.query.extra_order_by:
0.70 compiler.py(265):         elif not self.query.default_ordering:
0.70 compiler.py(267):         elif self.query.order_by:
0.70 compiler.py(269):         elif self.query.get_meta().ordering:
0.70 query.py(290):         return self.model._meta
0.70 compiler.py(273):             ordering = []
0.70 compiler.py(274):         if self.query.standard_ordering:
0.70 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.70 compiler.py(279):         order_by = []
0.70 compiler.py(280):         for field in ordering:
0.70 compiler.py(340):         result = []
0.70 compiler.py(341):         seen = set()
0.70 compiler.py(343):         for expr, is_ref in order_by:
0.70 compiler.py(376):         return result
0.70 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.70 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.70 compiler.py(379):         extra_select = []
0.70 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.70 compiler.py(386):         return extra_select
0.70 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.70 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.70 compiler.py(97):         if self.query.group_by is None:
0.70 compiler.py(98):             return []
0.70 compiler.py(58):         return extra_select, order_by, group_by
0.70 compiler.py(481):             for_update_part = None
0.70 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.70 compiler.py(484):             combinator = self.query.combinator
0.71 compiler.py(485):             features = self.connection.features
0.71 compiler.py(486):             if combinator:
0.71 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.71 compiler.py(683):         result = []
0.71 compiler.py(684):         params = []
0.71 compiler.py(685):         opts = self.query.get_meta()
0.71 query.py(290):         return self.model._meta
0.71 compiler.py(687):         for name in self.query.distinct_fields:
0.71 compiler.py(698):         return result, params
0.71 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.71 compiler.py(755):         result = []
0.71 compiler.py(756):         params = []
0.71 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.71 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.71 compiler.py(760):             try:
0.71 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.71 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.71 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.71 compiler.py(407):         if vendor_impl:
0.71 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.71 compiler.py(394):         if name in self.quote_cache:
0.71 compiler.py(395):             return self.quote_cache[name]
0.71 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.71 compiler.py(413):         return sql, params
0.71 compiler.py(767):             result.append(clause_sql)
0.71 compiler.py(768):             params.extend(clause_params)
0.71 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.71 compiler.py(769):         for t in self.query.extra_tables:
0.71 compiler.py(776):         return result, params
0.71 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.71 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.71 compiler.py(407):         if vendor_impl:
0.71 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.71 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.71 compiler.py(413):         return sql, params
0.71 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.71 compiler.py(497):                 result = ['SELECT']
0.71 compiler.py(498):                 params = []
0.71 compiler.py(500):                 if self.query.distinct:
0.71 compiler.py(508):                 out_cols = []
0.71 compiler.py(509):                 col_idx = 1
0.71 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.71 compiler.py(511):                     if alias:
0.71 compiler.py(513):                     elif with_col_aliases:
0.71 compiler.py(516):                     params.extend(s_params)
0.71 compiler.py(517):                     out_cols.append(s_sql)
0.71 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.71 compiler.py(511):                     if alias:
0.71 compiler.py(513):                     elif with_col_aliases:
0.71 compiler.py(516):                     params.extend(s_params)
0.71 compiler.py(517):                     out_cols.append(s_sql)
0.71 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.71 compiler.py(511):                     if alias:
0.71 compiler.py(513):                     elif with_col_aliases:
0.71 compiler.py(516):                     params.extend(s_params)
0.71 compiler.py(517):                     out_cols.append(s_sql)
0.71 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.71 compiler.py(511):                     if alias:
0.71 compiler.py(513):                     elif with_col_aliases:
0.71 compiler.py(516):                     params.extend(s_params)
0.71 compiler.py(517):                     out_cols.append(s_sql)
0.71 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.71 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.71 compiler.py(520):                 params.extend(f_params)
0.71 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.71 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.71 compiler.py(552):                 if where:
0.71 compiler.py(556):                 grouping = []
0.71 compiler.py(557):                 for g_sql, g_params in group_by:
0.71 compiler.py(560):                 if grouping:
0.71 compiler.py(577):                 if having:
0.71 compiler.py(581):             if self.query.explain_query:
0.71 compiler.py(587):             if order_by:
0.71 compiler.py(594):             if with_limit_offset:
0.71 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.71 compiler.py(600):             if self.query.subquery and extra_select:
0.71 compiler.py(627):             return ' '.join(result), tuple(params)
0.71 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.71 query.py(820):             self.unref_alias(alias, unref_amount)
0.71 query.py(758):         self.alias_refcount[alias] -= amount
0.71 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.71 compiler.py(1083):             if not sql:
0.71 compiler.py(1090):         if chunked_fetch:
0.71 compiler.py(1093):             cursor = self.connection.cursor()
0.71 compiler.py(1094):         try:
0.71 compiler.py(1095):             cursor.execute(sql, params)
0.71 compiler.py(1101):         if result_type == CURSOR:
0.71 compiler.py(1104):         if result_type == SINGLE:
0.71 compiler.py(1113):         if result_type == NO_RESULTS:
0.71 compiler.py(1117):         result = cursor_iter(
0.71 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.71 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.71 compiler.py(1120):             chunk_size,
0.71 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.71 compiler.py(1123):             try:
0.71 compiler.py(1128):                 return list(result)
0.71 compiler.py(1518):     try:
0.71 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.71 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.71 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.71 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.71 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.71 compiler.py(1522):         cursor.close()
0.71 compiler.py(1131):                 cursor.close()
0.71 compiler.py(1046):         if results is None:
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.71 compiler.py(1049):         converters = self.get_converters(fields)
0.71 compiler.py(1023):         converters = {}
0.71 compiler.py(1024):         for i, expression in enumerate(expressions):
0.71 compiler.py(1025):             if expression:
0.71 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.71 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.71 compiler.py(1028):                 if backend_converters or field_converters:
0.71 compiler.py(1024):         for i, expression in enumerate(expressions):
0.71 compiler.py(1025):             if expression:
0.71 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.71 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.71 compiler.py(1028):                 if backend_converters or field_converters:
0.71 compiler.py(1024):         for i, expression in enumerate(expressions):
0.71 compiler.py(1025):             if expression:
0.71 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.71 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.71 compiler.py(1028):                 if backend_converters or field_converters:
0.71 compiler.py(1024):         for i, expression in enumerate(expressions):
0.71 compiler.py(1025):             if expression:
0.71 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.71 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.71 compiler.py(1028):                 if backend_converters or field_converters:
0.71 compiler.py(1029):                     converters[i] = (backend_converters + field_converters, expression)
0.71 compiler.py(1024):         for i, expression in enumerate(expressions):
0.71 compiler.py(1030):         return converters
0.71 compiler.py(1050):         rows = chain.from_iterable(results)
0.71 compiler.py(1051):         if converters:
0.71 compiler.py(1052):             rows = self.apply_converters(rows, converters)
0.71 compiler.py(1053):             if tuple_expected:
0.71 compiler.py(1055):         return rows
0.71 compiler.py(1033):         connection = self.connection
0.71 compiler.py(1034):         converters = list(converters.items())
0.71 compiler.py(1035):         for row in map(list, rows):
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1037):                 value = row[pos]
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1039):                     value = converter(value, expression, connection)
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1040):                 row[pos] = value
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1041):             yield row
0.71 compiler.py(1035):         for row in map(list, rows):
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1037):                 value = row[pos]
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1039):                     value = converter(value, expression, connection)
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1040):                 row[pos] = value
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1041):             yield row
0.71 compiler.py(1035):         for row in map(list, rows):
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1037):                 value = row[pos]
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1039):                     value = converter(value, expression, connection)
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1040):                 row[pos] = value
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1041):             yield row
0.71 compiler.py(1035):         for row in map(list, rows):
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1037):                 value = row[pos]
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1039):                     value = converter(value, expression, connection)
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1040):                 row[pos] = value
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1041):             yield row
0.71 compiler.py(1035):         for row in map(list, rows):
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1037):                 value = row[pos]
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1039):                     value = converter(value, expression, connection)
0.71 compiler.py(1038):                 for converter in convs:
0.71 compiler.py(1040):                 row[pos] = value
0.71 compiler.py(1036):             for pos, (convs, expression) in converters:
0.71 compiler.py(1041):             yield row
0.71 compiler.py(1035):         for row in map(list, rows):
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1758):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.72 query.py(1331):         connector = q_object.connector
0.72 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.72 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.72 query.py(1334):         target_clause = self.where_class(connector=connector,
0.72 query.py(1335):                                          negated=q_object.negated)
0.72 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.72 query.py(2236):         self.connector = connector
0.72 query.py(2237):         self.negated = negated
0.72 query.py(2238):         if self.negated:
0.72 query.py(2244):             self.effective_connector = self.connector
0.72 query.py(2245):         self.num_children = num_children
0.72 query.py(2248):         self.votes = Counter()
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.72 query.py(290):         return self.model._meta
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2255):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.72 query.py(2264):         to_promote = set()
0.72 query.py(2265):         to_demote = set()
0.72 query.py(2268):         for table, votes in self.votes.items():
0.72 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2291):             if self.effective_connector == 'AND' or (
0.72 query.py(2293):                 to_demote.add(table)
0.72 query.py(2268):         for table, votes in self.votes.items():
0.72 query.py(2309):         query.promote_joins(to_promote)
0.72 query.py(771):         aliases = list(aliases)
0.72 query.py(772):         while aliases:
0.72 query.py(2310):         query.demote_joins(to_demote)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(2311):         return to_demote
0.72 query.py(1353):         return target_clause, needed_inner
0.72 query.py(1320):         if clause:
0.72 query.py(1321):             self.where.add(clause, AND)
0.72 query.py(1322):         self.demote_joins(existing_inner)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 compiler.py(25):         self.query = query
0.72 compiler.py(26):         self.connection = connection
0.72 compiler.py(27):         self.using = using
0.72 compiler.py(28):         self.quote_cache = {'*': '*'}
0.72 compiler.py(33):         self.select = None
0.72 compiler.py(34):         self.annotation_col_map = None
0.72 compiler.py(35):         self.klass_info = None
0.72 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.72 compiler.py(38):         self._meta_ordering = None
0.72 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.72 compiler.py(1081):         try:
0.72 compiler.py(1082):             sql, params = self.as_sql()
0.72 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.72 compiler.py(479):         try:
0.72 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.72 compiler.py(52):         self.setup_query()
0.72 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.72 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.72 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.72 compiler.py(202):         select = []
0.72 compiler.py(203):         klass_info = None
0.72 compiler.py(204):         annotations = {}
0.72 compiler.py(205):         select_idx = 0
0.72 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.72 compiler.py(211):         if self.query.default_cols:
0.72 compiler.py(212):             cols = self.get_default_columns()
0.72 compiler.py(644):         result = []
0.72 compiler.py(645):         if opts is None:
0.72 compiler.py(646):             opts = self.query.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(647):         only_load = self.deferred_to_columns()
0.72 compiler.py(1018):         columns = {}
0.72 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.72 query.py(655):         field_names, defer = self.deferred_loading
0.72 query.py(656):         if not field_names:
0.72 query.py(657):             return
0.72 compiler.py(1020):         return columns
0.72 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 compiler.py(652):         seen_models = {None: start_alias}
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(674):         return result
0.72 compiler.py(217):         if cols:
0.72 compiler.py(218):             select_list = []
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(224):                 'model': self.query.model,
0.72 compiler.py(225):                 'select_fields': select_list,
0.72 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.72 query.py(2075):         if self._annotation_select_cache is not None:
0.72 query.py(2077):         elif not self.annotations:
0.72 query.py(2078):             return {}
0.72 compiler.py(232):         if self.query.select_related:
0.72 compiler.py(244):         ret = []
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(252):         return ret, klass_info, annotations
0.72 compiler.py(44):         self.col_count = len(self.select)
0.72 compiler.py(53):         order_by = self.get_order_by()
0.72 compiler.py(263):         if self.query.extra_order_by:
0.72 compiler.py(265):         elif not self.query.default_ordering:
0.72 compiler.py(267):         elif self.query.order_by:
0.72 compiler.py(269):         elif self.query.get_meta().ordering:
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(273):             ordering = []
0.72 compiler.py(274):         if self.query.standard_ordering:
0.72 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.72 compiler.py(279):         order_by = []
0.72 compiler.py(280):         for field in ordering:
0.72 compiler.py(340):         result = []
0.72 compiler.py(341):         seen = set()
0.72 compiler.py(343):         for expr, is_ref in order_by:
0.72 compiler.py(376):         return result
0.72 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.72 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.72 compiler.py(379):         extra_select = []
0.72 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.72 compiler.py(386):         return extra_select
0.72 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.72 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.72 compiler.py(97):         if self.query.group_by is None:
0.72 compiler.py(98):             return []
0.72 compiler.py(58):         return extra_select, order_by, group_by
0.72 compiler.py(481):             for_update_part = None
0.72 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.72 compiler.py(484):             combinator = self.query.combinator
0.72 compiler.py(485):             features = self.connection.features
0.72 compiler.py(486):             if combinator:
0.72 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.72 compiler.py(683):         result = []
0.72 compiler.py(684):         params = []
0.72 compiler.py(685):         opts = self.query.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(687):         for name in self.query.distinct_fields:
0.72 compiler.py(698):         return result, params
0.72 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.72 compiler.py(755):         result = []
0.72 compiler.py(756):         params = []
0.72 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.72 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.72 compiler.py(760):             try:
0.72 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.72 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(767):             result.append(clause_sql)
0.72 compiler.py(768):             params.extend(clause_params)
0.72 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.72 compiler.py(769):         for t in self.query.extra_tables:
0.72 compiler.py(776):         return result, params
0.72 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.72 compiler.py(497):                 result = ['SELECT']
0.72 compiler.py(498):                 params = []
0.72 compiler.py(500):                 if self.query.distinct:
0.72 compiler.py(508):                 out_cols = []
0.72 compiler.py(509):                 col_idx = 1
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.72 compiler.py(520):                 params.extend(f_params)
0.72 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.72 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.72 compiler.py(552):                 if where:
0.72 compiler.py(553):                     result.append('WHERE %s' % where)
0.72 compiler.py(554):                     params.extend(w_params)
0.72 compiler.py(556):                 grouping = []
0.72 compiler.py(557):                 for g_sql, g_params in group_by:
0.72 compiler.py(560):                 if grouping:
0.72 compiler.py(577):                 if having:
0.72 compiler.py(581):             if self.query.explain_query:
0.72 compiler.py(587):             if order_by:
0.72 compiler.py(594):             if with_limit_offset:
0.72 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.72 compiler.py(600):             if self.query.subquery and extra_select:
0.72 compiler.py(627):             return ' '.join(result), tuple(params)
0.72 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 compiler.py(1083):             if not sql:
0.72 compiler.py(1090):         if chunked_fetch:
0.72 compiler.py(1093):             cursor = self.connection.cursor()
0.72 compiler.py(1094):         try:
0.72 compiler.py(1095):             cursor.execute(sql, params)
0.72 compiler.py(1101):         if result_type == CURSOR:
0.72 compiler.py(1104):         if result_type == SINGLE:
0.72 compiler.py(1113):         if result_type == NO_RESULTS:
0.72 compiler.py(1117):         result = cursor_iter(
0.72 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.72 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.72 compiler.py(1120):             chunk_size,
0.72 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.72 compiler.py(1123):             try:
0.72 compiler.py(1128):                 return list(result)
0.72 compiler.py(1518):     try:
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1522):         cursor.close()
0.72 compiler.py(1131):                 cursor.close()
0.72 compiler.py(1046):         if results is None:
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1049):         converters = self.get_converters(fields)
0.72 compiler.py(1023):         converters = {}
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1030):         return converters
0.72 compiler.py(1050):         rows = chain.from_iterable(results)
0.72 compiler.py(1051):         if converters:
0.72 compiler.py(1055):         return rows
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 compiler.py(25):         self.query = query
0.72 compiler.py(26):         self.connection = connection
0.72 compiler.py(27):         self.using = using
0.72 compiler.py(28):         self.quote_cache = {'*': '*'}
0.72 compiler.py(33):         self.select = None
0.72 compiler.py(34):         self.annotation_col_map = None
0.72 compiler.py(35):         self.klass_info = None
0.72 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.72 compiler.py(38):         self._meta_ordering = None
0.72 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.72 compiler.py(1333):         self.return_id = return_id
0.72 compiler.py(1334):         with self.connection.cursor() as cursor:
0.72 compiler.py(1335):             for sql, params in self.as_sql():
0.72 compiler.py(1269):         qn = self.connection.ops.quote_name
0.72 compiler.py(1270):         opts = self.query.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.72 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.72 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.72 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.72 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.72 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.72 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.72 compiler.py(1276):         if self.query.fields:
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1279):                 for obj in self.query.objs
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1279):                 for obj in self.query.objs
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1227):         if self.query.raw:
0.72 compiler.py(1229):         return field.pre_save(obj, add=True)
0.72 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.72 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.72 compiler.py(1220):         return value
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1227):         if self.query.raw:
0.72 compiler.py(1229):         return field.pre_save(obj, add=True)
0.72 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.72 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.72 compiler.py(1220):         return value
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.72 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.72 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.72 compiler.py(1243):         if not value_rows:
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1250):             for row in value_rows
0.72 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.72 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.72 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1250):             for row in value_rows
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1170):         if field is None:
0.72 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.72 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.72 compiler.py(1182):             sql, params = '%s', [val]
0.72 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.72 compiler.py(1191):         return sql, params
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1170):         if field is None:
0.72 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.72 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.72 compiler.py(1182):             sql, params = '%s', [val]
0.72 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.72 compiler.py(1191):         return sql, params
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.72 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.72 compiler.py(1264):         return placeholder_rows, param_rows
0.72 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.72 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.72 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.72 compiler.py(1315):         if can_bulk:
0.72 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.72 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.72 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.72 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.72 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.72 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.72 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.72 compiler.py(1336):                 cursor.execute(sql, params)
0.72 compiler.py(1335):             for sql, params in self.as_sql():
0.72 compiler.py(1337):             if not return_id:
0.72 compiler.py(1338):                 return
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1758):         return not self.low_mark and self.high_mark is None
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.72 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.72 query.py(1331):         connector = q_object.connector
0.72 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.72 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.72 query.py(1334):         target_clause = self.where_class(connector=connector,
0.72 query.py(1335):                                          negated=q_object.negated)
0.72 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.72 query.py(2236):         self.connector = connector
0.72 query.py(2237):         self.negated = negated
0.72 query.py(2238):         if self.negated:
0.72 query.py(2244):             self.effective_connector = self.connector
0.72 query.py(2245):         self.num_children = num_children
0.72 query.py(2248):         self.votes = Counter()
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1338):             if isinstance(child, Node):
0.72 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.72 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.72 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.72 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.72 query.py(1214):         if isinstance(filter_expr, dict):
0.72 query.py(1216):         arg, value = filter_expr
0.72 query.py(1217):         if not arg:
0.72 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.72 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.72 query.py(1074):         if self.annotations:
0.72 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.72 query.py(290):         return self.model._meta
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.72 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.72 query.py(1085):         return lookup_parts, field_parts, False
0.72 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.72 query.py(1227):         if not allow_joins and len(parts) > 1:
0.72 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.72 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.72 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.72 query.py(1055):         elif isinstance(value, (list, tuple)):
0.72 query.py(1067):         return value
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.72 query.py(1234):         clause = self.where_class()
0.72 query.py(1235):         if reffed_expression:
0.72 query.py(1240):         opts = self.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 query.py(1241):         alias = self.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.72 query.py(290):         return self.model._meta
0.72 query.py(943):         if reuse_with_filtered_relation and reuse:
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(950):                 a for a, j in self.alias_map.items()
0.72 query.py(953):         if reuse_aliases:
0.72 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.72 query.py(735):         alias_list = self.table_map.get(table_name)
0.72 query.py(736):         if not create and alias_list:
0.72 query.py(742):         if alias_list:
0.72 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.72 query.py(748):             self.table_map[table_name] = [alias]
0.72 query.py(749):         self.alias_refcount[alias] = 1
0.72 query.py(750):         return alias, True
0.72 query.py(965):         if join.join_type:
0.72 query.py(971):         join.table_alias = alias
0.72 query.py(972):         self.alias_map[alias] = join
0.72 query.py(973):         return alias
0.72 query.py(917):         return alias
0.72 query.py(1242):         allow_many = not branch_negated or not split_subq
0.72 query.py(1244):         try:
0.72 query.py(1245):             join_info = self.setup_joins(
0.72 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.72 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.72 query.py(1518):         joins = [alias]
0.72 query.py(1524):         def final_transformer(field, alias):
0.72 query.py(1529):         last_field_exception = None
0.72 query.py(1530):         for pivot in range(len(names), 0, -1):
0.72 query.py(1531):             try:
0.72 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.72 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.72 query.py(1405):         path, names_with_path = [], []
0.72 query.py(1406):         for pos, name in enumerate(names):
0.72 query.py(1407):             cur_names_with_path = (name, [])
0.72 query.py(1408):             if name == 'pk':
0.72 query.py(1411):             field = None
0.72 query.py(1412):             filtered_relation = None
0.72 query.py(1413):             try:
0.72 query.py(1414):                 field = opts.get_field(name)
0.72 query.py(1421):             if field is not None:
0.72 query.py(1425):                 if field.is_relation and not field.related_model:
0.72 query.py(1432):                 try:
0.72 query.py(1433):                     model = field.model._meta.concrete_model
0.72 query.py(1454):             if model is not opts.model:
0.72 query.py(1460):             if hasattr(field, 'get_path_info'):
0.72 query.py(1477):                 final_field = field
0.72 query.py(1478):                 targets = (field,)
0.72 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.72 query.py(1483):                 break
0.72 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.72 query.py(1545):                 transforms = names[pivot:]
0.72 query.py(1546):                 break
0.72 query.py(1547):         for name in transforms:
0.72 query.py(1562):         for join in path:
0.72 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.72 query.py(1251):             if isinstance(value, Iterator):
0.72 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.72 query.py(1100):         if field.is_relation:
0.72 query.py(1257):             self._lookup_joins = join_info.joins
0.72 query.py(1263):         used_joins.update(join_info.joins)
0.72 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.72 query.py(1601):         joins = joins[:]
0.72 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.72 query.py(1614):         return targets, joins[-1], joins
0.72 query.py(1265):         if can_reuse is not None:
0.72 query.py(1266):             can_reuse.update(join_list)
0.72 query.py(1268):         if join_info.final_field.is_relation:
0.72 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.72 query.py(72):     if simple_col:
0.72 query.py(74):     return target.get_col(alias, field)
0.72 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.72 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.72 query.py(1129):         for name in transforms:
0.72 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.72 query.py(1134):         if not lookup_class:
0.72 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.72 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.72 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.72 query.py(1161):         return lookup
0.72 query.py(1281):         lookup_type = condition.lookup_name
0.72 query.py(1282):         clause.add(condition, AND)
0.72 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.72 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.72 query.py(1302):         return clause, used_joins if not require_outer else ()
0.72 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.72 query.py(2255):         self.votes.update(votes)
0.72 query.py(1350):             if child_clause:
0.72 query.py(1351):                 target_clause.add(child_clause, connector)
0.72 query.py(1337):         for child in q_object.children:
0.72 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.72 query.py(2264):         to_promote = set()
0.72 query.py(2265):         to_demote = set()
0.72 query.py(2268):         for table, votes in self.votes.items():
0.72 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.72 query.py(2291):             if self.effective_connector == 'AND' or (
0.72 query.py(2293):                 to_demote.add(table)
0.72 query.py(2268):         for table, votes in self.votes.items():
0.72 query.py(2309):         query.promote_joins(to_promote)
0.72 query.py(771):         aliases = list(aliases)
0.72 query.py(772):         while aliases:
0.72 query.py(2310):         query.demote_joins(to_demote)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(806):             alias = aliases.pop(0)
0.72 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.72 query.py(805):         while aliases:
0.72 query.py(2311):         return to_demote
0.72 query.py(1353):         return target_clause, needed_inner
0.72 query.py(1320):         if clause:
0.72 query.py(1321):             self.where.add(clause, AND)
0.72 query.py(1322):         self.demote_joins(existing_inner)
0.72 query.py(804):         aliases = list(aliases)
0.72 query.py(805):         while aliases:
0.72 query.py(278):         if using is None and connection is None:
0.72 query.py(280):         if using:
0.72 query.py(281):             connection = connections[using]
0.72 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.72 compiler.py(25):         self.query = query
0.72 compiler.py(26):         self.connection = connection
0.72 compiler.py(27):         self.using = using
0.72 compiler.py(28):         self.quote_cache = {'*': '*'}
0.72 compiler.py(33):         self.select = None
0.72 compiler.py(34):         self.annotation_col_map = None
0.72 compiler.py(35):         self.klass_info = None
0.72 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.72 compiler.py(38):         self._meta_ordering = None
0.72 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.72 compiler.py(1081):         try:
0.72 compiler.py(1082):             sql, params = self.as_sql()
0.72 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.72 compiler.py(479):         try:
0.72 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.72 compiler.py(52):         self.setup_query()
0.72 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.72 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.72 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.72 compiler.py(202):         select = []
0.72 compiler.py(203):         klass_info = None
0.72 compiler.py(204):         annotations = {}
0.72 compiler.py(205):         select_idx = 0
0.72 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.72 compiler.py(211):         if self.query.default_cols:
0.72 compiler.py(212):             cols = self.get_default_columns()
0.72 compiler.py(644):         result = []
0.72 compiler.py(645):         if opts is None:
0.72 compiler.py(646):             opts = self.query.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(647):         only_load = self.deferred_to_columns()
0.72 compiler.py(1018):         columns = {}
0.72 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.72 query.py(655):         field_names, defer = self.deferred_loading
0.72 query.py(656):         if not field_names:
0.72 query.py(657):             return
0.72 compiler.py(1020):         return columns
0.72 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.72 query.py(912):         if self.alias_map:
0.72 query.py(913):             alias = self.base_table
0.72 query.py(250):         for alias in self.alias_map:
0.72 query.py(251):             return alias
0.72 query.py(914):             self.ref_alias(alias)
0.72 query.py(754):         self.alias_refcount[alias] += 1
0.72 query.py(917):         return alias
0.72 compiler.py(652):         seen_models = {None: start_alias}
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(655):             model = field.model._meta.concrete_model
0.72 compiler.py(658):             if model == opts.model:
0.72 compiler.py(659):                 model = None
0.72 compiler.py(660):             if from_parent and model is not None and issubclass(
0.72 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.72 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.72 compiler.py(671):                                                  seen_models)
0.72 query.py(984):         if model in seen:
0.72 query.py(985):             return seen[model]
0.72 compiler.py(672):             column = field.get_col(alias)
0.72 compiler.py(673):             result.append(column)
0.72 compiler.py(654):         for field in opts.concrete_fields:
0.72 compiler.py(674):         return result
0.72 compiler.py(217):         if cols:
0.72 compiler.py(218):             select_list = []
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(220):                 select_list.append(select_idx)
0.72 compiler.py(221):                 select.append((col, None))
0.72 compiler.py(222):                 select_idx += 1
0.72 compiler.py(219):             for col in cols:
0.72 compiler.py(224):                 'model': self.query.model,
0.72 compiler.py(225):                 'select_fields': select_list,
0.72 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.72 query.py(2075):         if self._annotation_select_cache is not None:
0.72 query.py(2077):         elif not self.annotations:
0.72 query.py(2078):             return {}
0.72 compiler.py(232):         if self.query.select_related:
0.72 compiler.py(244):         ret = []
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(246):             try:
0.72 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.72 compiler.py(397):                 name in self.query.extra_select or (
0.72 query.py(2090):         if self._extra_select_cache is not None:
0.72 query.py(2092):         if not self.extra:
0.72 query.py(2093):             return {}
0.72 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.72 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.72 compiler.py(402):         self.quote_cache[name] = r
0.72 compiler.py(403):         return r
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.72 compiler.py(251):             ret.append((col, (sql, params), alias))
0.72 compiler.py(245):         for col, alias in select:
0.72 compiler.py(252):         return ret, klass_info, annotations
0.72 compiler.py(44):         self.col_count = len(self.select)
0.72 compiler.py(53):         order_by = self.get_order_by()
0.72 compiler.py(263):         if self.query.extra_order_by:
0.72 compiler.py(265):         elif not self.query.default_ordering:
0.72 compiler.py(267):         elif self.query.order_by:
0.72 compiler.py(269):         elif self.query.get_meta().ordering:
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(273):             ordering = []
0.72 compiler.py(274):         if self.query.standard_ordering:
0.72 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.72 compiler.py(279):         order_by = []
0.72 compiler.py(280):         for field in ordering:
0.72 compiler.py(340):         result = []
0.72 compiler.py(341):         seen = set()
0.72 compiler.py(343):         for expr, is_ref in order_by:
0.72 compiler.py(376):         return result
0.72 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.72 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.72 compiler.py(379):         extra_select = []
0.72 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.72 compiler.py(386):         return extra_select
0.72 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.72 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.72 compiler.py(97):         if self.query.group_by is None:
0.72 compiler.py(98):             return []
0.72 compiler.py(58):         return extra_select, order_by, group_by
0.72 compiler.py(481):             for_update_part = None
0.72 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.72 compiler.py(484):             combinator = self.query.combinator
0.72 compiler.py(485):             features = self.connection.features
0.72 compiler.py(486):             if combinator:
0.72 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.72 compiler.py(683):         result = []
0.72 compiler.py(684):         params = []
0.72 compiler.py(685):         opts = self.query.get_meta()
0.72 query.py(290):         return self.model._meta
0.72 compiler.py(687):         for name in self.query.distinct_fields:
0.72 compiler.py(698):         return result, params
0.72 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.72 compiler.py(755):         result = []
0.72 compiler.py(756):         params = []
0.72 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.72 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.72 compiler.py(760):             try:
0.72 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.72 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(767):             result.append(clause_sql)
0.72 compiler.py(768):             params.extend(clause_params)
0.72 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.72 compiler.py(769):         for t in self.query.extra_tables:
0.72 compiler.py(776):         return result, params
0.72 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.72 compiler.py(407):         if vendor_impl:
0.72 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(394):         if name in self.quote_cache:
0.72 compiler.py(395):             return self.quote_cache[name]
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.72 compiler.py(413):         return sql, params
0.72 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.72 compiler.py(497):                 result = ['SELECT']
0.72 compiler.py(498):                 params = []
0.72 compiler.py(500):                 if self.query.distinct:
0.72 compiler.py(508):                 out_cols = []
0.72 compiler.py(509):                 col_idx = 1
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(511):                     if alias:
0.72 compiler.py(513):                     elif with_col_aliases:
0.72 compiler.py(516):                     params.extend(s_params)
0.72 compiler.py(517):                     out_cols.append(s_sql)
0.72 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.72 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.72 compiler.py(520):                 params.extend(f_params)
0.72 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.72 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.72 compiler.py(552):                 if where:
0.72 compiler.py(553):                     result.append('WHERE %s' % where)
0.72 compiler.py(554):                     params.extend(w_params)
0.72 compiler.py(556):                 grouping = []
0.72 compiler.py(557):                 for g_sql, g_params in group_by:
0.72 compiler.py(560):                 if grouping:
0.72 compiler.py(577):                 if having:
0.72 compiler.py(581):             if self.query.explain_query:
0.72 compiler.py(587):             if order_by:
0.72 compiler.py(594):             if with_limit_offset:
0.72 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.72 compiler.py(600):             if self.query.subquery and extra_select:
0.72 compiler.py(627):             return ' '.join(result), tuple(params)
0.72 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.72 query.py(820):             self.unref_alias(alias, unref_amount)
0.72 query.py(758):         self.alias_refcount[alias] -= amount
0.72 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.72 compiler.py(1083):             if not sql:
0.72 compiler.py(1090):         if chunked_fetch:
0.72 compiler.py(1093):             cursor = self.connection.cursor()
0.72 compiler.py(1094):         try:
0.72 compiler.py(1095):             cursor.execute(sql, params)
0.72 compiler.py(1101):         if result_type == CURSOR:
0.72 compiler.py(1104):         if result_type == SINGLE:
0.72 compiler.py(1113):         if result_type == NO_RESULTS:
0.72 compiler.py(1117):         result = cursor_iter(
0.72 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.72 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.72 compiler.py(1120):             chunk_size,
0.72 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.72 compiler.py(1123):             try:
0.72 compiler.py(1128):                 return list(result)
0.72 compiler.py(1518):     try:
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.72 compiler.py(1522):         cursor.close()
0.72 compiler.py(1131):                 cursor.close()
0.72 compiler.py(1046):         if results is None:
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.72 compiler.py(1049):         converters = self.get_converters(fields)
0.72 compiler.py(1023):         converters = {}
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1025):             if expression:
0.72 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.72 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.72 compiler.py(1028):                 if backend_converters or field_converters:
0.72 compiler.py(1024):         for i, expression in enumerate(expressions):
0.72 compiler.py(1030):         return converters
0.72 compiler.py(1050):         rows = chain.from_iterable(results)
0.72 compiler.py(1051):         if converters:
0.72 compiler.py(1055):         return rows
0.72 query.py(154):         self.model = model
0.72 query.py(155):         self.alias_refcount = {}
0.72 query.py(161):         self.alias_map = {}
0.72 query.py(165):         self.external_aliases = set()
0.72 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.72 query.py(167):         self.default_cols = True
0.72 query.py(168):         self.default_ordering = True
0.72 query.py(169):         self.standard_ordering = True
0.72 query.py(170):         self.used_aliases = set()
0.72 query.py(171):         self.filter_is_sticky = False
0.72 query.py(172):         self.subquery = False
0.72 query.py(180):         self.select = ()
0.72 query.py(181):         self.where = where()
0.72 query.py(182):         self.where_class = where
0.72 query.py(189):         self.group_by = None
0.72 query.py(190):         self.order_by = ()
0.72 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.72 query.py(192):         self.distinct = False
0.72 query.py(193):         self.distinct_fields = ()
0.72 query.py(194):         self.select_for_update = False
0.72 query.py(195):         self.select_for_update_nowait = False
0.72 query.py(196):         self.select_for_update_skip_locked = False
0.72 query.py(197):         self.select_for_update_of = ()
0.72 query.py(199):         self.select_related = False
0.72 query.py(201):         self.max_depth = 5
0.72 query.py(205):         self.values_select = ()
0.72 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.72 query.py(209):         self.annotation_select_mask = None
0.72 query.py(210):         self._annotation_select_cache = None
0.72 query.py(213):         self.combinator = None
0.72 query.py(214):         self.combinator_all = False
0.72 query.py(215):         self.combined_queries = ()
0.72 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.72 query.py(220):         self.extra_select_mask = None
0.72 query.py(221):         self._extra_select_cache = None
0.72 query.py(223):         self.extra_tables = ()
0.72 query.py(224):         self.extra_order_by = ()
0.72 query.py(229):         self.deferred_loading = (frozenset(), True)
0.72 query.py(231):         self._filtered_relations = {}
0.72 query.py(233):         self.explain_query = False
0.72 query.py(234):         self.explain_format = None
0.72 query.py(235):         self.explain_options = {}
0.72 query.py(343):         obj = self.clone()
0.72 query.py(297):         obj = Empty()
0.72 query.py(298):         obj.__class__ = self.__class__
0.72 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.72 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.72 query.py(303):         obj.alias_map = self.alias_map.copy()
0.72 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.72 query.py(305):         obj.table_map = self.table_map.copy()
0.72 query.py(306):         obj.where = self.where.clone()
0.72 query.py(307):         obj.annotations = self.annotations.copy()
0.72 query.py(308):         if self.annotation_select_mask is None:
0.72 query.py(309):             obj.annotation_select_mask = None
0.72 query.py(317):         obj._annotation_select_cache = None
0.72 query.py(318):         obj.extra = self.extra.copy()
0.72 query.py(319):         if self.extra_select_mask is None:
0.72 query.py(320):             obj.extra_select_mask = None
0.72 query.py(323):         if self._extra_select_cache is None:
0.72 query.py(324):             obj._extra_select_cache = None
0.72 query.py(327):         if 'subq_aliases' in self.__dict__:
0.72 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.72 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.72 query.py(332):         try:
0.72 query.py(333):             del obj.base_table
0.72 query.py(334):         except AttributeError:
0.72 query.py(335):             pass
0.72 query.py(336):         return obj
0.72 query.py(344):         if klass and obj.__class__ != klass:
0.72 query.py(346):         if not obj.filter_is_sticky:
0.72 query.py(347):             obj.used_aliases = set()
0.72 query.py(348):         obj.filter_is_sticky = False
0.72 query.py(349):         if hasattr(obj, '_setup_query'):
0.72 query.py(351):         return obj
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(1758):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.73 query.py(1331):         connector = q_object.connector
0.73 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.73 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.73 query.py(1334):         target_clause = self.where_class(connector=connector,
0.73 query.py(1335):                                          negated=q_object.negated)
0.73 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.73 query.py(2236):         self.connector = connector
0.73 query.py(2237):         self.negated = negated
0.73 query.py(2238):         if self.negated:
0.73 query.py(2244):             self.effective_connector = self.connector
0.73 query.py(2245):         self.num_children = num_children
0.73 query.py(2248):         self.votes = Counter()
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.73 query.py(290):         return self.model._meta
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2255):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2255):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.73 query.py(2264):         to_promote = set()
0.73 query.py(2265):         to_demote = set()
0.73 query.py(2268):         for table, votes in self.votes.items():
0.73 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2291):             if self.effective_connector == 'AND' or (
0.73 query.py(2293):                 to_demote.add(table)
0.73 query.py(2268):         for table, votes in self.votes.items():
0.73 query.py(2309):         query.promote_joins(to_promote)
0.73 query.py(771):         aliases = list(aliases)
0.73 query.py(772):         while aliases:
0.73 query.py(2310):         query.demote_joins(to_demote)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(2311):         return to_demote
0.73 query.py(1353):         return target_clause, needed_inner
0.73 query.py(1320):         if clause:
0.73 query.py(1321):             self.where.add(clause, AND)
0.73 query.py(1322):         self.demote_joins(existing_inner)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(1758):         return not self.low_mark and self.high_mark is None
0.73 query.py(1758):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1860):         self.order_by = ()
0.73 query.py(1861):         self.extra_order_by = ()
0.73 query.py(1862):         if force_empty:
0.73 query.py(1839):         errors = []
0.73 query.py(1840):         for item in ordering:
0.73 query.py(1848):         if errors:
0.73 query.py(1850):         if ordering:
0.73 query.py(1853):             self.default_ordering = False
0.73 query.py(1731):         if high is not None:
0.73 query.py(1732):             if self.high_mark is not None:
0.73 query.py(1735):                 self.high_mark = self.low_mark + high
0.73 query.py(1736):         if low is not None:
0.73 query.py(1742):         if self.low_mark == self.high_mark:
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 compiler.py(25):         self.query = query
0.73 compiler.py(26):         self.connection = connection
0.73 compiler.py(27):         self.using = using
0.73 compiler.py(28):         self.quote_cache = {'*': '*'}
0.73 compiler.py(33):         self.select = None
0.73 compiler.py(34):         self.annotation_col_map = None
0.73 compiler.py(35):         self.klass_info = None
0.73 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.73 compiler.py(38):         self._meta_ordering = None
0.73 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.73 compiler.py(1081):         try:
0.73 compiler.py(1082):             sql, params = self.as_sql()
0.73 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.73 compiler.py(479):         try:
0.73 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.73 compiler.py(52):         self.setup_query()
0.73 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.73 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.73 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.73 compiler.py(202):         select = []
0.73 compiler.py(203):         klass_info = None
0.73 compiler.py(204):         annotations = {}
0.73 compiler.py(205):         select_idx = 0
0.73 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.73 compiler.py(211):         if self.query.default_cols:
0.73 compiler.py(212):             cols = self.get_default_columns()
0.73 compiler.py(644):         result = []
0.73 compiler.py(645):         if opts is None:
0.73 compiler.py(646):             opts = self.query.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(647):         only_load = self.deferred_to_columns()
0.73 compiler.py(1018):         columns = {}
0.73 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.73 query.py(655):         field_names, defer = self.deferred_loading
0.73 query.py(656):         if not field_names:
0.73 query.py(657):             return
0.73 compiler.py(1020):         return columns
0.73 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 compiler.py(652):         seen_models = {None: start_alias}
0.73 compiler.py(654):         for field in opts.concrete_fields:
0.73 compiler.py(655):             model = field.model._meta.concrete_model
0.73 compiler.py(658):             if model == opts.model:
0.73 compiler.py(659):                 model = None
0.73 compiler.py(660):             if from_parent and model is not None and issubclass(
0.73 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.73 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.73 compiler.py(671):                                                  seen_models)
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 compiler.py(672):             column = field.get_col(alias)
0.73 compiler.py(673):             result.append(column)
0.73 compiler.py(654):         for field in opts.concrete_fields:
0.73 compiler.py(655):             model = field.model._meta.concrete_model
0.73 compiler.py(658):             if model == opts.model:
0.73 compiler.py(659):                 model = None
0.73 compiler.py(660):             if from_parent and model is not None and issubclass(
0.73 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.73 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.73 compiler.py(671):                                                  seen_models)
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 compiler.py(672):             column = field.get_col(alias)
0.73 compiler.py(673):             result.append(column)
0.73 compiler.py(654):         for field in opts.concrete_fields:
0.73 compiler.py(655):             model = field.model._meta.concrete_model
0.73 compiler.py(658):             if model == opts.model:
0.73 compiler.py(659):                 model = None
0.73 compiler.py(660):             if from_parent and model is not None and issubclass(
0.73 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.73 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.73 compiler.py(671):                                                  seen_models)
0.73 query.py(984):         if model in seen:
0.73 query.py(985):             return seen[model]
0.73 compiler.py(672):             column = field.get_col(alias)
0.73 compiler.py(673):             result.append(column)
0.73 compiler.py(654):         for field in opts.concrete_fields:
0.73 compiler.py(674):         return result
0.73 compiler.py(217):         if cols:
0.73 compiler.py(218):             select_list = []
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(220):                 select_list.append(select_idx)
0.73 compiler.py(221):                 select.append((col, None))
0.73 compiler.py(222):                 select_idx += 1
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(220):                 select_list.append(select_idx)
0.73 compiler.py(221):                 select.append((col, None))
0.73 compiler.py(222):                 select_idx += 1
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(220):                 select_list.append(select_idx)
0.73 compiler.py(221):                 select.append((col, None))
0.73 compiler.py(222):                 select_idx += 1
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(224):                 'model': self.query.model,
0.73 compiler.py(225):                 'select_fields': select_list,
0.73 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(232):         if self.query.select_related:
0.73 compiler.py(244):         ret = []
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(246):             try:
0.73 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.73 compiler.py(251):             ret.append((col, (sql, params), alias))
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(246):             try:
0.73 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.73 compiler.py(251):             ret.append((col, (sql, params), alias))
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(246):             try:
0.73 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.73 compiler.py(251):             ret.append((col, (sql, params), alias))
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(252):         return ret, klass_info, annotations
0.73 compiler.py(44):         self.col_count = len(self.select)
0.73 compiler.py(53):         order_by = self.get_order_by()
0.73 compiler.py(263):         if self.query.extra_order_by:
0.73 compiler.py(265):         elif not self.query.default_ordering:
0.73 compiler.py(266):             ordering = self.query.order_by
0.73 compiler.py(274):         if self.query.standard_ordering:
0.73 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.73 compiler.py(279):         order_by = []
0.73 compiler.py(280):         for field in ordering:
0.73 compiler.py(340):         result = []
0.73 compiler.py(341):         seen = set()
0.73 compiler.py(343):         for expr, is_ref in order_by:
0.73 compiler.py(376):         return result
0.73 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.73 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.73 compiler.py(379):         extra_select = []
0.73 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.73 compiler.py(386):         return extra_select
0.73 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.73 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.73 compiler.py(97):         if self.query.group_by is None:
0.73 compiler.py(98):             return []
0.73 compiler.py(58):         return extra_select, order_by, group_by
0.73 compiler.py(481):             for_update_part = None
0.73 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.73 compiler.py(484):             combinator = self.query.combinator
0.73 compiler.py(485):             features = self.connection.features
0.73 compiler.py(486):             if combinator:
0.73 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.73 compiler.py(683):         result = []
0.73 compiler.py(684):         params = []
0.73 compiler.py(685):         opts = self.query.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(687):         for name in self.query.distinct_fields:
0.73 compiler.py(698):         return result, params
0.73 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.73 compiler.py(755):         result = []
0.73 compiler.py(756):         params = []
0.73 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.73 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.73 compiler.py(760):             try:
0.73 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.73 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(767):             result.append(clause_sql)
0.73 compiler.py(768):             params.extend(clause_params)
0.73 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.73 compiler.py(769):         for t in self.query.extra_tables:
0.73 compiler.py(776):         return result, params
0.73 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.73 compiler.py(497):                 result = ['SELECT']
0.73 compiler.py(498):                 params = []
0.73 compiler.py(500):                 if self.query.distinct:
0.73 compiler.py(508):                 out_cols = []
0.73 compiler.py(509):                 col_idx = 1
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(511):                     if alias:
0.73 compiler.py(513):                     elif with_col_aliases:
0.73 compiler.py(516):                     params.extend(s_params)
0.73 compiler.py(517):                     out_cols.append(s_sql)
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(511):                     if alias:
0.73 compiler.py(513):                     elif with_col_aliases:
0.73 compiler.py(516):                     params.extend(s_params)
0.73 compiler.py(517):                     out_cols.append(s_sql)
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(511):                     if alias:
0.73 compiler.py(513):                     elif with_col_aliases:
0.73 compiler.py(516):                     params.extend(s_params)
0.73 compiler.py(517):                     out_cols.append(s_sql)
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.73 compiler.py(520):                 params.extend(f_params)
0.73 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.73 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.73 compiler.py(552):                 if where:
0.73 compiler.py(553):                     result.append('WHERE %s' % where)
0.73 compiler.py(554):                     params.extend(w_params)
0.73 compiler.py(556):                 grouping = []
0.73 compiler.py(557):                 for g_sql, g_params in group_by:
0.73 compiler.py(560):                 if grouping:
0.73 compiler.py(577):                 if having:
0.73 compiler.py(581):             if self.query.explain_query:
0.73 compiler.py(587):             if order_by:
0.73 compiler.py(594):             if with_limit_offset:
0.73 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.73 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.73 compiler.py(600):             if self.query.subquery and extra_select:
0.73 compiler.py(627):             return ' '.join(result), tuple(params)
0.73 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 compiler.py(1083):             if not sql:
0.73 compiler.py(1090):         if chunked_fetch:
0.73 compiler.py(1093):             cursor = self.connection.cursor()
0.73 compiler.py(1094):         try:
0.73 compiler.py(1095):             cursor.execute(sql, params)
0.73 compiler.py(1101):         if result_type == CURSOR:
0.73 compiler.py(1104):         if result_type == SINGLE:
0.73 compiler.py(1113):         if result_type == NO_RESULTS:
0.73 compiler.py(1117):         result = cursor_iter(
0.73 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.73 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.73 compiler.py(1120):             chunk_size,
0.73 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.73 compiler.py(1123):             try:
0.73 compiler.py(1128):                 return list(result)
0.73 compiler.py(1518):     try:
0.73 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.73 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.73 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.73 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.73 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.73 compiler.py(1522):         cursor.close()
0.73 compiler.py(1131):                 cursor.close()
0.73 compiler.py(1046):         if results is None:
0.73 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.73 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.73 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.73 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.73 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.73 compiler.py(1049):         converters = self.get_converters(fields)
0.73 compiler.py(1023):         converters = {}
0.73 compiler.py(1024):         for i, expression in enumerate(expressions):
0.73 compiler.py(1025):             if expression:
0.73 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.73 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.73 compiler.py(1028):                 if backend_converters or field_converters:
0.73 compiler.py(1024):         for i, expression in enumerate(expressions):
0.73 compiler.py(1025):             if expression:
0.73 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.73 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.73 compiler.py(1028):                 if backend_converters or field_converters:
0.73 compiler.py(1024):         for i, expression in enumerate(expressions):
0.73 compiler.py(1025):             if expression:
0.73 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.73 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.73 compiler.py(1028):                 if backend_converters or field_converters:
0.73 compiler.py(1024):         for i, expression in enumerate(expressions):
0.73 compiler.py(1030):         return converters
0.73 compiler.py(1050):         rows = chain.from_iterable(results)
0.73 compiler.py(1051):         if converters:
0.73 compiler.py(1055):         return rows
0.73 query.py(154):         self.model = model
0.73 query.py(155):         self.alias_refcount = {}
0.73 query.py(161):         self.alias_map = {}
0.73 query.py(165):         self.external_aliases = set()
0.73 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.73 query.py(167):         self.default_cols = True
0.73 query.py(168):         self.default_ordering = True
0.73 query.py(169):         self.standard_ordering = True
0.73 query.py(170):         self.used_aliases = set()
0.73 query.py(171):         self.filter_is_sticky = False
0.73 query.py(172):         self.subquery = False
0.73 query.py(180):         self.select = ()
0.73 query.py(181):         self.where = where()
0.73 query.py(182):         self.where_class = where
0.73 query.py(189):         self.group_by = None
0.73 query.py(190):         self.order_by = ()
0.73 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.73 query.py(192):         self.distinct = False
0.73 query.py(193):         self.distinct_fields = ()
0.73 query.py(194):         self.select_for_update = False
0.73 query.py(195):         self.select_for_update_nowait = False
0.73 query.py(196):         self.select_for_update_skip_locked = False
0.73 query.py(197):         self.select_for_update_of = ()
0.73 query.py(199):         self.select_related = False
0.73 query.py(201):         self.max_depth = 5
0.73 query.py(205):         self.values_select = ()
0.73 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.73 query.py(209):         self.annotation_select_mask = None
0.73 query.py(210):         self._annotation_select_cache = None
0.73 query.py(213):         self.combinator = None
0.73 query.py(214):         self.combinator_all = False
0.73 query.py(215):         self.combined_queries = ()
0.73 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.73 query.py(220):         self.extra_select_mask = None
0.73 query.py(221):         self._extra_select_cache = None
0.73 query.py(223):         self.extra_tables = ()
0.73 query.py(224):         self.extra_order_by = ()
0.73 query.py(229):         self.deferred_loading = (frozenset(), True)
0.73 query.py(231):         self._filtered_relations = {}
0.73 query.py(233):         self.explain_query = False
0.73 query.py(234):         self.explain_format = None
0.73 query.py(235):         self.explain_options = {}
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1758):         return not self.low_mark and self.high_mark is None
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.73 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.73 query.py(1331):         connector = q_object.connector
0.73 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.73 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.73 query.py(1334):         target_clause = self.where_class(connector=connector,
0.73 query.py(1335):                                          negated=q_object.negated)
0.73 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.73 query.py(2236):         self.connector = connector
0.73 query.py(2237):         self.negated = negated
0.73 query.py(2238):         if self.negated:
0.73 query.py(2244):             self.effective_connector = self.connector
0.73 query.py(2245):         self.num_children = num_children
0.73 query.py(2248):         self.votes = Counter()
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1338):             if isinstance(child, Node):
0.73 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.73 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.73 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.73 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.73 query.py(1214):         if isinstance(filter_expr, dict):
0.73 query.py(1216):         arg, value = filter_expr
0.73 query.py(1217):         if not arg:
0.73 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.73 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.73 query.py(1074):         if self.annotations:
0.73 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.73 query.py(290):         return self.model._meta
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1415):             except FieldDoesNotExist:
0.73 query.py(1416):                 if name in self.annotation_select:
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.73 query.py(1421):             if field is not None:
0.73 query.py(1441):                 pos -= 1
0.73 query.py(1442):                 if pos == -1 or fail_on_missing:
0.73 query.py(1450):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.73 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.73 query.py(1085):         return lookup_parts, field_parts, False
0.73 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.73 query.py(1227):         if not allow_joins and len(parts) > 1:
0.73 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.73 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.73 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.73 query.py(1055):         elif isinstance(value, (list, tuple)):
0.73 query.py(1067):         return value
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.73 query.py(1234):         clause = self.where_class()
0.73 query.py(1235):         if reffed_expression:
0.73 query.py(1240):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1241):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.73 query.py(290):         return self.model._meta
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(917):         return alias
0.73 query.py(1242):         allow_many = not branch_negated or not split_subq
0.73 query.py(1244):         try:
0.73 query.py(1245):             join_info = self.setup_joins(
0.73 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.73 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2193):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.73 query.py(735):         alias_list = self.table_map.get(table_name)
0.73 query.py(736):         if not create and alias_list:
0.73 query.py(742):         if alias_list:
0.73 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.73 query.py(748):             self.table_map[table_name] = [alias]
0.73 query.py(749):         self.alias_refcount[alias] = 1
0.73 query.py(750):         return alias, True
0.73 query.py(965):         if join.join_type:
0.73 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.73 query.py(969):                 join_type = INNER
0.73 query.py(970):             join.join_type = join_type
0.73 query.py(971):         join.table_alias = alias
0.73 query.py(972):         self.alias_map[alias] = join
0.73 query.py(973):         return alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1251):             if isinstance(value, Iterator):
0.73 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.73 query.py(1100):         if field.is_relation:
0.73 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.73 query.py(1112):             elif hasattr(value, '_meta'):
0.73 query.py(1114):             elif hasattr(value, '__iter__'):
0.73 query.py(1115):                 for v in value:
0.73 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.73 query.py(1092):         if hasattr(value, '_meta'):
0.73 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.73 query.py(1115):                 for v in value:
0.73 query.py(1257):             self._lookup_joins = join_info.joins
0.73 query.py(1263):         used_joins.update(join_info.joins)
0.73 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1613):             self.unref_alias(joins.pop())
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1265):         if can_reuse is not None:
0.73 query.py(1266):             can_reuse.update(join_list)
0.73 query.py(1268):         if join_info.final_field.is_relation:
0.73 query.py(1270):             num_lookups = len(lookups)
0.73 query.py(1271):             if num_lookups > 1:
0.73 query.py(1273):             if len(targets) == 1:
0.73 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.73 query.py(72):     if simple_col:
0.73 query.py(74):     return target.get_col(alias, field)
0.73 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.73 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.73 query.py(1129):         for name in transforms:
0.73 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.73 query.py(1134):         if not lookup_class:
0.73 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.73 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.73 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(1161):         return lookup
0.73 query.py(1281):         lookup_type = condition.lookup_name
0.73 query.py(1282):         clause.add(condition, AND)
0.73 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.73 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.73 query.py(1302):         return clause, used_joins if not require_outer else ()
0.73 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.73 query.py(2255):         self.votes.update(votes)
0.73 query.py(1350):             if child_clause:
0.73 query.py(1351):                 target_clause.add(child_clause, connector)
0.73 query.py(1337):         for child in q_object.children:
0.73 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.73 query.py(2264):         to_promote = set()
0.73 query.py(2265):         to_demote = set()
0.73 query.py(2268):         for table, votes in self.votes.items():
0.73 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2291):             if self.effective_connector == 'AND' or (
0.73 query.py(2293):                 to_demote.add(table)
0.73 query.py(2268):         for table, votes in self.votes.items():
0.73 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.73 query.py(2291):             if self.effective_connector == 'AND' or (
0.73 query.py(2293):                 to_demote.add(table)
0.73 query.py(2268):         for table, votes in self.votes.items():
0.73 query.py(2309):         query.promote_joins(to_promote)
0.73 query.py(771):         aliases = list(aliases)
0.73 query.py(772):         while aliases:
0.73 query.py(2310):         query.demote_joins(to_demote)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(806):             alias = aliases.pop(0)
0.73 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.73 query.py(805):         while aliases:
0.73 query.py(2311):         return to_demote
0.73 query.py(1353):         return target_clause, needed_inner
0.73 query.py(1320):         if clause:
0.73 query.py(1321):             self.where.add(clause, AND)
0.73 query.py(1322):         self.demote_joins(existing_inner)
0.73 query.py(804):         aliases = list(aliases)
0.73 query.py(805):         while aliases:
0.73 query.py(343):         obj = self.clone()
0.73 query.py(297):         obj = Empty()
0.73 query.py(298):         obj.__class__ = self.__class__
0.73 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.73 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.73 query.py(303):         obj.alias_map = self.alias_map.copy()
0.73 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.73 query.py(305):         obj.table_map = self.table_map.copy()
0.73 query.py(306):         obj.where = self.where.clone()
0.73 query.py(307):         obj.annotations = self.annotations.copy()
0.73 query.py(308):         if self.annotation_select_mask is None:
0.73 query.py(309):             obj.annotation_select_mask = None
0.73 query.py(317):         obj._annotation_select_cache = None
0.73 query.py(318):         obj.extra = self.extra.copy()
0.73 query.py(319):         if self.extra_select_mask is None:
0.73 query.py(320):             obj.extra_select_mask = None
0.73 query.py(323):         if self._extra_select_cache is None:
0.73 query.py(324):             obj._extra_select_cache = None
0.73 query.py(327):         if 'subq_aliases' in self.__dict__:
0.73 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.73 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.73 query.py(332):         try:
0.73 query.py(333):             del obj.base_table
0.73 query.py(334):         except AttributeError:
0.73 query.py(335):             pass
0.73 query.py(336):         return obj
0.73 query.py(344):         if klass and obj.__class__ != klass:
0.73 query.py(346):         if not obj.filter_is_sticky:
0.73 query.py(347):             obj.used_aliases = set()
0.73 query.py(348):         obj.filter_is_sticky = False
0.73 query.py(349):         if hasattr(obj, '_setup_query'):
0.73 query.py(351):         return obj
0.73 query.py(2035):         self.select_related = False
0.73 query.py(2036):         self.clear_deferred_loading()
0.73 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.73 query.py(2037):         self.clear_select_fields()
0.73 query.py(1774):         self.select = ()
0.73 query.py(1775):         self.values_select = ()
0.73 query.py(2039):         if self.group_by is True:
0.73 query.py(2044):         if fields:
0.73 query.py(2045):             field_names = []
0.73 query.py(2046):             extra_names = []
0.73 query.py(2047):             annotation_names = []
0.73 query.py(2048):             if not self.extra and not self.annotations:
0.73 query.py(2051):                 field_names = list(fields)
0.73 query.py(2061):             self.set_extra_mask(extra_names)
0.73 query.py(2028):         if names is None:
0.73 query.py(2031):             self.extra_select_mask = set(names)
0.73 query.py(2032):         self._extra_select_cache = None
0.73 query.py(2062):             self.set_annotation_mask(annotation_names)
0.73 query.py(2013):         if names is None:
0.73 query.py(2016):             self.annotation_select_mask = set(names)
0.73 query.py(2017):         self._annotation_select_cache = None
0.73 query.py(2066):         self.values_select = tuple(field_names)
0.73 query.py(2067):         self.add_fields(field_names, True)
0.73 query.py(1797):         alias = self.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(250):         for alias in self.alias_map:
0.73 query.py(251):             return alias
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 query.py(1798):         opts = self.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 query.py(1800):         try:
0.73 query.py(1801):             cols = []
0.73 query.py(1802):             for name in field_names:
0.73 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2193):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.73 query.py(1807):                     join_info.targets,
0.73 query.py(1808):                     join_info.joins,
0.73 query.py(1809):                     join_info.path,
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.73 query.py(1613):             self.unref_alias(joins.pop())
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1811):                 for target in targets:
0.73 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(1811):                 for target in targets:
0.73 query.py(1802):             for name in field_names:
0.73 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.73 query.py(1807):                     join_info.targets,
0.73 query.py(1808):                     join_info.joins,
0.73 query.py(1809):                     join_info.path,
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 query.py(1811):                 for target in targets:
0.73 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.73 query.py(1525):             return field.get_col(alias)
0.73 query.py(1811):                 for target in targets:
0.73 query.py(1802):             for name in field_names:
0.73 query.py(1813):             if cols:
0.73 query.py(1814):                 self.set_select(cols)
0.73 query.py(1782):         self.default_cols = False
0.73 query.py(1783):         self.select = tuple(cols)
0.73 query.py(278):         if using is None and connection is None:
0.73 query.py(280):         if using:
0.73 query.py(281):             connection = connections[using]
0.73 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.73 compiler.py(25):         self.query = query
0.73 compiler.py(26):         self.connection = connection
0.73 compiler.py(27):         self.using = using
0.73 compiler.py(28):         self.quote_cache = {'*': '*'}
0.73 compiler.py(33):         self.select = None
0.73 compiler.py(34):         self.annotation_col_map = None
0.73 compiler.py(35):         self.klass_info = None
0.73 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.73 compiler.py(38):         self._meta_ordering = None
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(1046):         if results is None:
0.73 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.73 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.73 compiler.py(1081):         try:
0.73 compiler.py(1082):             sql, params = self.as_sql()
0.73 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.73 compiler.py(479):         try:
0.73 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.73 compiler.py(52):         self.setup_query()
0.73 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.73 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.73 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.73 compiler.py(202):         select = []
0.73 compiler.py(203):         klass_info = None
0.73 compiler.py(204):         annotations = {}
0.73 compiler.py(205):         select_idx = 0
0.73 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.73 compiler.py(211):         if self.query.default_cols:
0.73 compiler.py(216):             cols = self.query.select
0.73 compiler.py(217):         if cols:
0.73 compiler.py(218):             select_list = []
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(220):                 select_list.append(select_idx)
0.73 compiler.py(221):                 select.append((col, None))
0.73 compiler.py(222):                 select_idx += 1
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(220):                 select_list.append(select_idx)
0.73 compiler.py(221):                 select.append((col, None))
0.73 compiler.py(222):                 select_idx += 1
0.73 compiler.py(219):             for col in cols:
0.73 compiler.py(224):                 'model': self.query.model,
0.73 compiler.py(225):                 'select_fields': select_list,
0.73 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(232):         if self.query.select_related:
0.73 compiler.py(244):         ret = []
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(246):             try:
0.73 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.73 compiler.py(251):             ret.append((col, (sql, params), alias))
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(246):             try:
0.73 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.73 compiler.py(251):             ret.append((col, (sql, params), alias))
0.73 compiler.py(245):         for col, alias in select:
0.73 compiler.py(252):         return ret, klass_info, annotations
0.73 compiler.py(44):         self.col_count = len(self.select)
0.73 compiler.py(53):         order_by = self.get_order_by()
0.73 compiler.py(263):         if self.query.extra_order_by:
0.73 compiler.py(265):         elif not self.query.default_ordering:
0.73 compiler.py(267):         elif self.query.order_by:
0.73 compiler.py(269):         elif self.query.get_meta().ordering:
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(270):             ordering = self.query.get_meta().ordering
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(271):             self._meta_ordering = ordering
0.73 compiler.py(274):         if self.query.standard_ordering:
0.73 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.73 compiler.py(279):         order_by = []
0.73 compiler.py(280):         for field in ordering:
0.73 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.73 compiler.py(292):             if field == '?':  # random
0.73 compiler.py(296):             col, order = get_order_dir(field, asc)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(297):             descending = order == 'DESC'
0.73 compiler.py(299):             if col in self.query.annotation_select:
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(305):             if col in self.query.annotations:
0.73 compiler.py(315):             if '.' in field:
0.73 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.73 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.73 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(708):         descending = order == 'DESC'
0.73 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.73 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.73 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2193):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 compiler.py(741):         alias = joins[-1]
0.73 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.73 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.73 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1610):                 break
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 query.py(1525):             return field.get_col(alias)
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(280):         for field in ordering:
0.73 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.73 compiler.py(292):             if field == '?':  # random
0.73 compiler.py(296):             col, order = get_order_dir(field, asc)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(297):             descending = order == 'DESC'
0.73 compiler.py(299):             if col in self.query.annotation_select:
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(305):             if col in self.query.annotations:
0.73 compiler.py(315):             if '.' in field:
0.73 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.73 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.73 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(708):         descending = order == 'DESC'
0.73 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.73 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.73 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.73 query.py(1462):                 if not allow_many:
0.73 query.py(1468):                 last = pathinfos[-1]
0.73 query.py(1469):                 path.extend(pathinfos)
0.73 query.py(1470):                 final_field = last.join_field
0.73 query.py(1471):                 opts = last.to_opts
0.73 query.py(1472):                 targets = last.target_fields
0.73 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.73 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1563):             if join.filtered_relation:
0.73 query.py(1567):                 filtered_relation = None
0.73 query.py(1568):                 table_alias = None
0.73 query.py(1569):             opts = join.to_opts
0.73 query.py(1570):             if join.direct:
0.73 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.73 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.73 query.py(2193):         ) or field.null
0.73 query.py(1574):             connection = Join(
0.73 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.73 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.73 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.73 query.py(1579):             alias = self.join(
0.73 query.py(1580):                 connection, reuse=reuse,
0.73 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.73 query.py(943):         if reuse_with_filtered_relation and reuse:
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.73 query.py(950):                 a for a, j in self.alias_map.items()
0.73 query.py(953):         if reuse_aliases:
0.73 query.py(954):             if join.table_alias in reuse_aliases:
0.73 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.73 query.py(960):             self.ref_alias(reuse_alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(961):             return reuse_alias
0.73 query.py(1583):             joins.append(alias)
0.73 query.py(1584):             if filtered_relation:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 compiler.py(741):         alias = joins[-1]
0.73 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.73 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.73 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1603):             if len(joins) == 1 or not info.direct:
0.73 query.py(1605):             if info.filtered_relation:
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1608):             cur_targets = {t.column for t in targets}
0.73 query.py(1609):             if not cur_targets.issubset(join_targets):
0.73 query.py(1610):                 break
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 query.py(1525):             return field.get_col(alias)
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(280):         for field in ordering:
0.73 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.73 compiler.py(292):             if field == '?':  # random
0.73 compiler.py(296):             col, order = get_order_dir(field, asc)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(297):             descending = order == 'DESC'
0.73 compiler.py(299):             if col in self.query.annotation_select:
0.73 query.py(2075):         if self._annotation_select_cache is not None:
0.73 query.py(2077):         elif not self.annotations:
0.73 query.py(2078):             return {}
0.73 compiler.py(305):             if col in self.query.annotations:
0.73 compiler.py(315):             if '.' in field:
0.73 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.73 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.73 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.73 query.py(2204):     dirn = ORDER_DIR[default]
0.73 query.py(2205):     if field[0] == '-':
0.73 query.py(2207):     return field, dirn[0]
0.73 compiler.py(708):         descending = order == 'DESC'
0.73 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.73 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.73 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.73 query.py(912):         if self.alias_map:
0.73 query.py(913):             alias = self.base_table
0.73 query.py(914):             self.ref_alias(alias)
0.73 query.py(754):         self.alias_refcount[alias] += 1
0.73 query.py(917):         return alias
0.73 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.73 query.py(1518):         joins = [alias]
0.73 query.py(1524):         def final_transformer(field, alias):
0.73 query.py(1529):         last_field_exception = None
0.73 query.py(1530):         for pivot in range(len(names), 0, -1):
0.73 query.py(1531):             try:
0.73 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.73 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.73 query.py(1405):         path, names_with_path = [], []
0.73 query.py(1406):         for pos, name in enumerate(names):
0.73 query.py(1407):             cur_names_with_path = (name, [])
0.73 query.py(1408):             if name == 'pk':
0.73 query.py(1411):             field = None
0.73 query.py(1412):             filtered_relation = None
0.73 query.py(1413):             try:
0.73 query.py(1414):                 field = opts.get_field(name)
0.73 query.py(1421):             if field is not None:
0.73 query.py(1425):                 if field.is_relation and not field.related_model:
0.73 query.py(1432):                 try:
0.73 query.py(1433):                     model = field.model._meta.concrete_model
0.73 query.py(1454):             if model is not opts.model:
0.73 query.py(1460):             if hasattr(field, 'get_path_info'):
0.73 query.py(1477):                 final_field = field
0.73 query.py(1478):                 targets = (field,)
0.73 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.73 query.py(1483):                 break
0.73 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.73 query.py(1545):                 transforms = names[pivot:]
0.73 query.py(1546):                 break
0.73 query.py(1547):         for name in transforms:
0.73 query.py(1562):         for join in path:
0.73 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.73 compiler.py(741):         alias = joins[-1]
0.73 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.73 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.73 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.73 query.py(1601):         joins = joins[:]
0.73 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.73 query.py(1614):         return targets, joins[-1], joins
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 query.py(1525):             return field.get_col(alias)
0.73 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.73 compiler.py(280):         for field in ordering:
0.73 compiler.py(340):         result = []
0.73 compiler.py(341):         seen = set()
0.73 compiler.py(343):         for expr, is_ref in order_by:
0.73 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.73 compiler.py(345):             if self.query.combinator:
0.73 compiler.py(365):             sql, params = self.compile(resolved)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.73 compiler.py(371):             params_hash = make_hashable(params)
0.73 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.73 compiler.py(374):             seen.add((without_ordering, params_hash))
0.73 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.73 compiler.py(343):         for expr, is_ref in order_by:
0.73 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.73 compiler.py(345):             if self.query.combinator:
0.73 compiler.py(365):             sql, params = self.compile(resolved)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.73 compiler.py(397):                 name in self.query.extra_select or (
0.73 query.py(2090):         if self._extra_select_cache is not None:
0.73 query.py(2092):         if not self.extra:
0.73 query.py(2093):             return {}
0.73 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.73 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.73 compiler.py(402):         self.quote_cache[name] = r
0.73 compiler.py(403):         return r
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.73 compiler.py(371):             params_hash = make_hashable(params)
0.73 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.73 compiler.py(374):             seen.add((without_ordering, params_hash))
0.73 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.73 compiler.py(343):         for expr, is_ref in order_by:
0.73 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.73 compiler.py(345):             if self.query.combinator:
0.73 compiler.py(365):             sql, params = self.compile(resolved)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.73 compiler.py(371):             params_hash = make_hashable(params)
0.73 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.73 compiler.py(374):             seen.add((without_ordering, params_hash))
0.73 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.73 compiler.py(343):         for expr, is_ref in order_by:
0.73 compiler.py(376):         return result
0.73 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.73 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.73 compiler.py(379):         extra_select = []
0.73 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.73 compiler.py(386):         return extra_select
0.73 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.73 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.73 compiler.py(97):         if self.query.group_by is None:
0.73 compiler.py(98):             return []
0.73 compiler.py(58):         return extra_select, order_by, group_by
0.73 compiler.py(481):             for_update_part = None
0.73 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.73 compiler.py(484):             combinator = self.query.combinator
0.73 compiler.py(485):             features = self.connection.features
0.73 compiler.py(486):             if combinator:
0.73 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.73 compiler.py(683):         result = []
0.73 compiler.py(684):         params = []
0.73 compiler.py(685):         opts = self.query.get_meta()
0.73 query.py(290):         return self.model._meta
0.73 compiler.py(687):         for name in self.query.distinct_fields:
0.73 compiler.py(698):         return result, params
0.73 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.73 compiler.py(755):         result = []
0.73 compiler.py(756):         params = []
0.73 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.73 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.73 compiler.py(760):             try:
0.73 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.73 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(767):             result.append(clause_sql)
0.73 compiler.py(768):             params.extend(clause_params)
0.73 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.73 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.73 compiler.py(760):             try:
0.73 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.73 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(767):             result.append(clause_sql)
0.73 compiler.py(768):             params.extend(clause_params)
0.73 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.73 compiler.py(769):         for t in self.query.extra_tables:
0.73 compiler.py(776):         return result, params
0.73 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.73 compiler.py(407):         if vendor_impl:
0.73 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(394):         if name in self.quote_cache:
0.73 compiler.py(395):             return self.quote_cache[name]
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.73 compiler.py(413):         return sql, params
0.73 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.73 compiler.py(497):                 result = ['SELECT']
0.73 compiler.py(498):                 params = []
0.73 compiler.py(500):                 if self.query.distinct:
0.73 compiler.py(508):                 out_cols = []
0.73 compiler.py(509):                 col_idx = 1
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(511):                     if alias:
0.73 compiler.py(513):                     elif with_col_aliases:
0.73 compiler.py(516):                     params.extend(s_params)
0.73 compiler.py(517):                     out_cols.append(s_sql)
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(511):                     if alias:
0.73 compiler.py(513):                     elif with_col_aliases:
0.73 compiler.py(516):                     params.extend(s_params)
0.73 compiler.py(517):                     out_cols.append(s_sql)
0.73 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.73 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.73 compiler.py(520):                 params.extend(f_params)
0.73 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.73 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.73 compiler.py(552):                 if where:
0.73 compiler.py(553):                     result.append('WHERE %s' % where)
0.73 compiler.py(554):                     params.extend(w_params)
0.73 compiler.py(556):                 grouping = []
0.73 compiler.py(557):                 for g_sql, g_params in group_by:
0.73 compiler.py(560):                 if grouping:
0.73 compiler.py(577):                 if having:
0.73 compiler.py(581):             if self.query.explain_query:
0.73 compiler.py(587):             if order_by:
0.73 compiler.py(588):                 ordering = []
0.73 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.73 compiler.py(590):                     ordering.append(o_sql)
0.73 compiler.py(591):                     params.extend(o_params)
0.73 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.73 compiler.py(590):                     ordering.append(o_sql)
0.73 compiler.py(591):                     params.extend(o_params)
0.73 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.73 compiler.py(590):                     ordering.append(o_sql)
0.73 compiler.py(591):                     params.extend(o_params)
0.73 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.73 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.73 compiler.py(594):             if with_limit_offset:
0.73 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.73 compiler.py(600):             if self.query.subquery and extra_select:
0.73 compiler.py(627):             return ' '.join(result), tuple(params)
0.73 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.73 query.py(820):             self.unref_alias(alias, unref_amount)
0.73 query.py(758):         self.alias_refcount[alias] -= amount
0.73 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.73 compiler.py(1083):             if not sql:
0.73 compiler.py(1090):         if chunked_fetch:
0.73 compiler.py(1093):             cursor = self.connection.cursor()
0.73 compiler.py(1094):         try:
0.73 compiler.py(1095):             cursor.execute(sql, params)
0.73 compiler.py(1101):         if result_type == CURSOR:
0.74 compiler.py(1104):         if result_type == SINGLE:
0.74 compiler.py(1113):         if result_type == NO_RESULTS:
0.74 compiler.py(1117):         result = cursor_iter(
0.74 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.74 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.74 compiler.py(1120):             chunk_size,
0.74 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.74 compiler.py(1123):             try:
0.74 compiler.py(1128):                 return list(result)
0.74 compiler.py(1518):     try:
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1522):         cursor.close()
0.74 compiler.py(1131):                 cursor.close()
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1049):         converters = self.get_converters(fields)
0.74 compiler.py(1023):         converters = {}
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1030):         return converters
0.74 compiler.py(1050):         rows = chain.from_iterable(results)
0.74 compiler.py(1051):         if converters:
0.74 compiler.py(1055):         return rows
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 compiler.py(25):         self.query = query
0.74 compiler.py(26):         self.connection = connection
0.74 compiler.py(27):         self.using = using
0.74 compiler.py(28):         self.quote_cache = {'*': '*'}
0.74 compiler.py(33):         self.select = None
0.74 compiler.py(34):         self.annotation_col_map = None
0.74 compiler.py(35):         self.klass_info = None
0.74 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.74 compiler.py(38):         self._meta_ordering = None
0.74 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.74 compiler.py(1333):         self.return_id = return_id
0.74 compiler.py(1334):         with self.connection.cursor() as cursor:
0.74 compiler.py(1335):             for sql, params in self.as_sql():
0.74 compiler.py(1269):         qn = self.connection.ops.quote_name
0.74 compiler.py(1270):         opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.74 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.74 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1276):         if self.query.fields:
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.74 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.74 compiler.py(1243):         if not value_rows:
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1264):         return placeholder_rows, param_rows
0.74 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.74 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.74 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.74 compiler.py(1315):         if can_bulk:
0.74 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.74 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1336):                 cursor.execute(sql, params)
0.74 compiler.py(1335):             for sql, params in self.as_sql():
0.74 compiler.py(1337):             if not return_id:
0.74 compiler.py(1338):                 return
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1758):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2236):         self.connector = connector
0.74 query.py(2237):         self.negated = negated
0.74 query.py(2238):         if self.negated:
0.74 query.py(2244):             self.effective_connector = self.connector
0.74 query.py(2245):         self.num_children = num_children
0.74 query.py(2248):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.74 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1545):                 transforms = names[pivot:]
0.74 query.py(1546):                 break
0.74 query.py(1547):         for name in transforms:
0.74 query.py(1562):         for join in path:
0.74 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.74 query.py(1251):             if isinstance(value, Iterator):
0.74 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.74 query.py(1100):         if field.is_relation:
0.74 query.py(1257):             self._lookup_joins = join_info.joins
0.74 query.py(1263):         used_joins.update(join_info.joins)
0.74 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.74 query.py(1601):         joins = joins[:]
0.74 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.74 query.py(1614):         return targets, joins[-1], joins
0.74 query.py(1265):         if can_reuse is not None:
0.74 query.py(1266):             can_reuse.update(join_list)
0.74 query.py(1268):         if join_info.final_field.is_relation:
0.74 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.74 query.py(72):     if simple_col:
0.74 query.py(74):     return target.get_col(alias, field)
0.74 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.74 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.74 query.py(1129):         for name in transforms:
0.74 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.74 query.py(1134):         if not lookup_class:
0.74 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.74 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.74 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.74 query.py(1161):         return lookup
0.74 query.py(1281):         lookup_type = condition.lookup_name
0.74 query.py(1282):         clause.add(condition, AND)
0.74 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.74 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.74 query.py(1302):         return clause, used_joins if not require_outer else ()
0.74 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.74 query.py(2255):         self.votes.update(votes)
0.74 query.py(1350):             if child_clause:
0.74 query.py(1351):                 target_clause.add(child_clause, connector)
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.74 query.py(2264):         to_promote = set()
0.74 query.py(2265):         to_demote = set()
0.74 query.py(2268):         for table, votes in self.votes.items():
0.74 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.74 query.py(2291):             if self.effective_connector == 'AND' or (
0.74 query.py(2293):                 to_demote.add(table)
0.74 query.py(2268):         for table, votes in self.votes.items():
0.74 query.py(2309):         query.promote_joins(to_promote)
0.74 query.py(771):         aliases = list(aliases)
0.74 query.py(772):         while aliases:
0.74 query.py(2310):         query.demote_joins(to_demote)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(806):             alias = aliases.pop(0)
0.74 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.74 query.py(805):         while aliases:
0.74 query.py(2311):         return to_demote
0.74 query.py(1353):         return target_clause, needed_inner
0.74 query.py(1320):         if clause:
0.74 query.py(1321):             self.where.add(clause, AND)
0.74 query.py(1322):         self.demote_joins(existing_inner)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 compiler.py(25):         self.query = query
0.74 compiler.py(26):         self.connection = connection
0.74 compiler.py(27):         self.using = using
0.74 compiler.py(28):         self.quote_cache = {'*': '*'}
0.74 compiler.py(33):         self.select = None
0.74 compiler.py(34):         self.annotation_col_map = None
0.74 compiler.py(35):         self.klass_info = None
0.74 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.74 compiler.py(38):         self._meta_ordering = None
0.74 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.74 compiler.py(1081):         try:
0.74 compiler.py(1082):             sql, params = self.as_sql()
0.74 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.74 compiler.py(479):         try:
0.74 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.74 compiler.py(52):         self.setup_query()
0.74 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.74 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.74 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.74 compiler.py(202):         select = []
0.74 compiler.py(203):         klass_info = None
0.74 compiler.py(204):         annotations = {}
0.74 compiler.py(205):         select_idx = 0
0.74 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.74 compiler.py(211):         if self.query.default_cols:
0.74 compiler.py(212):             cols = self.get_default_columns()
0.74 compiler.py(644):         result = []
0.74 compiler.py(645):         if opts is None:
0.74 compiler.py(646):             opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(647):         only_load = self.deferred_to_columns()
0.74 compiler.py(1018):         columns = {}
0.74 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.74 query.py(655):         field_names, defer = self.deferred_loading
0.74 query.py(656):         if not field_names:
0.74 query.py(657):             return
0.74 compiler.py(1020):         return columns
0.74 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(913):             alias = self.base_table
0.74 query.py(250):         for alias in self.alias_map:
0.74 query.py(251):             return alias
0.74 query.py(914):             self.ref_alias(alias)
0.74 query.py(754):         self.alias_refcount[alias] += 1
0.74 query.py(917):         return alias
0.74 compiler.py(652):         seen_models = {None: start_alias}
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(674):         return result
0.74 compiler.py(217):         if cols:
0.74 compiler.py(218):             select_list = []
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(224):                 'model': self.query.model,
0.74 compiler.py(225):                 'select_fields': select_list,
0.74 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.74 query.py(2075):         if self._annotation_select_cache is not None:
0.74 query.py(2077):         elif not self.annotations:
0.74 query.py(2078):             return {}
0.74 compiler.py(232):         if self.query.select_related:
0.74 compiler.py(244):         ret = []
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(252):         return ret, klass_info, annotations
0.74 compiler.py(44):         self.col_count = len(self.select)
0.74 compiler.py(53):         order_by = self.get_order_by()
0.74 compiler.py(263):         if self.query.extra_order_by:
0.74 compiler.py(265):         elif not self.query.default_ordering:
0.74 compiler.py(267):         elif self.query.order_by:
0.74 compiler.py(269):         elif self.query.get_meta().ordering:
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(273):             ordering = []
0.74 compiler.py(274):         if self.query.standard_ordering:
0.74 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.74 compiler.py(279):         order_by = []
0.74 compiler.py(280):         for field in ordering:
0.74 compiler.py(340):         result = []
0.74 compiler.py(341):         seen = set()
0.74 compiler.py(343):         for expr, is_ref in order_by:
0.74 compiler.py(376):         return result
0.74 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.74 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.74 compiler.py(379):         extra_select = []
0.74 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.74 compiler.py(386):         return extra_select
0.74 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.74 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.74 compiler.py(97):         if self.query.group_by is None:
0.74 compiler.py(98):             return []
0.74 compiler.py(58):         return extra_select, order_by, group_by
0.74 compiler.py(481):             for_update_part = None
0.74 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.74 compiler.py(484):             combinator = self.query.combinator
0.74 compiler.py(485):             features = self.connection.features
0.74 compiler.py(486):             if combinator:
0.74 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.74 compiler.py(683):         result = []
0.74 compiler.py(684):         params = []
0.74 compiler.py(685):         opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(687):         for name in self.query.distinct_fields:
0.74 compiler.py(698):         return result, params
0.74 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.74 compiler.py(755):         result = []
0.74 compiler.py(756):         params = []
0.74 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.74 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.74 compiler.py(760):             try:
0.74 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.74 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(767):             result.append(clause_sql)
0.74 compiler.py(768):             params.extend(clause_params)
0.74 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.74 compiler.py(769):         for t in self.query.extra_tables:
0.74 compiler.py(776):         return result, params
0.74 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.74 compiler.py(497):                 result = ['SELECT']
0.74 compiler.py(498):                 params = []
0.74 compiler.py(500):                 if self.query.distinct:
0.74 compiler.py(508):                 out_cols = []
0.74 compiler.py(509):                 col_idx = 1
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.74 compiler.py(520):                 params.extend(f_params)
0.74 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.74 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.74 compiler.py(552):                 if where:
0.74 compiler.py(553):                     result.append('WHERE %s' % where)
0.74 compiler.py(554):                     params.extend(w_params)
0.74 compiler.py(556):                 grouping = []
0.74 compiler.py(557):                 for g_sql, g_params in group_by:
0.74 compiler.py(560):                 if grouping:
0.74 compiler.py(577):                 if having:
0.74 compiler.py(581):             if self.query.explain_query:
0.74 compiler.py(587):             if order_by:
0.74 compiler.py(594):             if with_limit_offset:
0.74 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.74 compiler.py(600):             if self.query.subquery and extra_select:
0.74 compiler.py(627):             return ' '.join(result), tuple(params)
0.74 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.74 query.py(820):             self.unref_alias(alias, unref_amount)
0.74 query.py(758):         self.alias_refcount[alias] -= amount
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 compiler.py(1083):             if not sql:
0.74 compiler.py(1090):         if chunked_fetch:
0.74 compiler.py(1093):             cursor = self.connection.cursor()
0.74 compiler.py(1094):         try:
0.74 compiler.py(1095):             cursor.execute(sql, params)
0.74 compiler.py(1101):         if result_type == CURSOR:
0.74 compiler.py(1104):         if result_type == SINGLE:
0.74 compiler.py(1113):         if result_type == NO_RESULTS:
0.74 compiler.py(1117):         result = cursor_iter(
0.74 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.74 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.74 compiler.py(1120):             chunk_size,
0.74 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.74 compiler.py(1123):             try:
0.74 compiler.py(1128):                 return list(result)
0.74 compiler.py(1518):     try:
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1522):         cursor.close()
0.74 compiler.py(1131):                 cursor.close()
0.74 compiler.py(1046):         if results is None:
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1049):         converters = self.get_converters(fields)
0.74 compiler.py(1023):         converters = {}
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1030):         return converters
0.74 compiler.py(1050):         rows = chain.from_iterable(results)
0.74 compiler.py(1051):         if converters:
0.74 compiler.py(1055):         return rows
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 compiler.py(25):         self.query = query
0.74 compiler.py(26):         self.connection = connection
0.74 compiler.py(27):         self.using = using
0.74 compiler.py(28):         self.quote_cache = {'*': '*'}
0.74 compiler.py(33):         self.select = None
0.74 compiler.py(34):         self.annotation_col_map = None
0.74 compiler.py(35):         self.klass_info = None
0.74 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.74 compiler.py(38):         self._meta_ordering = None
0.74 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.74 compiler.py(1333):         self.return_id = return_id
0.74 compiler.py(1334):         with self.connection.cursor() as cursor:
0.74 compiler.py(1335):             for sql, params in self.as_sql():
0.74 compiler.py(1269):         qn = self.connection.ops.quote_name
0.74 compiler.py(1270):         opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.74 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.74 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.74 compiler.py(1276):         if self.query.fields:
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1279):                 for obj in self.query.objs
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1227):         if self.query.raw:
0.74 compiler.py(1229):         return field.pre_save(obj, add=True)
0.74 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.74 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.74 compiler.py(1220):         return value
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.74 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.74 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.74 compiler.py(1243):         if not value_rows:
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1250):             for row in value_rows
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1170):         if field is None:
0.74 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.74 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.74 compiler.py(1182):             sql, params = '%s', [val]
0.74 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.74 compiler.py(1191):         return sql, params
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.74 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.74 compiler.py(1264):         return placeholder_rows, param_rows
0.74 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.74 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.74 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.74 compiler.py(1315):         if can_bulk:
0.74 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.74 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.74 compiler.py(1336):                 cursor.execute(sql, params)
0.74 compiler.py(1335):             for sql, params in self.as_sql():
0.74 compiler.py(1337):             if not return_id:
0.74 compiler.py(1338):                 return
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1758):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2236):         self.connector = connector
0.74 query.py(2237):         self.negated = negated
0.74 query.py(2238):         if self.negated:
0.74 query.py(2244):             self.effective_connector = self.connector
0.74 query.py(2245):         self.num_children = num_children
0.74 query.py(2248):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.74 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1545):                 transforms = names[pivot:]
0.74 query.py(1546):                 break
0.74 query.py(1547):         for name in transforms:
0.74 query.py(1562):         for join in path:
0.74 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.74 query.py(1251):             if isinstance(value, Iterator):
0.74 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.74 query.py(1100):         if field.is_relation:
0.74 query.py(1257):             self._lookup_joins = join_info.joins
0.74 query.py(1263):         used_joins.update(join_info.joins)
0.74 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.74 query.py(1601):         joins = joins[:]
0.74 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.74 query.py(1614):         return targets, joins[-1], joins
0.74 query.py(1265):         if can_reuse is not None:
0.74 query.py(1266):             can_reuse.update(join_list)
0.74 query.py(1268):         if join_info.final_field.is_relation:
0.74 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.74 query.py(72):     if simple_col:
0.74 query.py(74):     return target.get_col(alias, field)
0.74 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.74 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.74 query.py(1129):         for name in transforms:
0.74 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.74 query.py(1134):         if not lookup_class:
0.74 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.74 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.74 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.74 query.py(1161):         return lookup
0.74 query.py(1281):         lookup_type = condition.lookup_name
0.74 query.py(1282):         clause.add(condition, AND)
0.74 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.74 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.74 query.py(1302):         return clause, used_joins if not require_outer else ()
0.74 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.74 query.py(2255):         self.votes.update(votes)
0.74 query.py(1350):             if child_clause:
0.74 query.py(1351):                 target_clause.add(child_clause, connector)
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.74 query.py(2264):         to_promote = set()
0.74 query.py(2265):         to_demote = set()
0.74 query.py(2268):         for table, votes in self.votes.items():
0.74 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.74 query.py(2291):             if self.effective_connector == 'AND' or (
0.74 query.py(2293):                 to_demote.add(table)
0.74 query.py(2268):         for table, votes in self.votes.items():
0.74 query.py(2309):         query.promote_joins(to_promote)
0.74 query.py(771):         aliases = list(aliases)
0.74 query.py(772):         while aliases:
0.74 query.py(2310):         query.demote_joins(to_demote)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(806):             alias = aliases.pop(0)
0.74 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.74 query.py(805):         while aliases:
0.74 query.py(2311):         return to_demote
0.74 query.py(1353):         return target_clause, needed_inner
0.74 query.py(1320):         if clause:
0.74 query.py(1321):             self.where.add(clause, AND)
0.74 query.py(1322):         self.demote_joins(existing_inner)
0.74 query.py(804):         aliases = list(aliases)
0.74 query.py(805):         while aliases:
0.74 query.py(278):         if using is None and connection is None:
0.74 query.py(280):         if using:
0.74 query.py(281):             connection = connections[using]
0.74 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.74 compiler.py(25):         self.query = query
0.74 compiler.py(26):         self.connection = connection
0.74 compiler.py(27):         self.using = using
0.74 compiler.py(28):         self.quote_cache = {'*': '*'}
0.74 compiler.py(33):         self.select = None
0.74 compiler.py(34):         self.annotation_col_map = None
0.74 compiler.py(35):         self.klass_info = None
0.74 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.74 compiler.py(38):         self._meta_ordering = None
0.74 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.74 compiler.py(1081):         try:
0.74 compiler.py(1082):             sql, params = self.as_sql()
0.74 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.74 compiler.py(479):         try:
0.74 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.74 compiler.py(52):         self.setup_query()
0.74 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.74 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.74 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.74 compiler.py(202):         select = []
0.74 compiler.py(203):         klass_info = None
0.74 compiler.py(204):         annotations = {}
0.74 compiler.py(205):         select_idx = 0
0.74 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.74 compiler.py(211):         if self.query.default_cols:
0.74 compiler.py(212):             cols = self.get_default_columns()
0.74 compiler.py(644):         result = []
0.74 compiler.py(645):         if opts is None:
0.74 compiler.py(646):             opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(647):         only_load = self.deferred_to_columns()
0.74 compiler.py(1018):         columns = {}
0.74 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.74 query.py(655):         field_names, defer = self.deferred_loading
0.74 query.py(656):         if not field_names:
0.74 query.py(657):             return
0.74 compiler.py(1020):         return columns
0.74 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(913):             alias = self.base_table
0.74 query.py(250):         for alias in self.alias_map:
0.74 query.py(251):             return alias
0.74 query.py(914):             self.ref_alias(alias)
0.74 query.py(754):         self.alias_refcount[alias] += 1
0.74 query.py(917):         return alias
0.74 compiler.py(652):         seen_models = {None: start_alias}
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(655):             model = field.model._meta.concrete_model
0.74 compiler.py(658):             if model == opts.model:
0.74 compiler.py(659):                 model = None
0.74 compiler.py(660):             if from_parent and model is not None and issubclass(
0.74 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.74 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.74 compiler.py(671):                                                  seen_models)
0.74 query.py(984):         if model in seen:
0.74 query.py(985):             return seen[model]
0.74 compiler.py(672):             column = field.get_col(alias)
0.74 compiler.py(673):             result.append(column)
0.74 compiler.py(654):         for field in opts.concrete_fields:
0.74 compiler.py(674):         return result
0.74 compiler.py(217):         if cols:
0.74 compiler.py(218):             select_list = []
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(220):                 select_list.append(select_idx)
0.74 compiler.py(221):                 select.append((col, None))
0.74 compiler.py(222):                 select_idx += 1
0.74 compiler.py(219):             for col in cols:
0.74 compiler.py(224):                 'model': self.query.model,
0.74 compiler.py(225):                 'select_fields': select_list,
0.74 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.74 query.py(2075):         if self._annotation_select_cache is not None:
0.74 query.py(2077):         elif not self.annotations:
0.74 query.py(2078):             return {}
0.74 compiler.py(232):         if self.query.select_related:
0.74 compiler.py(244):         ret = []
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(246):             try:
0.74 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.74 compiler.py(397):                 name in self.query.extra_select or (
0.74 query.py(2090):         if self._extra_select_cache is not None:
0.74 query.py(2092):         if not self.extra:
0.74 query.py(2093):             return {}
0.74 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.74 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.74 compiler.py(402):         self.quote_cache[name] = r
0.74 compiler.py(403):         return r
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.74 compiler.py(251):             ret.append((col, (sql, params), alias))
0.74 compiler.py(245):         for col, alias in select:
0.74 compiler.py(252):         return ret, klass_info, annotations
0.74 compiler.py(44):         self.col_count = len(self.select)
0.74 compiler.py(53):         order_by = self.get_order_by()
0.74 compiler.py(263):         if self.query.extra_order_by:
0.74 compiler.py(265):         elif not self.query.default_ordering:
0.74 compiler.py(267):         elif self.query.order_by:
0.74 compiler.py(269):         elif self.query.get_meta().ordering:
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(273):             ordering = []
0.74 compiler.py(274):         if self.query.standard_ordering:
0.74 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.74 compiler.py(279):         order_by = []
0.74 compiler.py(280):         for field in ordering:
0.74 compiler.py(340):         result = []
0.74 compiler.py(341):         seen = set()
0.74 compiler.py(343):         for expr, is_ref in order_by:
0.74 compiler.py(376):         return result
0.74 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.74 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.74 compiler.py(379):         extra_select = []
0.74 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.74 compiler.py(386):         return extra_select
0.74 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.74 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.74 compiler.py(97):         if self.query.group_by is None:
0.74 compiler.py(98):             return []
0.74 compiler.py(58):         return extra_select, order_by, group_by
0.74 compiler.py(481):             for_update_part = None
0.74 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.74 compiler.py(484):             combinator = self.query.combinator
0.74 compiler.py(485):             features = self.connection.features
0.74 compiler.py(486):             if combinator:
0.74 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.74 compiler.py(683):         result = []
0.74 compiler.py(684):         params = []
0.74 compiler.py(685):         opts = self.query.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 compiler.py(687):         for name in self.query.distinct_fields:
0.74 compiler.py(698):         return result, params
0.74 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.74 compiler.py(755):         result = []
0.74 compiler.py(756):         params = []
0.74 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.74 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.74 compiler.py(760):             try:
0.74 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.74 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(767):             result.append(clause_sql)
0.74 compiler.py(768):             params.extend(clause_params)
0.74 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.74 compiler.py(769):         for t in self.query.extra_tables:
0.74 compiler.py(776):         return result, params
0.74 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.74 compiler.py(407):         if vendor_impl:
0.74 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(394):         if name in self.quote_cache:
0.74 compiler.py(395):             return self.quote_cache[name]
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.74 compiler.py(413):         return sql, params
0.74 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.74 compiler.py(497):                 result = ['SELECT']
0.74 compiler.py(498):                 params = []
0.74 compiler.py(500):                 if self.query.distinct:
0.74 compiler.py(508):                 out_cols = []
0.74 compiler.py(509):                 col_idx = 1
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(511):                     if alias:
0.74 compiler.py(513):                     elif with_col_aliases:
0.74 compiler.py(516):                     params.extend(s_params)
0.74 compiler.py(517):                     out_cols.append(s_sql)
0.74 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.74 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.74 compiler.py(520):                 params.extend(f_params)
0.74 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.74 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.74 compiler.py(552):                 if where:
0.74 compiler.py(553):                     result.append('WHERE %s' % where)
0.74 compiler.py(554):                     params.extend(w_params)
0.74 compiler.py(556):                 grouping = []
0.74 compiler.py(557):                 for g_sql, g_params in group_by:
0.74 compiler.py(560):                 if grouping:
0.74 compiler.py(577):                 if having:
0.74 compiler.py(581):             if self.query.explain_query:
0.74 compiler.py(587):             if order_by:
0.74 compiler.py(594):             if with_limit_offset:
0.74 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.74 compiler.py(600):             if self.query.subquery and extra_select:
0.74 compiler.py(627):             return ' '.join(result), tuple(params)
0.74 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.74 query.py(820):             self.unref_alias(alias, unref_amount)
0.74 query.py(758):         self.alias_refcount[alias] -= amount
0.74 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.74 compiler.py(1083):             if not sql:
0.74 compiler.py(1090):         if chunked_fetch:
0.74 compiler.py(1093):             cursor = self.connection.cursor()
0.74 compiler.py(1094):         try:
0.74 compiler.py(1095):             cursor.execute(sql, params)
0.74 compiler.py(1101):         if result_type == CURSOR:
0.74 compiler.py(1104):         if result_type == SINGLE:
0.74 compiler.py(1113):         if result_type == NO_RESULTS:
0.74 compiler.py(1117):         result = cursor_iter(
0.74 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.74 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.74 compiler.py(1120):             chunk_size,
0.74 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.74 compiler.py(1123):             try:
0.74 compiler.py(1128):                 return list(result)
0.74 compiler.py(1518):     try:
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.74 compiler.py(1522):         cursor.close()
0.74 compiler.py(1131):                 cursor.close()
0.74 compiler.py(1046):         if results is None:
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.74 compiler.py(1049):         converters = self.get_converters(fields)
0.74 compiler.py(1023):         converters = {}
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1025):             if expression:
0.74 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.74 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.74 compiler.py(1028):                 if backend_converters or field_converters:
0.74 compiler.py(1024):         for i, expression in enumerate(expressions):
0.74 compiler.py(1030):         return converters
0.74 compiler.py(1050):         rows = chain.from_iterable(results)
0.74 compiler.py(1051):         if converters:
0.74 compiler.py(1055):         return rows
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(154):         self.model = model
0.74 query.py(155):         self.alias_refcount = {}
0.74 query.py(161):         self.alias_map = {}
0.74 query.py(165):         self.external_aliases = set()
0.74 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.74 query.py(167):         self.default_cols = True
0.74 query.py(168):         self.default_ordering = True
0.74 query.py(169):         self.standard_ordering = True
0.74 query.py(170):         self.used_aliases = set()
0.74 query.py(171):         self.filter_is_sticky = False
0.74 query.py(172):         self.subquery = False
0.74 query.py(180):         self.select = ()
0.74 query.py(181):         self.where = where()
0.74 query.py(182):         self.where_class = where
0.74 query.py(189):         self.group_by = None
0.74 query.py(190):         self.order_by = ()
0.74 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.74 query.py(192):         self.distinct = False
0.74 query.py(193):         self.distinct_fields = ()
0.74 query.py(194):         self.select_for_update = False
0.74 query.py(195):         self.select_for_update_nowait = False
0.74 query.py(196):         self.select_for_update_skip_locked = False
0.74 query.py(197):         self.select_for_update_of = ()
0.74 query.py(199):         self.select_related = False
0.74 query.py(201):         self.max_depth = 5
0.74 query.py(205):         self.values_select = ()
0.74 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.74 query.py(209):         self.annotation_select_mask = None
0.74 query.py(210):         self._annotation_select_cache = None
0.74 query.py(213):         self.combinator = None
0.74 query.py(214):         self.combinator_all = False
0.74 query.py(215):         self.combined_queries = ()
0.74 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.74 query.py(220):         self.extra_select_mask = None
0.74 query.py(221):         self._extra_select_cache = None
0.74 query.py(223):         self.extra_tables = ()
0.74 query.py(224):         self.extra_order_by = ()
0.74 query.py(229):         self.deferred_loading = (frozenset(), True)
0.74 query.py(231):         self._filtered_relations = {}
0.74 query.py(233):         self.explain_query = False
0.74 query.py(234):         self.explain_format = None
0.74 query.py(235):         self.explain_options = {}
0.74 query.py(1758):         return not self.low_mark and self.high_mark is None
0.74 query.py(343):         obj = self.clone()
0.74 query.py(297):         obj = Empty()
0.74 query.py(298):         obj.__class__ = self.__class__
0.74 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.74 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.74 query.py(303):         obj.alias_map = self.alias_map.copy()
0.74 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.74 query.py(305):         obj.table_map = self.table_map.copy()
0.74 query.py(306):         obj.where = self.where.clone()
0.74 query.py(307):         obj.annotations = self.annotations.copy()
0.74 query.py(308):         if self.annotation_select_mask is None:
0.74 query.py(309):             obj.annotation_select_mask = None
0.74 query.py(317):         obj._annotation_select_cache = None
0.74 query.py(318):         obj.extra = self.extra.copy()
0.74 query.py(319):         if self.extra_select_mask is None:
0.74 query.py(320):             obj.extra_select_mask = None
0.74 query.py(323):         if self._extra_select_cache is None:
0.74 query.py(324):             obj._extra_select_cache = None
0.74 query.py(327):         if 'subq_aliases' in self.__dict__:
0.74 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.74 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.74 query.py(332):         try:
0.74 query.py(333):             del obj.base_table
0.74 query.py(334):         except AttributeError:
0.74 query.py(335):             pass
0.74 query.py(336):         return obj
0.74 query.py(344):         if klass and obj.__class__ != klass:
0.74 query.py(346):         if not obj.filter_is_sticky:
0.74 query.py(347):             obj.used_aliases = set()
0.74 query.py(348):         obj.filter_is_sticky = False
0.74 query.py(349):         if hasattr(obj, '_setup_query'):
0.74 query.py(351):         return obj
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.74 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.74 query.py(1331):         connector = q_object.connector
0.74 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.74 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.74 query.py(1334):         target_clause = self.where_class(connector=connector,
0.74 query.py(1335):                                          negated=q_object.negated)
0.74 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.74 query.py(2236):         self.connector = connector
0.74 query.py(2237):         self.negated = negated
0.74 query.py(2238):         if self.negated:
0.74 query.py(2244):             self.effective_connector = self.connector
0.74 query.py(2245):         self.num_children = num_children
0.74 query.py(2248):         self.votes = Counter()
0.74 query.py(1337):         for child in q_object.children:
0.74 query.py(1338):             if isinstance(child, Node):
0.74 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.74 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.74 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.74 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.74 query.py(1214):         if isinstance(filter_expr, dict):
0.74 query.py(1216):         arg, value = filter_expr
0.74 query.py(1217):         if not arg:
0.74 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.74 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.74 query.py(1074):         if self.annotations:
0.74 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.74 query.py(290):         return self.model._meta
0.74 query.py(1405):         path, names_with_path = [], []
0.74 query.py(1406):         for pos, name in enumerate(names):
0.74 query.py(1407):             cur_names_with_path = (name, [])
0.74 query.py(1408):             if name == 'pk':
0.74 query.py(1411):             field = None
0.74 query.py(1412):             filtered_relation = None
0.74 query.py(1413):             try:
0.74 query.py(1414):                 field = opts.get_field(name)
0.74 query.py(1421):             if field is not None:
0.74 query.py(1425):                 if field.is_relation and not field.related_model:
0.74 query.py(1432):                 try:
0.74 query.py(1433):                     model = field.model._meta.concrete_model
0.74 query.py(1454):             if model is not opts.model:
0.74 query.py(1460):             if hasattr(field, 'get_path_info'):
0.74 query.py(1477):                 final_field = field
0.74 query.py(1478):                 targets = (field,)
0.74 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.74 query.py(1483):                 break
0.74 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.74 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.74 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.74 query.py(1085):         return lookup_parts, field_parts, False
0.74 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.74 query.py(1227):         if not allow_joins and len(parts) > 1:
0.74 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.74 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.74 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.74 query.py(1055):         elif isinstance(value, (list, tuple)):
0.74 query.py(1067):         return value
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.74 query.py(1234):         clause = self.where_class()
0.74 query.py(1235):         if reffed_expression:
0.74 query.py(1240):         opts = self.get_meta()
0.74 query.py(290):         return self.model._meta
0.74 query.py(1241):         alias = self.get_initial_alias()
0.74 query.py(912):         if self.alias_map:
0.74 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.74 query.py(290):         return self.model._meta
0.74 query.py(943):         if reuse_with_filtered_relation and reuse:
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(950):                 a for a, j in self.alias_map.items()
0.74 query.py(953):         if reuse_aliases:
0.74 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.74 query.py(735):         alias_list = self.table_map.get(table_name)
0.74 query.py(736):         if not create and alias_list:
0.74 query.py(742):         if alias_list:
0.74 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.74 query.py(748):             self.table_map[table_name] = [alias]
0.74 query.py(749):         self.alias_refcount[alias] = 1
0.74 query.py(750):         return alias, True
0.74 query.py(965):         if join.join_type:
0.74 query.py(971):         join.table_alias = alias
0.74 query.py(972):         self.alias_map[alias] = join
0.74 query.py(973):         return alias
0.74 query.py(917):         return alias
0.74 query.py(1242):         allow_many = not branch_negated or not split_subq
0.74 query.py(1244):         try:
0.74 query.py(1245):             join_info = self.setup_joins(
0.74 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.74 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.74 query.py(1518):         joins = [alias]
0.74 query.py(1524):         def final_transformer(field, alias):
0.74 query.py(1529):         last_field_exception = None
0.74 query.py(1530):         for pivot in range(len(names), 0, -1):
0.74 query.py(1531):             try:
0.74 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2264):         to_promote = set()
0.75 query.py(2265):         to_demote = set()
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2291):             if self.effective_connector == 'AND' or (
0.75 query.py(2293):                 to_demote.add(table)
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2309):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2310):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2311):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1860):         self.order_by = ()
0.75 query.py(1861):         self.extra_order_by = ()
0.75 query.py(1862):         if force_empty:
0.75 query.py(1839):         errors = []
0.75 query.py(1840):         for item in ordering:
0.75 query.py(1848):         if errors:
0.75 query.py(1850):         if ordering:
0.75 query.py(1853):             self.default_ordering = False
0.75 query.py(1731):         if high is not None:
0.75 query.py(1732):             if self.high_mark is not None:
0.75 query.py(1735):                 self.high_mark = self.low_mark + high
0.75 query.py(1736):         if low is not None:
0.75 query.py(1742):         if self.low_mark == self.high_mark:
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 compiler.py(25):         self.query = query
0.75 compiler.py(26):         self.connection = connection
0.75 compiler.py(27):         self.using = using
0.75 compiler.py(28):         self.quote_cache = {'*': '*'}
0.75 compiler.py(33):         self.select = None
0.75 compiler.py(34):         self.annotation_col_map = None
0.75 compiler.py(35):         self.klass_info = None
0.75 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.75 compiler.py(38):         self._meta_ordering = None
0.75 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.75 compiler.py(1081):         try:
0.75 compiler.py(1082):             sql, params = self.as_sql()
0.75 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.75 compiler.py(479):         try:
0.75 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.75 compiler.py(52):         self.setup_query()
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.75 compiler.py(202):         select = []
0.75 compiler.py(203):         klass_info = None
0.75 compiler.py(204):         annotations = {}
0.75 compiler.py(205):         select_idx = 0
0.75 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.75 compiler.py(211):         if self.query.default_cols:
0.75 compiler.py(212):             cols = self.get_default_columns()
0.75 compiler.py(644):         result = []
0.75 compiler.py(645):         if opts is None:
0.75 compiler.py(646):             opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(647):         only_load = self.deferred_to_columns()
0.75 compiler.py(1018):         columns = {}
0.75 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 compiler.py(1020):         return columns
0.75 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 compiler.py(652):         seen_models = {None: start_alias}
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(674):         return result
0.75 compiler.py(217):         if cols:
0.75 compiler.py(218):             select_list = []
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(224):                 'model': self.query.model,
0.75 compiler.py(225):                 'select_fields': select_list,
0.75 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.75 query.py(2075):         if self._annotation_select_cache is not None:
0.75 query.py(2077):         elif not self.annotations:
0.75 query.py(2078):             return {}
0.75 compiler.py(232):         if self.query.select_related:
0.75 compiler.py(244):         ret = []
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(252):         return ret, klass_info, annotations
0.75 compiler.py(44):         self.col_count = len(self.select)
0.75 compiler.py(53):         order_by = self.get_order_by()
0.75 compiler.py(263):         if self.query.extra_order_by:
0.75 compiler.py(265):         elif not self.query.default_ordering:
0.75 compiler.py(266):             ordering = self.query.order_by
0.75 compiler.py(274):         if self.query.standard_ordering:
0.75 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.75 compiler.py(279):         order_by = []
0.75 compiler.py(280):         for field in ordering:
0.75 compiler.py(340):         result = []
0.75 compiler.py(341):         seen = set()
0.75 compiler.py(343):         for expr, is_ref in order_by:
0.75 compiler.py(376):         return result
0.75 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.75 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.75 compiler.py(379):         extra_select = []
0.75 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.75 compiler.py(386):         return extra_select
0.75 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.75 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.75 compiler.py(97):         if self.query.group_by is None:
0.75 compiler.py(98):             return []
0.75 compiler.py(58):         return extra_select, order_by, group_by
0.75 compiler.py(481):             for_update_part = None
0.75 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.75 compiler.py(484):             combinator = self.query.combinator
0.75 compiler.py(485):             features = self.connection.features
0.75 compiler.py(486):             if combinator:
0.75 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.75 compiler.py(683):         result = []
0.75 compiler.py(684):         params = []
0.75 compiler.py(685):         opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(687):         for name in self.query.distinct_fields:
0.75 compiler.py(698):         return result, params
0.75 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.75 compiler.py(755):         result = []
0.75 compiler.py(756):         params = []
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.75 compiler.py(760):             try:
0.75 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.75 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(767):             result.append(clause_sql)
0.75 compiler.py(768):             params.extend(clause_params)
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(769):         for t in self.query.extra_tables:
0.75 compiler.py(776):         return result, params
0.75 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.75 compiler.py(497):                 result = ['SELECT']
0.75 compiler.py(498):                 params = []
0.75 compiler.py(500):                 if self.query.distinct:
0.75 compiler.py(508):                 out_cols = []
0.75 compiler.py(509):                 col_idx = 1
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.75 compiler.py(520):                 params.extend(f_params)
0.75 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.75 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.75 compiler.py(552):                 if where:
0.75 compiler.py(553):                     result.append('WHERE %s' % where)
0.75 compiler.py(554):                     params.extend(w_params)
0.75 compiler.py(556):                 grouping = []
0.75 compiler.py(557):                 for g_sql, g_params in group_by:
0.75 compiler.py(560):                 if grouping:
0.75 compiler.py(577):                 if having:
0.75 compiler.py(581):             if self.query.explain_query:
0.75 compiler.py(587):             if order_by:
0.75 compiler.py(594):             if with_limit_offset:
0.75 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.75 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.75 compiler.py(600):             if self.query.subquery and extra_select:
0.75 compiler.py(627):             return ' '.join(result), tuple(params)
0.75 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 compiler.py(1083):             if not sql:
0.75 compiler.py(1090):         if chunked_fetch:
0.75 compiler.py(1093):             cursor = self.connection.cursor()
0.75 compiler.py(1094):         try:
0.75 compiler.py(1095):             cursor.execute(sql, params)
0.75 compiler.py(1101):         if result_type == CURSOR:
0.75 compiler.py(1104):         if result_type == SINGLE:
0.75 compiler.py(1113):         if result_type == NO_RESULTS:
0.75 compiler.py(1117):         result = cursor_iter(
0.75 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.75 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.75 compiler.py(1120):             chunk_size,
0.75 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.75 compiler.py(1123):             try:
0.75 compiler.py(1128):                 return list(result)
0.75 compiler.py(1518):     try:
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1522):         cursor.close()
0.75 compiler.py(1131):                 cursor.close()
0.75 compiler.py(1046):         if results is None:
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1049):         converters = self.get_converters(fields)
0.75 compiler.py(1023):         converters = {}
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1030):         return converters
0.75 compiler.py(1050):         rows = chain.from_iterable(results)
0.75 compiler.py(1051):         if converters:
0.75 compiler.py(1055):         return rows
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.75 query.py(1331):         connector = q_object.connector
0.75 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.75 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.75 query.py(1334):         target_clause = self.where_class(connector=connector,
0.75 query.py(1335):                                          negated=q_object.negated)
0.75 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.75 query.py(2236):         self.connector = connector
0.75 query.py(2237):         self.negated = negated
0.75 query.py(2238):         if self.negated:
0.75 query.py(2244):             self.effective_connector = self.connector
0.75 query.py(2245):         self.num_children = num_children
0.75 query.py(2248):         self.votes = Counter()
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.75 query.py(290):         return self.model._meta
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2264):         to_promote = set()
0.75 query.py(2265):         to_demote = set()
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2291):             if self.effective_connector == 'AND' or (
0.75 query.py(2293):                 to_demote.add(table)
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2309):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2310):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2311):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1860):         self.order_by = ()
0.75 query.py(1861):         self.extra_order_by = ()
0.75 query.py(1862):         if force_empty:
0.75 query.py(1839):         errors = []
0.75 query.py(1840):         for item in ordering:
0.75 query.py(1848):         if errors:
0.75 query.py(1850):         if ordering:
0.75 query.py(1853):             self.default_ordering = False
0.75 query.py(1731):         if high is not None:
0.75 query.py(1732):             if self.high_mark is not None:
0.75 query.py(1735):                 self.high_mark = self.low_mark + high
0.75 query.py(1736):         if low is not None:
0.75 query.py(1742):         if self.low_mark == self.high_mark:
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 compiler.py(25):         self.query = query
0.75 compiler.py(26):         self.connection = connection
0.75 compiler.py(27):         self.using = using
0.75 compiler.py(28):         self.quote_cache = {'*': '*'}
0.75 compiler.py(33):         self.select = None
0.75 compiler.py(34):         self.annotation_col_map = None
0.75 compiler.py(35):         self.klass_info = None
0.75 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.75 compiler.py(38):         self._meta_ordering = None
0.75 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.75 compiler.py(1081):         try:
0.75 compiler.py(1082):             sql, params = self.as_sql()
0.75 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.75 compiler.py(479):         try:
0.75 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.75 compiler.py(52):         self.setup_query()
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.75 compiler.py(202):         select = []
0.75 compiler.py(203):         klass_info = None
0.75 compiler.py(204):         annotations = {}
0.75 compiler.py(205):         select_idx = 0
0.75 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.75 compiler.py(211):         if self.query.default_cols:
0.75 compiler.py(212):             cols = self.get_default_columns()
0.75 compiler.py(644):         result = []
0.75 compiler.py(645):         if opts is None:
0.75 compiler.py(646):             opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(647):         only_load = self.deferred_to_columns()
0.75 compiler.py(1018):         columns = {}
0.75 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 compiler.py(1020):         return columns
0.75 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 compiler.py(652):         seen_models = {None: start_alias}
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(674):         return result
0.75 compiler.py(217):         if cols:
0.75 compiler.py(218):             select_list = []
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(224):                 'model': self.query.model,
0.75 compiler.py(225):                 'select_fields': select_list,
0.75 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.75 query.py(2075):         if self._annotation_select_cache is not None:
0.75 query.py(2077):         elif not self.annotations:
0.75 query.py(2078):             return {}
0.75 compiler.py(232):         if self.query.select_related:
0.75 compiler.py(244):         ret = []
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(252):         return ret, klass_info, annotations
0.75 compiler.py(44):         self.col_count = len(self.select)
0.75 compiler.py(53):         order_by = self.get_order_by()
0.75 compiler.py(263):         if self.query.extra_order_by:
0.75 compiler.py(265):         elif not self.query.default_ordering:
0.75 compiler.py(266):             ordering = self.query.order_by
0.75 compiler.py(274):         if self.query.standard_ordering:
0.75 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.75 compiler.py(279):         order_by = []
0.75 compiler.py(280):         for field in ordering:
0.75 compiler.py(340):         result = []
0.75 compiler.py(341):         seen = set()
0.75 compiler.py(343):         for expr, is_ref in order_by:
0.75 compiler.py(376):         return result
0.75 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.75 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.75 compiler.py(379):         extra_select = []
0.75 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.75 compiler.py(386):         return extra_select
0.75 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.75 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.75 compiler.py(97):         if self.query.group_by is None:
0.75 compiler.py(98):             return []
0.75 compiler.py(58):         return extra_select, order_by, group_by
0.75 compiler.py(481):             for_update_part = None
0.75 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.75 compiler.py(484):             combinator = self.query.combinator
0.75 compiler.py(485):             features = self.connection.features
0.75 compiler.py(486):             if combinator:
0.75 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.75 compiler.py(683):         result = []
0.75 compiler.py(684):         params = []
0.75 compiler.py(685):         opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(687):         for name in self.query.distinct_fields:
0.75 compiler.py(698):         return result, params
0.75 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.75 compiler.py(755):         result = []
0.75 compiler.py(756):         params = []
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.75 compiler.py(760):             try:
0.75 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.75 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(767):             result.append(clause_sql)
0.75 compiler.py(768):             params.extend(clause_params)
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(769):         for t in self.query.extra_tables:
0.75 compiler.py(776):         return result, params
0.75 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.75 compiler.py(497):                 result = ['SELECT']
0.75 compiler.py(498):                 params = []
0.75 compiler.py(500):                 if self.query.distinct:
0.75 compiler.py(508):                 out_cols = []
0.75 compiler.py(509):                 col_idx = 1
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.75 compiler.py(520):                 params.extend(f_params)
0.75 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.75 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.75 compiler.py(552):                 if where:
0.75 compiler.py(553):                     result.append('WHERE %s' % where)
0.75 compiler.py(554):                     params.extend(w_params)
0.75 compiler.py(556):                 grouping = []
0.75 compiler.py(557):                 for g_sql, g_params in group_by:
0.75 compiler.py(560):                 if grouping:
0.75 compiler.py(577):                 if having:
0.75 compiler.py(581):             if self.query.explain_query:
0.75 compiler.py(587):             if order_by:
0.75 compiler.py(594):             if with_limit_offset:
0.75 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.75 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.75 compiler.py(600):             if self.query.subquery and extra_select:
0.75 compiler.py(627):             return ' '.join(result), tuple(params)
0.75 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.75 query.py(820):             self.unref_alias(alias, unref_amount)
0.75 query.py(758):         self.alias_refcount[alias] -= amount
0.75 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.75 compiler.py(1083):             if not sql:
0.75 compiler.py(1090):         if chunked_fetch:
0.75 compiler.py(1093):             cursor = self.connection.cursor()
0.75 compiler.py(1094):         try:
0.75 compiler.py(1095):             cursor.execute(sql, params)
0.75 compiler.py(1101):         if result_type == CURSOR:
0.75 compiler.py(1104):         if result_type == SINGLE:
0.75 compiler.py(1113):         if result_type == NO_RESULTS:
0.75 compiler.py(1117):         result = cursor_iter(
0.75 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.75 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.75 compiler.py(1120):             chunk_size,
0.75 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.75 compiler.py(1123):             try:
0.75 compiler.py(1128):                 return list(result)
0.75 compiler.py(1518):     try:
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.75 compiler.py(1522):         cursor.close()
0.75 compiler.py(1131):                 cursor.close()
0.75 compiler.py(1046):         if results is None:
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.75 compiler.py(1049):         converters = self.get_converters(fields)
0.75 compiler.py(1023):         converters = {}
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1025):             if expression:
0.75 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.75 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.75 compiler.py(1028):                 if backend_converters or field_converters:
0.75 compiler.py(1024):         for i, expression in enumerate(expressions):
0.75 compiler.py(1030):         return converters
0.75 compiler.py(1050):         rows = chain.from_iterable(results)
0.75 compiler.py(1051):         if converters:
0.75 compiler.py(1055):         return rows
0.75 query.py(154):         self.model = model
0.75 query.py(155):         self.alias_refcount = {}
0.75 query.py(161):         self.alias_map = {}
0.75 query.py(165):         self.external_aliases = set()
0.75 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.75 query.py(167):         self.default_cols = True
0.75 query.py(168):         self.default_ordering = True
0.75 query.py(169):         self.standard_ordering = True
0.75 query.py(170):         self.used_aliases = set()
0.75 query.py(171):         self.filter_is_sticky = False
0.75 query.py(172):         self.subquery = False
0.75 query.py(180):         self.select = ()
0.75 query.py(181):         self.where = where()
0.75 query.py(182):         self.where_class = where
0.75 query.py(189):         self.group_by = None
0.75 query.py(190):         self.order_by = ()
0.75 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.75 query.py(192):         self.distinct = False
0.75 query.py(193):         self.distinct_fields = ()
0.75 query.py(194):         self.select_for_update = False
0.75 query.py(195):         self.select_for_update_nowait = False
0.75 query.py(196):         self.select_for_update_skip_locked = False
0.75 query.py(197):         self.select_for_update_of = ()
0.75 query.py(199):         self.select_related = False
0.75 query.py(201):         self.max_depth = 5
0.75 query.py(205):         self.values_select = ()
0.75 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.75 query.py(209):         self.annotation_select_mask = None
0.75 query.py(210):         self._annotation_select_cache = None
0.75 query.py(213):         self.combinator = None
0.75 query.py(214):         self.combinator_all = False
0.75 query.py(215):         self.combined_queries = ()
0.75 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.75 query.py(220):         self.extra_select_mask = None
0.75 query.py(221):         self._extra_select_cache = None
0.75 query.py(223):         self.extra_tables = ()
0.75 query.py(224):         self.extra_order_by = ()
0.75 query.py(229):         self.deferred_loading = (frozenset(), True)
0.75 query.py(231):         self._filtered_relations = {}
0.75 query.py(233):         self.explain_query = False
0.75 query.py(234):         self.explain_format = None
0.75 query.py(235):         self.explain_options = {}
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(334):         except AttributeError:
0.75 query.py(335):             pass
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.75 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.75 query.py(1331):         connector = q_object.connector
0.75 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.75 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.75 query.py(1334):         target_clause = self.where_class(connector=connector,
0.75 query.py(1335):                                          negated=q_object.negated)
0.75 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.75 query.py(2236):         self.connector = connector
0.75 query.py(2237):         self.negated = negated
0.75 query.py(2238):         if self.negated:
0.75 query.py(2244):             self.effective_connector = self.connector
0.75 query.py(2245):         self.num_children = num_children
0.75 query.py(2248):         self.votes = Counter()
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.75 query.py(290):         return self.model._meta
0.75 query.py(943):         if reuse_with_filtered_relation and reuse:
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(950):                 a for a, j in self.alias_map.items()
0.75 query.py(953):         if reuse_aliases:
0.75 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.75 query.py(735):         alias_list = self.table_map.get(table_name)
0.75 query.py(736):         if not create and alias_list:
0.75 query.py(742):         if alias_list:
0.75 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.75 query.py(748):             self.table_map[table_name] = [alias]
0.75 query.py(749):         self.alias_refcount[alias] = 1
0.75 query.py(750):         return alias, True
0.75 query.py(965):         if join.join_type:
0.75 query.py(971):         join.table_alias = alias
0.75 query.py(972):         self.alias_map[alias] = join
0.75 query.py(973):         return alias
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1338):             if isinstance(child, Node):
0.75 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.75 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.75 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.75 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.75 query.py(1214):         if isinstance(filter_expr, dict):
0.75 query.py(1216):         arg, value = filter_expr
0.75 query.py(1217):         if not arg:
0.75 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.75 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.75 query.py(1074):         if self.annotations:
0.75 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.75 query.py(290):         return self.model._meta
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.75 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.75 query.py(1085):         return lookup_parts, field_parts, False
0.75 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.75 query.py(1227):         if not allow_joins and len(parts) > 1:
0.75 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.75 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.75 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.75 query.py(1055):         elif isinstance(value, (list, tuple)):
0.75 query.py(1067):         return value
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.75 query.py(1234):         clause = self.where_class()
0.75 query.py(1235):         if reffed_expression:
0.75 query.py(1240):         opts = self.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 query.py(1241):         alias = self.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 query.py(1242):         allow_many = not branch_negated or not split_subq
0.75 query.py(1244):         try:
0.75 query.py(1245):             join_info = self.setup_joins(
0.75 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.75 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.75 query.py(1518):         joins = [alias]
0.75 query.py(1524):         def final_transformer(field, alias):
0.75 query.py(1529):         last_field_exception = None
0.75 query.py(1530):         for pivot in range(len(names), 0, -1):
0.75 query.py(1531):             try:
0.75 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.75 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.75 query.py(1405):         path, names_with_path = [], []
0.75 query.py(1406):         for pos, name in enumerate(names):
0.75 query.py(1407):             cur_names_with_path = (name, [])
0.75 query.py(1408):             if name == 'pk':
0.75 query.py(1411):             field = None
0.75 query.py(1412):             filtered_relation = None
0.75 query.py(1413):             try:
0.75 query.py(1414):                 field = opts.get_field(name)
0.75 query.py(1421):             if field is not None:
0.75 query.py(1425):                 if field.is_relation and not field.related_model:
0.75 query.py(1432):                 try:
0.75 query.py(1433):                     model = field.model._meta.concrete_model
0.75 query.py(1454):             if model is not opts.model:
0.75 query.py(1460):             if hasattr(field, 'get_path_info'):
0.75 query.py(1477):                 final_field = field
0.75 query.py(1478):                 targets = (field,)
0.75 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.75 query.py(1483):                 break
0.75 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.75 query.py(1545):                 transforms = names[pivot:]
0.75 query.py(1546):                 break
0.75 query.py(1547):         for name in transforms:
0.75 query.py(1562):         for join in path:
0.75 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.75 query.py(1251):             if isinstance(value, Iterator):
0.75 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.75 query.py(1100):         if field.is_relation:
0.75 query.py(1257):             self._lookup_joins = join_info.joins
0.75 query.py(1263):         used_joins.update(join_info.joins)
0.75 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.75 query.py(1601):         joins = joins[:]
0.75 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.75 query.py(1614):         return targets, joins[-1], joins
0.75 query.py(1265):         if can_reuse is not None:
0.75 query.py(1266):             can_reuse.update(join_list)
0.75 query.py(1268):         if join_info.final_field.is_relation:
0.75 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.75 query.py(72):     if simple_col:
0.75 query.py(74):     return target.get_col(alias, field)
0.75 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.75 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.75 query.py(1129):         for name in transforms:
0.75 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.75 query.py(1134):         if not lookup_class:
0.75 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.75 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.75 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.75 query.py(1161):         return lookup
0.75 query.py(1281):         lookup_type = condition.lookup_name
0.75 query.py(1282):         clause.add(condition, AND)
0.75 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.75 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.75 query.py(1302):         return clause, used_joins if not require_outer else ()
0.75 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.75 query.py(2255):         self.votes.update(votes)
0.75 query.py(1350):             if child_clause:
0.75 query.py(1351):                 target_clause.add(child_clause, connector)
0.75 query.py(1337):         for child in q_object.children:
0.75 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.75 query.py(2264):         to_promote = set()
0.75 query.py(2265):         to_demote = set()
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.75 query.py(2291):             if self.effective_connector == 'AND' or (
0.75 query.py(2293):                 to_demote.add(table)
0.75 query.py(2268):         for table, votes in self.votes.items():
0.75 query.py(2309):         query.promote_joins(to_promote)
0.75 query.py(771):         aliases = list(aliases)
0.75 query.py(772):         while aliases:
0.75 query.py(2310):         query.demote_joins(to_demote)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(806):             alias = aliases.pop(0)
0.75 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.75 query.py(805):         while aliases:
0.75 query.py(2311):         return to_demote
0.75 query.py(1353):         return target_clause, needed_inner
0.75 query.py(1320):         if clause:
0.75 query.py(1321):             self.where.add(clause, AND)
0.75 query.py(1322):         self.demote_joins(existing_inner)
0.75 query.py(804):         aliases = list(aliases)
0.75 query.py(805):         while aliases:
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(1758):         return not self.low_mark and self.high_mark is None
0.75 query.py(343):         obj = self.clone()
0.75 query.py(297):         obj = Empty()
0.75 query.py(298):         obj.__class__ = self.__class__
0.75 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.75 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.75 query.py(303):         obj.alias_map = self.alias_map.copy()
0.75 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.75 query.py(305):         obj.table_map = self.table_map.copy()
0.75 query.py(306):         obj.where = self.where.clone()
0.75 query.py(307):         obj.annotations = self.annotations.copy()
0.75 query.py(308):         if self.annotation_select_mask is None:
0.75 query.py(309):             obj.annotation_select_mask = None
0.75 query.py(317):         obj._annotation_select_cache = None
0.75 query.py(318):         obj.extra = self.extra.copy()
0.75 query.py(319):         if self.extra_select_mask is None:
0.75 query.py(320):             obj.extra_select_mask = None
0.75 query.py(323):         if self._extra_select_cache is None:
0.75 query.py(324):             obj._extra_select_cache = None
0.75 query.py(327):         if 'subq_aliases' in self.__dict__:
0.75 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.75 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.75 query.py(332):         try:
0.75 query.py(333):             del obj.base_table
0.75 query.py(336):         return obj
0.75 query.py(344):         if klass and obj.__class__ != klass:
0.75 query.py(346):         if not obj.filter_is_sticky:
0.75 query.py(347):             obj.used_aliases = set()
0.75 query.py(348):         obj.filter_is_sticky = False
0.75 query.py(349):         if hasattr(obj, '_setup_query'):
0.75 query.py(351):         return obj
0.75 query.py(1860):         self.order_by = ()
0.75 query.py(1861):         self.extra_order_by = ()
0.75 query.py(1862):         if force_empty:
0.75 query.py(1839):         errors = []
0.75 query.py(1840):         for item in ordering:
0.75 query.py(1848):         if errors:
0.75 query.py(1850):         if ordering:
0.75 query.py(1853):             self.default_ordering = False
0.75 query.py(1731):         if high is not None:
0.75 query.py(1732):             if self.high_mark is not None:
0.75 query.py(1735):                 self.high_mark = self.low_mark + high
0.75 query.py(1736):         if low is not None:
0.75 query.py(1742):         if self.low_mark == self.high_mark:
0.75 query.py(278):         if using is None and connection is None:
0.75 query.py(280):         if using:
0.75 query.py(281):             connection = connections[using]
0.75 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.75 compiler.py(25):         self.query = query
0.75 compiler.py(26):         self.connection = connection
0.75 compiler.py(27):         self.using = using
0.75 compiler.py(28):         self.quote_cache = {'*': '*'}
0.75 compiler.py(33):         self.select = None
0.75 compiler.py(34):         self.annotation_col_map = None
0.75 compiler.py(35):         self.klass_info = None
0.75 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.75 compiler.py(38):         self._meta_ordering = None
0.75 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.75 compiler.py(1081):         try:
0.75 compiler.py(1082):             sql, params = self.as_sql()
0.75 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.75 compiler.py(479):         try:
0.75 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.75 compiler.py(52):         self.setup_query()
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.75 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.75 compiler.py(202):         select = []
0.75 compiler.py(203):         klass_info = None
0.75 compiler.py(204):         annotations = {}
0.75 compiler.py(205):         select_idx = 0
0.75 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.75 compiler.py(211):         if self.query.default_cols:
0.75 compiler.py(212):             cols = self.get_default_columns()
0.75 compiler.py(644):         result = []
0.75 compiler.py(645):         if opts is None:
0.75 compiler.py(646):             opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(647):         only_load = self.deferred_to_columns()
0.75 compiler.py(1018):         columns = {}
0.75 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.75 query.py(655):         field_names, defer = self.deferred_loading
0.75 query.py(656):         if not field_names:
0.75 query.py(657):             return
0.75 compiler.py(1020):         return columns
0.75 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.75 query.py(912):         if self.alias_map:
0.75 query.py(913):             alias = self.base_table
0.75 query.py(250):         for alias in self.alias_map:
0.75 query.py(251):             return alias
0.75 query.py(914):             self.ref_alias(alias)
0.75 query.py(754):         self.alias_refcount[alias] += 1
0.75 query.py(917):         return alias
0.75 compiler.py(652):         seen_models = {None: start_alias}
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(655):             model = field.model._meta.concrete_model
0.75 compiler.py(658):             if model == opts.model:
0.75 compiler.py(659):                 model = None
0.75 compiler.py(660):             if from_parent and model is not None and issubclass(
0.75 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.75 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.75 compiler.py(671):                                                  seen_models)
0.75 query.py(984):         if model in seen:
0.75 query.py(985):             return seen[model]
0.75 compiler.py(672):             column = field.get_col(alias)
0.75 compiler.py(673):             result.append(column)
0.75 compiler.py(654):         for field in opts.concrete_fields:
0.75 compiler.py(674):         return result
0.75 compiler.py(217):         if cols:
0.75 compiler.py(218):             select_list = []
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(220):                 select_list.append(select_idx)
0.75 compiler.py(221):                 select.append((col, None))
0.75 compiler.py(222):                 select_idx += 1
0.75 compiler.py(219):             for col in cols:
0.75 compiler.py(224):                 'model': self.query.model,
0.75 compiler.py(225):                 'select_fields': select_list,
0.75 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.75 query.py(2075):         if self._annotation_select_cache is not None:
0.75 query.py(2077):         elif not self.annotations:
0.75 query.py(2078):             return {}
0.75 compiler.py(232):         if self.query.select_related:
0.75 compiler.py(244):         ret = []
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(246):             try:
0.75 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.75 compiler.py(397):                 name in self.query.extra_select or (
0.75 query.py(2090):         if self._extra_select_cache is not None:
0.75 query.py(2092):         if not self.extra:
0.75 query.py(2093):             return {}
0.75 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.75 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.75 compiler.py(402):         self.quote_cache[name] = r
0.75 compiler.py(403):         return r
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.75 compiler.py(251):             ret.append((col, (sql, params), alias))
0.75 compiler.py(245):         for col, alias in select:
0.75 compiler.py(252):         return ret, klass_info, annotations
0.75 compiler.py(44):         self.col_count = len(self.select)
0.75 compiler.py(53):         order_by = self.get_order_by()
0.75 compiler.py(263):         if self.query.extra_order_by:
0.75 compiler.py(265):         elif not self.query.default_ordering:
0.75 compiler.py(266):             ordering = self.query.order_by
0.75 compiler.py(274):         if self.query.standard_ordering:
0.75 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.75 compiler.py(279):         order_by = []
0.75 compiler.py(280):         for field in ordering:
0.75 compiler.py(340):         result = []
0.75 compiler.py(341):         seen = set()
0.75 compiler.py(343):         for expr, is_ref in order_by:
0.75 compiler.py(376):         return result
0.75 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.75 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.75 compiler.py(379):         extra_select = []
0.75 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.75 compiler.py(386):         return extra_select
0.75 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.75 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.75 compiler.py(97):         if self.query.group_by is None:
0.75 compiler.py(98):             return []
0.75 compiler.py(58):         return extra_select, order_by, group_by
0.75 compiler.py(481):             for_update_part = None
0.75 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.75 compiler.py(484):             combinator = self.query.combinator
0.75 compiler.py(485):             features = self.connection.features
0.75 compiler.py(486):             if combinator:
0.75 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.75 compiler.py(683):         result = []
0.75 compiler.py(684):         params = []
0.75 compiler.py(685):         opts = self.query.get_meta()
0.75 query.py(290):         return self.model._meta
0.75 compiler.py(687):         for name in self.query.distinct_fields:
0.75 compiler.py(698):         return result, params
0.75 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.75 compiler.py(755):         result = []
0.75 compiler.py(756):         params = []
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.75 compiler.py(760):             try:
0.75 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.75 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(767):             result.append(clause_sql)
0.75 compiler.py(768):             params.extend(clause_params)
0.75 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.75 compiler.py(769):         for t in self.query.extra_tables:
0.75 compiler.py(776):         return result, params
0.75 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.75 compiler.py(407):         if vendor_impl:
0.75 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(394):         if name in self.quote_cache:
0.75 compiler.py(395):             return self.quote_cache[name]
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.75 compiler.py(413):         return sql, params
0.75 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.75 compiler.py(497):                 result = ['SELECT']
0.75 compiler.py(498):                 params = []
0.75 compiler.py(500):                 if self.query.distinct:
0.75 compiler.py(508):                 out_cols = []
0.75 compiler.py(509):                 col_idx = 1
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(511):                     if alias:
0.75 compiler.py(513):                     elif with_col_aliases:
0.75 compiler.py(516):                     params.extend(s_params)
0.75 compiler.py(517):                     out_cols.append(s_sql)
0.75 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.75 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.75 compiler.py(520):                 params.extend(f_params)
0.75 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.75 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.75 compiler.py(552):                 if where:
0.75 compiler.py(553):                     result.append('WHERE %s' % where)
0.75 compiler.py(554):                     params.extend(w_params)
0.75 compiler.py(556):                 grouping = []
0.75 compiler.py(557):                 for g_sql, g_params in group_by:
0.75 compiler.py(560):                 if grouping:
0.75 compiler.py(577):                 if having:
0.75 compiler.py(581):             if self.query.explain_query:
0.75 compiler.py(587):             if order_by:
0.75 compiler.py(594):             if with_limit_offset:
0.75 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.75 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.75 compiler.py(600):             if self.query.subquery and extra_select:
0.76 compiler.py(627):             return ' '.join(result), tuple(params)
0.76 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 compiler.py(1083):             if not sql:
0.76 compiler.py(1090):         if chunked_fetch:
0.76 compiler.py(1093):             cursor = self.connection.cursor()
0.76 compiler.py(1094):         try:
0.76 compiler.py(1095):             cursor.execute(sql, params)
0.76 compiler.py(1101):         if result_type == CURSOR:
0.76 compiler.py(1104):         if result_type == SINGLE:
0.76 compiler.py(1113):         if result_type == NO_RESULTS:
0.76 compiler.py(1117):         result = cursor_iter(
0.76 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.76 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.76 compiler.py(1120):             chunk_size,
0.76 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.76 compiler.py(1123):             try:
0.76 compiler.py(1128):                 return list(result)
0.76 compiler.py(1518):     try:
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1522):         cursor.close()
0.76 compiler.py(1131):                 cursor.close()
0.76 compiler.py(1046):         if results is None:
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1049):         converters = self.get_converters(fields)
0.76 compiler.py(1023):         converters = {}
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1025):             if expression:
0.76 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.76 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.76 compiler.py(1028):                 if backend_converters or field_converters:
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1025):             if expression:
0.76 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.76 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.76 compiler.py(1028):                 if backend_converters or field_converters:
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1025):             if expression:
0.76 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.76 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.76 compiler.py(1028):                 if backend_converters or field_converters:
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1030):         return converters
0.76 compiler.py(1050):         rows = chain.from_iterable(results)
0.76 compiler.py(1051):         if converters:
0.76 compiler.py(1055):         return rows
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1758):         return not self.low_mark and self.high_mark is None
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.76 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.76 query.py(1331):         connector = q_object.connector
0.76 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.76 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.76 query.py(1334):         target_clause = self.where_class(connector=connector,
0.76 query.py(1335):                                          negated=q_object.negated)
0.76 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.76 query.py(2236):         self.connector = connector
0.76 query.py(2237):         self.negated = negated
0.76 query.py(2238):         if self.negated:
0.76 query.py(2244):             self.effective_connector = self.connector
0.76 query.py(2245):         self.num_children = num_children
0.76 query.py(2248):         self.votes = Counter()
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1338):             if isinstance(child, Node):
0.76 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.76 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.76 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.76 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.76 query.py(1214):         if isinstance(filter_expr, dict):
0.76 query.py(1216):         arg, value = filter_expr
0.76 query.py(1217):         if not arg:
0.76 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.76 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.76 query.py(1074):         if self.annotations:
0.76 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.76 query.py(290):         return self.model._meta
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1415):             except FieldDoesNotExist:
0.76 query.py(1416):                 if name in self.annotation_select:
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.76 query.py(1421):             if field is not None:
0.76 query.py(1441):                 pos -= 1
0.76 query.py(1442):                 if pos == -1 or fail_on_missing:
0.76 query.py(1450):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.76 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.76 query.py(1085):         return lookup_parts, field_parts, False
0.76 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.76 query.py(1227):         if not allow_joins and len(parts) > 1:
0.76 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.76 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.76 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.76 query.py(1055):         elif isinstance(value, (list, tuple)):
0.76 query.py(1067):         return value
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.76 query.py(1234):         clause = self.where_class()
0.76 query.py(1235):         if reffed_expression:
0.76 query.py(1240):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1241):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.76 query.py(290):         return self.model._meta
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(917):         return alias
0.76 query.py(1242):         allow_many = not branch_negated or not split_subq
0.76 query.py(1244):         try:
0.76 query.py(1245):             join_info = self.setup_joins(
0.76 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.76 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2193):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.76 query.py(735):         alias_list = self.table_map.get(table_name)
0.76 query.py(736):         if not create and alias_list:
0.76 query.py(742):         if alias_list:
0.76 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.76 query.py(748):             self.table_map[table_name] = [alias]
0.76 query.py(749):         self.alias_refcount[alias] = 1
0.76 query.py(750):         return alias, True
0.76 query.py(965):         if join.join_type:
0.76 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.76 query.py(969):                 join_type = INNER
0.76 query.py(970):             join.join_type = join_type
0.76 query.py(971):         join.table_alias = alias
0.76 query.py(972):         self.alias_map[alias] = join
0.76 query.py(973):         return alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1251):             if isinstance(value, Iterator):
0.76 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.76 query.py(1100):         if field.is_relation:
0.76 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.76 query.py(1112):             elif hasattr(value, '_meta'):
0.76 query.py(1114):             elif hasattr(value, '__iter__'):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.76 query.py(1092):         if hasattr(value, '_meta'):
0.76 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.76 query.py(1092):         if hasattr(value, '_meta'):
0.76 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.76 query.py(1092):         if hasattr(value, '_meta'):
0.76 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.76 query.py(1115):                 for v in value:
0.76 query.py(1257):             self._lookup_joins = join_info.joins
0.76 query.py(1263):         used_joins.update(join_info.joins)
0.76 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1613):             self.unref_alias(joins.pop())
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1265):         if can_reuse is not None:
0.76 query.py(1266):             can_reuse.update(join_list)
0.76 query.py(1268):         if join_info.final_field.is_relation:
0.76 query.py(1270):             num_lookups = len(lookups)
0.76 query.py(1271):             if num_lookups > 1:
0.76 query.py(1273):             if len(targets) == 1:
0.76 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.76 query.py(72):     if simple_col:
0.76 query.py(74):     return target.get_col(alias, field)
0.76 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.76 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.76 query.py(1129):         for name in transforms:
0.76 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.76 query.py(1134):         if not lookup_class:
0.76 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.76 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.76 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(1161):         return lookup
0.76 query.py(1281):         lookup_type = condition.lookup_name
0.76 query.py(1282):         clause.add(condition, AND)
0.76 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.76 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.76 query.py(1302):         return clause, used_joins if not require_outer else ()
0.76 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.76 query.py(2255):         self.votes.update(votes)
0.76 query.py(1350):             if child_clause:
0.76 query.py(1351):                 target_clause.add(child_clause, connector)
0.76 query.py(1337):         for child in q_object.children:
0.76 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.76 query.py(2264):         to_promote = set()
0.76 query.py(2265):         to_demote = set()
0.76 query.py(2268):         for table, votes in self.votes.items():
0.76 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2291):             if self.effective_connector == 'AND' or (
0.76 query.py(2293):                 to_demote.add(table)
0.76 query.py(2268):         for table, votes in self.votes.items():
0.76 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.76 query.py(2291):             if self.effective_connector == 'AND' or (
0.76 query.py(2293):                 to_demote.add(table)
0.76 query.py(2268):         for table, votes in self.votes.items():
0.76 query.py(2309):         query.promote_joins(to_promote)
0.76 query.py(771):         aliases = list(aliases)
0.76 query.py(772):         while aliases:
0.76 query.py(2310):         query.demote_joins(to_demote)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(806):             alias = aliases.pop(0)
0.76 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.76 query.py(805):         while aliases:
0.76 query.py(2311):         return to_demote
0.76 query.py(1353):         return target_clause, needed_inner
0.76 query.py(1320):         if clause:
0.76 query.py(1321):             self.where.add(clause, AND)
0.76 query.py(1322):         self.demote_joins(existing_inner)
0.76 query.py(804):         aliases = list(aliases)
0.76 query.py(805):         while aliases:
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(2035):         self.select_related = False
0.76 query.py(2036):         self.clear_deferred_loading()
0.76 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.76 query.py(2037):         self.clear_select_fields()
0.76 query.py(1774):         self.select = ()
0.76 query.py(1775):         self.values_select = ()
0.76 query.py(2039):         if self.group_by is True:
0.76 query.py(2044):         if fields:
0.76 query.py(2045):             field_names = []
0.76 query.py(2046):             extra_names = []
0.76 query.py(2047):             annotation_names = []
0.76 query.py(2048):             if not self.extra and not self.annotations:
0.76 query.py(2051):                 field_names = list(fields)
0.76 query.py(2061):             self.set_extra_mask(extra_names)
0.76 query.py(2028):         if names is None:
0.76 query.py(2031):             self.extra_select_mask = set(names)
0.76 query.py(2032):         self._extra_select_cache = None
0.76 query.py(2062):             self.set_annotation_mask(annotation_names)
0.76 query.py(2013):         if names is None:
0.76 query.py(2016):             self.annotation_select_mask = set(names)
0.76 query.py(2017):         self._annotation_select_cache = None
0.76 query.py(2066):         self.values_select = tuple(field_names)
0.76 query.py(2067):         self.add_fields(field_names, True)
0.76 query.py(1797):         alias = self.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(250):         for alias in self.alias_map:
0.76 query.py(251):             return alias
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 query.py(1798):         opts = self.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 query.py(1800):         try:
0.76 query.py(1801):             cols = []
0.76 query.py(1802):             for name in field_names:
0.76 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2193):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.76 query.py(1807):                     join_info.targets,
0.76 query.py(1808):                     join_info.joins,
0.76 query.py(1809):                     join_info.path,
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.76 query.py(1613):             self.unref_alias(joins.pop())
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1811):                 for target in targets:
0.76 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(1811):                 for target in targets:
0.76 query.py(1802):             for name in field_names:
0.76 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.76 query.py(1807):                     join_info.targets,
0.76 query.py(1808):                     join_info.joins,
0.76 query.py(1809):                     join_info.path,
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 query.py(1811):                 for target in targets:
0.76 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.76 query.py(1525):             return field.get_col(alias)
0.76 query.py(1811):                 for target in targets:
0.76 query.py(1802):             for name in field_names:
0.76 query.py(1813):             if cols:
0.76 query.py(1814):                 self.set_select(cols)
0.76 query.py(1782):         self.default_cols = False
0.76 query.py(1783):         self.select = tuple(cols)
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 compiler.py(25):         self.query = query
0.76 compiler.py(26):         self.connection = connection
0.76 compiler.py(27):         self.using = using
0.76 compiler.py(28):         self.quote_cache = {'*': '*'}
0.76 compiler.py(33):         self.select = None
0.76 compiler.py(34):         self.annotation_col_map = None
0.76 compiler.py(35):         self.klass_info = None
0.76 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.76 compiler.py(38):         self._meta_ordering = None
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 compiler.py(1046):         if results is None:
0.76 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.76 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.76 compiler.py(1081):         try:
0.76 compiler.py(1082):             sql, params = self.as_sql()
0.76 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.76 compiler.py(479):         try:
0.76 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.76 compiler.py(52):         self.setup_query()
0.76 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.76 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.76 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.76 compiler.py(202):         select = []
0.76 compiler.py(203):         klass_info = None
0.76 compiler.py(204):         annotations = {}
0.76 compiler.py(205):         select_idx = 0
0.76 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.76 compiler.py(211):         if self.query.default_cols:
0.76 compiler.py(216):             cols = self.query.select
0.76 compiler.py(217):         if cols:
0.76 compiler.py(218):             select_list = []
0.76 compiler.py(219):             for col in cols:
0.76 compiler.py(220):                 select_list.append(select_idx)
0.76 compiler.py(221):                 select.append((col, None))
0.76 compiler.py(222):                 select_idx += 1
0.76 compiler.py(219):             for col in cols:
0.76 compiler.py(220):                 select_list.append(select_idx)
0.76 compiler.py(221):                 select.append((col, None))
0.76 compiler.py(222):                 select_idx += 1
0.76 compiler.py(219):             for col in cols:
0.76 compiler.py(224):                 'model': self.query.model,
0.76 compiler.py(225):                 'select_fields': select_list,
0.76 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 compiler.py(232):         if self.query.select_related:
0.76 compiler.py(244):         ret = []
0.76 compiler.py(245):         for col, alias in select:
0.76 compiler.py(246):             try:
0.76 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.76 compiler.py(251):             ret.append((col, (sql, params), alias))
0.76 compiler.py(245):         for col, alias in select:
0.76 compiler.py(246):             try:
0.76 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.76 compiler.py(251):             ret.append((col, (sql, params), alias))
0.76 compiler.py(245):         for col, alias in select:
0.76 compiler.py(252):         return ret, klass_info, annotations
0.76 compiler.py(44):         self.col_count = len(self.select)
0.76 compiler.py(53):         order_by = self.get_order_by()
0.76 compiler.py(263):         if self.query.extra_order_by:
0.76 compiler.py(265):         elif not self.query.default_ordering:
0.76 compiler.py(267):         elif self.query.order_by:
0.76 compiler.py(269):         elif self.query.get_meta().ordering:
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(270):             ordering = self.query.get_meta().ordering
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(271):             self._meta_ordering = ordering
0.76 compiler.py(274):         if self.query.standard_ordering:
0.76 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.76 compiler.py(279):         order_by = []
0.76 compiler.py(280):         for field in ordering:
0.76 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.76 compiler.py(292):             if field == '?':  # random
0.76 compiler.py(296):             col, order = get_order_dir(field, asc)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(297):             descending = order == 'DESC'
0.76 compiler.py(299):             if col in self.query.annotation_select:
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 compiler.py(305):             if col in self.query.annotations:
0.76 compiler.py(315):             if '.' in field:
0.76 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.76 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.76 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(708):         descending = order == 'DESC'
0.76 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.76 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.76 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2193):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 compiler.py(741):         alias = joins[-1]
0.76 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.76 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.76 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1610):                 break
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 query.py(1525):             return field.get_col(alias)
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(280):         for field in ordering:
0.76 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.76 compiler.py(292):             if field == '?':  # random
0.76 compiler.py(296):             col, order = get_order_dir(field, asc)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(297):             descending = order == 'DESC'
0.76 compiler.py(299):             if col in self.query.annotation_select:
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 compiler.py(305):             if col in self.query.annotations:
0.76 compiler.py(315):             if '.' in field:
0.76 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.76 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.76 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(708):         descending = order == 'DESC'
0.76 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.76 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.76 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.76 query.py(1462):                 if not allow_many:
0.76 query.py(1468):                 last = pathinfos[-1]
0.76 query.py(1469):                 path.extend(pathinfos)
0.76 query.py(1470):                 final_field = last.join_field
0.76 query.py(1471):                 opts = last.to_opts
0.76 query.py(1472):                 targets = last.target_fields
0.76 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.76 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1563):             if join.filtered_relation:
0.76 query.py(1567):                 filtered_relation = None
0.76 query.py(1568):                 table_alias = None
0.76 query.py(1569):             opts = join.to_opts
0.76 query.py(1570):             if join.direct:
0.76 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.76 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.76 query.py(2193):         ) or field.null
0.76 query.py(1574):             connection = Join(
0.76 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.76 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.76 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.76 query.py(1579):             alias = self.join(
0.76 query.py(1580):                 connection, reuse=reuse,
0.76 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.76 query.py(943):         if reuse_with_filtered_relation and reuse:
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.76 query.py(950):                 a for a, j in self.alias_map.items()
0.76 query.py(953):         if reuse_aliases:
0.76 query.py(954):             if join.table_alias in reuse_aliases:
0.76 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.76 query.py(960):             self.ref_alias(reuse_alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(961):             return reuse_alias
0.76 query.py(1583):             joins.append(alias)
0.76 query.py(1584):             if filtered_relation:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 compiler.py(741):         alias = joins[-1]
0.76 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.76 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.76 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1603):             if len(joins) == 1 or not info.direct:
0.76 query.py(1605):             if info.filtered_relation:
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1608):             cur_targets = {t.column for t in targets}
0.76 query.py(1609):             if not cur_targets.issubset(join_targets):
0.76 query.py(1610):                 break
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 query.py(1525):             return field.get_col(alias)
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(280):         for field in ordering:
0.76 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.76 compiler.py(292):             if field == '?':  # random
0.76 compiler.py(296):             col, order = get_order_dir(field, asc)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(297):             descending = order == 'DESC'
0.76 compiler.py(299):             if col in self.query.annotation_select:
0.76 query.py(2075):         if self._annotation_select_cache is not None:
0.76 query.py(2077):         elif not self.annotations:
0.76 query.py(2078):             return {}
0.76 compiler.py(305):             if col in self.query.annotations:
0.76 compiler.py(315):             if '.' in field:
0.76 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.76 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.76 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.76 query.py(2204):     dirn = ORDER_DIR[default]
0.76 query.py(2205):     if field[0] == '-':
0.76 query.py(2207):     return field, dirn[0]
0.76 compiler.py(708):         descending = order == 'DESC'
0.76 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.76 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.76 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.76 query.py(912):         if self.alias_map:
0.76 query.py(913):             alias = self.base_table
0.76 query.py(914):             self.ref_alias(alias)
0.76 query.py(754):         self.alias_refcount[alias] += 1
0.76 query.py(917):         return alias
0.76 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.76 query.py(1518):         joins = [alias]
0.76 query.py(1524):         def final_transformer(field, alias):
0.76 query.py(1529):         last_field_exception = None
0.76 query.py(1530):         for pivot in range(len(names), 0, -1):
0.76 query.py(1531):             try:
0.76 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.76 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.76 query.py(1405):         path, names_with_path = [], []
0.76 query.py(1406):         for pos, name in enumerate(names):
0.76 query.py(1407):             cur_names_with_path = (name, [])
0.76 query.py(1408):             if name == 'pk':
0.76 query.py(1411):             field = None
0.76 query.py(1412):             filtered_relation = None
0.76 query.py(1413):             try:
0.76 query.py(1414):                 field = opts.get_field(name)
0.76 query.py(1421):             if field is not None:
0.76 query.py(1425):                 if field.is_relation and not field.related_model:
0.76 query.py(1432):                 try:
0.76 query.py(1433):                     model = field.model._meta.concrete_model
0.76 query.py(1454):             if model is not opts.model:
0.76 query.py(1460):             if hasattr(field, 'get_path_info'):
0.76 query.py(1477):                 final_field = field
0.76 query.py(1478):                 targets = (field,)
0.76 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.76 query.py(1483):                 break
0.76 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.76 query.py(1545):                 transforms = names[pivot:]
0.76 query.py(1546):                 break
0.76 query.py(1547):         for name in transforms:
0.76 query.py(1562):         for join in path:
0.76 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.76 compiler.py(741):         alias = joins[-1]
0.76 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.76 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.76 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.76 query.py(1601):         joins = joins[:]
0.76 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.76 query.py(1614):         return targets, joins[-1], joins
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 query.py(1525):             return field.get_col(alias)
0.76 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.76 compiler.py(280):         for field in ordering:
0.76 compiler.py(340):         result = []
0.76 compiler.py(341):         seen = set()
0.76 compiler.py(343):         for expr, is_ref in order_by:
0.76 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.76 compiler.py(345):             if self.query.combinator:
0.76 compiler.py(365):             sql, params = self.compile(resolved)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.76 compiler.py(371):             params_hash = make_hashable(params)
0.76 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.76 compiler.py(374):             seen.add((without_ordering, params_hash))
0.76 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.76 compiler.py(343):         for expr, is_ref in order_by:
0.76 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.76 compiler.py(345):             if self.query.combinator:
0.76 compiler.py(365):             sql, params = self.compile(resolved)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.76 compiler.py(397):                 name in self.query.extra_select or (
0.76 query.py(2090):         if self._extra_select_cache is not None:
0.76 query.py(2092):         if not self.extra:
0.76 query.py(2093):             return {}
0.76 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.76 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.76 compiler.py(402):         self.quote_cache[name] = r
0.76 compiler.py(403):         return r
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.76 compiler.py(371):             params_hash = make_hashable(params)
0.76 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.76 compiler.py(374):             seen.add((without_ordering, params_hash))
0.76 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.76 compiler.py(343):         for expr, is_ref in order_by:
0.76 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.76 compiler.py(345):             if self.query.combinator:
0.76 compiler.py(365):             sql, params = self.compile(resolved)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.76 compiler.py(371):             params_hash = make_hashable(params)
0.76 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.76 compiler.py(374):             seen.add((without_ordering, params_hash))
0.76 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.76 compiler.py(343):         for expr, is_ref in order_by:
0.76 compiler.py(376):         return result
0.76 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.76 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.76 compiler.py(379):         extra_select = []
0.76 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.76 compiler.py(386):         return extra_select
0.76 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.76 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.76 compiler.py(97):         if self.query.group_by is None:
0.76 compiler.py(98):             return []
0.76 compiler.py(58):         return extra_select, order_by, group_by
0.76 compiler.py(481):             for_update_part = None
0.76 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.76 compiler.py(484):             combinator = self.query.combinator
0.76 compiler.py(485):             features = self.connection.features
0.76 compiler.py(486):             if combinator:
0.76 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.76 compiler.py(683):         result = []
0.76 compiler.py(684):         params = []
0.76 compiler.py(685):         opts = self.query.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(687):         for name in self.query.distinct_fields:
0.76 compiler.py(698):         return result, params
0.76 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.76 compiler.py(755):         result = []
0.76 compiler.py(756):         params = []
0.76 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.76 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.76 compiler.py(760):             try:
0.76 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.76 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(767):             result.append(clause_sql)
0.76 compiler.py(768):             params.extend(clause_params)
0.76 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.76 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.76 compiler.py(760):             try:
0.76 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.76 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(767):             result.append(clause_sql)
0.76 compiler.py(768):             params.extend(clause_params)
0.76 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.76 compiler.py(769):         for t in self.query.extra_tables:
0.76 compiler.py(776):         return result, params
0.76 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.76 compiler.py(407):         if vendor_impl:
0.76 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(394):         if name in self.quote_cache:
0.76 compiler.py(395):             return self.quote_cache[name]
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.76 compiler.py(413):         return sql, params
0.76 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.76 compiler.py(497):                 result = ['SELECT']
0.76 compiler.py(498):                 params = []
0.76 compiler.py(500):                 if self.query.distinct:
0.76 compiler.py(508):                 out_cols = []
0.76 compiler.py(509):                 col_idx = 1
0.76 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.76 compiler.py(511):                     if alias:
0.76 compiler.py(513):                     elif with_col_aliases:
0.76 compiler.py(516):                     params.extend(s_params)
0.76 compiler.py(517):                     out_cols.append(s_sql)
0.76 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.76 compiler.py(511):                     if alias:
0.76 compiler.py(513):                     elif with_col_aliases:
0.76 compiler.py(516):                     params.extend(s_params)
0.76 compiler.py(517):                     out_cols.append(s_sql)
0.76 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.76 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.76 compiler.py(520):                 params.extend(f_params)
0.76 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.76 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.76 compiler.py(552):                 if where:
0.76 compiler.py(553):                     result.append('WHERE %s' % where)
0.76 compiler.py(554):                     params.extend(w_params)
0.76 compiler.py(556):                 grouping = []
0.76 compiler.py(557):                 for g_sql, g_params in group_by:
0.76 compiler.py(560):                 if grouping:
0.76 compiler.py(577):                 if having:
0.76 compiler.py(581):             if self.query.explain_query:
0.76 compiler.py(587):             if order_by:
0.76 compiler.py(588):                 ordering = []
0.76 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.76 compiler.py(590):                     ordering.append(o_sql)
0.76 compiler.py(591):                     params.extend(o_params)
0.76 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.76 compiler.py(590):                     ordering.append(o_sql)
0.76 compiler.py(591):                     params.extend(o_params)
0.76 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.76 compiler.py(590):                     ordering.append(o_sql)
0.76 compiler.py(591):                     params.extend(o_params)
0.76 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.76 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.76 compiler.py(594):             if with_limit_offset:
0.76 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.76 compiler.py(600):             if self.query.subquery and extra_select:
0.76 compiler.py(627):             return ' '.join(result), tuple(params)
0.76 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.76 query.py(820):             self.unref_alias(alias, unref_amount)
0.76 query.py(758):         self.alias_refcount[alias] -= amount
0.76 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.76 compiler.py(1083):             if not sql:
0.76 compiler.py(1090):         if chunked_fetch:
0.76 compiler.py(1093):             cursor = self.connection.cursor()
0.76 compiler.py(1094):         try:
0.76 compiler.py(1095):             cursor.execute(sql, params)
0.76 compiler.py(1101):         if result_type == CURSOR:
0.76 compiler.py(1104):         if result_type == SINGLE:
0.76 compiler.py(1113):         if result_type == NO_RESULTS:
0.76 compiler.py(1117):         result = cursor_iter(
0.76 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.76 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.76 compiler.py(1120):             chunk_size,
0.76 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.76 compiler.py(1123):             try:
0.76 compiler.py(1128):                 return list(result)
0.76 compiler.py(1518):     try:
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.76 compiler.py(1522):         cursor.close()
0.76 compiler.py(1131):                 cursor.close()
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.76 compiler.py(1049):         converters = self.get_converters(fields)
0.76 compiler.py(1023):         converters = {}
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1025):             if expression:
0.76 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.76 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.76 compiler.py(1028):                 if backend_converters or field_converters:
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1025):             if expression:
0.76 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.76 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.76 compiler.py(1028):                 if backend_converters or field_converters:
0.76 compiler.py(1024):         for i, expression in enumerate(expressions):
0.76 compiler.py(1030):         return converters
0.76 compiler.py(1050):         rows = chain.from_iterable(results)
0.76 compiler.py(1051):         if converters:
0.76 compiler.py(1055):         return rows
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(343):         obj = self.clone()
0.76 query.py(297):         obj = Empty()
0.76 query.py(298):         obj.__class__ = self.__class__
0.76 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.76 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.76 query.py(303):         obj.alias_map = self.alias_map.copy()
0.76 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.76 query.py(305):         obj.table_map = self.table_map.copy()
0.76 query.py(306):         obj.where = self.where.clone()
0.76 query.py(307):         obj.annotations = self.annotations.copy()
0.76 query.py(308):         if self.annotation_select_mask is None:
0.76 query.py(309):             obj.annotation_select_mask = None
0.76 query.py(317):         obj._annotation_select_cache = None
0.76 query.py(318):         obj.extra = self.extra.copy()
0.76 query.py(319):         if self.extra_select_mask is None:
0.76 query.py(320):             obj.extra_select_mask = None
0.76 query.py(323):         if self._extra_select_cache is None:
0.76 query.py(324):             obj._extra_select_cache = None
0.76 query.py(327):         if 'subq_aliases' in self.__dict__:
0.76 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.76 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.76 query.py(332):         try:
0.76 query.py(333):             del obj.base_table
0.76 query.py(334):         except AttributeError:
0.76 query.py(335):             pass
0.76 query.py(336):         return obj
0.76 query.py(344):         if klass and obj.__class__ != klass:
0.76 query.py(346):         if not obj.filter_is_sticky:
0.76 query.py(347):             obj.used_aliases = set()
0.76 query.py(348):         obj.filter_is_sticky = False
0.76 query.py(349):         if hasattr(obj, '_setup_query'):
0.76 query.py(351):         return obj
0.76 query.py(154):         self.model = model
0.76 query.py(155):         self.alias_refcount = {}
0.76 query.py(161):         self.alias_map = {}
0.76 query.py(165):         self.external_aliases = set()
0.76 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.76 query.py(167):         self.default_cols = True
0.76 query.py(168):         self.default_ordering = True
0.76 query.py(169):         self.standard_ordering = True
0.76 query.py(170):         self.used_aliases = set()
0.76 query.py(171):         self.filter_is_sticky = False
0.76 query.py(172):         self.subquery = False
0.76 query.py(180):         self.select = ()
0.76 query.py(181):         self.where = where()
0.76 query.py(182):         self.where_class = where
0.76 query.py(189):         self.group_by = None
0.76 query.py(190):         self.order_by = ()
0.76 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.76 query.py(192):         self.distinct = False
0.76 query.py(193):         self.distinct_fields = ()
0.76 query.py(194):         self.select_for_update = False
0.76 query.py(195):         self.select_for_update_nowait = False
0.76 query.py(196):         self.select_for_update_skip_locked = False
0.76 query.py(197):         self.select_for_update_of = ()
0.76 query.py(199):         self.select_related = False
0.76 query.py(201):         self.max_depth = 5
0.76 query.py(205):         self.values_select = ()
0.76 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.76 query.py(209):         self.annotation_select_mask = None
0.76 query.py(210):         self._annotation_select_cache = None
0.76 query.py(213):         self.combinator = None
0.76 query.py(214):         self.combinator_all = False
0.76 query.py(215):         self.combined_queries = ()
0.76 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.76 query.py(220):         self.extra_select_mask = None
0.76 query.py(221):         self._extra_select_cache = None
0.76 query.py(223):         self.extra_tables = ()
0.76 query.py(224):         self.extra_order_by = ()
0.76 query.py(229):         self.deferred_loading = (frozenset(), True)
0.76 query.py(231):         self._filtered_relations = {}
0.76 query.py(233):         self.explain_query = False
0.76 query.py(234):         self.explain_format = None
0.76 query.py(235):         self.explain_options = {}
0.76 query.py(278):         if using is None and connection is None:
0.76 query.py(280):         if using:
0.76 query.py(281):             connection = connections[using]
0.76 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.76 compiler.py(25):         self.query = query
0.76 compiler.py(26):         self.connection = connection
0.76 compiler.py(27):         self.using = using
0.76 compiler.py(28):         self.quote_cache = {'*': '*'}
0.76 compiler.py(33):         self.select = None
0.76 compiler.py(34):         self.annotation_col_map = None
0.76 compiler.py(35):         self.klass_info = None
0.76 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.76 compiler.py(38):         self._meta_ordering = None
0.76 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.76 compiler.py(1333):         self.return_id = return_id
0.76 compiler.py(1334):         with self.connection.cursor() as cursor:
0.76 compiler.py(1335):             for sql, params in self.as_sql():
0.76 compiler.py(1269):         qn = self.connection.ops.quote_name
0.76 compiler.py(1270):         opts = self.query.get_meta()
0.76 query.py(290):         return self.model._meta
0.76 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.76 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.76 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.76 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.76 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.76 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.76 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.76 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.76 compiler.py(1276):         if self.query.fields:
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1279):                 for obj in self.query.objs
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1227):         if self.query.raw:
0.76 compiler.py(1229):         return field.pre_save(obj, add=True)
0.76 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.76 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.76 compiler.py(1220):         return value
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.76 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.76 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.76 compiler.py(1243):         if not value_rows:
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1250):             for row in value_rows
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1170):         if field is None:
0.76 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.76 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.76 compiler.py(1182):             sql, params = '%s', [val]
0.76 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.76 compiler.py(1191):         return sql, params
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.76 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.76 compiler.py(1264):         return placeholder_rows, param_rows
0.76 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.76 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.76 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.76 compiler.py(1315):         if can_bulk:
0.76 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.77 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1336):                 cursor.execute(sql, params)
0.77 compiler.py(1335):             for sql, params in self.as_sql():
0.77 compiler.py(1337):             if not return_id:
0.77 compiler.py(1338):                 return
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1758):         return not self.low_mark and self.high_mark is None
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.77 query.py(1331):         connector = q_object.connector
0.77 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.77 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.77 query.py(1334):         target_clause = self.where_class(connector=connector,
0.77 query.py(1335):                                          negated=q_object.negated)
0.77 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.77 query.py(2236):         self.connector = connector
0.77 query.py(2237):         self.negated = negated
0.77 query.py(2238):         if self.negated:
0.77 query.py(2244):             self.effective_connector = self.connector
0.77 query.py(2245):         self.num_children = num_children
0.77 query.py(2248):         self.votes = Counter()
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1338):             if isinstance(child, Node):
0.77 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.77 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.77 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.77 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.77 query.py(1214):         if isinstance(filter_expr, dict):
0.77 query.py(1216):         arg, value = filter_expr
0.77 query.py(1217):         if not arg:
0.77 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.77 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.77 query.py(1074):         if self.annotations:
0.77 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.77 query.py(290):         return self.model._meta
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.77 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.77 query.py(1085):         return lookup_parts, field_parts, False
0.77 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.77 query.py(1227):         if not allow_joins and len(parts) > 1:
0.77 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.77 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.77 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.77 query.py(1055):         elif isinstance(value, (list, tuple)):
0.77 query.py(1067):         return value
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1234):         clause = self.where_class()
0.77 query.py(1235):         if reffed_expression:
0.77 query.py(1240):         opts = self.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 query.py(1241):         alias = self.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.77 query.py(290):         return self.model._meta
0.77 query.py(943):         if reuse_with_filtered_relation and reuse:
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(953):         if reuse_aliases:
0.77 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.77 query.py(735):         alias_list = self.table_map.get(table_name)
0.77 query.py(736):         if not create and alias_list:
0.77 query.py(742):         if alias_list:
0.77 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.77 query.py(748):             self.table_map[table_name] = [alias]
0.77 query.py(749):         self.alias_refcount[alias] = 1
0.77 query.py(750):         return alias, True
0.77 query.py(965):         if join.join_type:
0.77 query.py(971):         join.table_alias = alias
0.77 query.py(972):         self.alias_map[alias] = join
0.77 query.py(973):         return alias
0.77 query.py(917):         return alias
0.77 query.py(1242):         allow_many = not branch_negated or not split_subq
0.77 query.py(1244):         try:
0.77 query.py(1245):             join_info = self.setup_joins(
0.77 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.77 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.77 query.py(1518):         joins = [alias]
0.77 query.py(1524):         def final_transformer(field, alias):
0.77 query.py(1529):         last_field_exception = None
0.77 query.py(1530):         for pivot in range(len(names), 0, -1):
0.77 query.py(1531):             try:
0.77 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.77 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1545):                 transforms = names[pivot:]
0.77 query.py(1546):                 break
0.77 query.py(1547):         for name in transforms:
0.77 query.py(1562):         for join in path:
0.77 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.77 query.py(1251):             if isinstance(value, Iterator):
0.77 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.77 query.py(1100):         if field.is_relation:
0.77 query.py(1257):             self._lookup_joins = join_info.joins
0.77 query.py(1263):         used_joins.update(join_info.joins)
0.77 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.77 query.py(1601):         joins = joins[:]
0.77 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.77 query.py(1614):         return targets, joins[-1], joins
0.77 query.py(1265):         if can_reuse is not None:
0.77 query.py(1266):             can_reuse.update(join_list)
0.77 query.py(1268):         if join_info.final_field.is_relation:
0.77 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.77 query.py(72):     if simple_col:
0.77 query.py(74):     return target.get_col(alias, field)
0.77 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.77 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.77 query.py(1129):         for name in transforms:
0.77 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.77 query.py(1134):         if not lookup_class:
0.77 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.77 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.77 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.77 query.py(1161):         return lookup
0.77 query.py(1281):         lookup_type = condition.lookup_name
0.77 query.py(1282):         clause.add(condition, AND)
0.77 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.77 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.77 query.py(1302):         return clause, used_joins if not require_outer else ()
0.77 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.77 query.py(2255):         self.votes.update(votes)
0.77 query.py(1350):             if child_clause:
0.77 query.py(1351):                 target_clause.add(child_clause, connector)
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.77 query.py(2264):         to_promote = set()
0.77 query.py(2265):         to_demote = set()
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.77 query.py(2291):             if self.effective_connector == 'AND' or (
0.77 query.py(2293):                 to_demote.add(table)
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2309):         query.promote_joins(to_promote)
0.77 query.py(771):         aliases = list(aliases)
0.77 query.py(772):         while aliases:
0.77 query.py(2310):         query.demote_joins(to_demote)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(806):             alias = aliases.pop(0)
0.77 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.77 query.py(805):         while aliases:
0.77 query.py(2311):         return to_demote
0.77 query.py(1353):         return target_clause, needed_inner
0.77 query.py(1320):         if clause:
0.77 query.py(1321):             self.where.add(clause, AND)
0.77 query.py(1322):         self.demote_joins(existing_inner)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(278):         if using is None and connection is None:
0.77 query.py(280):         if using:
0.77 query.py(281):             connection = connections[using]
0.77 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.77 compiler.py(25):         self.query = query
0.77 compiler.py(26):         self.connection = connection
0.77 compiler.py(27):         self.using = using
0.77 compiler.py(28):         self.quote_cache = {'*': '*'}
0.77 compiler.py(33):         self.select = None
0.77 compiler.py(34):         self.annotation_col_map = None
0.77 compiler.py(35):         self.klass_info = None
0.77 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.77 compiler.py(38):         self._meta_ordering = None
0.77 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.77 compiler.py(1081):         try:
0.77 compiler.py(1082):             sql, params = self.as_sql()
0.77 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.77 compiler.py(479):         try:
0.77 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.77 compiler.py(52):         self.setup_query()
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.77 compiler.py(202):         select = []
0.77 compiler.py(203):         klass_info = None
0.77 compiler.py(204):         annotations = {}
0.77 compiler.py(205):         select_idx = 0
0.77 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.77 compiler.py(211):         if self.query.default_cols:
0.77 compiler.py(212):             cols = self.get_default_columns()
0.77 compiler.py(644):         result = []
0.77 compiler.py(645):         if opts is None:
0.77 compiler.py(646):             opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(647):         only_load = self.deferred_to_columns()
0.77 compiler.py(1018):         columns = {}
0.77 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.77 query.py(655):         field_names, defer = self.deferred_loading
0.77 query.py(656):         if not field_names:
0.77 query.py(657):             return
0.77 compiler.py(1020):         return columns
0.77 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(913):             alias = self.base_table
0.77 query.py(250):         for alias in self.alias_map:
0.77 query.py(251):             return alias
0.77 query.py(914):             self.ref_alias(alias)
0.77 query.py(754):         self.alias_refcount[alias] += 1
0.77 query.py(917):         return alias
0.77 compiler.py(652):         seen_models = {None: start_alias}
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(674):         return result
0.77 compiler.py(217):         if cols:
0.77 compiler.py(218):             select_list = []
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(224):                 'model': self.query.model,
0.77 compiler.py(225):                 'select_fields': select_list,
0.77 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.77 query.py(2075):         if self._annotation_select_cache is not None:
0.77 query.py(2077):         elif not self.annotations:
0.77 query.py(2078):             return {}
0.77 compiler.py(232):         if self.query.select_related:
0.77 compiler.py(244):         ret = []
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(252):         return ret, klass_info, annotations
0.77 compiler.py(44):         self.col_count = len(self.select)
0.77 compiler.py(53):         order_by = self.get_order_by()
0.77 compiler.py(263):         if self.query.extra_order_by:
0.77 compiler.py(265):         elif not self.query.default_ordering:
0.77 compiler.py(267):         elif self.query.order_by:
0.77 compiler.py(269):         elif self.query.get_meta().ordering:
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(273):             ordering = []
0.77 compiler.py(274):         if self.query.standard_ordering:
0.77 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.77 compiler.py(279):         order_by = []
0.77 compiler.py(280):         for field in ordering:
0.77 compiler.py(340):         result = []
0.77 compiler.py(341):         seen = set()
0.77 compiler.py(343):         for expr, is_ref in order_by:
0.77 compiler.py(376):         return result
0.77 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.77 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.77 compiler.py(379):         extra_select = []
0.77 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.77 compiler.py(386):         return extra_select
0.77 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.77 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.77 compiler.py(97):         if self.query.group_by is None:
0.77 compiler.py(98):             return []
0.77 compiler.py(58):         return extra_select, order_by, group_by
0.77 compiler.py(481):             for_update_part = None
0.77 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.77 compiler.py(484):             combinator = self.query.combinator
0.77 compiler.py(485):             features = self.connection.features
0.77 compiler.py(486):             if combinator:
0.77 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.77 compiler.py(683):         result = []
0.77 compiler.py(684):         params = []
0.77 compiler.py(685):         opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(687):         for name in self.query.distinct_fields:
0.77 compiler.py(698):         return result, params
0.77 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.77 compiler.py(755):         result = []
0.77 compiler.py(756):         params = []
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.77 compiler.py(760):             try:
0.77 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.77 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(767):             result.append(clause_sql)
0.77 compiler.py(768):             params.extend(clause_params)
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(769):         for t in self.query.extra_tables:
0.77 compiler.py(776):         return result, params
0.77 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.77 compiler.py(497):                 result = ['SELECT']
0.77 compiler.py(498):                 params = []
0.77 compiler.py(500):                 if self.query.distinct:
0.77 compiler.py(508):                 out_cols = []
0.77 compiler.py(509):                 col_idx = 1
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.77 compiler.py(520):                 params.extend(f_params)
0.77 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.77 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.77 compiler.py(552):                 if where:
0.77 compiler.py(553):                     result.append('WHERE %s' % where)
0.77 compiler.py(554):                     params.extend(w_params)
0.77 compiler.py(556):                 grouping = []
0.77 compiler.py(557):                 for g_sql, g_params in group_by:
0.77 compiler.py(560):                 if grouping:
0.77 compiler.py(577):                 if having:
0.77 compiler.py(581):             if self.query.explain_query:
0.77 compiler.py(587):             if order_by:
0.77 compiler.py(594):             if with_limit_offset:
0.77 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.77 compiler.py(600):             if self.query.subquery and extra_select:
0.77 compiler.py(627):             return ' '.join(result), tuple(params)
0.77 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.77 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.77 query.py(820):             self.unref_alias(alias, unref_amount)
0.77 query.py(758):         self.alias_refcount[alias] -= amount
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.77 compiler.py(1083):             if not sql:
0.77 compiler.py(1090):         if chunked_fetch:
0.77 compiler.py(1093):             cursor = self.connection.cursor()
0.77 compiler.py(1094):         try:
0.77 compiler.py(1095):             cursor.execute(sql, params)
0.77 compiler.py(1101):         if result_type == CURSOR:
0.77 compiler.py(1104):         if result_type == SINGLE:
0.77 compiler.py(1113):         if result_type == NO_RESULTS:
0.77 compiler.py(1117):         result = cursor_iter(
0.77 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.77 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.77 compiler.py(1120):             chunk_size,
0.77 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.77 compiler.py(1123):             try:
0.77 compiler.py(1128):                 return list(result)
0.77 compiler.py(1518):     try:
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1522):         cursor.close()
0.77 compiler.py(1131):                 cursor.close()
0.77 compiler.py(1046):         if results is None:
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1049):         converters = self.get_converters(fields)
0.77 compiler.py(1023):         converters = {}
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1030):         return converters
0.77 compiler.py(1050):         rows = chain.from_iterable(results)
0.77 compiler.py(1051):         if converters:
0.77 compiler.py(1055):         return rows
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(278):         if using is None and connection is None:
0.77 query.py(280):         if using:
0.77 query.py(281):             connection = connections[using]
0.77 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.77 compiler.py(25):         self.query = query
0.77 compiler.py(26):         self.connection = connection
0.77 compiler.py(27):         self.using = using
0.77 compiler.py(28):         self.quote_cache = {'*': '*'}
0.77 compiler.py(33):         self.select = None
0.77 compiler.py(34):         self.annotation_col_map = None
0.77 compiler.py(35):         self.klass_info = None
0.77 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.77 compiler.py(38):         self._meta_ordering = None
0.77 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.77 compiler.py(1333):         self.return_id = return_id
0.77 compiler.py(1334):         with self.connection.cursor() as cursor:
0.77 compiler.py(1335):             for sql, params in self.as_sql():
0.77 compiler.py(1269):         qn = self.connection.ops.quote_name
0.77 compiler.py(1270):         opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.77 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.77 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.77 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.77 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.77 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.77 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.77 compiler.py(1276):         if self.query.fields:
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1279):                 for obj in self.query.objs
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1279):                 for obj in self.query.objs
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1227):         if self.query.raw:
0.77 compiler.py(1229):         return field.pre_save(obj, add=True)
0.77 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.77 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.77 compiler.py(1220):         return value
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1227):         if self.query.raw:
0.77 compiler.py(1229):         return field.pre_save(obj, add=True)
0.77 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.77 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.77 compiler.py(1220):         return value
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.77 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.77 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.77 compiler.py(1243):         if not value_rows:
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1250):             for row in value_rows
0.77 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.77 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.77 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1250):             for row in value_rows
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1170):         if field is None:
0.77 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.77 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.77 compiler.py(1182):             sql, params = '%s', [val]
0.77 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.77 compiler.py(1191):         return sql, params
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1170):         if field is None:
0.77 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.77 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.77 compiler.py(1182):             sql, params = '%s', [val]
0.77 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.77 compiler.py(1191):         return sql, params
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.77 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.77 compiler.py(1264):         return placeholder_rows, param_rows
0.77 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.77 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.77 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.77 compiler.py(1315):         if can_bulk:
0.77 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.77 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.77 compiler.py(1336):                 cursor.execute(sql, params)
0.77 compiler.py(1335):             for sql, params in self.as_sql():
0.77 compiler.py(1337):             if not return_id:
0.77 compiler.py(1338):                 return
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1758):         return not self.low_mark and self.high_mark is None
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.77 query.py(1331):         connector = q_object.connector
0.77 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.77 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.77 query.py(1334):         target_clause = self.where_class(connector=connector,
0.77 query.py(1335):                                          negated=q_object.negated)
0.77 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.77 query.py(2236):         self.connector = connector
0.77 query.py(2237):         self.negated = negated
0.77 query.py(2238):         if self.negated:
0.77 query.py(2244):             self.effective_connector = self.connector
0.77 query.py(2245):         self.num_children = num_children
0.77 query.py(2248):         self.votes = Counter()
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1338):             if isinstance(child, Node):
0.77 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.77 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.77 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.77 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.77 query.py(1214):         if isinstance(filter_expr, dict):
0.77 query.py(1216):         arg, value = filter_expr
0.77 query.py(1217):         if not arg:
0.77 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.77 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.77 query.py(1074):         if self.annotations:
0.77 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.77 query.py(290):         return self.model._meta
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.77 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.77 query.py(1085):         return lookup_parts, field_parts, False
0.77 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.77 query.py(1227):         if not allow_joins and len(parts) > 1:
0.77 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.77 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.77 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.77 query.py(1055):         elif isinstance(value, (list, tuple)):
0.77 query.py(1067):         return value
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1234):         clause = self.where_class()
0.77 query.py(1235):         if reffed_expression:
0.77 query.py(1240):         opts = self.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 query.py(1241):         alias = self.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.77 query.py(290):         return self.model._meta
0.77 query.py(943):         if reuse_with_filtered_relation and reuse:
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(953):         if reuse_aliases:
0.77 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.77 query.py(735):         alias_list = self.table_map.get(table_name)
0.77 query.py(736):         if not create and alias_list:
0.77 query.py(742):         if alias_list:
0.77 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.77 query.py(748):             self.table_map[table_name] = [alias]
0.77 query.py(749):         self.alias_refcount[alias] = 1
0.77 query.py(750):         return alias, True
0.77 query.py(965):         if join.join_type:
0.77 query.py(971):         join.table_alias = alias
0.77 query.py(972):         self.alias_map[alias] = join
0.77 query.py(973):         return alias
0.77 query.py(917):         return alias
0.77 query.py(1242):         allow_many = not branch_negated or not split_subq
0.77 query.py(1244):         try:
0.77 query.py(1245):             join_info = self.setup_joins(
0.77 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.77 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.77 query.py(1518):         joins = [alias]
0.77 query.py(1524):         def final_transformer(field, alias):
0.77 query.py(1529):         last_field_exception = None
0.77 query.py(1530):         for pivot in range(len(names), 0, -1):
0.77 query.py(1531):             try:
0.77 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.77 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1545):                 transforms = names[pivot:]
0.77 query.py(1546):                 break
0.77 query.py(1547):         for name in transforms:
0.77 query.py(1562):         for join in path:
0.77 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.77 query.py(1251):             if isinstance(value, Iterator):
0.77 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.77 query.py(1100):         if field.is_relation:
0.77 query.py(1257):             self._lookup_joins = join_info.joins
0.77 query.py(1263):         used_joins.update(join_info.joins)
0.77 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.77 query.py(1601):         joins = joins[:]
0.77 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.77 query.py(1614):         return targets, joins[-1], joins
0.77 query.py(1265):         if can_reuse is not None:
0.77 query.py(1266):             can_reuse.update(join_list)
0.77 query.py(1268):         if join_info.final_field.is_relation:
0.77 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.77 query.py(72):     if simple_col:
0.77 query.py(74):     return target.get_col(alias, field)
0.77 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.77 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.77 query.py(1129):         for name in transforms:
0.77 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.77 query.py(1134):         if not lookup_class:
0.77 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.77 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.77 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.77 query.py(1161):         return lookup
0.77 query.py(1281):         lookup_type = condition.lookup_name
0.77 query.py(1282):         clause.add(condition, AND)
0.77 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.77 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.77 query.py(1302):         return clause, used_joins if not require_outer else ()
0.77 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.77 query.py(2255):         self.votes.update(votes)
0.77 query.py(1350):             if child_clause:
0.77 query.py(1351):                 target_clause.add(child_clause, connector)
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.77 query.py(2264):         to_promote = set()
0.77 query.py(2265):         to_demote = set()
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.77 query.py(2291):             if self.effective_connector == 'AND' or (
0.77 query.py(2293):                 to_demote.add(table)
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2309):         query.promote_joins(to_promote)
0.77 query.py(771):         aliases = list(aliases)
0.77 query.py(772):         while aliases:
0.77 query.py(2310):         query.demote_joins(to_demote)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(806):             alias = aliases.pop(0)
0.77 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.77 query.py(805):         while aliases:
0.77 query.py(2311):         return to_demote
0.77 query.py(1353):         return target_clause, needed_inner
0.77 query.py(1320):         if clause:
0.77 query.py(1321):             self.where.add(clause, AND)
0.77 query.py(1322):         self.demote_joins(existing_inner)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(278):         if using is None and connection is None:
0.77 query.py(280):         if using:
0.77 query.py(281):             connection = connections[using]
0.77 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.77 compiler.py(25):         self.query = query
0.77 compiler.py(26):         self.connection = connection
0.77 compiler.py(27):         self.using = using
0.77 compiler.py(28):         self.quote_cache = {'*': '*'}
0.77 compiler.py(33):         self.select = None
0.77 compiler.py(34):         self.annotation_col_map = None
0.77 compiler.py(35):         self.klass_info = None
0.77 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.77 compiler.py(38):         self._meta_ordering = None
0.77 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.77 compiler.py(1081):         try:
0.77 compiler.py(1082):             sql, params = self.as_sql()
0.77 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.77 compiler.py(479):         try:
0.77 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.77 compiler.py(52):         self.setup_query()
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.77 compiler.py(202):         select = []
0.77 compiler.py(203):         klass_info = None
0.77 compiler.py(204):         annotations = {}
0.77 compiler.py(205):         select_idx = 0
0.77 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.77 compiler.py(211):         if self.query.default_cols:
0.77 compiler.py(212):             cols = self.get_default_columns()
0.77 compiler.py(644):         result = []
0.77 compiler.py(645):         if opts is None:
0.77 compiler.py(646):             opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(647):         only_load = self.deferred_to_columns()
0.77 compiler.py(1018):         columns = {}
0.77 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.77 query.py(655):         field_names, defer = self.deferred_loading
0.77 query.py(656):         if not field_names:
0.77 query.py(657):             return
0.77 compiler.py(1020):         return columns
0.77 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(913):             alias = self.base_table
0.77 query.py(250):         for alias in self.alias_map:
0.77 query.py(251):             return alias
0.77 query.py(914):             self.ref_alias(alias)
0.77 query.py(754):         self.alias_refcount[alias] += 1
0.77 query.py(917):         return alias
0.77 compiler.py(652):         seen_models = {None: start_alias}
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(674):         return result
0.77 compiler.py(217):         if cols:
0.77 compiler.py(218):             select_list = []
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(224):                 'model': self.query.model,
0.77 compiler.py(225):                 'select_fields': select_list,
0.77 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.77 query.py(2075):         if self._annotation_select_cache is not None:
0.77 query.py(2077):         elif not self.annotations:
0.77 query.py(2078):             return {}
0.77 compiler.py(232):         if self.query.select_related:
0.77 compiler.py(244):         ret = []
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(252):         return ret, klass_info, annotations
0.77 compiler.py(44):         self.col_count = len(self.select)
0.77 compiler.py(53):         order_by = self.get_order_by()
0.77 compiler.py(263):         if self.query.extra_order_by:
0.77 compiler.py(265):         elif not self.query.default_ordering:
0.77 compiler.py(267):         elif self.query.order_by:
0.77 compiler.py(269):         elif self.query.get_meta().ordering:
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(273):             ordering = []
0.77 compiler.py(274):         if self.query.standard_ordering:
0.77 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.77 compiler.py(279):         order_by = []
0.77 compiler.py(280):         for field in ordering:
0.77 compiler.py(340):         result = []
0.77 compiler.py(341):         seen = set()
0.77 compiler.py(343):         for expr, is_ref in order_by:
0.77 compiler.py(376):         return result
0.77 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.77 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.77 compiler.py(379):         extra_select = []
0.77 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.77 compiler.py(386):         return extra_select
0.77 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.77 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.77 compiler.py(97):         if self.query.group_by is None:
0.77 compiler.py(98):             return []
0.77 compiler.py(58):         return extra_select, order_by, group_by
0.77 compiler.py(481):             for_update_part = None
0.77 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.77 compiler.py(484):             combinator = self.query.combinator
0.77 compiler.py(485):             features = self.connection.features
0.77 compiler.py(486):             if combinator:
0.77 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.77 compiler.py(683):         result = []
0.77 compiler.py(684):         params = []
0.77 compiler.py(685):         opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(687):         for name in self.query.distinct_fields:
0.77 compiler.py(698):         return result, params
0.77 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.77 compiler.py(755):         result = []
0.77 compiler.py(756):         params = []
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.77 compiler.py(760):             try:
0.77 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.77 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(767):             result.append(clause_sql)
0.77 compiler.py(768):             params.extend(clause_params)
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(769):         for t in self.query.extra_tables:
0.77 compiler.py(776):         return result, params
0.77 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.77 compiler.py(497):                 result = ['SELECT']
0.77 compiler.py(498):                 params = []
0.77 compiler.py(500):                 if self.query.distinct:
0.77 compiler.py(508):                 out_cols = []
0.77 compiler.py(509):                 col_idx = 1
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(511):                     if alias:
0.77 compiler.py(513):                     elif with_col_aliases:
0.77 compiler.py(516):                     params.extend(s_params)
0.77 compiler.py(517):                     out_cols.append(s_sql)
0.77 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.77 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.77 compiler.py(520):                 params.extend(f_params)
0.77 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.77 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.77 compiler.py(552):                 if where:
0.77 compiler.py(553):                     result.append('WHERE %s' % where)
0.77 compiler.py(554):                     params.extend(w_params)
0.77 compiler.py(556):                 grouping = []
0.77 compiler.py(557):                 for g_sql, g_params in group_by:
0.77 compiler.py(560):                 if grouping:
0.77 compiler.py(577):                 if having:
0.77 compiler.py(581):             if self.query.explain_query:
0.77 compiler.py(587):             if order_by:
0.77 compiler.py(594):             if with_limit_offset:
0.77 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.77 compiler.py(600):             if self.query.subquery and extra_select:
0.77 compiler.py(627):             return ' '.join(result), tuple(params)
0.77 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.77 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.77 query.py(820):             self.unref_alias(alias, unref_amount)
0.77 query.py(758):         self.alias_refcount[alias] -= amount
0.77 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.77 compiler.py(1083):             if not sql:
0.77 compiler.py(1090):         if chunked_fetch:
0.77 compiler.py(1093):             cursor = self.connection.cursor()
0.77 compiler.py(1094):         try:
0.77 compiler.py(1095):             cursor.execute(sql, params)
0.77 compiler.py(1101):         if result_type == CURSOR:
0.77 compiler.py(1104):         if result_type == SINGLE:
0.77 compiler.py(1113):         if result_type == NO_RESULTS:
0.77 compiler.py(1117):         result = cursor_iter(
0.77 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.77 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.77 compiler.py(1120):             chunk_size,
0.77 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.77 compiler.py(1123):             try:
0.77 compiler.py(1128):                 return list(result)
0.77 compiler.py(1518):     try:
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.77 compiler.py(1522):         cursor.close()
0.77 compiler.py(1131):                 cursor.close()
0.77 compiler.py(1046):         if results is None:
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.77 compiler.py(1049):         converters = self.get_converters(fields)
0.77 compiler.py(1023):         converters = {}
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1025):             if expression:
0.77 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.77 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.77 compiler.py(1028):                 if backend_converters or field_converters:
0.77 compiler.py(1024):         for i, expression in enumerate(expressions):
0.77 compiler.py(1030):         return converters
0.77 compiler.py(1050):         rows = chain.from_iterable(results)
0.77 compiler.py(1051):         if converters:
0.77 compiler.py(1055):         return rows
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(154):         self.model = model
0.77 query.py(155):         self.alias_refcount = {}
0.77 query.py(161):         self.alias_map = {}
0.77 query.py(165):         self.external_aliases = set()
0.77 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.77 query.py(167):         self.default_cols = True
0.77 query.py(168):         self.default_ordering = True
0.77 query.py(169):         self.standard_ordering = True
0.77 query.py(170):         self.used_aliases = set()
0.77 query.py(171):         self.filter_is_sticky = False
0.77 query.py(172):         self.subquery = False
0.77 query.py(180):         self.select = ()
0.77 query.py(181):         self.where = where()
0.77 query.py(182):         self.where_class = where
0.77 query.py(189):         self.group_by = None
0.77 query.py(190):         self.order_by = ()
0.77 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.77 query.py(192):         self.distinct = False
0.77 query.py(193):         self.distinct_fields = ()
0.77 query.py(194):         self.select_for_update = False
0.77 query.py(195):         self.select_for_update_nowait = False
0.77 query.py(196):         self.select_for_update_skip_locked = False
0.77 query.py(197):         self.select_for_update_of = ()
0.77 query.py(199):         self.select_related = False
0.77 query.py(201):         self.max_depth = 5
0.77 query.py(205):         self.values_select = ()
0.77 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.77 query.py(209):         self.annotation_select_mask = None
0.77 query.py(210):         self._annotation_select_cache = None
0.77 query.py(213):         self.combinator = None
0.77 query.py(214):         self.combinator_all = False
0.77 query.py(215):         self.combined_queries = ()
0.77 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.77 query.py(220):         self.extra_select_mask = None
0.77 query.py(221):         self._extra_select_cache = None
0.77 query.py(223):         self.extra_tables = ()
0.77 query.py(224):         self.extra_order_by = ()
0.77 query.py(229):         self.deferred_loading = (frozenset(), True)
0.77 query.py(231):         self._filtered_relations = {}
0.77 query.py(233):         self.explain_query = False
0.77 query.py(234):         self.explain_format = None
0.77 query.py(235):         self.explain_options = {}
0.77 query.py(1758):         return not self.low_mark and self.high_mark is None
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(334):         except AttributeError:
0.77 query.py(335):             pass
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.77 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.77 query.py(1331):         connector = q_object.connector
0.77 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.77 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.77 query.py(1334):         target_clause = self.where_class(connector=connector,
0.77 query.py(1335):                                          negated=q_object.negated)
0.77 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.77 query.py(2236):         self.connector = connector
0.77 query.py(2237):         self.negated = negated
0.77 query.py(2238):         if self.negated:
0.77 query.py(2244):             self.effective_connector = self.connector
0.77 query.py(2245):         self.num_children = num_children
0.77 query.py(2248):         self.votes = Counter()
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1338):             if isinstance(child, Node):
0.77 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.77 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.77 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.77 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.77 query.py(1214):         if isinstance(filter_expr, dict):
0.77 query.py(1216):         arg, value = filter_expr
0.77 query.py(1217):         if not arg:
0.77 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.77 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.77 query.py(1074):         if self.annotations:
0.77 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.77 query.py(290):         return self.model._meta
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.77 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.77 query.py(1085):         return lookup_parts, field_parts, False
0.77 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.77 query.py(1227):         if not allow_joins and len(parts) > 1:
0.77 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.77 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.77 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.77 query.py(1055):         elif isinstance(value, (list, tuple)):
0.77 query.py(1067):         return value
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1234):         clause = self.where_class()
0.77 query.py(1235):         if reffed_expression:
0.77 query.py(1240):         opts = self.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 query.py(1241):         alias = self.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.77 query.py(290):         return self.model._meta
0.77 query.py(943):         if reuse_with_filtered_relation and reuse:
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(950):                 a for a, j in self.alias_map.items()
0.77 query.py(953):         if reuse_aliases:
0.77 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.77 query.py(735):         alias_list = self.table_map.get(table_name)
0.77 query.py(736):         if not create and alias_list:
0.77 query.py(742):         if alias_list:
0.77 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.77 query.py(748):             self.table_map[table_name] = [alias]
0.77 query.py(749):         self.alias_refcount[alias] = 1
0.77 query.py(750):         return alias, True
0.77 query.py(965):         if join.join_type:
0.77 query.py(971):         join.table_alias = alias
0.77 query.py(972):         self.alias_map[alias] = join
0.77 query.py(973):         return alias
0.77 query.py(917):         return alias
0.77 query.py(1242):         allow_many = not branch_negated or not split_subq
0.77 query.py(1244):         try:
0.77 query.py(1245):             join_info = self.setup_joins(
0.77 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.77 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.77 query.py(1518):         joins = [alias]
0.77 query.py(1524):         def final_transformer(field, alias):
0.77 query.py(1529):         last_field_exception = None
0.77 query.py(1530):         for pivot in range(len(names), 0, -1):
0.77 query.py(1531):             try:
0.77 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.77 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1545):                 transforms = names[pivot:]
0.77 query.py(1546):                 break
0.77 query.py(1547):         for name in transforms:
0.77 query.py(1562):         for join in path:
0.77 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.77 query.py(1251):             if isinstance(value, Iterator):
0.77 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.77 query.py(1100):         if field.is_relation:
0.77 query.py(1257):             self._lookup_joins = join_info.joins
0.77 query.py(1263):         used_joins.update(join_info.joins)
0.77 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.77 query.py(1601):         joins = joins[:]
0.77 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.77 query.py(1614):         return targets, joins[-1], joins
0.77 query.py(1265):         if can_reuse is not None:
0.77 query.py(1266):             can_reuse.update(join_list)
0.77 query.py(1268):         if join_info.final_field.is_relation:
0.77 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.77 query.py(72):     if simple_col:
0.77 query.py(74):     return target.get_col(alias, field)
0.77 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.77 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.77 query.py(1129):         for name in transforms:
0.77 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.77 query.py(1134):         if not lookup_class:
0.77 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.77 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.77 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.77 query.py(1161):         return lookup
0.77 query.py(1281):         lookup_type = condition.lookup_name
0.77 query.py(1282):         clause.add(condition, AND)
0.77 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.77 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.77 query.py(1302):         return clause, used_joins if not require_outer else ()
0.77 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.77 query.py(2255):         self.votes.update(votes)
0.77 query.py(1350):             if child_clause:
0.77 query.py(1351):                 target_clause.add(child_clause, connector)
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1338):             if isinstance(child, Node):
0.77 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.77 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.77 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.77 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.77 query.py(1214):         if isinstance(filter_expr, dict):
0.77 query.py(1216):         arg, value = filter_expr
0.77 query.py(1217):         if not arg:
0.77 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.77 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.77 query.py(1074):         if self.annotations:
0.77 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.77 query.py(290):         return self.model._meta
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.77 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.77 query.py(1085):         return lookup_parts, field_parts, False
0.77 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.77 query.py(1227):         if not allow_joins and len(parts) > 1:
0.77 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.77 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.77 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.77 query.py(1055):         elif isinstance(value, (list, tuple)):
0.77 query.py(1067):         return value
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.77 query.py(1234):         clause = self.where_class()
0.77 query.py(1235):         if reffed_expression:
0.77 query.py(1240):         opts = self.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 query.py(1241):         alias = self.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(913):             alias = self.base_table
0.77 query.py(250):         for alias in self.alias_map:
0.77 query.py(251):             return alias
0.77 query.py(914):             self.ref_alias(alias)
0.77 query.py(754):         self.alias_refcount[alias] += 1
0.77 query.py(917):         return alias
0.77 query.py(1242):         allow_many = not branch_negated or not split_subq
0.77 query.py(1244):         try:
0.77 query.py(1245):             join_info = self.setup_joins(
0.77 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.77 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.77 query.py(1518):         joins = [alias]
0.77 query.py(1524):         def final_transformer(field, alias):
0.77 query.py(1529):         last_field_exception = None
0.77 query.py(1530):         for pivot in range(len(names), 0, -1):
0.77 query.py(1531):             try:
0.77 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.77 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.77 query.py(1405):         path, names_with_path = [], []
0.77 query.py(1406):         for pos, name in enumerate(names):
0.77 query.py(1407):             cur_names_with_path = (name, [])
0.77 query.py(1408):             if name == 'pk':
0.77 query.py(1411):             field = None
0.77 query.py(1412):             filtered_relation = None
0.77 query.py(1413):             try:
0.77 query.py(1414):                 field = opts.get_field(name)
0.77 query.py(1421):             if field is not None:
0.77 query.py(1425):                 if field.is_relation and not field.related_model:
0.77 query.py(1432):                 try:
0.77 query.py(1433):                     model = field.model._meta.concrete_model
0.77 query.py(1454):             if model is not opts.model:
0.77 query.py(1460):             if hasattr(field, 'get_path_info'):
0.77 query.py(1477):                 final_field = field
0.77 query.py(1478):                 targets = (field,)
0.77 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.77 query.py(1483):                 break
0.77 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.77 query.py(1545):                 transforms = names[pivot:]
0.77 query.py(1546):                 break
0.77 query.py(1547):         for name in transforms:
0.77 query.py(1562):         for join in path:
0.77 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.77 query.py(1251):             if isinstance(value, Iterator):
0.77 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.77 query.py(1100):         if field.is_relation:
0.77 query.py(1257):             self._lookup_joins = join_info.joins
0.77 query.py(1263):         used_joins.update(join_info.joins)
0.77 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.77 query.py(1601):         joins = joins[:]
0.77 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.77 query.py(1614):         return targets, joins[-1], joins
0.77 query.py(1265):         if can_reuse is not None:
0.77 query.py(1266):             can_reuse.update(join_list)
0.77 query.py(1268):         if join_info.final_field.is_relation:
0.77 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.77 query.py(72):     if simple_col:
0.77 query.py(74):     return target.get_col(alias, field)
0.77 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.77 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.77 query.py(1129):         for name in transforms:
0.77 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.77 query.py(1134):         if not lookup_class:
0.77 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.77 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.77 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.77 query.py(1161):         return lookup
0.77 query.py(1281):         lookup_type = condition.lookup_name
0.77 query.py(1282):         clause.add(condition, AND)
0.77 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.77 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.77 query.py(1302):         return clause, used_joins if not require_outer else ()
0.77 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.77 query.py(2255):         self.votes.update(votes)
0.77 query.py(1350):             if child_clause:
0.77 query.py(1351):                 target_clause.add(child_clause, connector)
0.77 query.py(1337):         for child in q_object.children:
0.77 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.77 query.py(2264):         to_promote = set()
0.77 query.py(2265):         to_demote = set()
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.77 query.py(2291):             if self.effective_connector == 'AND' or (
0.77 query.py(2293):                 to_demote.add(table)
0.77 query.py(2268):         for table, votes in self.votes.items():
0.77 query.py(2309):         query.promote_joins(to_promote)
0.77 query.py(771):         aliases = list(aliases)
0.77 query.py(772):         while aliases:
0.77 query.py(2310):         query.demote_joins(to_demote)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(806):             alias = aliases.pop(0)
0.77 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.77 query.py(805):         while aliases:
0.77 query.py(2311):         return to_demote
0.77 query.py(1353):         return target_clause, needed_inner
0.77 query.py(1320):         if clause:
0.77 query.py(1321):             self.where.add(clause, AND)
0.77 query.py(1322):         self.demote_joins(existing_inner)
0.77 query.py(804):         aliases = list(aliases)
0.77 query.py(805):         while aliases:
0.77 query.py(1758):         return not self.low_mark and self.high_mark is None
0.77 query.py(1758):         return not self.low_mark and self.high_mark is None
0.77 query.py(343):         obj = self.clone()
0.77 query.py(297):         obj = Empty()
0.77 query.py(298):         obj.__class__ = self.__class__
0.77 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.77 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.77 query.py(303):         obj.alias_map = self.alias_map.copy()
0.77 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.77 query.py(305):         obj.table_map = self.table_map.copy()
0.77 query.py(306):         obj.where = self.where.clone()
0.77 query.py(307):         obj.annotations = self.annotations.copy()
0.77 query.py(308):         if self.annotation_select_mask is None:
0.77 query.py(309):             obj.annotation_select_mask = None
0.77 query.py(317):         obj._annotation_select_cache = None
0.77 query.py(318):         obj.extra = self.extra.copy()
0.77 query.py(319):         if self.extra_select_mask is None:
0.77 query.py(320):             obj.extra_select_mask = None
0.77 query.py(323):         if self._extra_select_cache is None:
0.77 query.py(324):             obj._extra_select_cache = None
0.77 query.py(327):         if 'subq_aliases' in self.__dict__:
0.77 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.77 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.77 query.py(332):         try:
0.77 query.py(333):             del obj.base_table
0.77 query.py(336):         return obj
0.77 query.py(344):         if klass and obj.__class__ != klass:
0.77 query.py(346):         if not obj.filter_is_sticky:
0.77 query.py(347):             obj.used_aliases = set()
0.77 query.py(348):         obj.filter_is_sticky = False
0.77 query.py(349):         if hasattr(obj, '_setup_query'):
0.77 query.py(351):         return obj
0.77 query.py(1860):         self.order_by = ()
0.77 query.py(1861):         self.extra_order_by = ()
0.77 query.py(1862):         if force_empty:
0.77 query.py(1839):         errors = []
0.77 query.py(1840):         for item in ordering:
0.77 query.py(1848):         if errors:
0.77 query.py(1850):         if ordering:
0.77 query.py(1853):             self.default_ordering = False
0.77 query.py(1731):         if high is not None:
0.77 query.py(1732):             if self.high_mark is not None:
0.77 query.py(1735):                 self.high_mark = self.low_mark + high
0.77 query.py(1736):         if low is not None:
0.77 query.py(1742):         if self.low_mark == self.high_mark:
0.77 query.py(278):         if using is None and connection is None:
0.77 query.py(280):         if using:
0.77 query.py(281):             connection = connections[using]
0.77 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.77 compiler.py(25):         self.query = query
0.77 compiler.py(26):         self.connection = connection
0.77 compiler.py(27):         self.using = using
0.77 compiler.py(28):         self.quote_cache = {'*': '*'}
0.77 compiler.py(33):         self.select = None
0.77 compiler.py(34):         self.annotation_col_map = None
0.77 compiler.py(35):         self.klass_info = None
0.77 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.77 compiler.py(38):         self._meta_ordering = None
0.77 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.77 compiler.py(1081):         try:
0.77 compiler.py(1082):             sql, params = self.as_sql()
0.77 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.77 compiler.py(479):         try:
0.77 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.77 compiler.py(52):         self.setup_query()
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.77 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.77 compiler.py(202):         select = []
0.77 compiler.py(203):         klass_info = None
0.77 compiler.py(204):         annotations = {}
0.77 compiler.py(205):         select_idx = 0
0.77 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.77 compiler.py(211):         if self.query.default_cols:
0.77 compiler.py(212):             cols = self.get_default_columns()
0.77 compiler.py(644):         result = []
0.77 compiler.py(645):         if opts is None:
0.77 compiler.py(646):             opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(647):         only_load = self.deferred_to_columns()
0.77 compiler.py(1018):         columns = {}
0.77 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.77 query.py(655):         field_names, defer = self.deferred_loading
0.77 query.py(656):         if not field_names:
0.77 query.py(657):             return
0.77 compiler.py(1020):         return columns
0.77 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.77 query.py(912):         if self.alias_map:
0.77 query.py(913):             alias = self.base_table
0.77 query.py(250):         for alias in self.alias_map:
0.77 query.py(251):             return alias
0.77 query.py(914):             self.ref_alias(alias)
0.77 query.py(754):         self.alias_refcount[alias] += 1
0.77 query.py(917):         return alias
0.77 compiler.py(652):         seen_models = {None: start_alias}
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(655):             model = field.model._meta.concrete_model
0.77 compiler.py(658):             if model == opts.model:
0.77 compiler.py(659):                 model = None
0.77 compiler.py(660):             if from_parent and model is not None and issubclass(
0.77 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.77 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.77 compiler.py(671):                                                  seen_models)
0.77 query.py(984):         if model in seen:
0.77 query.py(985):             return seen[model]
0.77 compiler.py(672):             column = field.get_col(alias)
0.77 compiler.py(673):             result.append(column)
0.77 compiler.py(654):         for field in opts.concrete_fields:
0.77 compiler.py(674):         return result
0.77 compiler.py(217):         if cols:
0.77 compiler.py(218):             select_list = []
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(220):                 select_list.append(select_idx)
0.77 compiler.py(221):                 select.append((col, None))
0.77 compiler.py(222):                 select_idx += 1
0.77 compiler.py(219):             for col in cols:
0.77 compiler.py(224):                 'model': self.query.model,
0.77 compiler.py(225):                 'select_fields': select_list,
0.77 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.77 query.py(2075):         if self._annotation_select_cache is not None:
0.77 query.py(2077):         elif not self.annotations:
0.77 query.py(2078):             return {}
0.77 compiler.py(232):         if self.query.select_related:
0.77 compiler.py(244):         ret = []
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(246):             try:
0.77 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.77 compiler.py(397):                 name in self.query.extra_select or (
0.77 query.py(2090):         if self._extra_select_cache is not None:
0.77 query.py(2092):         if not self.extra:
0.77 query.py(2093):             return {}
0.77 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.77 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.77 compiler.py(402):         self.quote_cache[name] = r
0.77 compiler.py(403):         return r
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.77 compiler.py(251):             ret.append((col, (sql, params), alias))
0.77 compiler.py(245):         for col, alias in select:
0.77 compiler.py(252):         return ret, klass_info, annotations
0.77 compiler.py(44):         self.col_count = len(self.select)
0.77 compiler.py(53):         order_by = self.get_order_by()
0.77 compiler.py(263):         if self.query.extra_order_by:
0.77 compiler.py(265):         elif not self.query.default_ordering:
0.77 compiler.py(266):             ordering = self.query.order_by
0.77 compiler.py(274):         if self.query.standard_ordering:
0.77 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.77 compiler.py(279):         order_by = []
0.77 compiler.py(280):         for field in ordering:
0.77 compiler.py(340):         result = []
0.77 compiler.py(341):         seen = set()
0.77 compiler.py(343):         for expr, is_ref in order_by:
0.77 compiler.py(376):         return result
0.77 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.77 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.77 compiler.py(379):         extra_select = []
0.77 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.77 compiler.py(386):         return extra_select
0.77 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.77 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.77 compiler.py(97):         if self.query.group_by is None:
0.77 compiler.py(98):             return []
0.77 compiler.py(58):         return extra_select, order_by, group_by
0.77 compiler.py(481):             for_update_part = None
0.77 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.77 compiler.py(484):             combinator = self.query.combinator
0.77 compiler.py(485):             features = self.connection.features
0.77 compiler.py(486):             if combinator:
0.77 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.77 compiler.py(683):         result = []
0.77 compiler.py(684):         params = []
0.77 compiler.py(685):         opts = self.query.get_meta()
0.77 query.py(290):         return self.model._meta
0.77 compiler.py(687):         for name in self.query.distinct_fields:
0.77 compiler.py(698):         return result, params
0.77 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.77 compiler.py(755):         result = []
0.77 compiler.py(756):         params = []
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.77 compiler.py(760):             try:
0.77 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.77 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.77 compiler.py(767):             result.append(clause_sql)
0.77 compiler.py(768):             params.extend(clause_params)
0.77 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.77 compiler.py(769):         for t in self.query.extra_tables:
0.77 compiler.py(776):         return result, params
0.77 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.77 compiler.py(407):         if vendor_impl:
0.77 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(394):         if name in self.quote_cache:
0.77 compiler.py(395):             return self.quote_cache[name]
0.77 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.77 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.78 compiler.py(497):                 result = ['SELECT']
0.78 compiler.py(498):                 params = []
0.78 compiler.py(500):                 if self.query.distinct:
0.78 compiler.py(508):                 out_cols = []
0.78 compiler.py(509):                 col_idx = 1
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(513):                     elif with_col_aliases:
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(513):                     elif with_col_aliases:
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(513):                     elif with_col_aliases:
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.78 compiler.py(520):                 params.extend(f_params)
0.78 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.78 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.78 compiler.py(552):                 if where:
0.78 compiler.py(553):                     result.append('WHERE %s' % where)
0.78 compiler.py(554):                     params.extend(w_params)
0.78 compiler.py(556):                 grouping = []
0.78 compiler.py(557):                 for g_sql, g_params in group_by:
0.78 compiler.py(560):                 if grouping:
0.78 compiler.py(577):                 if having:
0.78 compiler.py(581):             if self.query.explain_query:
0.78 compiler.py(587):             if order_by:
0.78 compiler.py(594):             if with_limit_offset:
0.78 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.78 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.78 compiler.py(600):             if self.query.subquery and extra_select:
0.78 compiler.py(627):             return ' '.join(result), tuple(params)
0.78 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.78 query.py(820):             self.unref_alias(alias, unref_amount)
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 compiler.py(1083):             if not sql:
0.78 compiler.py(1090):         if chunked_fetch:
0.78 compiler.py(1093):             cursor = self.connection.cursor()
0.78 compiler.py(1094):         try:
0.78 compiler.py(1095):             cursor.execute(sql, params)
0.78 compiler.py(1101):         if result_type == CURSOR:
0.78 compiler.py(1104):         if result_type == SINGLE:
0.78 compiler.py(1113):         if result_type == NO_RESULTS:
0.78 compiler.py(1117):         result = cursor_iter(
0.78 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.78 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.78 compiler.py(1120):             chunk_size,
0.78 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.78 compiler.py(1123):             try:
0.78 compiler.py(1128):                 return list(result)
0.78 compiler.py(1518):     try:
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1522):         cursor.close()
0.78 compiler.py(1131):                 cursor.close()
0.78 compiler.py(1046):         if results is None:
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1049):         converters = self.get_converters(fields)
0.78 compiler.py(1023):         converters = {}
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1025):             if expression:
0.78 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.78 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.78 compiler.py(1028):                 if backend_converters or field_converters:
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1025):             if expression:
0.78 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.78 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.78 compiler.py(1028):                 if backend_converters or field_converters:
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1025):             if expression:
0.78 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.78 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.78 compiler.py(1028):                 if backend_converters or field_converters:
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1030):         return converters
0.78 compiler.py(1050):         rows = chain.from_iterable(results)
0.78 compiler.py(1051):         if converters:
0.78 compiler.py(1055):         return rows
0.78 query.py(154):         self.model = model
0.78 query.py(155):         self.alias_refcount = {}
0.78 query.py(161):         self.alias_map = {}
0.78 query.py(165):         self.external_aliases = set()
0.78 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.78 query.py(167):         self.default_cols = True
0.78 query.py(168):         self.default_ordering = True
0.78 query.py(169):         self.standard_ordering = True
0.78 query.py(170):         self.used_aliases = set()
0.78 query.py(171):         self.filter_is_sticky = False
0.78 query.py(172):         self.subquery = False
0.78 query.py(180):         self.select = ()
0.78 query.py(181):         self.where = where()
0.78 query.py(182):         self.where_class = where
0.78 query.py(189):         self.group_by = None
0.78 query.py(190):         self.order_by = ()
0.78 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.78 query.py(192):         self.distinct = False
0.78 query.py(193):         self.distinct_fields = ()
0.78 query.py(194):         self.select_for_update = False
0.78 query.py(195):         self.select_for_update_nowait = False
0.78 query.py(196):         self.select_for_update_skip_locked = False
0.78 query.py(197):         self.select_for_update_of = ()
0.78 query.py(199):         self.select_related = False
0.78 query.py(201):         self.max_depth = 5
0.78 query.py(205):         self.values_select = ()
0.78 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.78 query.py(209):         self.annotation_select_mask = None
0.78 query.py(210):         self._annotation_select_cache = None
0.78 query.py(213):         self.combinator = None
0.78 query.py(214):         self.combinator_all = False
0.78 query.py(215):         self.combined_queries = ()
0.78 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.78 query.py(220):         self.extra_select_mask = None
0.78 query.py(221):         self._extra_select_cache = None
0.78 query.py(223):         self.extra_tables = ()
0.78 query.py(224):         self.extra_order_by = ()
0.78 query.py(229):         self.deferred_loading = (frozenset(), True)
0.78 query.py(231):         self._filtered_relations = {}
0.78 query.py(233):         self.explain_query = False
0.78 query.py(234):         self.explain_format = None
0.78 query.py(235):         self.explain_options = {}
0.78 query.py(343):         obj = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(344):         if klass and obj.__class__ != klass:
0.78 query.py(346):         if not obj.filter_is_sticky:
0.78 query.py(347):             obj.used_aliases = set()
0.78 query.py(348):         obj.filter_is_sticky = False
0.78 query.py(349):         if hasattr(obj, '_setup_query'):
0.78 query.py(351):         return obj
0.78 query.py(1758):         return not self.low_mark and self.high_mark is None
0.78 query.py(343):         obj = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(344):         if klass and obj.__class__ != klass:
0.78 query.py(346):         if not obj.filter_is_sticky:
0.78 query.py(347):             obj.used_aliases = set()
0.78 query.py(348):         obj.filter_is_sticky = False
0.78 query.py(349):         if hasattr(obj, '_setup_query'):
0.78 query.py(351):         return obj
0.78 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.78 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.78 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.78 query.py(1331):         connector = q_object.connector
0.78 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.78 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.78 query.py(1334):         target_clause = self.where_class(connector=connector,
0.78 query.py(1335):                                          negated=q_object.negated)
0.78 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.78 query.py(2236):         self.connector = connector
0.78 query.py(2237):         self.negated = negated
0.78 query.py(2238):         if self.negated:
0.78 query.py(2244):             self.effective_connector = self.connector
0.78 query.py(2245):         self.num_children = num_children
0.78 query.py(2248):         self.votes = Counter()
0.78 query.py(1337):         for child in q_object.children:
0.78 query.py(1338):             if isinstance(child, Node):
0.78 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.78 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.78 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.78 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.78 query.py(1214):         if isinstance(filter_expr, dict):
0.78 query.py(1216):         arg, value = filter_expr
0.78 query.py(1217):         if not arg:
0.78 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.78 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.78 query.py(1074):         if self.annotations:
0.78 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.78 query.py(290):         return self.model._meta
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.78 query.py(1462):                 if not allow_many:
0.78 query.py(1468):                 last = pathinfos[-1]
0.78 query.py(1469):                 path.extend(pathinfos)
0.78 query.py(1470):                 final_field = last.join_field
0.78 query.py(1471):                 opts = last.to_opts
0.78 query.py(1472):                 targets = last.target_fields
0.78 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.78 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1415):             except FieldDoesNotExist:
0.78 query.py(1416):                 if name in self.annotation_select:
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.78 query.py(1421):             if field is not None:
0.78 query.py(1441):                 pos -= 1
0.78 query.py(1442):                 if pos == -1 or fail_on_missing:
0.78 query.py(1450):                 break
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.78 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.78 query.py(1085):         return lookup_parts, field_parts, False
0.78 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.78 query.py(1227):         if not allow_joins and len(parts) > 1:
0.78 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.78 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.78 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.78 query.py(1055):         elif isinstance(value, (list, tuple)):
0.78 query.py(1067):         return value
0.78 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.78 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.78 query.py(1234):         clause = self.where_class()
0.78 query.py(1235):         if reffed_expression:
0.78 query.py(1240):         opts = self.get_meta()
0.78 query.py(290):         return self.model._meta
0.78 query.py(1241):         alias = self.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.78 query.py(290):         return self.model._meta
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.78 query.py(735):         alias_list = self.table_map.get(table_name)
0.78 query.py(736):         if not create and alias_list:
0.78 query.py(742):         if alias_list:
0.78 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.78 query.py(748):             self.table_map[table_name] = [alias]
0.78 query.py(749):         self.alias_refcount[alias] = 1
0.78 query.py(750):         return alias, True
0.78 query.py(965):         if join.join_type:
0.78 query.py(971):         join.table_alias = alias
0.78 query.py(972):         self.alias_map[alias] = join
0.78 query.py(973):         return alias
0.78 query.py(917):         return alias
0.78 query.py(1242):         allow_many = not branch_negated or not split_subq
0.78 query.py(1244):         try:
0.78 query.py(1245):             join_info = self.setup_joins(
0.78 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.78 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.78 query.py(1462):                 if not allow_many:
0.78 query.py(1468):                 last = pathinfos[-1]
0.78 query.py(1469):                 path.extend(pathinfos)
0.78 query.py(1470):                 final_field = last.join_field
0.78 query.py(1471):                 opts = last.to_opts
0.78 query.py(1472):                 targets = last.target_fields
0.78 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.78 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1563):             if join.filtered_relation:
0.78 query.py(1567):                 filtered_relation = None
0.78 query.py(1568):                 table_alias = None
0.78 query.py(1569):             opts = join.to_opts
0.78 query.py(1570):             if join.direct:
0.78 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.78 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.78 query.py(2193):         ) or field.null
0.78 query.py(1574):             connection = Join(
0.78 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.78 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.78 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.78 query.py(1579):             alias = self.join(
0.78 query.py(1580):                 connection, reuse=reuse,
0.78 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.78 query.py(735):         alias_list = self.table_map.get(table_name)
0.78 query.py(736):         if not create and alias_list:
0.78 query.py(742):         if alias_list:
0.78 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.78 query.py(748):             self.table_map[table_name] = [alias]
0.78 query.py(749):         self.alias_refcount[alias] = 1
0.78 query.py(750):         return alias, True
0.78 query.py(965):         if join.join_type:
0.78 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.78 query.py(969):                 join_type = INNER
0.78 query.py(970):             join.join_type = join_type
0.78 query.py(971):         join.table_alias = alias
0.78 query.py(972):         self.alias_map[alias] = join
0.78 query.py(973):         return alias
0.78 query.py(1583):             joins.append(alias)
0.78 query.py(1584):             if filtered_relation:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 query.py(1251):             if isinstance(value, Iterator):
0.78 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.78 query.py(1100):         if field.is_relation:
0.78 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.78 query.py(1112):             elif hasattr(value, '_meta'):
0.78 query.py(1114):             elif hasattr(value, '__iter__'):
0.78 query.py(1115):                 for v in value:
0.78 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.78 query.py(1092):         if hasattr(value, '_meta'):
0.78 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.78 query.py(1115):                 for v in value:
0.78 query.py(1257):             self._lookup_joins = join_info.joins
0.78 query.py(1263):         used_joins.update(join_info.joins)
0.78 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1603):             if len(joins) == 1 or not info.direct:
0.78 query.py(1605):             if info.filtered_relation:
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1609):             if not cur_targets.issubset(join_targets):
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1613):             self.unref_alias(joins.pop())
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 query.py(1265):         if can_reuse is not None:
0.78 query.py(1266):             can_reuse.update(join_list)
0.78 query.py(1268):         if join_info.final_field.is_relation:
0.78 query.py(1270):             num_lookups = len(lookups)
0.78 query.py(1271):             if num_lookups > 1:
0.78 query.py(1273):             if len(targets) == 1:
0.78 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.78 query.py(72):     if simple_col:
0.78 query.py(74):     return target.get_col(alias, field)
0.78 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.78 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.78 query.py(1129):         for name in transforms:
0.78 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.78 query.py(1134):         if not lookup_class:
0.78 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.78 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.78 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.78 query.py(1161):         return lookup
0.78 query.py(1281):         lookup_type = condition.lookup_name
0.78 query.py(1282):         clause.add(condition, AND)
0.78 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.78 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.78 query.py(1302):         return clause, used_joins if not require_outer else ()
0.78 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.78 query.py(2255):         self.votes.update(votes)
0.78 query.py(1350):             if child_clause:
0.78 query.py(1351):                 target_clause.add(child_clause, connector)
0.78 query.py(1337):         for child in q_object.children:
0.78 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.78 query.py(2264):         to_promote = set()
0.78 query.py(2265):         to_demote = set()
0.78 query.py(2268):         for table, votes in self.votes.items():
0.78 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.78 query.py(2291):             if self.effective_connector == 'AND' or (
0.78 query.py(2293):                 to_demote.add(table)
0.78 query.py(2268):         for table, votes in self.votes.items():
0.78 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.78 query.py(2291):             if self.effective_connector == 'AND' or (
0.78 query.py(2293):                 to_demote.add(table)
0.78 query.py(2268):         for table, votes in self.votes.items():
0.78 query.py(2309):         query.promote_joins(to_promote)
0.78 query.py(771):         aliases = list(aliases)
0.78 query.py(772):         while aliases:
0.78 query.py(2310):         query.demote_joins(to_demote)
0.78 query.py(804):         aliases = list(aliases)
0.78 query.py(805):         while aliases:
0.78 query.py(806):             alias = aliases.pop(0)
0.78 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.78 query.py(805):         while aliases:
0.78 query.py(806):             alias = aliases.pop(0)
0.78 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.78 query.py(805):         while aliases:
0.78 query.py(2311):         return to_demote
0.78 query.py(1353):         return target_clause, needed_inner
0.78 query.py(1320):         if clause:
0.78 query.py(1321):             self.where.add(clause, AND)
0.78 query.py(1322):         self.demote_joins(existing_inner)
0.78 query.py(804):         aliases = list(aliases)
0.78 query.py(805):         while aliases:
0.78 query.py(343):         obj = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(344):         if klass and obj.__class__ != klass:
0.78 query.py(346):         if not obj.filter_is_sticky:
0.78 query.py(347):             obj.used_aliases = set()
0.78 query.py(348):         obj.filter_is_sticky = False
0.78 query.py(349):         if hasattr(obj, '_setup_query'):
0.78 query.py(351):         return obj
0.78 query.py(2035):         self.select_related = False
0.78 query.py(2036):         self.clear_deferred_loading()
0.78 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.78 query.py(2037):         self.clear_select_fields()
0.78 query.py(1774):         self.select = ()
0.78 query.py(1775):         self.values_select = ()
0.78 query.py(2039):         if self.group_by is True:
0.78 query.py(2044):         if fields:
0.78 query.py(2045):             field_names = []
0.78 query.py(2046):             extra_names = []
0.78 query.py(2047):             annotation_names = []
0.78 query.py(2048):             if not self.extra and not self.annotations:
0.78 query.py(2051):                 field_names = list(fields)
0.78 query.py(2061):             self.set_extra_mask(extra_names)
0.78 query.py(2028):         if names is None:
0.78 query.py(2031):             self.extra_select_mask = set(names)
0.78 query.py(2032):         self._extra_select_cache = None
0.78 query.py(2062):             self.set_annotation_mask(annotation_names)
0.78 query.py(2013):         if names is None:
0.78 query.py(2016):             self.annotation_select_mask = set(names)
0.78 query.py(2017):         self._annotation_select_cache = None
0.78 query.py(2066):         self.values_select = tuple(field_names)
0.78 query.py(2067):         self.add_fields(field_names, True)
0.78 query.py(1797):         alias = self.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(913):             alias = self.base_table
0.78 query.py(250):         for alias in self.alias_map:
0.78 query.py(251):             return alias
0.78 query.py(914):             self.ref_alias(alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(917):         return alias
0.78 query.py(1798):         opts = self.get_meta()
0.78 query.py(290):         return self.model._meta
0.78 query.py(1800):         try:
0.78 query.py(1801):             cols = []
0.78 query.py(1802):             for name in field_names:
0.78 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.78 query.py(1462):                 if not allow_many:
0.78 query.py(1468):                 last = pathinfos[-1]
0.78 query.py(1469):                 path.extend(pathinfos)
0.78 query.py(1470):                 final_field = last.join_field
0.78 query.py(1471):                 opts = last.to_opts
0.78 query.py(1472):                 targets = last.target_fields
0.78 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.78 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1563):             if join.filtered_relation:
0.78 query.py(1567):                 filtered_relation = None
0.78 query.py(1568):                 table_alias = None
0.78 query.py(1569):             opts = join.to_opts
0.78 query.py(1570):             if join.direct:
0.78 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.78 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.78 query.py(2193):         ) or field.null
0.78 query.py(1574):             connection = Join(
0.78 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.78 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.78 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.78 query.py(1579):             alias = self.join(
0.78 query.py(1580):                 connection, reuse=reuse,
0.78 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(954):             if join.table_alias in reuse_aliases:
0.78 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.78 query.py(960):             self.ref_alias(reuse_alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(961):             return reuse_alias
0.78 query.py(1583):             joins.append(alias)
0.78 query.py(1584):             if filtered_relation:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.78 query.py(1807):                     join_info.targets,
0.78 query.py(1808):                     join_info.joins,
0.78 query.py(1809):                     join_info.path,
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1603):             if len(joins) == 1 or not info.direct:
0.78 query.py(1605):             if info.filtered_relation:
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1609):             if not cur_targets.issubset(join_targets):
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.78 query.py(1613):             self.unref_alias(joins.pop())
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 query.py(1811):                 for target in targets:
0.78 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.78 query.py(1525):             return field.get_col(alias)
0.78 query.py(1811):                 for target in targets:
0.78 query.py(1802):             for name in field_names:
0.78 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1477):                 final_field = field
0.78 query.py(1478):                 targets = (field,)
0.78 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.78 query.py(1483):                 break
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.78 query.py(1807):                     join_info.targets,
0.78 query.py(1808):                     join_info.joins,
0.78 query.py(1809):                     join_info.path,
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 query.py(1811):                 for target in targets:
0.78 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.78 query.py(1525):             return field.get_col(alias)
0.78 query.py(1811):                 for target in targets:
0.78 query.py(1802):             for name in field_names:
0.78 query.py(1813):             if cols:
0.78 query.py(1814):                 self.set_select(cols)
0.78 query.py(1782):         self.default_cols = False
0.78 query.py(1783):         self.select = tuple(cols)
0.78 query.py(278):         if using is None and connection is None:
0.78 query.py(280):         if using:
0.78 query.py(281):             connection = connections[using]
0.78 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.78 compiler.py(25):         self.query = query
0.78 compiler.py(26):         self.connection = connection
0.78 compiler.py(27):         self.using = using
0.78 compiler.py(28):         self.quote_cache = {'*': '*'}
0.78 compiler.py(33):         self.select = None
0.78 compiler.py(34):         self.annotation_col_map = None
0.78 compiler.py(35):         self.klass_info = None
0.78 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.78 compiler.py(38):         self._meta_ordering = None
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(1046):         if results is None:
0.78 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.78 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.78 compiler.py(1081):         try:
0.78 compiler.py(1082):             sql, params = self.as_sql()
0.78 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.78 compiler.py(479):         try:
0.78 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.78 compiler.py(52):         self.setup_query()
0.78 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.78 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.78 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.78 compiler.py(202):         select = []
0.78 compiler.py(203):         klass_info = None
0.78 compiler.py(204):         annotations = {}
0.78 compiler.py(205):         select_idx = 0
0.78 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.78 compiler.py(211):         if self.query.default_cols:
0.78 compiler.py(216):             cols = self.query.select
0.78 compiler.py(217):         if cols:
0.78 compiler.py(218):             select_list = []
0.78 compiler.py(219):             for col in cols:
0.78 compiler.py(220):                 select_list.append(select_idx)
0.78 compiler.py(221):                 select.append((col, None))
0.78 compiler.py(222):                 select_idx += 1
0.78 compiler.py(219):             for col in cols:
0.78 compiler.py(220):                 select_list.append(select_idx)
0.78 compiler.py(221):                 select.append((col, None))
0.78 compiler.py(222):                 select_idx += 1
0.78 compiler.py(219):             for col in cols:
0.78 compiler.py(224):                 'model': self.query.model,
0.78 compiler.py(225):                 'select_fields': select_list,
0.78 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(232):         if self.query.select_related:
0.78 compiler.py(244):         ret = []
0.78 compiler.py(245):         for col, alias in select:
0.78 compiler.py(246):             try:
0.78 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.78 compiler.py(251):             ret.append((col, (sql, params), alias))
0.78 compiler.py(245):         for col, alias in select:
0.78 compiler.py(246):             try:
0.78 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.78 compiler.py(251):             ret.append((col, (sql, params), alias))
0.78 compiler.py(245):         for col, alias in select:
0.78 compiler.py(252):         return ret, klass_info, annotations
0.78 compiler.py(44):         self.col_count = len(self.select)
0.78 compiler.py(53):         order_by = self.get_order_by()
0.78 compiler.py(263):         if self.query.extra_order_by:
0.78 compiler.py(265):         elif not self.query.default_ordering:
0.78 compiler.py(267):         elif self.query.order_by:
0.78 compiler.py(269):         elif self.query.get_meta().ordering:
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(270):             ordering = self.query.get_meta().ordering
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(271):             self._meta_ordering = ordering
0.78 compiler.py(274):         if self.query.standard_ordering:
0.78 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.78 compiler.py(279):         order_by = []
0.78 compiler.py(280):         for field in ordering:
0.78 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.78 compiler.py(292):             if field == '?':  # random
0.78 compiler.py(296):             col, order = get_order_dir(field, asc)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(297):             descending = order == 'DESC'
0.78 compiler.py(299):             if col in self.query.annotation_select:
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(305):             if col in self.query.annotations:
0.78 compiler.py(315):             if '.' in field:
0.78 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.78 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.78 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(708):         descending = order == 'DESC'
0.78 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.78 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.78 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(913):             alias = self.base_table
0.78 query.py(914):             self.ref_alias(alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(917):         return alias
0.78 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.78 query.py(1462):                 if not allow_many:
0.78 query.py(1468):                 last = pathinfos[-1]
0.78 query.py(1469):                 path.extend(pathinfos)
0.78 query.py(1470):                 final_field = last.join_field
0.78 query.py(1471):                 opts = last.to_opts
0.78 query.py(1472):                 targets = last.target_fields
0.78 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.78 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1477):                 final_field = field
0.78 query.py(1478):                 targets = (field,)
0.78 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.78 query.py(1483):                 break
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1563):             if join.filtered_relation:
0.78 query.py(1567):                 filtered_relation = None
0.78 query.py(1568):                 table_alias = None
0.78 query.py(1569):             opts = join.to_opts
0.78 query.py(1570):             if join.direct:
0.78 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.78 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.78 query.py(2193):         ) or field.null
0.78 query.py(1574):             connection = Join(
0.78 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.78 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.78 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.78 query.py(1579):             alias = self.join(
0.78 query.py(1580):                 connection, reuse=reuse,
0.78 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(954):             if join.table_alias in reuse_aliases:
0.78 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.78 query.py(960):             self.ref_alias(reuse_alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(961):             return reuse_alias
0.78 query.py(1583):             joins.append(alias)
0.78 query.py(1584):             if filtered_relation:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 compiler.py(741):         alias = joins[-1]
0.78 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.78 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.78 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1603):             if len(joins) == 1 or not info.direct:
0.78 query.py(1605):             if info.filtered_relation:
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1609):             if not cur_targets.issubset(join_targets):
0.78 query.py(1610):                 break
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 query.py(1525):             return field.get_col(alias)
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(280):         for field in ordering:
0.78 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.78 compiler.py(292):             if field == '?':  # random
0.78 compiler.py(296):             col, order = get_order_dir(field, asc)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(297):             descending = order == 'DESC'
0.78 compiler.py(299):             if col in self.query.annotation_select:
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(305):             if col in self.query.annotations:
0.78 compiler.py(315):             if '.' in field:
0.78 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.78 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.78 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(708):         descending = order == 'DESC'
0.78 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.78 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.78 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(913):             alias = self.base_table
0.78 query.py(914):             self.ref_alias(alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(917):         return alias
0.78 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.78 query.py(1462):                 if not allow_many:
0.78 query.py(1468):                 last = pathinfos[-1]
0.78 query.py(1469):                 path.extend(pathinfos)
0.78 query.py(1470):                 final_field = last.join_field
0.78 query.py(1471):                 opts = last.to_opts
0.78 query.py(1472):                 targets = last.target_fields
0.78 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.78 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1477):                 final_field = field
0.78 query.py(1478):                 targets = (field,)
0.78 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.78 query.py(1483):                 break
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1563):             if join.filtered_relation:
0.78 query.py(1567):                 filtered_relation = None
0.78 query.py(1568):                 table_alias = None
0.78 query.py(1569):             opts = join.to_opts
0.78 query.py(1570):             if join.direct:
0.78 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.78 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.78 query.py(2193):         ) or field.null
0.78 query.py(1574):             connection = Join(
0.78 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.78 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.78 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.78 query.py(1579):             alias = self.join(
0.78 query.py(1580):                 connection, reuse=reuse,
0.78 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(954):             if join.table_alias in reuse_aliases:
0.78 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.78 query.py(960):             self.ref_alias(reuse_alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(961):             return reuse_alias
0.78 query.py(1583):             joins.append(alias)
0.78 query.py(1584):             if filtered_relation:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 compiler.py(741):         alias = joins[-1]
0.78 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.78 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.78 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1603):             if len(joins) == 1 or not info.direct:
0.78 query.py(1605):             if info.filtered_relation:
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1608):             cur_targets = {t.column for t in targets}
0.78 query.py(1609):             if not cur_targets.issubset(join_targets):
0.78 query.py(1610):                 break
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 query.py(1525):             return field.get_col(alias)
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(280):         for field in ordering:
0.78 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.78 compiler.py(292):             if field == '?':  # random
0.78 compiler.py(296):             col, order = get_order_dir(field, asc)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(297):             descending = order == 'DESC'
0.78 compiler.py(299):             if col in self.query.annotation_select:
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(305):             if col in self.query.annotations:
0.78 compiler.py(315):             if '.' in field:
0.78 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.78 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.78 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.78 query.py(2204):     dirn = ORDER_DIR[default]
0.78 query.py(2205):     if field[0] == '-':
0.78 query.py(2207):     return field, dirn[0]
0.78 compiler.py(708):         descending = order == 'DESC'
0.78 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.78 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.78 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(913):             alias = self.base_table
0.78 query.py(914):             self.ref_alias(alias)
0.78 query.py(754):         self.alias_refcount[alias] += 1
0.78 query.py(917):         return alias
0.78 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.78 query.py(1518):         joins = [alias]
0.78 query.py(1524):         def final_transformer(field, alias):
0.78 query.py(1529):         last_field_exception = None
0.78 query.py(1530):         for pivot in range(len(names), 0, -1):
0.78 query.py(1531):             try:
0.78 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.78 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.78 query.py(1405):         path, names_with_path = [], []
0.78 query.py(1406):         for pos, name in enumerate(names):
0.78 query.py(1407):             cur_names_with_path = (name, [])
0.78 query.py(1408):             if name == 'pk':
0.78 query.py(1411):             field = None
0.78 query.py(1412):             filtered_relation = None
0.78 query.py(1413):             try:
0.78 query.py(1414):                 field = opts.get_field(name)
0.78 query.py(1421):             if field is not None:
0.78 query.py(1425):                 if field.is_relation and not field.related_model:
0.78 query.py(1432):                 try:
0.78 query.py(1433):                     model = field.model._meta.concrete_model
0.78 query.py(1454):             if model is not opts.model:
0.78 query.py(1460):             if hasattr(field, 'get_path_info'):
0.78 query.py(1477):                 final_field = field
0.78 query.py(1478):                 targets = (field,)
0.78 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.78 query.py(1483):                 break
0.78 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.78 query.py(1545):                 transforms = names[pivot:]
0.78 query.py(1546):                 break
0.78 query.py(1547):         for name in transforms:
0.78 query.py(1562):         for join in path:
0.78 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.78 compiler.py(741):         alias = joins[-1]
0.78 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.78 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.78 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.78 query.py(1601):         joins = joins[:]
0.78 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.78 query.py(1614):         return targets, joins[-1], joins
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 query.py(1525):             return field.get_col(alias)
0.78 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.78 compiler.py(280):         for field in ordering:
0.78 compiler.py(340):         result = []
0.78 compiler.py(341):         seen = set()
0.78 compiler.py(343):         for expr, is_ref in order_by:
0.78 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.78 compiler.py(345):             if self.query.combinator:
0.78 compiler.py(365):             sql, params = self.compile(resolved)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.78 compiler.py(371):             params_hash = make_hashable(params)
0.78 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.78 compiler.py(374):             seen.add((without_ordering, params_hash))
0.78 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.78 compiler.py(343):         for expr, is_ref in order_by:
0.78 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.78 compiler.py(345):             if self.query.combinator:
0.78 compiler.py(365):             sql, params = self.compile(resolved)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2093):             return {}
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.78 compiler.py(371):             params_hash = make_hashable(params)
0.78 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.78 compiler.py(374):             seen.add((without_ordering, params_hash))
0.78 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.78 compiler.py(343):         for expr, is_ref in order_by:
0.78 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.78 compiler.py(345):             if self.query.combinator:
0.78 compiler.py(365):             sql, params = self.compile(resolved)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.78 compiler.py(371):             params_hash = make_hashable(params)
0.78 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.78 compiler.py(374):             seen.add((without_ordering, params_hash))
0.78 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.78 compiler.py(343):         for expr, is_ref in order_by:
0.78 compiler.py(376):         return result
0.78 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.78 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.78 compiler.py(379):         extra_select = []
0.78 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.78 compiler.py(386):         return extra_select
0.78 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.78 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.78 compiler.py(97):         if self.query.group_by is None:
0.78 compiler.py(98):             return []
0.78 compiler.py(58):         return extra_select, order_by, group_by
0.78 compiler.py(481):             for_update_part = None
0.78 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.78 compiler.py(484):             combinator = self.query.combinator
0.78 compiler.py(485):             features = self.connection.features
0.78 compiler.py(486):             if combinator:
0.78 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.78 compiler.py(683):         result = []
0.78 compiler.py(684):         params = []
0.78 compiler.py(685):         opts = self.query.get_meta()
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(687):         for name in self.query.distinct_fields:
0.78 compiler.py(698):         return result, params
0.78 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.78 compiler.py(755):         result = []
0.78 compiler.py(756):         params = []
0.78 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.78 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.78 compiler.py(760):             try:
0.78 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.78 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(767):             result.append(clause_sql)
0.78 compiler.py(768):             params.extend(clause_params)
0.78 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.78 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.78 compiler.py(760):             try:
0.78 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.78 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(767):             result.append(clause_sql)
0.78 compiler.py(768):             params.extend(clause_params)
0.78 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.78 compiler.py(769):         for t in self.query.extra_tables:
0.78 compiler.py(776):         return result, params
0.78 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(395):             return self.quote_cache[name]
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.78 compiler.py(497):                 result = ['SELECT']
0.78 compiler.py(498):                 params = []
0.78 compiler.py(500):                 if self.query.distinct:
0.78 compiler.py(508):                 out_cols = []
0.78 compiler.py(509):                 col_idx = 1
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(513):                     elif with_col_aliases:
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(513):                     elif with_col_aliases:
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.78 compiler.py(520):                 params.extend(f_params)
0.78 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.78 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.78 compiler.py(552):                 if where:
0.78 compiler.py(553):                     result.append('WHERE %s' % where)
0.78 compiler.py(554):                     params.extend(w_params)
0.78 compiler.py(556):                 grouping = []
0.78 compiler.py(557):                 for g_sql, g_params in group_by:
0.78 compiler.py(560):                 if grouping:
0.78 compiler.py(577):                 if having:
0.78 compiler.py(581):             if self.query.explain_query:
0.78 compiler.py(587):             if order_by:
0.78 compiler.py(588):                 ordering = []
0.78 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.78 compiler.py(590):                     ordering.append(o_sql)
0.78 compiler.py(591):                     params.extend(o_params)
0.78 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.78 compiler.py(590):                     ordering.append(o_sql)
0.78 compiler.py(591):                     params.extend(o_params)
0.78 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.78 compiler.py(590):                     ordering.append(o_sql)
0.78 compiler.py(591):                     params.extend(o_params)
0.78 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.78 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.78 compiler.py(594):             if with_limit_offset:
0.78 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.78 compiler.py(600):             if self.query.subquery and extra_select:
0.78 compiler.py(627):             return ' '.join(result), tuple(params)
0.78 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.78 query.py(820):             self.unref_alias(alias, unref_amount)
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.78 query.py(820):             self.unref_alias(alias, unref_amount)
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 compiler.py(1083):             if not sql:
0.78 compiler.py(1090):         if chunked_fetch:
0.78 compiler.py(1093):             cursor = self.connection.cursor()
0.78 compiler.py(1094):         try:
0.78 compiler.py(1095):             cursor.execute(sql, params)
0.78 compiler.py(1101):         if result_type == CURSOR:
0.78 compiler.py(1104):         if result_type == SINGLE:
0.78 compiler.py(1113):         if result_type == NO_RESULTS:
0.78 compiler.py(1117):         result = cursor_iter(
0.78 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.78 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.78 compiler.py(1120):             chunk_size,
0.78 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.78 compiler.py(1123):             try:
0.78 compiler.py(1128):                 return list(result)
0.78 compiler.py(1518):     try:
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.78 compiler.py(1522):         cursor.close()
0.78 compiler.py(1131):                 cursor.close()
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.78 compiler.py(1049):         converters = self.get_converters(fields)
0.78 compiler.py(1023):         converters = {}
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1025):             if expression:
0.78 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.78 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.78 compiler.py(1028):                 if backend_converters or field_converters:
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1025):             if expression:
0.78 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.78 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.78 compiler.py(1028):                 if backend_converters or field_converters:
0.78 compiler.py(1024):         for i, expression in enumerate(expressions):
0.78 compiler.py(1030):         return converters
0.78 compiler.py(1050):         rows = chain.from_iterable(results)
0.78 compiler.py(1051):         if converters:
0.78 compiler.py(1055):         return rows
0.78 query.py(154):         self.model = model
0.78 query.py(155):         self.alias_refcount = {}
0.78 query.py(161):         self.alias_map = {}
0.78 query.py(165):         self.external_aliases = set()
0.78 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.78 query.py(167):         self.default_cols = True
0.78 query.py(168):         self.default_ordering = True
0.78 query.py(169):         self.standard_ordering = True
0.78 query.py(170):         self.used_aliases = set()
0.78 query.py(171):         self.filter_is_sticky = False
0.78 query.py(172):         self.subquery = False
0.78 query.py(180):         self.select = ()
0.78 query.py(181):         self.where = where()
0.78 query.py(182):         self.where_class = where
0.78 query.py(189):         self.group_by = None
0.78 query.py(190):         self.order_by = ()
0.78 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.78 query.py(192):         self.distinct = False
0.78 query.py(193):         self.distinct_fields = ()
0.78 query.py(194):         self.select_for_update = False
0.78 query.py(195):         self.select_for_update_nowait = False
0.78 query.py(196):         self.select_for_update_skip_locked = False
0.78 query.py(197):         self.select_for_update_of = ()
0.78 query.py(199):         self.select_related = False
0.78 query.py(201):         self.max_depth = 5
0.78 query.py(205):         self.values_select = ()
0.78 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.78 query.py(209):         self.annotation_select_mask = None
0.78 query.py(210):         self._annotation_select_cache = None
0.78 query.py(213):         self.combinator = None
0.78 query.py(214):         self.combinator_all = False
0.78 query.py(215):         self.combined_queries = ()
0.78 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.78 query.py(220):         self.extra_select_mask = None
0.78 query.py(221):         self._extra_select_cache = None
0.78 query.py(223):         self.extra_tables = ()
0.78 query.py(224):         self.extra_order_by = ()
0.78 query.py(229):         self.deferred_loading = (frozenset(), True)
0.78 query.py(231):         self._filtered_relations = {}
0.78 query.py(233):         self.explain_query = False
0.78 query.py(234):         self.explain_format = None
0.78 query.py(235):         self.explain_options = {}
0.78 query.py(343):         obj = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(344):         if klass and obj.__class__ != klass:
0.78 query.py(346):         if not obj.filter_is_sticky:
0.78 query.py(347):             obj.used_aliases = set()
0.78 query.py(348):         obj.filter_is_sticky = False
0.78 query.py(349):         if hasattr(obj, '_setup_query'):
0.78 query.py(351):         return obj
0.78 query.py(154):         self.model = model
0.78 query.py(155):         self.alias_refcount = {}
0.78 query.py(161):         self.alias_map = {}
0.78 query.py(165):         self.external_aliases = set()
0.78 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.78 query.py(167):         self.default_cols = True
0.78 query.py(168):         self.default_ordering = True
0.78 query.py(169):         self.standard_ordering = True
0.78 query.py(170):         self.used_aliases = set()
0.78 query.py(171):         self.filter_is_sticky = False
0.78 query.py(172):         self.subquery = False
0.78 query.py(180):         self.select = ()
0.78 query.py(181):         self.where = where()
0.78 query.py(182):         self.where_class = where
0.78 query.py(189):         self.group_by = None
0.78 query.py(190):         self.order_by = ()
0.78 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.78 query.py(192):         self.distinct = False
0.78 query.py(193):         self.distinct_fields = ()
0.78 query.py(194):         self.select_for_update = False
0.78 query.py(195):         self.select_for_update_nowait = False
0.78 query.py(196):         self.select_for_update_skip_locked = False
0.78 query.py(197):         self.select_for_update_of = ()
0.78 query.py(199):         self.select_related = False
0.78 query.py(201):         self.max_depth = 5
0.78 query.py(205):         self.values_select = ()
0.78 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.78 query.py(209):         self.annotation_select_mask = None
0.78 query.py(210):         self._annotation_select_cache = None
0.78 query.py(213):         self.combinator = None
0.78 query.py(214):         self.combinator_all = False
0.78 query.py(215):         self.combined_queries = ()
0.78 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.78 query.py(220):         self.extra_select_mask = None
0.78 query.py(221):         self._extra_select_cache = None
0.78 query.py(223):         self.extra_tables = ()
0.78 query.py(224):         self.extra_order_by = ()
0.78 query.py(229):         self.deferred_loading = (frozenset(), True)
0.78 query.py(231):         self._filtered_relations = {}
0.78 query.py(233):         self.explain_query = False
0.78 query.py(234):         self.explain_format = None
0.78 query.py(235):         self.explain_options = {}
0.78 query.py(278):         if using is None and connection is None:
0.78 query.py(280):         if using:
0.78 query.py(281):             connection = connections[using]
0.78 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.78 compiler.py(25):         self.query = query
0.78 compiler.py(26):         self.connection = connection
0.78 compiler.py(27):         self.using = using
0.78 compiler.py(28):         self.quote_cache = {'*': '*'}
0.78 compiler.py(33):         self.select = None
0.78 compiler.py(34):         self.annotation_col_map = None
0.78 compiler.py(35):         self.klass_info = None
0.78 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.78 compiler.py(38):         self._meta_ordering = None
0.78 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.78 compiler.py(1333):         self.return_id = return_id
0.78 compiler.py(1334):         with self.connection.cursor() as cursor:
0.78 compiler.py(1335):             for sql, params in self.as_sql():
0.78 compiler.py(1269):         qn = self.connection.ops.quote_name
0.78 compiler.py(1270):         opts = self.query.get_meta()
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.78 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.78 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.78 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.78 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.78 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.78 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.78 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.78 compiler.py(1276):         if self.query.fields:
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1279):                 for obj in self.query.objs
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1279):                 for obj in self.query.objs
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1279):                 for obj in self.query.objs
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1279):                 for obj in self.query.objs
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1279):                 for obj in self.query.objs
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1227):         if self.query.raw:
0.78 compiler.py(1229):         return field.pre_save(obj, add=True)
0.78 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.78 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.78 compiler.py(1220):         return value
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.78 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.78 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.78 compiler.py(1243):         if not value_rows:
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1250):             for row in value_rows
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1250):             for row in value_rows
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1250):             for row in value_rows
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1250):             for row in value_rows
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1250):             for row in value_rows
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1170):         if field is None:
0.78 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.78 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.78 compiler.py(1182):             sql, params = '%s', [val]
0.78 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.78 compiler.py(1191):         return sql, params
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.78 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.78 compiler.py(1264):         return placeholder_rows, param_rows
0.78 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.78 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.78 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.78 compiler.py(1315):         if can_bulk:
0.78 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.78 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.78 compiler.py(1336):                 cursor.execute(sql, params)
0.78 compiler.py(1335):             for sql, params in self.as_sql():
0.78 compiler.py(1337):             if not return_id:
0.78 compiler.py(1338):                 return
0.78 query.py(154):         self.model = model
0.78 query.py(155):         self.alias_refcount = {}
0.78 query.py(161):         self.alias_map = {}
0.78 query.py(165):         self.external_aliases = set()
0.78 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.78 query.py(167):         self.default_cols = True
0.78 query.py(168):         self.default_ordering = True
0.78 query.py(169):         self.standard_ordering = True
0.78 query.py(170):         self.used_aliases = set()
0.78 query.py(171):         self.filter_is_sticky = False
0.78 query.py(172):         self.subquery = False
0.78 query.py(180):         self.select = ()
0.78 query.py(181):         self.where = where()
0.78 query.py(182):         self.where_class = where
0.78 query.py(189):         self.group_by = None
0.78 query.py(190):         self.order_by = ()
0.78 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.78 query.py(192):         self.distinct = False
0.78 query.py(193):         self.distinct_fields = ()
0.78 query.py(194):         self.select_for_update = False
0.78 query.py(195):         self.select_for_update_nowait = False
0.78 query.py(196):         self.select_for_update_skip_locked = False
0.78 query.py(197):         self.select_for_update_of = ()
0.78 query.py(199):         self.select_related = False
0.78 query.py(201):         self.max_depth = 5
0.78 query.py(205):         self.values_select = ()
0.78 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.78 query.py(209):         self.annotation_select_mask = None
0.78 query.py(210):         self._annotation_select_cache = None
0.78 query.py(213):         self.combinator = None
0.78 query.py(214):         self.combinator_all = False
0.78 query.py(215):         self.combined_queries = ()
0.78 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.78 query.py(220):         self.extra_select_mask = None
0.78 query.py(221):         self._extra_select_cache = None
0.78 query.py(223):         self.extra_tables = ()
0.78 query.py(224):         self.extra_order_by = ()
0.78 query.py(229):         self.deferred_loading = (frozenset(), True)
0.78 query.py(231):         self._filtered_relations = {}
0.78 query.py(233):         self.explain_query = False
0.78 query.py(234):         self.explain_format = None
0.78 query.py(235):         self.explain_options = {}
0.78 query.py(343):         obj = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(344):         if klass and obj.__class__ != klass:
0.78 query.py(346):         if not obj.filter_is_sticky:
0.78 query.py(347):             obj.used_aliases = set()
0.78 query.py(348):         obj.filter_is_sticky = False
0.78 query.py(349):         if hasattr(obj, '_setup_query'):
0.78 query.py(351):         return obj
0.78 query.py(521):         q = self.clone()
0.78 query.py(297):         obj = Empty()
0.78 query.py(298):         obj.__class__ = self.__class__
0.78 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.78 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.78 query.py(303):         obj.alias_map = self.alias_map.copy()
0.78 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.78 query.py(305):         obj.table_map = self.table_map.copy()
0.78 query.py(306):         obj.where = self.where.clone()
0.78 query.py(307):         obj.annotations = self.annotations.copy()
0.78 query.py(308):         if self.annotation_select_mask is None:
0.78 query.py(309):             obj.annotation_select_mask = None
0.78 query.py(317):         obj._annotation_select_cache = None
0.78 query.py(318):         obj.extra = self.extra.copy()
0.78 query.py(319):         if self.extra_select_mask is None:
0.78 query.py(320):             obj.extra_select_mask = None
0.78 query.py(323):         if self._extra_select_cache is None:
0.78 query.py(324):             obj._extra_select_cache = None
0.78 query.py(327):         if 'subq_aliases' in self.__dict__:
0.78 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.78 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.78 query.py(332):         try:
0.78 query.py(333):             del obj.base_table
0.78 query.py(334):         except AttributeError:
0.78 query.py(335):             pass
0.78 query.py(336):         return obj
0.78 query.py(522):         if not q.distinct:
0.78 query.py(523):             if q.group_by is True:
0.78 query.py(526):             q.clear_select_clause()
0.78 query.py(1762):         self.select = ()
0.78 query.py(1763):         self.default_cols = False
0.78 query.py(1764):         self.select_related = False
0.78 query.py(1765):         self.set_extra_mask(())
0.78 query.py(2028):         if names is None:
0.78 query.py(2031):             self.extra_select_mask = set(names)
0.78 query.py(2032):         self._extra_select_cache = None
0.78 query.py(1766):         self.set_annotation_mask(())
0.78 query.py(2013):         if names is None:
0.78 query.py(2016):             self.annotation_select_mask = set(names)
0.78 query.py(2017):         self._annotation_select_cache = None
0.78 query.py(527):         q.clear_ordering(True)
0.78 query.py(1860):         self.order_by = ()
0.78 query.py(1861):         self.extra_order_by = ()
0.78 query.py(1862):         if force_empty:
0.78 query.py(1863):             self.default_ordering = False
0.78 query.py(528):         q.set_limits(high=1)
0.78 query.py(1731):         if high is not None:
0.78 query.py(1732):             if self.high_mark is not None:
0.78 query.py(1735):                 self.high_mark = self.low_mark + high
0.78 query.py(1736):         if low is not None:
0.78 query.py(1742):         if self.low_mark == self.high_mark:
0.78 query.py(529):         compiler = q.get_compiler(using=using)
0.78 query.py(278):         if using is None and connection is None:
0.78 query.py(280):         if using:
0.78 query.py(281):             connection = connections[using]
0.78 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.78 compiler.py(25):         self.query = query
0.78 compiler.py(26):         self.connection = connection
0.78 compiler.py(27):         self.using = using
0.78 compiler.py(28):         self.quote_cache = {'*': '*'}
0.78 compiler.py(33):         self.select = None
0.78 compiler.py(34):         self.annotation_col_map = None
0.78 compiler.py(35):         self.klass_info = None
0.78 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.78 compiler.py(38):         self._meta_ordering = None
0.78 query.py(530):         return compiler.has_results()
0.78 compiler.py(1063):         self.query.add_extra({'a': 1}, None, None, None, None, None)
0.78 query.py(1913):         if select:
0.78 query.py(1918):             select_pairs = {}
0.78 query.py(1919):             if select_params:
0.78 query.py(1922):                 param_iter = iter([])
0.78 query.py(1923):             for name, entry in select.items():
0.78 query.py(1924):                 entry = str(entry)
0.78 query.py(1925):                 entry_params = []
0.78 query.py(1926):                 pos = entry.find("%s")
0.78 query.py(1927):                 while pos != -1:
0.78 query.py(1931):                 select_pairs[name] = (entry, entry_params)
0.78 query.py(1923):             for name, entry in select.items():
0.78 query.py(1932):             self.extra.update(select_pairs)
0.78 query.py(1933):         if where or params:
0.78 query.py(1935):         if tables:
0.78 query.py(1937):         if order_by:
0.78 compiler.py(1064):         self.query.set_extra_mask(['a'])
0.78 query.py(2028):         if names is None:
0.78 query.py(2031):             self.extra_select_mask = set(names)
0.78 query.py(2032):         self._extra_select_cache = None
0.78 compiler.py(1065):         return bool(self.execute_sql(SINGLE))
0.78 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.78 compiler.py(1081):         try:
0.78 compiler.py(1082):             sql, params = self.as_sql()
0.78 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.78 compiler.py(479):         try:
0.78 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.78 compiler.py(52):         self.setup_query()
0.78 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.78 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.78 compiler.py(42):             self.query.get_initial_alias()
0.78 query.py(912):         if self.alias_map:
0.78 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.78 query.py(290):         return self.model._meta
0.78 query.py(943):         if reuse_with_filtered_relation and reuse:
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(950):                 a for a, j in self.alias_map.items()
0.78 query.py(953):         if reuse_aliases:
0.78 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.78 query.py(735):         alias_list = self.table_map.get(table_name)
0.78 query.py(736):         if not create and alias_list:
0.78 query.py(742):         if alias_list:
0.78 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.78 query.py(748):             self.table_map[table_name] = [alias]
0.78 query.py(749):         self.alias_refcount[alias] = 1
0.78 query.py(750):         return alias, True
0.78 query.py(965):         if join.join_type:
0.78 query.py(971):         join.table_alias = alias
0.78 query.py(972):         self.alias_map[alias] = join
0.78 query.py(973):         return alias
0.78 query.py(917):         return alias
0.78 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.78 compiler.py(202):         select = []
0.78 compiler.py(203):         klass_info = None
0.78 compiler.py(204):         annotations = {}
0.78 compiler.py(205):         select_idx = 0
0.78 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2092):         if not self.extra:
0.78 query.py(2094):         elif self.extra_select_mask is not None:
0.78 query.py(2095):             self._extra_select_cache = {
0.78 query.py(2096):                 k: v for k, v in self.extra.items()
0.78 query.py(2095):             self._extra_select_cache = {
0.78 query.py(2096):                 k: v for k, v in self.extra.items()
0.78 query.py(2097):                 if k in self.extra_select_mask
0.78 query.py(2095):             self._extra_select_cache = {
0.78 query.py(2099):             return self._extra_select_cache
0.78 compiler.py(207):             annotations[alias] = select_idx
0.78 compiler.py(208):             select.append((RawSQL(sql, params), alias))
0.78 compiler.py(209):             select_idx += 1
0.78 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.78 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.78 compiler.py(211):         if self.query.default_cols:
0.78 compiler.py(216):             cols = self.query.select
0.78 compiler.py(217):         if cols:
0.78 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.78 query.py(2075):         if self._annotation_select_cache is not None:
0.78 query.py(2077):         elif not self.annotations:
0.78 query.py(2078):             return {}
0.78 compiler.py(232):         if self.query.select_related:
0.78 compiler.py(244):         ret = []
0.78 compiler.py(245):         for col, alias in select:
0.78 compiler.py(246):             try:
0.78 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.78 compiler.py(251):             ret.append((col, (sql, params), alias))
0.78 compiler.py(245):         for col, alias in select:
0.78 compiler.py(252):         return ret, klass_info, annotations
0.78 compiler.py(44):         self.col_count = len(self.select)
0.78 compiler.py(53):         order_by = self.get_order_by()
0.78 compiler.py(263):         if self.query.extra_order_by:
0.78 compiler.py(265):         elif not self.query.default_ordering:
0.78 compiler.py(266):             ordering = self.query.order_by
0.78 compiler.py(274):         if self.query.standard_ordering:
0.78 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.78 compiler.py(279):         order_by = []
0.78 compiler.py(280):         for field in ordering:
0.78 compiler.py(340):         result = []
0.78 compiler.py(341):         seen = set()
0.78 compiler.py(343):         for expr, is_ref in order_by:
0.78 compiler.py(376):         return result
0.78 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.78 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.78 compiler.py(379):         extra_select = []
0.78 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.78 compiler.py(386):         return extra_select
0.78 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.78 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.78 compiler.py(97):         if self.query.group_by is None:
0.78 compiler.py(98):             return []
0.78 compiler.py(58):         return extra_select, order_by, group_by
0.78 compiler.py(481):             for_update_part = None
0.78 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.78 compiler.py(484):             combinator = self.query.combinator
0.78 compiler.py(485):             features = self.connection.features
0.78 compiler.py(486):             if combinator:
0.78 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.78 compiler.py(683):         result = []
0.78 compiler.py(684):         params = []
0.78 compiler.py(685):         opts = self.query.get_meta()
0.78 query.py(290):         return self.model._meta
0.78 compiler.py(687):         for name in self.query.distinct_fields:
0.78 compiler.py(698):         return result, params
0.78 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.78 compiler.py(755):         result = []
0.78 compiler.py(756):         params = []
0.78 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.78 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.78 compiler.py(760):             try:
0.78 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.78 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(394):         if name in self.quote_cache:
0.78 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.78 compiler.py(397):                 name in self.query.extra_select or (
0.78 query.py(2090):         if self._extra_select_cache is not None:
0.78 query.py(2091):             return self._extra_select_cache
0.78 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.78 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.78 compiler.py(402):         self.quote_cache[name] = r
0.78 compiler.py(403):         return r
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(767):             result.append(clause_sql)
0.78 compiler.py(768):             params.extend(clause_params)
0.78 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.78 compiler.py(769):         for t in self.query.extra_tables:
0.78 compiler.py(776):         return result, params
0.78 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.78 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.78 compiler.py(407):         if vendor_impl:
0.78 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.78 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.78 compiler.py(413):         return sql, params
0.78 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.78 compiler.py(497):                 result = ['SELECT']
0.78 compiler.py(498):                 params = []
0.78 compiler.py(500):                 if self.query.distinct:
0.78 compiler.py(508):                 out_cols = []
0.78 compiler.py(509):                 col_idx = 1
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(511):                     if alias:
0.78 compiler.py(512):                         s_sql = '%s AS %s' % (s_sql, self.connection.ops.quote_name(alias))
0.78 compiler.py(516):                     params.extend(s_params)
0.78 compiler.py(517):                     out_cols.append(s_sql)
0.78 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.78 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.78 compiler.py(520):                 params.extend(f_params)
0.78 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.78 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.78 compiler.py(552):                 if where:
0.78 compiler.py(556):                 grouping = []
0.78 compiler.py(557):                 for g_sql, g_params in group_by:
0.78 compiler.py(560):                 if grouping:
0.78 compiler.py(577):                 if having:
0.78 compiler.py(581):             if self.query.explain_query:
0.78 compiler.py(587):             if order_by:
0.78 compiler.py(594):             if with_limit_offset:
0.78 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.78 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.78 compiler.py(600):             if self.query.subquery and extra_select:
0.78 compiler.py(627):             return ' '.join(result), tuple(params)
0.78 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.78 query.py(820):             self.unref_alias(alias, unref_amount)
0.78 query.py(758):         self.alias_refcount[alias] -= amount
0.78 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.78 compiler.py(1083):             if not sql:
0.78 compiler.py(1090):         if chunked_fetch:
0.78 compiler.py(1093):             cursor = self.connection.cursor()
0.78 compiler.py(1094):         try:
0.78 compiler.py(1095):             cursor.execute(sql, params)
0.78 compiler.py(1101):         if result_type == CURSOR:
0.78 compiler.py(1104):         if result_type == SINGLE:
0.78 compiler.py(1105):             try:
0.78 compiler.py(1106):                 val = cursor.fetchone()
0.78 compiler.py(1107):                 if val:
0.78 compiler.py(1109):                 return val
0.78 compiler.py(1112):                 cursor.close()
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1758):         return not self.low_mark and self.high_mark is None
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.79 query.py(1331):         connector = q_object.connector
0.79 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.79 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.79 query.py(1334):         target_clause = self.where_class(connector=connector,
0.79 query.py(1335):                                          negated=q_object.negated)
0.79 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.79 query.py(2236):         self.connector = connector
0.79 query.py(2237):         self.negated = negated
0.79 query.py(2238):         if self.negated:
0.79 query.py(2244):             self.effective_connector = self.connector
0.79 query.py(2245):         self.num_children = num_children
0.79 query.py(2248):         self.votes = Counter()
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1338):             if isinstance(child, Node):
0.79 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.79 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.79 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.79 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.79 query.py(1214):         if isinstance(filter_expr, dict):
0.79 query.py(1216):         arg, value = filter_expr
0.79 query.py(1217):         if not arg:
0.79 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.79 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.79 query.py(1074):         if self.annotations:
0.79 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.79 query.py(290):         return self.model._meta
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1409):                 name = opts.pk.name
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.79 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.79 query.py(1085):         return lookup_parts, field_parts, False
0.79 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.79 query.py(1227):         if not allow_joins and len(parts) > 1:
0.79 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.79 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.79 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.79 query.py(1055):         elif isinstance(value, (list, tuple)):
0.79 query.py(1067):         return value
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1234):         clause = self.where_class()
0.79 query.py(1235):         if reffed_expression:
0.79 query.py(1240):         opts = self.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 query.py(1241):         alias = self.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.79 query.py(290):         return self.model._meta
0.79 query.py(943):         if reuse_with_filtered_relation and reuse:
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(953):         if reuse_aliases:
0.79 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.79 query.py(735):         alias_list = self.table_map.get(table_name)
0.79 query.py(736):         if not create and alias_list:
0.79 query.py(742):         if alias_list:
0.79 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.79 query.py(748):             self.table_map[table_name] = [alias]
0.79 query.py(749):         self.alias_refcount[alias] = 1
0.79 query.py(750):         return alias, True
0.79 query.py(965):         if join.join_type:
0.79 query.py(971):         join.table_alias = alias
0.79 query.py(972):         self.alias_map[alias] = join
0.79 query.py(973):         return alias
0.79 query.py(917):         return alias
0.79 query.py(1242):         allow_many = not branch_negated or not split_subq
0.79 query.py(1244):         try:
0.79 query.py(1245):             join_info = self.setup_joins(
0.79 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.79 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.79 query.py(1518):         joins = [alias]
0.79 query.py(1524):         def final_transformer(field, alias):
0.79 query.py(1529):         last_field_exception = None
0.79 query.py(1530):         for pivot in range(len(names), 0, -1):
0.79 query.py(1531):             try:
0.79 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.79 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1409):                 name = opts.pk.name
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1545):                 transforms = names[pivot:]
0.79 query.py(1546):                 break
0.79 query.py(1547):         for name in transforms:
0.79 query.py(1562):         for join in path:
0.79 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.79 query.py(1251):             if isinstance(value, Iterator):
0.79 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.79 query.py(1100):         if field.is_relation:
0.79 query.py(1257):             self._lookup_joins = join_info.joins
0.79 query.py(1263):         used_joins.update(join_info.joins)
0.79 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.79 query.py(1601):         joins = joins[:]
0.79 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.79 query.py(1614):         return targets, joins[-1], joins
0.79 query.py(1265):         if can_reuse is not None:
0.79 query.py(1266):             can_reuse.update(join_list)
0.79 query.py(1268):         if join_info.final_field.is_relation:
0.79 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.79 query.py(72):     if simple_col:
0.79 query.py(74):     return target.get_col(alias, field)
0.79 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.79 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.79 query.py(1129):         for name in transforms:
0.79 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.79 query.py(1134):         if not lookup_class:
0.79 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.79 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.79 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.79 query.py(1161):         return lookup
0.79 query.py(1281):         lookup_type = condition.lookup_name
0.79 query.py(1282):         clause.add(condition, AND)
0.79 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.79 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.79 query.py(1302):         return clause, used_joins if not require_outer else ()
0.79 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.79 query.py(2255):         self.votes.update(votes)
0.79 query.py(1350):             if child_clause:
0.79 query.py(1351):                 target_clause.add(child_clause, connector)
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.79 query.py(2264):         to_promote = set()
0.79 query.py(2265):         to_demote = set()
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.79 query.py(2291):             if self.effective_connector == 'AND' or (
0.79 query.py(2293):                 to_demote.add(table)
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2309):         query.promote_joins(to_promote)
0.79 query.py(771):         aliases = list(aliases)
0.79 query.py(772):         while aliases:
0.79 query.py(2310):         query.demote_joins(to_demote)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(806):             alias = aliases.pop(0)
0.79 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.79 query.py(805):         while aliases:
0.79 query.py(2311):         return to_demote
0.79 query.py(1353):         return target_clause, needed_inner
0.79 query.py(1320):         if clause:
0.79 query.py(1321):             self.where.add(clause, AND)
0.79 query.py(1322):         self.demote_joins(existing_inner)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(1758):         return not self.low_mark and self.high_mark is None
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(345):             obj.__class__ = klass
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(350):             obj._setup_query()
0.79 query.py(351):         return obj
0.79 query.py(278):         if using is None and connection is None:
0.79 query.py(280):         if using:
0.79 query.py(281):             connection = connections[using]
0.79 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.79 compiler.py(25):         self.query = query
0.79 compiler.py(26):         self.connection = connection
0.79 compiler.py(27):         self.using = using
0.79 compiler.py(28):         self.quote_cache = {'*': '*'}
0.79 compiler.py(33):         self.select = None
0.79 compiler.py(34):         self.annotation_col_map = None
0.79 compiler.py(35):         self.klass_info = None
0.79 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.79 compiler.py(38):         self._meta_ordering = None
0.79 compiler.py(1436):         cursor = super().execute_sql(result_type)
0.79 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.79 compiler.py(1081):         try:
0.79 compiler.py(1082):             sql, params = self.as_sql()
0.79 compiler.py(1371):         self.pre_sql_setup()
0.79 compiler.py(1459):         refcounts_before = self.query.alias_refcount.copy()
0.79 compiler.py(1461):         self.query.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(913):             alias = self.base_table
0.79 query.py(250):         for alias in self.alias_map:
0.79 query.py(251):             return alias
0.79 query.py(914):             self.ref_alias(alias)
0.79 query.py(754):         self.alias_refcount[alias] += 1
0.79 query.py(917):         return alias
0.79 compiler.py(1462):         count = self.query.count_active_tables()
0.79 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.79 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.79 query.py(925):         return len([1 for count in self.alias_refcount.values() if count])
0.79 compiler.py(1463):         if not self.query.related_updates and count == 1:
0.79 compiler.py(1464):             return
0.79 compiler.py(1372):         if not self.query.values:
0.79 compiler.py(1374):         qn = self.quote_name_unless_alias
0.79 compiler.py(1375):         values, update_params = [], []
0.79 compiler.py(1376):         for field, model, val in self.query.values:
0.79 compiler.py(1377):             if hasattr(val, 'resolve_expression'):
0.79 compiler.py(1389):             elif hasattr(val, 'prepare_database_save'):
0.79 compiler.py(1402):                 val = field.get_db_prep_save(val, connection=self.connection)
0.79 compiler.py(1405):             if hasattr(field, 'get_placeholder'):
0.79 compiler.py(1408):                 placeholder = '%s'
0.79 compiler.py(1409):             name = field.column
0.79 compiler.py(1410):             if hasattr(val, 'as_sql'):
0.79 compiler.py(1414):             elif val is not None:
0.79 compiler.py(1415):                 values.append('%s = %s' % (qn(name), placeholder))
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(1416):                 update_params.append(val)
0.79 compiler.py(1376):         for field, model, val in self.query.values:
0.79 compiler.py(1377):             if hasattr(val, 'resolve_expression'):
0.79 compiler.py(1389):             elif hasattr(val, 'prepare_database_save'):
0.79 compiler.py(1402):                 val = field.get_db_prep_save(val, connection=self.connection)
0.79 compiler.py(1405):             if hasattr(field, 'get_placeholder'):
0.79 compiler.py(1408):                 placeholder = '%s'
0.79 compiler.py(1409):             name = field.column
0.79 compiler.py(1410):             if hasattr(val, 'as_sql'):
0.79 compiler.py(1414):             elif val is not None:
0.79 compiler.py(1415):                 values.append('%s = %s' % (qn(name), placeholder))
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(1416):                 update_params.append(val)
0.79 compiler.py(1376):         for field, model, val in self.query.values:
0.79 compiler.py(1419):         table = self.query.base_table
0.79 compiler.py(1421):             'UPDATE %s SET' % qn(table),
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(1422):             ', '.join(values),
0.79 compiler.py(1424):         where, params = self.compile(self.query.where)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(1425):         if where:
0.79 compiler.py(1426):             result.append('WHERE %s' % where)
0.79 compiler.py(1427):         return ' '.join(result), tuple(update_params + params)
0.79 compiler.py(1083):             if not sql:
0.79 compiler.py(1090):         if chunked_fetch:
0.79 compiler.py(1093):             cursor = self.connection.cursor()
0.79 compiler.py(1094):         try:
0.79 compiler.py(1095):             cursor.execute(sql, params)
0.79 compiler.py(1101):         if result_type == CURSOR:
0.79 compiler.py(1103):             return cursor
0.79 compiler.py(1437):         try:
0.79 compiler.py(1438):             rows = cursor.rowcount if cursor else 0
0.79 compiler.py(1439):             is_empty = cursor is None
0.79 compiler.py(1441):             if cursor:
0.79 compiler.py(1442):                 cursor.close()
0.79 compiler.py(1443):         for query in self.query.get_related_updates():
0.79 compiler.py(1448):         return rows
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(278):         if using is None and connection is None:
0.79 query.py(280):         if using:
0.79 query.py(281):             connection = connections[using]
0.79 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.79 compiler.py(25):         self.query = query
0.79 compiler.py(26):         self.connection = connection
0.79 compiler.py(27):         self.using = using
0.79 compiler.py(28):         self.quote_cache = {'*': '*'}
0.79 compiler.py(33):         self.select = None
0.79 compiler.py(34):         self.annotation_col_map = None
0.79 compiler.py(35):         self.klass_info = None
0.79 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.79 compiler.py(38):         self._meta_ordering = None
0.79 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.79 compiler.py(1333):         self.return_id = return_id
0.79 compiler.py(1334):         with self.connection.cursor() as cursor:
0.79 compiler.py(1335):             for sql, params in self.as_sql():
0.79 compiler.py(1269):         qn = self.connection.ops.quote_name
0.79 compiler.py(1270):         opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.79 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.79 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1276):         if self.query.fields:
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1279):                 for obj in self.query.objs
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1279):                 for obj in self.query.objs
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1227):         if self.query.raw:
0.79 compiler.py(1229):         return field.pre_save(obj, add=True)
0.79 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.79 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.79 compiler.py(1220):         return value
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1227):         if self.query.raw:
0.79 compiler.py(1229):         return field.pre_save(obj, add=True)
0.79 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.79 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.79 compiler.py(1220):         return value
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1227):         if self.query.raw:
0.79 compiler.py(1229):         return field.pre_save(obj, add=True)
0.79 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.79 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.79 compiler.py(1220):         return value
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.79 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.79 compiler.py(1243):         if not value_rows:
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1250):             for row in value_rows
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1250):             for row in value_rows
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1170):         if field is None:
0.79 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.79 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.79 compiler.py(1182):             sql, params = '%s', [val]
0.79 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.79 compiler.py(1191):         return sql, params
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1170):         if field is None:
0.79 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.79 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.79 compiler.py(1182):             sql, params = '%s', [val]
0.79 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.79 compiler.py(1191):         return sql, params
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1170):         if field is None:
0.79 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.79 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.79 compiler.py(1182):             sql, params = '%s', [val]
0.79 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.79 compiler.py(1191):         return sql, params
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1264):         return placeholder_rows, param_rows
0.79 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.79 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.79 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.79 compiler.py(1315):         if can_bulk:
0.79 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.79 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1336):                 cursor.execute(sql, params)
0.79 compiler.py(1335):             for sql, params in self.as_sql():
0.79 compiler.py(1337):             if not return_id:
0.79 compiler.py(1338):                 return
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1758):         return not self.low_mark and self.high_mark is None
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.79 query.py(1331):         connector = q_object.connector
0.79 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.79 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.79 query.py(1334):         target_clause = self.where_class(connector=connector,
0.79 query.py(1335):                                          negated=q_object.negated)
0.79 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.79 query.py(2236):         self.connector = connector
0.79 query.py(2237):         self.negated = negated
0.79 query.py(2238):         if self.negated:
0.79 query.py(2244):             self.effective_connector = self.connector
0.79 query.py(2245):         self.num_children = num_children
0.79 query.py(2248):         self.votes = Counter()
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1338):             if isinstance(child, Node):
0.79 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.79 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.79 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.79 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.79 query.py(1214):         if isinstance(filter_expr, dict):
0.79 query.py(1216):         arg, value = filter_expr
0.79 query.py(1217):         if not arg:
0.79 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.79 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.79 query.py(1074):         if self.annotations:
0.79 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.79 query.py(290):         return self.model._meta
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.79 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.79 query.py(1085):         return lookup_parts, field_parts, False
0.79 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.79 query.py(1227):         if not allow_joins and len(parts) > 1:
0.79 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.79 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.79 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.79 query.py(1055):         elif isinstance(value, (list, tuple)):
0.79 query.py(1067):         return value
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1234):         clause = self.where_class()
0.79 query.py(1235):         if reffed_expression:
0.79 query.py(1240):         opts = self.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 query.py(1241):         alias = self.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.79 query.py(290):         return self.model._meta
0.79 query.py(943):         if reuse_with_filtered_relation and reuse:
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(953):         if reuse_aliases:
0.79 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.79 query.py(735):         alias_list = self.table_map.get(table_name)
0.79 query.py(736):         if not create and alias_list:
0.79 query.py(742):         if alias_list:
0.79 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.79 query.py(748):             self.table_map[table_name] = [alias]
0.79 query.py(749):         self.alias_refcount[alias] = 1
0.79 query.py(750):         return alias, True
0.79 query.py(965):         if join.join_type:
0.79 query.py(971):         join.table_alias = alias
0.79 query.py(972):         self.alias_map[alias] = join
0.79 query.py(973):         return alias
0.79 query.py(917):         return alias
0.79 query.py(1242):         allow_many = not branch_negated or not split_subq
0.79 query.py(1244):         try:
0.79 query.py(1245):             join_info = self.setup_joins(
0.79 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.79 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.79 query.py(1518):         joins = [alias]
0.79 query.py(1524):         def final_transformer(field, alias):
0.79 query.py(1529):         last_field_exception = None
0.79 query.py(1530):         for pivot in range(len(names), 0, -1):
0.79 query.py(1531):             try:
0.79 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.79 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1545):                 transforms = names[pivot:]
0.79 query.py(1546):                 break
0.79 query.py(1547):         for name in transforms:
0.79 query.py(1562):         for join in path:
0.79 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.79 query.py(1251):             if isinstance(value, Iterator):
0.79 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.79 query.py(1100):         if field.is_relation:
0.79 query.py(1257):             self._lookup_joins = join_info.joins
0.79 query.py(1263):         used_joins.update(join_info.joins)
0.79 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.79 query.py(1601):         joins = joins[:]
0.79 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.79 query.py(1614):         return targets, joins[-1], joins
0.79 query.py(1265):         if can_reuse is not None:
0.79 query.py(1266):             can_reuse.update(join_list)
0.79 query.py(1268):         if join_info.final_field.is_relation:
0.79 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.79 query.py(72):     if simple_col:
0.79 query.py(74):     return target.get_col(alias, field)
0.79 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.79 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.79 query.py(1129):         for name in transforms:
0.79 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.79 query.py(1134):         if not lookup_class:
0.79 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.79 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.79 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.79 query.py(1161):         return lookup
0.79 query.py(1281):         lookup_type = condition.lookup_name
0.79 query.py(1282):         clause.add(condition, AND)
0.79 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.79 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.79 query.py(1302):         return clause, used_joins if not require_outer else ()
0.79 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.79 query.py(2255):         self.votes.update(votes)
0.79 query.py(1350):             if child_clause:
0.79 query.py(1351):                 target_clause.add(child_clause, connector)
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.79 query.py(2264):         to_promote = set()
0.79 query.py(2265):         to_demote = set()
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.79 query.py(2291):             if self.effective_connector == 'AND' or (
0.79 query.py(2293):                 to_demote.add(table)
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2309):         query.promote_joins(to_promote)
0.79 query.py(771):         aliases = list(aliases)
0.79 query.py(772):         while aliases:
0.79 query.py(2310):         query.demote_joins(to_demote)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(806):             alias = aliases.pop(0)
0.79 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.79 query.py(805):         while aliases:
0.79 query.py(2311):         return to_demote
0.79 query.py(1353):         return target_clause, needed_inner
0.79 query.py(1320):         if clause:
0.79 query.py(1321):             self.where.add(clause, AND)
0.79 query.py(1322):         self.demote_joins(existing_inner)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(278):         if using is None and connection is None:
0.79 query.py(280):         if using:
0.79 query.py(281):             connection = connections[using]
0.79 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.79 compiler.py(25):         self.query = query
0.79 compiler.py(26):         self.connection = connection
0.79 compiler.py(27):         self.using = using
0.79 compiler.py(28):         self.quote_cache = {'*': '*'}
0.79 compiler.py(33):         self.select = None
0.79 compiler.py(34):         self.annotation_col_map = None
0.79 compiler.py(35):         self.klass_info = None
0.79 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.79 compiler.py(38):         self._meta_ordering = None
0.79 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.79 compiler.py(1081):         try:
0.79 compiler.py(1082):             sql, params = self.as_sql()
0.79 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.79 compiler.py(479):         try:
0.79 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.79 compiler.py(52):         self.setup_query()
0.79 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.79 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.79 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.79 compiler.py(202):         select = []
0.79 compiler.py(203):         klass_info = None
0.79 compiler.py(204):         annotations = {}
0.79 compiler.py(205):         select_idx = 0
0.79 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.79 compiler.py(211):         if self.query.default_cols:
0.79 compiler.py(212):             cols = self.get_default_columns()
0.79 compiler.py(644):         result = []
0.79 compiler.py(645):         if opts is None:
0.79 compiler.py(646):             opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(647):         only_load = self.deferred_to_columns()
0.79 compiler.py(1018):         columns = {}
0.79 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.79 query.py(655):         field_names, defer = self.deferred_loading
0.79 query.py(656):         if not field_names:
0.79 query.py(657):             return
0.79 compiler.py(1020):         return columns
0.79 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(913):             alias = self.base_table
0.79 query.py(250):         for alias in self.alias_map:
0.79 query.py(251):             return alias
0.79 query.py(914):             self.ref_alias(alias)
0.79 query.py(754):         self.alias_refcount[alias] += 1
0.79 query.py(917):         return alias
0.79 compiler.py(652):         seen_models = {None: start_alias}
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(674):         return result
0.79 compiler.py(217):         if cols:
0.79 compiler.py(218):             select_list = []
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(224):                 'model': self.query.model,
0.79 compiler.py(225):                 'select_fields': select_list,
0.79 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.79 query.py(2075):         if self._annotation_select_cache is not None:
0.79 query.py(2077):         elif not self.annotations:
0.79 query.py(2078):             return {}
0.79 compiler.py(232):         if self.query.select_related:
0.79 compiler.py(244):         ret = []
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(252):         return ret, klass_info, annotations
0.79 compiler.py(44):         self.col_count = len(self.select)
0.79 compiler.py(53):         order_by = self.get_order_by()
0.79 compiler.py(263):         if self.query.extra_order_by:
0.79 compiler.py(265):         elif not self.query.default_ordering:
0.79 compiler.py(267):         elif self.query.order_by:
0.79 compiler.py(269):         elif self.query.get_meta().ordering:
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(273):             ordering = []
0.79 compiler.py(274):         if self.query.standard_ordering:
0.79 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.79 compiler.py(279):         order_by = []
0.79 compiler.py(280):         for field in ordering:
0.79 compiler.py(340):         result = []
0.79 compiler.py(341):         seen = set()
0.79 compiler.py(343):         for expr, is_ref in order_by:
0.79 compiler.py(376):         return result
0.79 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.79 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.79 compiler.py(379):         extra_select = []
0.79 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.79 compiler.py(386):         return extra_select
0.79 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.79 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.79 compiler.py(97):         if self.query.group_by is None:
0.79 compiler.py(98):             return []
0.79 compiler.py(58):         return extra_select, order_by, group_by
0.79 compiler.py(481):             for_update_part = None
0.79 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.79 compiler.py(484):             combinator = self.query.combinator
0.79 compiler.py(485):             features = self.connection.features
0.79 compiler.py(486):             if combinator:
0.79 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.79 compiler.py(683):         result = []
0.79 compiler.py(684):         params = []
0.79 compiler.py(685):         opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(687):         for name in self.query.distinct_fields:
0.79 compiler.py(698):         return result, params
0.79 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.79 compiler.py(755):         result = []
0.79 compiler.py(756):         params = []
0.79 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.79 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.79 compiler.py(760):             try:
0.79 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.79 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(767):             result.append(clause_sql)
0.79 compiler.py(768):             params.extend(clause_params)
0.79 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.79 compiler.py(769):         for t in self.query.extra_tables:
0.79 compiler.py(776):         return result, params
0.79 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.79 compiler.py(497):                 result = ['SELECT']
0.79 compiler.py(498):                 params = []
0.79 compiler.py(500):                 if self.query.distinct:
0.79 compiler.py(508):                 out_cols = []
0.79 compiler.py(509):                 col_idx = 1
0.79 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.79 compiler.py(511):                     if alias:
0.79 compiler.py(513):                     elif with_col_aliases:
0.79 compiler.py(516):                     params.extend(s_params)
0.79 compiler.py(517):                     out_cols.append(s_sql)
0.79 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.79 compiler.py(511):                     if alias:
0.79 compiler.py(513):                     elif with_col_aliases:
0.79 compiler.py(516):                     params.extend(s_params)
0.79 compiler.py(517):                     out_cols.append(s_sql)
0.79 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.79 compiler.py(511):                     if alias:
0.79 compiler.py(513):                     elif with_col_aliases:
0.79 compiler.py(516):                     params.extend(s_params)
0.79 compiler.py(517):                     out_cols.append(s_sql)
0.79 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.79 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.79 compiler.py(520):                 params.extend(f_params)
0.79 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.79 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.79 compiler.py(552):                 if where:
0.79 compiler.py(553):                     result.append('WHERE %s' % where)
0.79 compiler.py(554):                     params.extend(w_params)
0.79 compiler.py(556):                 grouping = []
0.79 compiler.py(557):                 for g_sql, g_params in group_by:
0.79 compiler.py(560):                 if grouping:
0.79 compiler.py(577):                 if having:
0.79 compiler.py(581):             if self.query.explain_query:
0.79 compiler.py(587):             if order_by:
0.79 compiler.py(594):             if with_limit_offset:
0.79 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.79 compiler.py(600):             if self.query.subquery and extra_select:
0.79 compiler.py(627):             return ' '.join(result), tuple(params)
0.79 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.79 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.79 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.79 query.py(820):             self.unref_alias(alias, unref_amount)
0.79 query.py(758):         self.alias_refcount[alias] -= amount
0.79 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.79 compiler.py(1083):             if not sql:
0.79 compiler.py(1090):         if chunked_fetch:
0.79 compiler.py(1093):             cursor = self.connection.cursor()
0.79 compiler.py(1094):         try:
0.79 compiler.py(1095):             cursor.execute(sql, params)
0.79 compiler.py(1101):         if result_type == CURSOR:
0.79 compiler.py(1104):         if result_type == SINGLE:
0.79 compiler.py(1113):         if result_type == NO_RESULTS:
0.79 compiler.py(1117):         result = cursor_iter(
0.79 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.79 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.79 compiler.py(1120):             chunk_size,
0.79 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.79 compiler.py(1123):             try:
0.79 compiler.py(1128):                 return list(result)
0.79 compiler.py(1518):     try:
0.79 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.79 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.79 compiler.py(1522):         cursor.close()
0.79 compiler.py(1131):                 cursor.close()
0.79 compiler.py(1046):         if results is None:
0.79 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.79 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.79 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.79 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.79 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.79 compiler.py(1049):         converters = self.get_converters(fields)
0.79 compiler.py(1023):         converters = {}
0.79 compiler.py(1024):         for i, expression in enumerate(expressions):
0.79 compiler.py(1025):             if expression:
0.79 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.79 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.79 compiler.py(1028):                 if backend_converters or field_converters:
0.79 compiler.py(1024):         for i, expression in enumerate(expressions):
0.79 compiler.py(1025):             if expression:
0.79 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.79 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.79 compiler.py(1028):                 if backend_converters or field_converters:
0.79 compiler.py(1024):         for i, expression in enumerate(expressions):
0.79 compiler.py(1025):             if expression:
0.79 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.79 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.79 compiler.py(1028):                 if backend_converters or field_converters:
0.79 compiler.py(1024):         for i, expression in enumerate(expressions):
0.79 compiler.py(1030):         return converters
0.79 compiler.py(1050):         rows = chain.from_iterable(results)
0.79 compiler.py(1051):         if converters:
0.79 compiler.py(1055):         return rows
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(278):         if using is None and connection is None:
0.79 query.py(280):         if using:
0.79 query.py(281):             connection = connections[using]
0.79 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.79 compiler.py(25):         self.query = query
0.79 compiler.py(26):         self.connection = connection
0.79 compiler.py(27):         self.using = using
0.79 compiler.py(28):         self.quote_cache = {'*': '*'}
0.79 compiler.py(33):         self.select = None
0.79 compiler.py(34):         self.annotation_col_map = None
0.79 compiler.py(35):         self.klass_info = None
0.79 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.79 compiler.py(38):         self._meta_ordering = None
0.79 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.79 compiler.py(1333):         self.return_id = return_id
0.79 compiler.py(1334):         with self.connection.cursor() as cursor:
0.79 compiler.py(1335):             for sql, params in self.as_sql():
0.79 compiler.py(1269):         qn = self.connection.ops.quote_name
0.79 compiler.py(1270):         opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.79 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.79 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.79 compiler.py(1276):         if self.query.fields:
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1279):                 for obj in self.query.objs
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1279):                 for obj in self.query.objs
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1227):         if self.query.raw:
0.79 compiler.py(1229):         return field.pre_save(obj, add=True)
0.79 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.79 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.79 compiler.py(1220):         return value
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1227):         if self.query.raw:
0.79 compiler.py(1229):         return field.pre_save(obj, add=True)
0.79 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.79 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.79 compiler.py(1220):         return value
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.79 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.79 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.79 compiler.py(1243):         if not value_rows:
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1250):             for row in value_rows
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1250):             for row in value_rows
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1170):         if field is None:
0.79 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.79 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.79 compiler.py(1182):             sql, params = '%s', [val]
0.79 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.79 compiler.py(1191):         return sql, params
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1170):         if field is None:
0.79 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.79 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.79 compiler.py(1182):             sql, params = '%s', [val]
0.79 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.79 compiler.py(1191):         return sql, params
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.79 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.79 compiler.py(1264):         return placeholder_rows, param_rows
0.79 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.79 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.79 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.79 compiler.py(1315):         if can_bulk:
0.79 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.79 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.79 compiler.py(1336):                 cursor.execute(sql, params)
0.79 compiler.py(1335):             for sql, params in self.as_sql():
0.79 compiler.py(1337):             if not return_id:
0.79 compiler.py(1338):                 return
0.79 query.py(154):         self.model = model
0.79 query.py(155):         self.alias_refcount = {}
0.79 query.py(161):         self.alias_map = {}
0.79 query.py(165):         self.external_aliases = set()
0.79 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.79 query.py(167):         self.default_cols = True
0.79 query.py(168):         self.default_ordering = True
0.79 query.py(169):         self.standard_ordering = True
0.79 query.py(170):         self.used_aliases = set()
0.79 query.py(171):         self.filter_is_sticky = False
0.79 query.py(172):         self.subquery = False
0.79 query.py(180):         self.select = ()
0.79 query.py(181):         self.where = where()
0.79 query.py(182):         self.where_class = where
0.79 query.py(189):         self.group_by = None
0.79 query.py(190):         self.order_by = ()
0.79 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.79 query.py(192):         self.distinct = False
0.79 query.py(193):         self.distinct_fields = ()
0.79 query.py(194):         self.select_for_update = False
0.79 query.py(195):         self.select_for_update_nowait = False
0.79 query.py(196):         self.select_for_update_skip_locked = False
0.79 query.py(197):         self.select_for_update_of = ()
0.79 query.py(199):         self.select_related = False
0.79 query.py(201):         self.max_depth = 5
0.79 query.py(205):         self.values_select = ()
0.79 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.79 query.py(209):         self.annotation_select_mask = None
0.79 query.py(210):         self._annotation_select_cache = None
0.79 query.py(213):         self.combinator = None
0.79 query.py(214):         self.combinator_all = False
0.79 query.py(215):         self.combined_queries = ()
0.79 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.79 query.py(220):         self.extra_select_mask = None
0.79 query.py(221):         self._extra_select_cache = None
0.79 query.py(223):         self.extra_tables = ()
0.79 query.py(224):         self.extra_order_by = ()
0.79 query.py(229):         self.deferred_loading = (frozenset(), True)
0.79 query.py(231):         self._filtered_relations = {}
0.79 query.py(233):         self.explain_query = False
0.79 query.py(234):         self.explain_format = None
0.79 query.py(235):         self.explain_options = {}
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1758):         return not self.low_mark and self.high_mark is None
0.79 query.py(343):         obj = self.clone()
0.79 query.py(297):         obj = Empty()
0.79 query.py(298):         obj.__class__ = self.__class__
0.79 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.79 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.79 query.py(303):         obj.alias_map = self.alias_map.copy()
0.79 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.79 query.py(305):         obj.table_map = self.table_map.copy()
0.79 query.py(306):         obj.where = self.where.clone()
0.79 query.py(307):         obj.annotations = self.annotations.copy()
0.79 query.py(308):         if self.annotation_select_mask is None:
0.79 query.py(309):             obj.annotation_select_mask = None
0.79 query.py(317):         obj._annotation_select_cache = None
0.79 query.py(318):         obj.extra = self.extra.copy()
0.79 query.py(319):         if self.extra_select_mask is None:
0.79 query.py(320):             obj.extra_select_mask = None
0.79 query.py(323):         if self._extra_select_cache is None:
0.79 query.py(324):             obj._extra_select_cache = None
0.79 query.py(327):         if 'subq_aliases' in self.__dict__:
0.79 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.79 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.79 query.py(332):         try:
0.79 query.py(333):             del obj.base_table
0.79 query.py(334):         except AttributeError:
0.79 query.py(335):             pass
0.79 query.py(336):         return obj
0.79 query.py(344):         if klass and obj.__class__ != klass:
0.79 query.py(346):         if not obj.filter_is_sticky:
0.79 query.py(347):             obj.used_aliases = set()
0.79 query.py(348):         obj.filter_is_sticky = False
0.79 query.py(349):         if hasattr(obj, '_setup_query'):
0.79 query.py(351):         return obj
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.79 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.79 query.py(1331):         connector = q_object.connector
0.79 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.79 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.79 query.py(1334):         target_clause = self.where_class(connector=connector,
0.79 query.py(1335):                                          negated=q_object.negated)
0.79 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.79 query.py(2236):         self.connector = connector
0.79 query.py(2237):         self.negated = negated
0.79 query.py(2238):         if self.negated:
0.79 query.py(2244):             self.effective_connector = self.connector
0.79 query.py(2245):         self.num_children = num_children
0.79 query.py(2248):         self.votes = Counter()
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1338):             if isinstance(child, Node):
0.79 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.79 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.79 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.79 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.79 query.py(1214):         if isinstance(filter_expr, dict):
0.79 query.py(1216):         arg, value = filter_expr
0.79 query.py(1217):         if not arg:
0.79 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.79 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.79 query.py(1074):         if self.annotations:
0.79 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.79 query.py(290):         return self.model._meta
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.79 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.79 query.py(1085):         return lookup_parts, field_parts, False
0.79 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.79 query.py(1227):         if not allow_joins and len(parts) > 1:
0.79 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.79 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.79 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.79 query.py(1055):         elif isinstance(value, (list, tuple)):
0.79 query.py(1067):         return value
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.79 query.py(1234):         clause = self.where_class()
0.79 query.py(1235):         if reffed_expression:
0.79 query.py(1240):         opts = self.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 query.py(1241):         alias = self.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.79 query.py(290):         return self.model._meta
0.79 query.py(943):         if reuse_with_filtered_relation and reuse:
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(950):                 a for a, j in self.alias_map.items()
0.79 query.py(953):         if reuse_aliases:
0.79 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.79 query.py(735):         alias_list = self.table_map.get(table_name)
0.79 query.py(736):         if not create and alias_list:
0.79 query.py(742):         if alias_list:
0.79 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.79 query.py(748):             self.table_map[table_name] = [alias]
0.79 query.py(749):         self.alias_refcount[alias] = 1
0.79 query.py(750):         return alias, True
0.79 query.py(965):         if join.join_type:
0.79 query.py(971):         join.table_alias = alias
0.79 query.py(972):         self.alias_map[alias] = join
0.79 query.py(973):         return alias
0.79 query.py(917):         return alias
0.79 query.py(1242):         allow_many = not branch_negated or not split_subq
0.79 query.py(1244):         try:
0.79 query.py(1245):             join_info = self.setup_joins(
0.79 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.79 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.79 query.py(1518):         joins = [alias]
0.79 query.py(1524):         def final_transformer(field, alias):
0.79 query.py(1529):         last_field_exception = None
0.79 query.py(1530):         for pivot in range(len(names), 0, -1):
0.79 query.py(1531):             try:
0.79 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.79 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.79 query.py(1405):         path, names_with_path = [], []
0.79 query.py(1406):         for pos, name in enumerate(names):
0.79 query.py(1407):             cur_names_with_path = (name, [])
0.79 query.py(1408):             if name == 'pk':
0.79 query.py(1411):             field = None
0.79 query.py(1412):             filtered_relation = None
0.79 query.py(1413):             try:
0.79 query.py(1414):                 field = opts.get_field(name)
0.79 query.py(1421):             if field is not None:
0.79 query.py(1425):                 if field.is_relation and not field.related_model:
0.79 query.py(1432):                 try:
0.79 query.py(1433):                     model = field.model._meta.concrete_model
0.79 query.py(1454):             if model is not opts.model:
0.79 query.py(1460):             if hasattr(field, 'get_path_info'):
0.79 query.py(1477):                 final_field = field
0.79 query.py(1478):                 targets = (field,)
0.79 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.79 query.py(1483):                 break
0.79 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.79 query.py(1545):                 transforms = names[pivot:]
0.79 query.py(1546):                 break
0.79 query.py(1547):         for name in transforms:
0.79 query.py(1562):         for join in path:
0.79 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.79 query.py(1251):             if isinstance(value, Iterator):
0.79 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.79 query.py(1100):         if field.is_relation:
0.79 query.py(1257):             self._lookup_joins = join_info.joins
0.79 query.py(1263):         used_joins.update(join_info.joins)
0.79 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.79 query.py(1601):         joins = joins[:]
0.79 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.79 query.py(1614):         return targets, joins[-1], joins
0.79 query.py(1265):         if can_reuse is not None:
0.79 query.py(1266):             can_reuse.update(join_list)
0.79 query.py(1268):         if join_info.final_field.is_relation:
0.79 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.79 query.py(72):     if simple_col:
0.79 query.py(74):     return target.get_col(alias, field)
0.79 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.79 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.79 query.py(1129):         for name in transforms:
0.79 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.79 query.py(1134):         if not lookup_class:
0.79 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.79 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.79 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.79 query.py(1161):         return lookup
0.79 query.py(1281):         lookup_type = condition.lookup_name
0.79 query.py(1282):         clause.add(condition, AND)
0.79 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.79 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.79 query.py(1302):         return clause, used_joins if not require_outer else ()
0.79 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.79 query.py(2255):         self.votes.update(votes)
0.79 query.py(1350):             if child_clause:
0.79 query.py(1351):                 target_clause.add(child_clause, connector)
0.79 query.py(1337):         for child in q_object.children:
0.79 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.79 query.py(2264):         to_promote = set()
0.79 query.py(2265):         to_demote = set()
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.79 query.py(2291):             if self.effective_connector == 'AND' or (
0.79 query.py(2293):                 to_demote.add(table)
0.79 query.py(2268):         for table, votes in self.votes.items():
0.79 query.py(2309):         query.promote_joins(to_promote)
0.79 query.py(771):         aliases = list(aliases)
0.79 query.py(772):         while aliases:
0.79 query.py(2310):         query.demote_joins(to_demote)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(806):             alias = aliases.pop(0)
0.79 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.79 query.py(805):         while aliases:
0.79 query.py(2311):         return to_demote
0.79 query.py(1353):         return target_clause, needed_inner
0.79 query.py(1320):         if clause:
0.79 query.py(1321):             self.where.add(clause, AND)
0.79 query.py(1322):         self.demote_joins(existing_inner)
0.79 query.py(804):         aliases = list(aliases)
0.79 query.py(805):         while aliases:
0.79 query.py(278):         if using is None and connection is None:
0.79 query.py(280):         if using:
0.79 query.py(281):             connection = connections[using]
0.79 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.79 compiler.py(25):         self.query = query
0.79 compiler.py(26):         self.connection = connection
0.79 compiler.py(27):         self.using = using
0.79 compiler.py(28):         self.quote_cache = {'*': '*'}
0.79 compiler.py(33):         self.select = None
0.79 compiler.py(34):         self.annotation_col_map = None
0.79 compiler.py(35):         self.klass_info = None
0.79 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.79 compiler.py(38):         self._meta_ordering = None
0.79 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.79 compiler.py(1081):         try:
0.79 compiler.py(1082):             sql, params = self.as_sql()
0.79 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.79 compiler.py(479):         try:
0.79 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.79 compiler.py(52):         self.setup_query()
0.79 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.79 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.79 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.79 compiler.py(202):         select = []
0.79 compiler.py(203):         klass_info = None
0.79 compiler.py(204):         annotations = {}
0.79 compiler.py(205):         select_idx = 0
0.79 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.79 compiler.py(211):         if self.query.default_cols:
0.79 compiler.py(212):             cols = self.get_default_columns()
0.79 compiler.py(644):         result = []
0.79 compiler.py(645):         if opts is None:
0.79 compiler.py(646):             opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(647):         only_load = self.deferred_to_columns()
0.79 compiler.py(1018):         columns = {}
0.79 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.79 query.py(655):         field_names, defer = self.deferred_loading
0.79 query.py(656):         if not field_names:
0.79 query.py(657):             return
0.79 compiler.py(1020):         return columns
0.79 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.79 query.py(912):         if self.alias_map:
0.79 query.py(913):             alias = self.base_table
0.79 query.py(250):         for alias in self.alias_map:
0.79 query.py(251):             return alias
0.79 query.py(914):             self.ref_alias(alias)
0.79 query.py(754):         self.alias_refcount[alias] += 1
0.79 query.py(917):         return alias
0.79 compiler.py(652):         seen_models = {None: start_alias}
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(655):             model = field.model._meta.concrete_model
0.79 compiler.py(658):             if model == opts.model:
0.79 compiler.py(659):                 model = None
0.79 compiler.py(660):             if from_parent and model is not None and issubclass(
0.79 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.79 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.79 compiler.py(671):                                                  seen_models)
0.79 query.py(984):         if model in seen:
0.79 query.py(985):             return seen[model]
0.79 compiler.py(672):             column = field.get_col(alias)
0.79 compiler.py(673):             result.append(column)
0.79 compiler.py(654):         for field in opts.concrete_fields:
0.79 compiler.py(674):         return result
0.79 compiler.py(217):         if cols:
0.79 compiler.py(218):             select_list = []
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(220):                 select_list.append(select_idx)
0.79 compiler.py(221):                 select.append((col, None))
0.79 compiler.py(222):                 select_idx += 1
0.79 compiler.py(219):             for col in cols:
0.79 compiler.py(224):                 'model': self.query.model,
0.79 compiler.py(225):                 'select_fields': select_list,
0.79 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.79 query.py(2075):         if self._annotation_select_cache is not None:
0.79 query.py(2077):         elif not self.annotations:
0.79 query.py(2078):             return {}
0.79 compiler.py(232):         if self.query.select_related:
0.79 compiler.py(244):         ret = []
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(246):             try:
0.79 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.79 compiler.py(397):                 name in self.query.extra_select or (
0.79 query.py(2090):         if self._extra_select_cache is not None:
0.79 query.py(2092):         if not self.extra:
0.79 query.py(2093):             return {}
0.79 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.79 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.79 compiler.py(402):         self.quote_cache[name] = r
0.79 compiler.py(403):         return r
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.79 compiler.py(251):             ret.append((col, (sql, params), alias))
0.79 compiler.py(245):         for col, alias in select:
0.79 compiler.py(252):         return ret, klass_info, annotations
0.79 compiler.py(44):         self.col_count = len(self.select)
0.79 compiler.py(53):         order_by = self.get_order_by()
0.79 compiler.py(263):         if self.query.extra_order_by:
0.79 compiler.py(265):         elif not self.query.default_ordering:
0.79 compiler.py(267):         elif self.query.order_by:
0.79 compiler.py(269):         elif self.query.get_meta().ordering:
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(273):             ordering = []
0.79 compiler.py(274):         if self.query.standard_ordering:
0.79 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.79 compiler.py(279):         order_by = []
0.79 compiler.py(280):         for field in ordering:
0.79 compiler.py(340):         result = []
0.79 compiler.py(341):         seen = set()
0.79 compiler.py(343):         for expr, is_ref in order_by:
0.79 compiler.py(376):         return result
0.79 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.79 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.79 compiler.py(379):         extra_select = []
0.79 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.79 compiler.py(386):         return extra_select
0.79 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.79 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.79 compiler.py(97):         if self.query.group_by is None:
0.79 compiler.py(98):             return []
0.79 compiler.py(58):         return extra_select, order_by, group_by
0.79 compiler.py(481):             for_update_part = None
0.79 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.79 compiler.py(484):             combinator = self.query.combinator
0.79 compiler.py(485):             features = self.connection.features
0.79 compiler.py(486):             if combinator:
0.79 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.79 compiler.py(683):         result = []
0.79 compiler.py(684):         params = []
0.79 compiler.py(685):         opts = self.query.get_meta()
0.79 query.py(290):         return self.model._meta
0.79 compiler.py(687):         for name in self.query.distinct_fields:
0.79 compiler.py(698):         return result, params
0.79 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.79 compiler.py(755):         result = []
0.79 compiler.py(756):         params = []
0.79 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.79 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.79 compiler.py(760):             try:
0.79 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.79 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.79 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.79 compiler.py(407):         if vendor_impl:
0.79 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.79 compiler.py(394):         if name in self.quote_cache:
0.79 compiler.py(395):             return self.quote_cache[name]
0.79 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.79 compiler.py(413):         return sql, params
0.79 compiler.py(767):             result.append(clause_sql)
0.80 compiler.py(768):             params.extend(clause_params)
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(769):         for t in self.query.extra_tables:
0.80 compiler.py(776):         return result, params
0.80 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.80 compiler.py(497):                 result = ['SELECT']
0.80 compiler.py(498):                 params = []
0.80 compiler.py(500):                 if self.query.distinct:
0.80 compiler.py(508):                 out_cols = []
0.80 compiler.py(509):                 col_idx = 1
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.80 compiler.py(520):                 params.extend(f_params)
0.80 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.80 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.80 compiler.py(552):                 if where:
0.80 compiler.py(553):                     result.append('WHERE %s' % where)
0.80 compiler.py(554):                     params.extend(w_params)
0.80 compiler.py(556):                 grouping = []
0.80 compiler.py(557):                 for g_sql, g_params in group_by:
0.80 compiler.py(560):                 if grouping:
0.80 compiler.py(577):                 if having:
0.80 compiler.py(581):             if self.query.explain_query:
0.80 compiler.py(587):             if order_by:
0.80 compiler.py(594):             if with_limit_offset:
0.80 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.80 compiler.py(600):             if self.query.subquery and extra_select:
0.80 compiler.py(627):             return ' '.join(result), tuple(params)
0.80 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.80 query.py(820):             self.unref_alias(alias, unref_amount)
0.80 query.py(758):         self.alias_refcount[alias] -= amount
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 compiler.py(1083):             if not sql:
0.80 compiler.py(1090):         if chunked_fetch:
0.80 compiler.py(1093):             cursor = self.connection.cursor()
0.80 compiler.py(1094):         try:
0.80 compiler.py(1095):             cursor.execute(sql, params)
0.80 compiler.py(1101):         if result_type == CURSOR:
0.80 compiler.py(1104):         if result_type == SINGLE:
0.80 compiler.py(1113):         if result_type == NO_RESULTS:
0.80 compiler.py(1117):         result = cursor_iter(
0.80 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.80 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.80 compiler.py(1120):             chunk_size,
0.80 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.80 compiler.py(1123):             try:
0.80 compiler.py(1128):                 return list(result)
0.80 compiler.py(1518):     try:
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1522):         cursor.close()
0.80 compiler.py(1131):                 cursor.close()
0.80 compiler.py(1046):         if results is None:
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1049):         converters = self.get_converters(fields)
0.80 compiler.py(1023):         converters = {}
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1030):         return converters
0.80 compiler.py(1050):         rows = chain.from_iterable(results)
0.80 compiler.py(1051):         if converters:
0.80 compiler.py(1055):         return rows
0.80 query.py(154):         self.model = model
0.80 query.py(155):         self.alias_refcount = {}
0.80 query.py(161):         self.alias_map = {}
0.80 query.py(165):         self.external_aliases = set()
0.80 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.80 query.py(167):         self.default_cols = True
0.80 query.py(168):         self.default_ordering = True
0.80 query.py(169):         self.standard_ordering = True
0.80 query.py(170):         self.used_aliases = set()
0.80 query.py(171):         self.filter_is_sticky = False
0.80 query.py(172):         self.subquery = False
0.80 query.py(180):         self.select = ()
0.80 query.py(181):         self.where = where()
0.80 query.py(182):         self.where_class = where
0.80 query.py(189):         self.group_by = None
0.80 query.py(190):         self.order_by = ()
0.80 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.80 query.py(192):         self.distinct = False
0.80 query.py(193):         self.distinct_fields = ()
0.80 query.py(194):         self.select_for_update = False
0.80 query.py(195):         self.select_for_update_nowait = False
0.80 query.py(196):         self.select_for_update_skip_locked = False
0.80 query.py(197):         self.select_for_update_of = ()
0.80 query.py(199):         self.select_related = False
0.80 query.py(201):         self.max_depth = 5
0.80 query.py(205):         self.values_select = ()
0.80 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.80 query.py(209):         self.annotation_select_mask = None
0.80 query.py(210):         self._annotation_select_cache = None
0.80 query.py(213):         self.combinator = None
0.80 query.py(214):         self.combinator_all = False
0.80 query.py(215):         self.combined_queries = ()
0.80 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.80 query.py(220):         self.extra_select_mask = None
0.80 query.py(221):         self._extra_select_cache = None
0.80 query.py(223):         self.extra_tables = ()
0.80 query.py(224):         self.extra_order_by = ()
0.80 query.py(229):         self.deferred_loading = (frozenset(), True)
0.80 query.py(231):         self._filtered_relations = {}
0.80 query.py(233):         self.explain_query = False
0.80 query.py(234):         self.explain_format = None
0.80 query.py(235):         self.explain_options = {}
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(154):         self.model = model
0.80 query.py(155):         self.alias_refcount = {}
0.80 query.py(161):         self.alias_map = {}
0.80 query.py(165):         self.external_aliases = set()
0.80 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.80 query.py(167):         self.default_cols = True
0.80 query.py(168):         self.default_ordering = True
0.80 query.py(169):         self.standard_ordering = True
0.80 query.py(170):         self.used_aliases = set()
0.80 query.py(171):         self.filter_is_sticky = False
0.80 query.py(172):         self.subquery = False
0.80 query.py(180):         self.select = ()
0.80 query.py(181):         self.where = where()
0.80 query.py(182):         self.where_class = where
0.80 query.py(189):         self.group_by = None
0.80 query.py(190):         self.order_by = ()
0.80 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.80 query.py(192):         self.distinct = False
0.80 query.py(193):         self.distinct_fields = ()
0.80 query.py(194):         self.select_for_update = False
0.80 query.py(195):         self.select_for_update_nowait = False
0.80 query.py(196):         self.select_for_update_skip_locked = False
0.80 query.py(197):         self.select_for_update_of = ()
0.80 query.py(199):         self.select_related = False
0.80 query.py(201):         self.max_depth = 5
0.80 query.py(205):         self.values_select = ()
0.80 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.80 query.py(209):         self.annotation_select_mask = None
0.80 query.py(210):         self._annotation_select_cache = None
0.80 query.py(213):         self.combinator = None
0.80 query.py(214):         self.combinator_all = False
0.80 query.py(215):         self.combined_queries = ()
0.80 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.80 query.py(220):         self.extra_select_mask = None
0.80 query.py(221):         self._extra_select_cache = None
0.80 query.py(223):         self.extra_tables = ()
0.80 query.py(224):         self.extra_order_by = ()
0.80 query.py(229):         self.deferred_loading = (frozenset(), True)
0.80 query.py(231):         self._filtered_relations = {}
0.80 query.py(233):         self.explain_query = False
0.80 query.py(234):         self.explain_format = None
0.80 query.py(235):         self.explain_options = {}
0.80 query.py(1758):         return not self.low_mark and self.high_mark is None
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.80 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.80 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.80 query.py(1331):         connector = q_object.connector
0.80 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.80 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.80 query.py(1334):         target_clause = self.where_class(connector=connector,
0.80 query.py(1335):                                          negated=q_object.negated)
0.80 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.80 query.py(2236):         self.connector = connector
0.80 query.py(2237):         self.negated = negated
0.80 query.py(2238):         if self.negated:
0.80 query.py(2244):             self.effective_connector = self.connector
0.80 query.py(2245):         self.num_children = num_children
0.80 query.py(2248):         self.votes = Counter()
0.80 query.py(1337):         for child in q_object.children:
0.80 query.py(1338):             if isinstance(child, Node):
0.80 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.80 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.80 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.80 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.80 query.py(1214):         if isinstance(filter_expr, dict):
0.80 query.py(1216):         arg, value = filter_expr
0.80 query.py(1217):         if not arg:
0.80 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.80 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.80 query.py(1074):         if self.annotations:
0.80 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.80 query.py(290):         return self.model._meta
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.80 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.80 query.py(1085):         return lookup_parts, field_parts, False
0.80 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.80 query.py(1227):         if not allow_joins and len(parts) > 1:
0.80 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.80 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.80 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.80 query.py(1055):         elif isinstance(value, (list, tuple)):
0.80 query.py(1067):         return value
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1234):         clause = self.where_class()
0.80 query.py(1235):         if reffed_expression:
0.80 query.py(1240):         opts = self.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 query.py(1241):         alias = self.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.80 query.py(290):         return self.model._meta
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.80 query.py(735):         alias_list = self.table_map.get(table_name)
0.80 query.py(736):         if not create and alias_list:
0.80 query.py(742):         if alias_list:
0.80 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.80 query.py(748):             self.table_map[table_name] = [alias]
0.80 query.py(749):         self.alias_refcount[alias] = 1
0.80 query.py(750):         return alias, True
0.80 query.py(965):         if join.join_type:
0.80 query.py(971):         join.table_alias = alias
0.80 query.py(972):         self.alias_map[alias] = join
0.80 query.py(973):         return alias
0.80 query.py(917):         return alias
0.80 query.py(1242):         allow_many = not branch_negated or not split_subq
0.80 query.py(1244):         try:
0.80 query.py(1245):             join_info = self.setup_joins(
0.80 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.80 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1251):             if isinstance(value, Iterator):
0.80 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.80 query.py(1100):         if field.is_relation:
0.80 query.py(1257):             self._lookup_joins = join_info.joins
0.80 query.py(1263):         used_joins.update(join_info.joins)
0.80 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1265):         if can_reuse is not None:
0.80 query.py(1266):             can_reuse.update(join_list)
0.80 query.py(1268):         if join_info.final_field.is_relation:
0.80 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.80 query.py(72):     if simple_col:
0.80 query.py(74):     return target.get_col(alias, field)
0.80 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.80 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.80 query.py(1129):         for name in transforms:
0.80 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.80 query.py(1134):         if not lookup_class:
0.80 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.80 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.80 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(1161):         return lookup
0.80 query.py(1281):         lookup_type = condition.lookup_name
0.80 query.py(1282):         clause.add(condition, AND)
0.80 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.80 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.80 query.py(1302):         return clause, used_joins if not require_outer else ()
0.80 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.80 query.py(2255):         self.votes.update(votes)
0.80 query.py(1350):             if child_clause:
0.80 query.py(1351):                 target_clause.add(child_clause, connector)
0.80 query.py(1337):         for child in q_object.children:
0.80 query.py(1338):             if isinstance(child, Node):
0.80 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.80 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.80 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.80 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.80 query.py(1214):         if isinstance(filter_expr, dict):
0.80 query.py(1216):         arg, value = filter_expr
0.80 query.py(1217):         if not arg:
0.80 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.80 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.80 query.py(1074):         if self.annotations:
0.80 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.80 query.py(290):         return self.model._meta
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.80 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.80 query.py(1085):         return lookup_parts, field_parts, False
0.80 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.80 query.py(1227):         if not allow_joins and len(parts) > 1:
0.80 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.80 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.80 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.80 query.py(1055):         elif isinstance(value, (list, tuple)):
0.80 query.py(1067):         return value
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1234):         clause = self.where_class()
0.80 query.py(1235):         if reffed_expression:
0.80 query.py(1240):         opts = self.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 query.py(1241):         alias = self.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(250):         for alias in self.alias_map:
0.80 query.py(251):             return alias
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 query.py(1242):         allow_many = not branch_negated or not split_subq
0.80 query.py(1244):         try:
0.80 query.py(1245):             join_info = self.setup_joins(
0.80 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.80 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1251):             if isinstance(value, Iterator):
0.80 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.80 query.py(1100):         if field.is_relation:
0.80 query.py(1257):             self._lookup_joins = join_info.joins
0.80 query.py(1263):         used_joins.update(join_info.joins)
0.80 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1265):         if can_reuse is not None:
0.80 query.py(1266):             can_reuse.update(join_list)
0.80 query.py(1268):         if join_info.final_field.is_relation:
0.80 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.80 query.py(72):     if simple_col:
0.80 query.py(74):     return target.get_col(alias, field)
0.80 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.80 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.80 query.py(1129):         for name in transforms:
0.80 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.80 query.py(1134):         if not lookup_class:
0.80 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.80 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.80 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(1161):         return lookup
0.80 query.py(1281):         lookup_type = condition.lookup_name
0.80 query.py(1282):         clause.add(condition, AND)
0.80 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.80 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.80 query.py(1302):         return clause, used_joins if not require_outer else ()
0.80 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.80 query.py(2255):         self.votes.update(votes)
0.80 query.py(1350):             if child_clause:
0.80 query.py(1351):                 target_clause.add(child_clause, connector)
0.80 query.py(1337):         for child in q_object.children:
0.80 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.80 query.py(2264):         to_promote = set()
0.80 query.py(2265):         to_demote = set()
0.80 query.py(2268):         for table, votes in self.votes.items():
0.80 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.80 query.py(2291):             if self.effective_connector == 'AND' or (
0.80 query.py(2293):                 to_demote.add(table)
0.80 query.py(2268):         for table, votes in self.votes.items():
0.80 query.py(2309):         query.promote_joins(to_promote)
0.80 query.py(771):         aliases = list(aliases)
0.80 query.py(772):         while aliases:
0.80 query.py(2310):         query.demote_joins(to_demote)
0.80 query.py(804):         aliases = list(aliases)
0.80 query.py(805):         while aliases:
0.80 query.py(806):             alias = aliases.pop(0)
0.80 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.80 query.py(805):         while aliases:
0.80 query.py(2311):         return to_demote
0.80 query.py(1353):         return target_clause, needed_inner
0.80 query.py(1320):         if clause:
0.80 query.py(1321):             self.where.add(clause, AND)
0.80 query.py(1322):         self.demote_joins(existing_inner)
0.80 query.py(804):         aliases = list(aliases)
0.80 query.py(805):         while aliases:
0.80 query.py(1758):         return not self.low_mark and self.high_mark is None
0.80 query.py(1758):         return not self.low_mark and self.high_mark is None
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1860):         self.order_by = ()
0.80 query.py(1861):         self.extra_order_by = ()
0.80 query.py(1862):         if force_empty:
0.80 query.py(1839):         errors = []
0.80 query.py(1840):         for item in ordering:
0.80 query.py(1848):         if errors:
0.80 query.py(1850):         if ordering:
0.80 query.py(1853):             self.default_ordering = False
0.80 query.py(1731):         if high is not None:
0.80 query.py(1732):             if self.high_mark is not None:
0.80 query.py(1735):                 self.high_mark = self.low_mark + high
0.80 query.py(1736):         if low is not None:
0.80 query.py(1742):         if self.low_mark == self.high_mark:
0.80 query.py(278):         if using is None and connection is None:
0.80 query.py(280):         if using:
0.80 query.py(281):             connection = connections[using]
0.80 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.80 compiler.py(25):         self.query = query
0.80 compiler.py(26):         self.connection = connection
0.80 compiler.py(27):         self.using = using
0.80 compiler.py(28):         self.quote_cache = {'*': '*'}
0.80 compiler.py(33):         self.select = None
0.80 compiler.py(34):         self.annotation_col_map = None
0.80 compiler.py(35):         self.klass_info = None
0.80 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.80 compiler.py(38):         self._meta_ordering = None
0.80 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.80 compiler.py(1081):         try:
0.80 compiler.py(1082):             sql, params = self.as_sql()
0.80 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.80 compiler.py(479):         try:
0.80 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.80 compiler.py(52):         self.setup_query()
0.80 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.80 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.80 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.80 compiler.py(202):         select = []
0.80 compiler.py(203):         klass_info = None
0.80 compiler.py(204):         annotations = {}
0.80 compiler.py(205):         select_idx = 0
0.80 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.80 compiler.py(211):         if self.query.default_cols:
0.80 compiler.py(212):             cols = self.get_default_columns()
0.80 compiler.py(644):         result = []
0.80 compiler.py(645):         if opts is None:
0.80 compiler.py(646):             opts = self.query.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(647):         only_load = self.deferred_to_columns()
0.80 compiler.py(1018):         columns = {}
0.80 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.80 query.py(655):         field_names, defer = self.deferred_loading
0.80 query.py(656):         if not field_names:
0.80 query.py(657):             return
0.80 compiler.py(1020):         return columns
0.80 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(250):         for alias in self.alias_map:
0.80 query.py(251):             return alias
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 compiler.py(652):         seen_models = {None: start_alias}
0.80 compiler.py(654):         for field in opts.concrete_fields:
0.80 compiler.py(655):             model = field.model._meta.concrete_model
0.80 compiler.py(658):             if model == opts.model:
0.80 compiler.py(659):                 model = None
0.80 compiler.py(660):             if from_parent and model is not None and issubclass(
0.80 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.80 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.80 compiler.py(671):                                                  seen_models)
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 compiler.py(672):             column = field.get_col(alias)
0.80 compiler.py(673):             result.append(column)
0.80 compiler.py(654):         for field in opts.concrete_fields:
0.80 compiler.py(655):             model = field.model._meta.concrete_model
0.80 compiler.py(658):             if model == opts.model:
0.80 compiler.py(659):                 model = None
0.80 compiler.py(660):             if from_parent and model is not None and issubclass(
0.80 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.80 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.80 compiler.py(671):                                                  seen_models)
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 compiler.py(672):             column = field.get_col(alias)
0.80 compiler.py(673):             result.append(column)
0.80 compiler.py(654):         for field in opts.concrete_fields:
0.80 compiler.py(655):             model = field.model._meta.concrete_model
0.80 compiler.py(658):             if model == opts.model:
0.80 compiler.py(659):                 model = None
0.80 compiler.py(660):             if from_parent and model is not None and issubclass(
0.80 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.80 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.80 compiler.py(671):                                                  seen_models)
0.80 query.py(984):         if model in seen:
0.80 query.py(985):             return seen[model]
0.80 compiler.py(672):             column = field.get_col(alias)
0.80 compiler.py(673):             result.append(column)
0.80 compiler.py(654):         for field in opts.concrete_fields:
0.80 compiler.py(674):         return result
0.80 compiler.py(217):         if cols:
0.80 compiler.py(218):             select_list = []
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(220):                 select_list.append(select_idx)
0.80 compiler.py(221):                 select.append((col, None))
0.80 compiler.py(222):                 select_idx += 1
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(220):                 select_list.append(select_idx)
0.80 compiler.py(221):                 select.append((col, None))
0.80 compiler.py(222):                 select_idx += 1
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(220):                 select_list.append(select_idx)
0.80 compiler.py(221):                 select.append((col, None))
0.80 compiler.py(222):                 select_idx += 1
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(224):                 'model': self.query.model,
0.80 compiler.py(225):                 'select_fields': select_list,
0.80 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(232):         if self.query.select_related:
0.80 compiler.py(244):         ret = []
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(246):             try:
0.80 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.80 compiler.py(251):             ret.append((col, (sql, params), alias))
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(246):             try:
0.80 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.80 compiler.py(251):             ret.append((col, (sql, params), alias))
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(246):             try:
0.80 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.80 compiler.py(251):             ret.append((col, (sql, params), alias))
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(252):         return ret, klass_info, annotations
0.80 compiler.py(44):         self.col_count = len(self.select)
0.80 compiler.py(53):         order_by = self.get_order_by()
0.80 compiler.py(263):         if self.query.extra_order_by:
0.80 compiler.py(265):         elif not self.query.default_ordering:
0.80 compiler.py(266):             ordering = self.query.order_by
0.80 compiler.py(274):         if self.query.standard_ordering:
0.80 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.80 compiler.py(279):         order_by = []
0.80 compiler.py(280):         for field in ordering:
0.80 compiler.py(340):         result = []
0.80 compiler.py(341):         seen = set()
0.80 compiler.py(343):         for expr, is_ref in order_by:
0.80 compiler.py(376):         return result
0.80 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.80 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.80 compiler.py(379):         extra_select = []
0.80 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.80 compiler.py(386):         return extra_select
0.80 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.80 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.80 compiler.py(97):         if self.query.group_by is None:
0.80 compiler.py(98):             return []
0.80 compiler.py(58):         return extra_select, order_by, group_by
0.80 compiler.py(481):             for_update_part = None
0.80 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.80 compiler.py(484):             combinator = self.query.combinator
0.80 compiler.py(485):             features = self.connection.features
0.80 compiler.py(486):             if combinator:
0.80 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.80 compiler.py(683):         result = []
0.80 compiler.py(684):         params = []
0.80 compiler.py(685):         opts = self.query.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(687):         for name in self.query.distinct_fields:
0.80 compiler.py(698):         return result, params
0.80 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.80 compiler.py(755):         result = []
0.80 compiler.py(756):         params = []
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.80 compiler.py(760):             try:
0.80 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.80 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(767):             result.append(clause_sql)
0.80 compiler.py(768):             params.extend(clause_params)
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(769):         for t in self.query.extra_tables:
0.80 compiler.py(776):         return result, params
0.80 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.80 compiler.py(497):                 result = ['SELECT']
0.80 compiler.py(498):                 params = []
0.80 compiler.py(500):                 if self.query.distinct:
0.80 compiler.py(508):                 out_cols = []
0.80 compiler.py(509):                 col_idx = 1
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.80 compiler.py(520):                 params.extend(f_params)
0.80 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.80 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.80 compiler.py(552):                 if where:
0.80 compiler.py(553):                     result.append('WHERE %s' % where)
0.80 compiler.py(554):                     params.extend(w_params)
0.80 compiler.py(556):                 grouping = []
0.80 compiler.py(557):                 for g_sql, g_params in group_by:
0.80 compiler.py(560):                 if grouping:
0.80 compiler.py(577):                 if having:
0.80 compiler.py(581):             if self.query.explain_query:
0.80 compiler.py(587):             if order_by:
0.80 compiler.py(594):             if with_limit_offset:
0.80 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.80 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.80 compiler.py(600):             if self.query.subquery and extra_select:
0.80 compiler.py(627):             return ' '.join(result), tuple(params)
0.80 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.80 query.py(820):             self.unref_alias(alias, unref_amount)
0.80 query.py(758):         self.alias_refcount[alias] -= amount
0.80 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.80 compiler.py(1083):             if not sql:
0.80 compiler.py(1090):         if chunked_fetch:
0.80 compiler.py(1093):             cursor = self.connection.cursor()
0.80 compiler.py(1094):         try:
0.80 compiler.py(1095):             cursor.execute(sql, params)
0.80 compiler.py(1101):         if result_type == CURSOR:
0.80 compiler.py(1104):         if result_type == SINGLE:
0.80 compiler.py(1113):         if result_type == NO_RESULTS:
0.80 compiler.py(1117):         result = cursor_iter(
0.80 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.80 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.80 compiler.py(1120):             chunk_size,
0.80 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.80 compiler.py(1123):             try:
0.80 compiler.py(1128):                 return list(result)
0.80 compiler.py(1518):     try:
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.80 compiler.py(1522):         cursor.close()
0.80 compiler.py(1131):                 cursor.close()
0.80 compiler.py(1046):         if results is None:
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.80 compiler.py(1049):         converters = self.get_converters(fields)
0.80 compiler.py(1023):         converters = {}
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1025):             if expression:
0.80 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.80 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.80 compiler.py(1028):                 if backend_converters or field_converters:
0.80 compiler.py(1024):         for i, expression in enumerate(expressions):
0.80 compiler.py(1030):         return converters
0.80 compiler.py(1050):         rows = chain.from_iterable(results)
0.80 compiler.py(1051):         if converters:
0.80 compiler.py(1055):         return rows
0.80 query.py(154):         self.model = model
0.80 query.py(155):         self.alias_refcount = {}
0.80 query.py(161):         self.alias_map = {}
0.80 query.py(165):         self.external_aliases = set()
0.80 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.80 query.py(167):         self.default_cols = True
0.80 query.py(168):         self.default_ordering = True
0.80 query.py(169):         self.standard_ordering = True
0.80 query.py(170):         self.used_aliases = set()
0.80 query.py(171):         self.filter_is_sticky = False
0.80 query.py(172):         self.subquery = False
0.80 query.py(180):         self.select = ()
0.80 query.py(181):         self.where = where()
0.80 query.py(182):         self.where_class = where
0.80 query.py(189):         self.group_by = None
0.80 query.py(190):         self.order_by = ()
0.80 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.80 query.py(192):         self.distinct = False
0.80 query.py(193):         self.distinct_fields = ()
0.80 query.py(194):         self.select_for_update = False
0.80 query.py(195):         self.select_for_update_nowait = False
0.80 query.py(196):         self.select_for_update_skip_locked = False
0.80 query.py(197):         self.select_for_update_of = ()
0.80 query.py(199):         self.select_related = False
0.80 query.py(201):         self.max_depth = 5
0.80 query.py(205):         self.values_select = ()
0.80 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.80 query.py(209):         self.annotation_select_mask = None
0.80 query.py(210):         self._annotation_select_cache = None
0.80 query.py(213):         self.combinator = None
0.80 query.py(214):         self.combinator_all = False
0.80 query.py(215):         self.combined_queries = ()
0.80 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.80 query.py(220):         self.extra_select_mask = None
0.80 query.py(221):         self._extra_select_cache = None
0.80 query.py(223):         self.extra_tables = ()
0.80 query.py(224):         self.extra_order_by = ()
0.80 query.py(229):         self.deferred_loading = (frozenset(), True)
0.80 query.py(231):         self._filtered_relations = {}
0.80 query.py(233):         self.explain_query = False
0.80 query.py(234):         self.explain_format = None
0.80 query.py(235):         self.explain_options = {}
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1758):         return not self.low_mark and self.high_mark is None
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.80 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.80 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.80 query.py(1331):         connector = q_object.connector
0.80 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.80 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.80 query.py(1334):         target_clause = self.where_class(connector=connector,
0.80 query.py(1335):                                          negated=q_object.negated)
0.80 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.80 query.py(2236):         self.connector = connector
0.80 query.py(2237):         self.negated = negated
0.80 query.py(2238):         if self.negated:
0.80 query.py(2244):             self.effective_connector = self.connector
0.80 query.py(2245):         self.num_children = num_children
0.80 query.py(2248):         self.votes = Counter()
0.80 query.py(1337):         for child in q_object.children:
0.80 query.py(1338):             if isinstance(child, Node):
0.80 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.80 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.80 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.80 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.80 query.py(1214):         if isinstance(filter_expr, dict):
0.80 query.py(1216):         arg, value = filter_expr
0.80 query.py(1217):         if not arg:
0.80 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.80 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.80 query.py(1074):         if self.annotations:
0.80 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.80 query.py(290):         return self.model._meta
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.80 query.py(1462):                 if not allow_many:
0.80 query.py(1468):                 last = pathinfos[-1]
0.80 query.py(1469):                 path.extend(pathinfos)
0.80 query.py(1470):                 final_field = last.join_field
0.80 query.py(1471):                 opts = last.to_opts
0.80 query.py(1472):                 targets = last.target_fields
0.80 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.80 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1415):             except FieldDoesNotExist:
0.80 query.py(1416):                 if name in self.annotation_select:
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.80 query.py(1421):             if field is not None:
0.80 query.py(1441):                 pos -= 1
0.80 query.py(1442):                 if pos == -1 or fail_on_missing:
0.80 query.py(1450):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.80 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.80 query.py(1085):         return lookup_parts, field_parts, False
0.80 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.80 query.py(1227):         if not allow_joins and len(parts) > 1:
0.80 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.80 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.80 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.80 query.py(1055):         elif isinstance(value, (list, tuple)):
0.80 query.py(1067):         return value
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.80 query.py(1234):         clause = self.where_class()
0.80 query.py(1235):         if reffed_expression:
0.80 query.py(1240):         opts = self.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 query.py(1241):         alias = self.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.80 query.py(290):         return self.model._meta
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.80 query.py(735):         alias_list = self.table_map.get(table_name)
0.80 query.py(736):         if not create and alias_list:
0.80 query.py(742):         if alias_list:
0.80 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.80 query.py(748):             self.table_map[table_name] = [alias]
0.80 query.py(749):         self.alias_refcount[alias] = 1
0.80 query.py(750):         return alias, True
0.80 query.py(965):         if join.join_type:
0.80 query.py(971):         join.table_alias = alias
0.80 query.py(972):         self.alias_map[alias] = join
0.80 query.py(973):         return alias
0.80 query.py(917):         return alias
0.80 query.py(1242):         allow_many = not branch_negated or not split_subq
0.80 query.py(1244):         try:
0.80 query.py(1245):             join_info = self.setup_joins(
0.80 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.80 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.80 query.py(1462):                 if not allow_many:
0.80 query.py(1468):                 last = pathinfos[-1]
0.80 query.py(1469):                 path.extend(pathinfos)
0.80 query.py(1470):                 final_field = last.join_field
0.80 query.py(1471):                 opts = last.to_opts
0.80 query.py(1472):                 targets = last.target_fields
0.80 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.80 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1563):             if join.filtered_relation:
0.80 query.py(1567):                 filtered_relation = None
0.80 query.py(1568):                 table_alias = None
0.80 query.py(1569):             opts = join.to_opts
0.80 query.py(1570):             if join.direct:
0.80 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.80 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(2193):         ) or field.null
0.80 query.py(1574):             connection = Join(
0.80 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.80 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.80 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.80 query.py(1579):             alias = self.join(
0.80 query.py(1580):                 connection, reuse=reuse,
0.80 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.80 query.py(735):         alias_list = self.table_map.get(table_name)
0.80 query.py(736):         if not create and alias_list:
0.80 query.py(742):         if alias_list:
0.80 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.80 query.py(748):             self.table_map[table_name] = [alias]
0.80 query.py(749):         self.alias_refcount[alias] = 1
0.80 query.py(750):         return alias, True
0.80 query.py(965):         if join.join_type:
0.80 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.80 query.py(969):                 join_type = INNER
0.80 query.py(970):             join.join_type = join_type
0.80 query.py(971):         join.table_alias = alias
0.80 query.py(972):         self.alias_map[alias] = join
0.80 query.py(973):         return alias
0.80 query.py(1583):             joins.append(alias)
0.80 query.py(1584):             if filtered_relation:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1251):             if isinstance(value, Iterator):
0.80 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.80 query.py(1100):         if field.is_relation:
0.80 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.80 query.py(1112):             elif hasattr(value, '_meta'):
0.80 query.py(1114):             elif hasattr(value, '__iter__'):
0.80 query.py(1115):                 for v in value:
0.80 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.80 query.py(1092):         if hasattr(value, '_meta'):
0.80 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.80 query.py(1115):                 for v in value:
0.80 query.py(1257):             self._lookup_joins = join_info.joins
0.80 query.py(1263):         used_joins.update(join_info.joins)
0.80 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1603):             if len(joins) == 1 or not info.direct:
0.80 query.py(1605):             if info.filtered_relation:
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1609):             if not cur_targets.issubset(join_targets):
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1613):             self.unref_alias(joins.pop())
0.80 query.py(758):         self.alias_refcount[alias] -= amount
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1265):         if can_reuse is not None:
0.80 query.py(1266):             can_reuse.update(join_list)
0.80 query.py(1268):         if join_info.final_field.is_relation:
0.80 query.py(1270):             num_lookups = len(lookups)
0.80 query.py(1271):             if num_lookups > 1:
0.80 query.py(1273):             if len(targets) == 1:
0.80 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.80 query.py(72):     if simple_col:
0.80 query.py(74):     return target.get_col(alias, field)
0.80 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.80 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.80 query.py(1129):         for name in transforms:
0.80 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.80 query.py(1134):         if not lookup_class:
0.80 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.80 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.80 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(1161):         return lookup
0.80 query.py(1281):         lookup_type = condition.lookup_name
0.80 query.py(1282):         clause.add(condition, AND)
0.80 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.80 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.80 query.py(1302):         return clause, used_joins if not require_outer else ()
0.80 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.80 query.py(2255):         self.votes.update(votes)
0.80 query.py(1350):             if child_clause:
0.80 query.py(1351):                 target_clause.add(child_clause, connector)
0.80 query.py(1337):         for child in q_object.children:
0.80 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.80 query.py(2264):         to_promote = set()
0.80 query.py(2265):         to_demote = set()
0.80 query.py(2268):         for table, votes in self.votes.items():
0.80 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.80 query.py(2291):             if self.effective_connector == 'AND' or (
0.80 query.py(2293):                 to_demote.add(table)
0.80 query.py(2268):         for table, votes in self.votes.items():
0.80 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.80 query.py(2291):             if self.effective_connector == 'AND' or (
0.80 query.py(2293):                 to_demote.add(table)
0.80 query.py(2268):         for table, votes in self.votes.items():
0.80 query.py(2309):         query.promote_joins(to_promote)
0.80 query.py(771):         aliases = list(aliases)
0.80 query.py(772):         while aliases:
0.80 query.py(2310):         query.demote_joins(to_demote)
0.80 query.py(804):         aliases = list(aliases)
0.80 query.py(805):         while aliases:
0.80 query.py(806):             alias = aliases.pop(0)
0.80 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.80 query.py(805):         while aliases:
0.80 query.py(806):             alias = aliases.pop(0)
0.80 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.80 query.py(805):         while aliases:
0.80 query.py(2311):         return to_demote
0.80 query.py(1353):         return target_clause, needed_inner
0.80 query.py(1320):         if clause:
0.80 query.py(1321):             self.where.add(clause, AND)
0.80 query.py(1322):         self.demote_joins(existing_inner)
0.80 query.py(804):         aliases = list(aliases)
0.80 query.py(805):         while aliases:
0.80 query.py(343):         obj = self.clone()
0.80 query.py(297):         obj = Empty()
0.80 query.py(298):         obj.__class__ = self.__class__
0.80 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.80 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.80 query.py(303):         obj.alias_map = self.alias_map.copy()
0.80 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.80 query.py(305):         obj.table_map = self.table_map.copy()
0.80 query.py(306):         obj.where = self.where.clone()
0.80 query.py(307):         obj.annotations = self.annotations.copy()
0.80 query.py(308):         if self.annotation_select_mask is None:
0.80 query.py(309):             obj.annotation_select_mask = None
0.80 query.py(317):         obj._annotation_select_cache = None
0.80 query.py(318):         obj.extra = self.extra.copy()
0.80 query.py(319):         if self.extra_select_mask is None:
0.80 query.py(320):             obj.extra_select_mask = None
0.80 query.py(323):         if self._extra_select_cache is None:
0.80 query.py(324):             obj._extra_select_cache = None
0.80 query.py(327):         if 'subq_aliases' in self.__dict__:
0.80 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.80 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.80 query.py(332):         try:
0.80 query.py(333):             del obj.base_table
0.80 query.py(334):         except AttributeError:
0.80 query.py(335):             pass
0.80 query.py(336):         return obj
0.80 query.py(344):         if klass and obj.__class__ != klass:
0.80 query.py(346):         if not obj.filter_is_sticky:
0.80 query.py(347):             obj.used_aliases = set()
0.80 query.py(348):         obj.filter_is_sticky = False
0.80 query.py(349):         if hasattr(obj, '_setup_query'):
0.80 query.py(351):         return obj
0.80 query.py(2035):         self.select_related = False
0.80 query.py(2036):         self.clear_deferred_loading()
0.80 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.80 query.py(2037):         self.clear_select_fields()
0.80 query.py(1774):         self.select = ()
0.80 query.py(1775):         self.values_select = ()
0.80 query.py(2039):         if self.group_by is True:
0.80 query.py(2044):         if fields:
0.80 query.py(2045):             field_names = []
0.80 query.py(2046):             extra_names = []
0.80 query.py(2047):             annotation_names = []
0.80 query.py(2048):             if not self.extra and not self.annotations:
0.80 query.py(2051):                 field_names = list(fields)
0.80 query.py(2061):             self.set_extra_mask(extra_names)
0.80 query.py(2028):         if names is None:
0.80 query.py(2031):             self.extra_select_mask = set(names)
0.80 query.py(2032):         self._extra_select_cache = None
0.80 query.py(2062):             self.set_annotation_mask(annotation_names)
0.80 query.py(2013):         if names is None:
0.80 query.py(2016):             self.annotation_select_mask = set(names)
0.80 query.py(2017):         self._annotation_select_cache = None
0.80 query.py(2066):         self.values_select = tuple(field_names)
0.80 query.py(2067):         self.add_fields(field_names, True)
0.80 query.py(1797):         alias = self.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(250):         for alias in self.alias_map:
0.80 query.py(251):             return alias
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 query.py(1798):         opts = self.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 query.py(1800):         try:
0.80 query.py(1801):             cols = []
0.80 query.py(1802):             for name in field_names:
0.80 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.80 query.py(1462):                 if not allow_many:
0.80 query.py(1468):                 last = pathinfos[-1]
0.80 query.py(1469):                 path.extend(pathinfos)
0.80 query.py(1470):                 final_field = last.join_field
0.80 query.py(1471):                 opts = last.to_opts
0.80 query.py(1472):                 targets = last.target_fields
0.80 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.80 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1563):             if join.filtered_relation:
0.80 query.py(1567):                 filtered_relation = None
0.80 query.py(1568):                 table_alias = None
0.80 query.py(1569):             opts = join.to_opts
0.80 query.py(1570):             if join.direct:
0.80 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.80 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(2193):         ) or field.null
0.80 query.py(1574):             connection = Join(
0.80 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.80 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.80 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.80 query.py(1579):             alias = self.join(
0.80 query.py(1580):                 connection, reuse=reuse,
0.80 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(954):             if join.table_alias in reuse_aliases:
0.80 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.80 query.py(960):             self.ref_alias(reuse_alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(961):             return reuse_alias
0.80 query.py(1583):             joins.append(alias)
0.80 query.py(1584):             if filtered_relation:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.80 query.py(1807):                     join_info.targets,
0.80 query.py(1808):                     join_info.joins,
0.80 query.py(1809):                     join_info.path,
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1603):             if len(joins) == 1 or not info.direct:
0.80 query.py(1605):             if info.filtered_relation:
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1609):             if not cur_targets.issubset(join_targets):
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.80 query.py(1613):             self.unref_alias(joins.pop())
0.80 query.py(758):         self.alias_refcount[alias] -= amount
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1811):                 for target in targets:
0.80 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.80 query.py(1525):             return field.get_col(alias)
0.80 query.py(1811):                 for target in targets:
0.80 query.py(1802):             for name in field_names:
0.80 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.80 query.py(1807):                     join_info.targets,
0.80 query.py(1808):                     join_info.joins,
0.80 query.py(1809):                     join_info.path,
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 query.py(1811):                 for target in targets:
0.80 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.80 query.py(1525):             return field.get_col(alias)
0.80 query.py(1811):                 for target in targets:
0.80 query.py(1802):             for name in field_names:
0.80 query.py(1813):             if cols:
0.80 query.py(1814):                 self.set_select(cols)
0.80 query.py(1782):         self.default_cols = False
0.80 query.py(1783):         self.select = tuple(cols)
0.80 query.py(278):         if using is None and connection is None:
0.80 query.py(280):         if using:
0.80 query.py(281):             connection = connections[using]
0.80 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.80 compiler.py(25):         self.query = query
0.80 compiler.py(26):         self.connection = connection
0.80 compiler.py(27):         self.using = using
0.80 compiler.py(28):         self.quote_cache = {'*': '*'}
0.80 compiler.py(33):         self.select = None
0.80 compiler.py(34):         self.annotation_col_map = None
0.80 compiler.py(35):         self.klass_info = None
0.80 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.80 compiler.py(38):         self._meta_ordering = None
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(1046):         if results is None:
0.80 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.80 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.80 compiler.py(1081):         try:
0.80 compiler.py(1082):             sql, params = self.as_sql()
0.80 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.80 compiler.py(479):         try:
0.80 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.80 compiler.py(52):         self.setup_query()
0.80 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.80 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.80 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.80 compiler.py(202):         select = []
0.80 compiler.py(203):         klass_info = None
0.80 compiler.py(204):         annotations = {}
0.80 compiler.py(205):         select_idx = 0
0.80 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.80 compiler.py(211):         if self.query.default_cols:
0.80 compiler.py(216):             cols = self.query.select
0.80 compiler.py(217):         if cols:
0.80 compiler.py(218):             select_list = []
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(220):                 select_list.append(select_idx)
0.80 compiler.py(221):                 select.append((col, None))
0.80 compiler.py(222):                 select_idx += 1
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(220):                 select_list.append(select_idx)
0.80 compiler.py(221):                 select.append((col, None))
0.80 compiler.py(222):                 select_idx += 1
0.80 compiler.py(219):             for col in cols:
0.80 compiler.py(224):                 'model': self.query.model,
0.80 compiler.py(225):                 'select_fields': select_list,
0.80 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(232):         if self.query.select_related:
0.80 compiler.py(244):         ret = []
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(246):             try:
0.80 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.80 compiler.py(251):             ret.append((col, (sql, params), alias))
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(246):             try:
0.80 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.80 compiler.py(251):             ret.append((col, (sql, params), alias))
0.80 compiler.py(245):         for col, alias in select:
0.80 compiler.py(252):         return ret, klass_info, annotations
0.80 compiler.py(44):         self.col_count = len(self.select)
0.80 compiler.py(53):         order_by = self.get_order_by()
0.80 compiler.py(263):         if self.query.extra_order_by:
0.80 compiler.py(265):         elif not self.query.default_ordering:
0.80 compiler.py(267):         elif self.query.order_by:
0.80 compiler.py(269):         elif self.query.get_meta().ordering:
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(270):             ordering = self.query.get_meta().ordering
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(271):             self._meta_ordering = ordering
0.80 compiler.py(274):         if self.query.standard_ordering:
0.80 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.80 compiler.py(279):         order_by = []
0.80 compiler.py(280):         for field in ordering:
0.80 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.80 compiler.py(292):             if field == '?':  # random
0.80 compiler.py(296):             col, order = get_order_dir(field, asc)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(297):             descending = order == 'DESC'
0.80 compiler.py(299):             if col in self.query.annotation_select:
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(305):             if col in self.query.annotations:
0.80 compiler.py(315):             if '.' in field:
0.80 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.80 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.80 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(708):         descending = order == 'DESC'
0.80 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.80 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.80 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.80 query.py(1462):                 if not allow_many:
0.80 query.py(1468):                 last = pathinfos[-1]
0.80 query.py(1469):                 path.extend(pathinfos)
0.80 query.py(1470):                 final_field = last.join_field
0.80 query.py(1471):                 opts = last.to_opts
0.80 query.py(1472):                 targets = last.target_fields
0.80 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.80 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1563):             if join.filtered_relation:
0.80 query.py(1567):                 filtered_relation = None
0.80 query.py(1568):                 table_alias = None
0.80 query.py(1569):             opts = join.to_opts
0.80 query.py(1570):             if join.direct:
0.80 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.80 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(2193):         ) or field.null
0.80 query.py(1574):             connection = Join(
0.80 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.80 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.80 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.80 query.py(1579):             alias = self.join(
0.80 query.py(1580):                 connection, reuse=reuse,
0.80 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(954):             if join.table_alias in reuse_aliases:
0.80 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.80 query.py(960):             self.ref_alias(reuse_alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(961):             return reuse_alias
0.80 query.py(1583):             joins.append(alias)
0.80 query.py(1584):             if filtered_relation:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 compiler.py(741):         alias = joins[-1]
0.80 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.80 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.80 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1603):             if len(joins) == 1 or not info.direct:
0.80 query.py(1605):             if info.filtered_relation:
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1609):             if not cur_targets.issubset(join_targets):
0.80 query.py(1610):                 break
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 query.py(1525):             return field.get_col(alias)
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(280):         for field in ordering:
0.80 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.80 compiler.py(292):             if field == '?':  # random
0.80 compiler.py(296):             col, order = get_order_dir(field, asc)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(297):             descending = order == 'DESC'
0.80 compiler.py(299):             if col in self.query.annotation_select:
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(305):             if col in self.query.annotations:
0.80 compiler.py(315):             if '.' in field:
0.80 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.80 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.80 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(708):         descending = order == 'DESC'
0.80 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.80 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.80 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.80 query.py(1462):                 if not allow_many:
0.80 query.py(1468):                 last = pathinfos[-1]
0.80 query.py(1469):                 path.extend(pathinfos)
0.80 query.py(1470):                 final_field = last.join_field
0.80 query.py(1471):                 opts = last.to_opts
0.80 query.py(1472):                 targets = last.target_fields
0.80 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.80 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1563):             if join.filtered_relation:
0.80 query.py(1567):                 filtered_relation = None
0.80 query.py(1568):                 table_alias = None
0.80 query.py(1569):             opts = join.to_opts
0.80 query.py(1570):             if join.direct:
0.80 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.80 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.80 query.py(2193):         ) or field.null
0.80 query.py(1574):             connection = Join(
0.80 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.80 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.80 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.80 query.py(1579):             alias = self.join(
0.80 query.py(1580):                 connection, reuse=reuse,
0.80 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.80 query.py(943):         if reuse_with_filtered_relation and reuse:
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.80 query.py(950):                 a for a, j in self.alias_map.items()
0.80 query.py(953):         if reuse_aliases:
0.80 query.py(954):             if join.table_alias in reuse_aliases:
0.80 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.80 query.py(960):             self.ref_alias(reuse_alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(961):             return reuse_alias
0.80 query.py(1583):             joins.append(alias)
0.80 query.py(1584):             if filtered_relation:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 compiler.py(741):         alias = joins[-1]
0.80 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.80 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.80 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1603):             if len(joins) == 1 or not info.direct:
0.80 query.py(1605):             if info.filtered_relation:
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1608):             cur_targets = {t.column for t in targets}
0.80 query.py(1609):             if not cur_targets.issubset(join_targets):
0.80 query.py(1610):                 break
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 query.py(1525):             return field.get_col(alias)
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(280):         for field in ordering:
0.80 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.80 compiler.py(292):             if field == '?':  # random
0.80 compiler.py(296):             col, order = get_order_dir(field, asc)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(297):             descending = order == 'DESC'
0.80 compiler.py(299):             if col in self.query.annotation_select:
0.80 query.py(2075):         if self._annotation_select_cache is not None:
0.80 query.py(2077):         elif not self.annotations:
0.80 query.py(2078):             return {}
0.80 compiler.py(305):             if col in self.query.annotations:
0.80 compiler.py(315):             if '.' in field:
0.80 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.80 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.80 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.80 query.py(2204):     dirn = ORDER_DIR[default]
0.80 query.py(2205):     if field[0] == '-':
0.80 query.py(2207):     return field, dirn[0]
0.80 compiler.py(708):         descending = order == 'DESC'
0.80 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.80 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.80 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.80 query.py(912):         if self.alias_map:
0.80 query.py(913):             alias = self.base_table
0.80 query.py(914):             self.ref_alias(alias)
0.80 query.py(754):         self.alias_refcount[alias] += 1
0.80 query.py(917):         return alias
0.80 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.80 query.py(1518):         joins = [alias]
0.80 query.py(1524):         def final_transformer(field, alias):
0.80 query.py(1529):         last_field_exception = None
0.80 query.py(1530):         for pivot in range(len(names), 0, -1):
0.80 query.py(1531):             try:
0.80 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.80 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.80 query.py(1405):         path, names_with_path = [], []
0.80 query.py(1406):         for pos, name in enumerate(names):
0.80 query.py(1407):             cur_names_with_path = (name, [])
0.80 query.py(1408):             if name == 'pk':
0.80 query.py(1411):             field = None
0.80 query.py(1412):             filtered_relation = None
0.80 query.py(1413):             try:
0.80 query.py(1414):                 field = opts.get_field(name)
0.80 query.py(1421):             if field is not None:
0.80 query.py(1425):                 if field.is_relation and not field.related_model:
0.80 query.py(1432):                 try:
0.80 query.py(1433):                     model = field.model._meta.concrete_model
0.80 query.py(1454):             if model is not opts.model:
0.80 query.py(1460):             if hasattr(field, 'get_path_info'):
0.80 query.py(1477):                 final_field = field
0.80 query.py(1478):                 targets = (field,)
0.80 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.80 query.py(1483):                 break
0.80 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.80 query.py(1545):                 transforms = names[pivot:]
0.80 query.py(1546):                 break
0.80 query.py(1547):         for name in transforms:
0.80 query.py(1562):         for join in path:
0.80 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.80 compiler.py(741):         alias = joins[-1]
0.80 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.80 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.80 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.80 query.py(1601):         joins = joins[:]
0.80 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.80 query.py(1614):         return targets, joins[-1], joins
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 query.py(1525):             return field.get_col(alias)
0.80 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.80 compiler.py(280):         for field in ordering:
0.80 compiler.py(340):         result = []
0.80 compiler.py(341):         seen = set()
0.80 compiler.py(343):         for expr, is_ref in order_by:
0.80 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.80 compiler.py(345):             if self.query.combinator:
0.80 compiler.py(365):             sql, params = self.compile(resolved)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.80 compiler.py(371):             params_hash = make_hashable(params)
0.80 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.80 compiler.py(374):             seen.add((without_ordering, params_hash))
0.80 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.80 compiler.py(343):         for expr, is_ref in order_by:
0.80 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.80 compiler.py(345):             if self.query.combinator:
0.80 compiler.py(365):             sql, params = self.compile(resolved)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.80 compiler.py(397):                 name in self.query.extra_select or (
0.80 query.py(2090):         if self._extra_select_cache is not None:
0.80 query.py(2092):         if not self.extra:
0.80 query.py(2093):             return {}
0.80 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.80 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.80 compiler.py(402):         self.quote_cache[name] = r
0.80 compiler.py(403):         return r
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.80 compiler.py(371):             params_hash = make_hashable(params)
0.80 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.80 compiler.py(374):             seen.add((without_ordering, params_hash))
0.80 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.80 compiler.py(343):         for expr, is_ref in order_by:
0.80 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.80 compiler.py(345):             if self.query.combinator:
0.80 compiler.py(365):             sql, params = self.compile(resolved)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.80 compiler.py(371):             params_hash = make_hashable(params)
0.80 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.80 compiler.py(374):             seen.add((without_ordering, params_hash))
0.80 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.80 compiler.py(343):         for expr, is_ref in order_by:
0.80 compiler.py(376):         return result
0.80 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.80 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.80 compiler.py(379):         extra_select = []
0.80 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.80 compiler.py(386):         return extra_select
0.80 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.80 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.80 compiler.py(97):         if self.query.group_by is None:
0.80 compiler.py(98):             return []
0.80 compiler.py(58):         return extra_select, order_by, group_by
0.80 compiler.py(481):             for_update_part = None
0.80 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.80 compiler.py(484):             combinator = self.query.combinator
0.80 compiler.py(485):             features = self.connection.features
0.80 compiler.py(486):             if combinator:
0.80 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.80 compiler.py(683):         result = []
0.80 compiler.py(684):         params = []
0.80 compiler.py(685):         opts = self.query.get_meta()
0.80 query.py(290):         return self.model._meta
0.80 compiler.py(687):         for name in self.query.distinct_fields:
0.80 compiler.py(698):         return result, params
0.80 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.80 compiler.py(755):         result = []
0.80 compiler.py(756):         params = []
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.80 compiler.py(760):             try:
0.80 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.80 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(767):             result.append(clause_sql)
0.80 compiler.py(768):             params.extend(clause_params)
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.80 compiler.py(760):             try:
0.80 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.80 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(767):             result.append(clause_sql)
0.80 compiler.py(768):             params.extend(clause_params)
0.80 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.80 compiler.py(769):         for t in self.query.extra_tables:
0.80 compiler.py(776):         return result, params
0.80 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.80 compiler.py(407):         if vendor_impl:
0.80 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(394):         if name in self.quote_cache:
0.80 compiler.py(395):             return self.quote_cache[name]
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.80 compiler.py(413):         return sql, params
0.80 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.80 compiler.py(497):                 result = ['SELECT']
0.80 compiler.py(498):                 params = []
0.80 compiler.py(500):                 if self.query.distinct:
0.80 compiler.py(508):                 out_cols = []
0.80 compiler.py(509):                 col_idx = 1
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(511):                     if alias:
0.80 compiler.py(513):                     elif with_col_aliases:
0.80 compiler.py(516):                     params.extend(s_params)
0.80 compiler.py(517):                     out_cols.append(s_sql)
0.80 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.80 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.80 compiler.py(520):                 params.extend(f_params)
0.80 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.80 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.80 compiler.py(552):                 if where:
0.80 compiler.py(553):                     result.append('WHERE %s' % where)
0.80 compiler.py(554):                     params.extend(w_params)
0.80 compiler.py(556):                 grouping = []
0.80 compiler.py(557):                 for g_sql, g_params in group_by:
0.80 compiler.py(560):                 if grouping:
0.80 compiler.py(577):                 if having:
0.80 compiler.py(581):             if self.query.explain_query:
0.80 compiler.py(587):             if order_by:
0.80 compiler.py(588):                 ordering = []
0.80 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.80 compiler.py(590):                     ordering.append(o_sql)
0.80 compiler.py(591):                     params.extend(o_params)
0.80 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.80 compiler.py(590):                     ordering.append(o_sql)
0.80 compiler.py(591):                     params.extend(o_params)
0.80 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.80 compiler.py(590):                     ordering.append(o_sql)
0.80 compiler.py(591):                     params.extend(o_params)
0.80 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.80 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.80 compiler.py(594):             if with_limit_offset:
0.80 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.80 compiler.py(600):             if self.query.subquery and extra_select:
0.81 compiler.py(627):             return ' '.join(result), tuple(params)
0.81 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.81 query.py(820):             self.unref_alias(alias, unref_amount)
0.81 query.py(758):         self.alias_refcount[alias] -= amount
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.81 query.py(820):             self.unref_alias(alias, unref_amount)
0.81 query.py(758):         self.alias_refcount[alias] -= amount
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 compiler.py(1083):             if not sql:
0.81 compiler.py(1090):         if chunked_fetch:
0.81 compiler.py(1093):             cursor = self.connection.cursor()
0.81 compiler.py(1094):         try:
0.81 compiler.py(1095):             cursor.execute(sql, params)
0.81 compiler.py(1101):         if result_type == CURSOR:
0.81 compiler.py(1104):         if result_type == SINGLE:
0.81 compiler.py(1113):         if result_type == NO_RESULTS:
0.81 compiler.py(1117):         result = cursor_iter(
0.81 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.81 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.81 compiler.py(1120):             chunk_size,
0.81 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.81 compiler.py(1123):             try:
0.81 compiler.py(1128):                 return list(result)
0.81 compiler.py(1518):     try:
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1522):         cursor.close()
0.81 compiler.py(1131):                 cursor.close()
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1049):         converters = self.get_converters(fields)
0.81 compiler.py(1023):         converters = {}
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1030):         return converters
0.81 compiler.py(1050):         rows = chain.from_iterable(results)
0.81 compiler.py(1051):         if converters:
0.81 compiler.py(1055):         return rows
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(278):         if using is None and connection is None:
0.81 query.py(280):         if using:
0.81 query.py(281):             connection = connections[using]
0.81 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.81 compiler.py(25):         self.query = query
0.81 compiler.py(26):         self.connection = connection
0.81 compiler.py(27):         self.using = using
0.81 compiler.py(28):         self.quote_cache = {'*': '*'}
0.81 compiler.py(33):         self.select = None
0.81 compiler.py(34):         self.annotation_col_map = None
0.81 compiler.py(35):         self.klass_info = None
0.81 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.81 compiler.py(38):         self._meta_ordering = None
0.81 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.81 compiler.py(1333):         self.return_id = return_id
0.81 compiler.py(1334):         with self.connection.cursor() as cursor:
0.81 compiler.py(1335):             for sql, params in self.as_sql():
0.81 compiler.py(1269):         qn = self.connection.ops.quote_name
0.81 compiler.py(1270):         opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.81 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.81 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1276):         if self.query.fields:
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.81 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.81 compiler.py(1243):         if not value_rows:
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1264):         return placeholder_rows, param_rows
0.81 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.81 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.81 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.81 compiler.py(1315):         if can_bulk:
0.81 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.81 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1336):                 cursor.execute(sql, params)
0.81 compiler.py(1335):             for sql, params in self.as_sql():
0.81 compiler.py(1337):             if not return_id:
0.81 compiler.py(1338):                 return
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(1758):         return not self.low_mark and self.high_mark is None
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.81 query.py(1331):         connector = q_object.connector
0.81 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.81 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.81 query.py(1334):         target_clause = self.where_class(connector=connector,
0.81 query.py(1335):                                          negated=q_object.negated)
0.81 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.81 query.py(2236):         self.connector = connector
0.81 query.py(2237):         self.negated = negated
0.81 query.py(2238):         if self.negated:
0.81 query.py(2244):             self.effective_connector = self.connector
0.81 query.py(2245):         self.num_children = num_children
0.81 query.py(2248):         self.votes = Counter()
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1338):             if isinstance(child, Node):
0.81 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.81 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.81 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.81 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.81 query.py(1214):         if isinstance(filter_expr, dict):
0.81 query.py(1216):         arg, value = filter_expr
0.81 query.py(1217):         if not arg:
0.81 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.81 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.81 query.py(1074):         if self.annotations:
0.81 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.81 query.py(290):         return self.model._meta
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.81 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.81 query.py(1085):         return lookup_parts, field_parts, False
0.81 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.81 query.py(1227):         if not allow_joins and len(parts) > 1:
0.81 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.81 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.81 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.81 query.py(1055):         elif isinstance(value, (list, tuple)):
0.81 query.py(1067):         return value
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1234):         clause = self.where_class()
0.81 query.py(1235):         if reffed_expression:
0.81 query.py(1240):         opts = self.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 query.py(1241):         alias = self.get_initial_alias()
0.81 query.py(912):         if self.alias_map:
0.81 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.81 query.py(290):         return self.model._meta
0.81 query.py(943):         if reuse_with_filtered_relation and reuse:
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(953):         if reuse_aliases:
0.81 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.81 query.py(735):         alias_list = self.table_map.get(table_name)
0.81 query.py(736):         if not create and alias_list:
0.81 query.py(742):         if alias_list:
0.81 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.81 query.py(748):             self.table_map[table_name] = [alias]
0.81 query.py(749):         self.alias_refcount[alias] = 1
0.81 query.py(750):         return alias, True
0.81 query.py(965):         if join.join_type:
0.81 query.py(971):         join.table_alias = alias
0.81 query.py(972):         self.alias_map[alias] = join
0.81 query.py(973):         return alias
0.81 query.py(917):         return alias
0.81 query.py(1242):         allow_many = not branch_negated or not split_subq
0.81 query.py(1244):         try:
0.81 query.py(1245):             join_info = self.setup_joins(
0.81 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.81 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.81 query.py(1518):         joins = [alias]
0.81 query.py(1524):         def final_transformer(field, alias):
0.81 query.py(1529):         last_field_exception = None
0.81 query.py(1530):         for pivot in range(len(names), 0, -1):
0.81 query.py(1531):             try:
0.81 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.81 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1545):                 transforms = names[pivot:]
0.81 query.py(1546):                 break
0.81 query.py(1547):         for name in transforms:
0.81 query.py(1562):         for join in path:
0.81 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.81 query.py(1251):             if isinstance(value, Iterator):
0.81 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.81 query.py(1100):         if field.is_relation:
0.81 query.py(1257):             self._lookup_joins = join_info.joins
0.81 query.py(1263):         used_joins.update(join_info.joins)
0.81 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.81 query.py(1601):         joins = joins[:]
0.81 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.81 query.py(1614):         return targets, joins[-1], joins
0.81 query.py(1265):         if can_reuse is not None:
0.81 query.py(1266):             can_reuse.update(join_list)
0.81 query.py(1268):         if join_info.final_field.is_relation:
0.81 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.81 query.py(72):     if simple_col:
0.81 query.py(74):     return target.get_col(alias, field)
0.81 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.81 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.81 query.py(1129):         for name in transforms:
0.81 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.81 query.py(1134):         if not lookup_class:
0.81 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.81 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.81 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.81 query.py(1161):         return lookup
0.81 query.py(1281):         lookup_type = condition.lookup_name
0.81 query.py(1282):         clause.add(condition, AND)
0.81 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.81 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.81 query.py(1302):         return clause, used_joins if not require_outer else ()
0.81 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.81 query.py(2255):         self.votes.update(votes)
0.81 query.py(1350):             if child_clause:
0.81 query.py(1351):                 target_clause.add(child_clause, connector)
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.81 query.py(2264):         to_promote = set()
0.81 query.py(2265):         to_demote = set()
0.81 query.py(2268):         for table, votes in self.votes.items():
0.81 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.81 query.py(2291):             if self.effective_connector == 'AND' or (
0.81 query.py(2293):                 to_demote.add(table)
0.81 query.py(2268):         for table, votes in self.votes.items():
0.81 query.py(2309):         query.promote_joins(to_promote)
0.81 query.py(771):         aliases = list(aliases)
0.81 query.py(772):         while aliases:
0.81 query.py(2310):         query.demote_joins(to_demote)
0.81 query.py(804):         aliases = list(aliases)
0.81 query.py(805):         while aliases:
0.81 query.py(806):             alias = aliases.pop(0)
0.81 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.81 query.py(805):         while aliases:
0.81 query.py(2311):         return to_demote
0.81 query.py(1353):         return target_clause, needed_inner
0.81 query.py(1320):         if clause:
0.81 query.py(1321):             self.where.add(clause, AND)
0.81 query.py(1322):         self.demote_joins(existing_inner)
0.81 query.py(804):         aliases = list(aliases)
0.81 query.py(805):         while aliases:
0.81 query.py(278):         if using is None and connection is None:
0.81 query.py(280):         if using:
0.81 query.py(281):             connection = connections[using]
0.81 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.81 compiler.py(25):         self.query = query
0.81 compiler.py(26):         self.connection = connection
0.81 compiler.py(27):         self.using = using
0.81 compiler.py(28):         self.quote_cache = {'*': '*'}
0.81 compiler.py(33):         self.select = None
0.81 compiler.py(34):         self.annotation_col_map = None
0.81 compiler.py(35):         self.klass_info = None
0.81 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.81 compiler.py(38):         self._meta_ordering = None
0.81 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.81 compiler.py(1081):         try:
0.81 compiler.py(1082):             sql, params = self.as_sql()
0.81 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.81 compiler.py(479):         try:
0.81 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.81 compiler.py(52):         self.setup_query()
0.81 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.81 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.81 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.81 compiler.py(202):         select = []
0.81 compiler.py(203):         klass_info = None
0.81 compiler.py(204):         annotations = {}
0.81 compiler.py(205):         select_idx = 0
0.81 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.81 compiler.py(211):         if self.query.default_cols:
0.81 compiler.py(212):             cols = self.get_default_columns()
0.81 compiler.py(644):         result = []
0.81 compiler.py(645):         if opts is None:
0.81 compiler.py(646):             opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(647):         only_load = self.deferred_to_columns()
0.81 compiler.py(1018):         columns = {}
0.81 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.81 query.py(655):         field_names, defer = self.deferred_loading
0.81 query.py(656):         if not field_names:
0.81 query.py(657):             return
0.81 compiler.py(1020):         return columns
0.81 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.81 query.py(912):         if self.alias_map:
0.81 query.py(913):             alias = self.base_table
0.81 query.py(250):         for alias in self.alias_map:
0.81 query.py(251):             return alias
0.81 query.py(914):             self.ref_alias(alias)
0.81 query.py(754):         self.alias_refcount[alias] += 1
0.81 query.py(917):         return alias
0.81 compiler.py(652):         seen_models = {None: start_alias}
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(674):         return result
0.81 compiler.py(217):         if cols:
0.81 compiler.py(218):             select_list = []
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(224):                 'model': self.query.model,
0.81 compiler.py(225):                 'select_fields': select_list,
0.81 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.81 query.py(2075):         if self._annotation_select_cache is not None:
0.81 query.py(2077):         elif not self.annotations:
0.81 query.py(2078):             return {}
0.81 compiler.py(232):         if self.query.select_related:
0.81 compiler.py(244):         ret = []
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(252):         return ret, klass_info, annotations
0.81 compiler.py(44):         self.col_count = len(self.select)
0.81 compiler.py(53):         order_by = self.get_order_by()
0.81 compiler.py(263):         if self.query.extra_order_by:
0.81 compiler.py(265):         elif not self.query.default_ordering:
0.81 compiler.py(267):         elif self.query.order_by:
0.81 compiler.py(269):         elif self.query.get_meta().ordering:
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(273):             ordering = []
0.81 compiler.py(274):         if self.query.standard_ordering:
0.81 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.81 compiler.py(279):         order_by = []
0.81 compiler.py(280):         for field in ordering:
0.81 compiler.py(340):         result = []
0.81 compiler.py(341):         seen = set()
0.81 compiler.py(343):         for expr, is_ref in order_by:
0.81 compiler.py(376):         return result
0.81 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.81 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.81 compiler.py(379):         extra_select = []
0.81 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.81 compiler.py(386):         return extra_select
0.81 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.81 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.81 compiler.py(97):         if self.query.group_by is None:
0.81 compiler.py(98):             return []
0.81 compiler.py(58):         return extra_select, order_by, group_by
0.81 compiler.py(481):             for_update_part = None
0.81 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.81 compiler.py(484):             combinator = self.query.combinator
0.81 compiler.py(485):             features = self.connection.features
0.81 compiler.py(486):             if combinator:
0.81 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.81 compiler.py(683):         result = []
0.81 compiler.py(684):         params = []
0.81 compiler.py(685):         opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(687):         for name in self.query.distinct_fields:
0.81 compiler.py(698):         return result, params
0.81 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.81 compiler.py(755):         result = []
0.81 compiler.py(756):         params = []
0.81 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.81 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.81 compiler.py(760):             try:
0.81 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.81 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(767):             result.append(clause_sql)
0.81 compiler.py(768):             params.extend(clause_params)
0.81 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.81 compiler.py(769):         for t in self.query.extra_tables:
0.81 compiler.py(776):         return result, params
0.81 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.81 compiler.py(497):                 result = ['SELECT']
0.81 compiler.py(498):                 params = []
0.81 compiler.py(500):                 if self.query.distinct:
0.81 compiler.py(508):                 out_cols = []
0.81 compiler.py(509):                 col_idx = 1
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.81 compiler.py(520):                 params.extend(f_params)
0.81 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.81 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.81 compiler.py(552):                 if where:
0.81 compiler.py(553):                     result.append('WHERE %s' % where)
0.81 compiler.py(554):                     params.extend(w_params)
0.81 compiler.py(556):                 grouping = []
0.81 compiler.py(557):                 for g_sql, g_params in group_by:
0.81 compiler.py(560):                 if grouping:
0.81 compiler.py(577):                 if having:
0.81 compiler.py(581):             if self.query.explain_query:
0.81 compiler.py(587):             if order_by:
0.81 compiler.py(594):             if with_limit_offset:
0.81 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.81 compiler.py(600):             if self.query.subquery and extra_select:
0.81 compiler.py(627):             return ' '.join(result), tuple(params)
0.81 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.81 query.py(820):             self.unref_alias(alias, unref_amount)
0.81 query.py(758):         self.alias_refcount[alias] -= amount
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 compiler.py(1083):             if not sql:
0.81 compiler.py(1090):         if chunked_fetch:
0.81 compiler.py(1093):             cursor = self.connection.cursor()
0.81 compiler.py(1094):         try:
0.81 compiler.py(1095):             cursor.execute(sql, params)
0.81 compiler.py(1101):         if result_type == CURSOR:
0.81 compiler.py(1104):         if result_type == SINGLE:
0.81 compiler.py(1113):         if result_type == NO_RESULTS:
0.81 compiler.py(1117):         result = cursor_iter(
0.81 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.81 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.81 compiler.py(1120):             chunk_size,
0.81 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.81 compiler.py(1123):             try:
0.81 compiler.py(1128):                 return list(result)
0.81 compiler.py(1518):     try:
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1522):         cursor.close()
0.81 compiler.py(1131):                 cursor.close()
0.81 compiler.py(1046):         if results is None:
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1049):         converters = self.get_converters(fields)
0.81 compiler.py(1023):         converters = {}
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1030):         return converters
0.81 compiler.py(1050):         rows = chain.from_iterable(results)
0.81 compiler.py(1051):         if converters:
0.81 compiler.py(1055):         return rows
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(278):         if using is None and connection is None:
0.81 query.py(280):         if using:
0.81 query.py(281):             connection = connections[using]
0.81 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.81 compiler.py(25):         self.query = query
0.81 compiler.py(26):         self.connection = connection
0.81 compiler.py(27):         self.using = using
0.81 compiler.py(28):         self.quote_cache = {'*': '*'}
0.81 compiler.py(33):         self.select = None
0.81 compiler.py(34):         self.annotation_col_map = None
0.81 compiler.py(35):         self.klass_info = None
0.81 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.81 compiler.py(38):         self._meta_ordering = None
0.81 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.81 compiler.py(1333):         self.return_id = return_id
0.81 compiler.py(1334):         with self.connection.cursor() as cursor:
0.81 compiler.py(1335):             for sql, params in self.as_sql():
0.81 compiler.py(1269):         qn = self.connection.ops.quote_name
0.81 compiler.py(1270):         opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.81 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.81 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.81 compiler.py(1276):         if self.query.fields:
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1279):                 for obj in self.query.objs
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1227):         if self.query.raw:
0.81 compiler.py(1229):         return field.pre_save(obj, add=True)
0.81 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.81 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.81 compiler.py(1220):         return value
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.81 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.81 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.81 compiler.py(1243):         if not value_rows:
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1250):             for row in value_rows
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1170):         if field is None:
0.81 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.81 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.81 compiler.py(1182):             sql, params = '%s', [val]
0.81 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.81 compiler.py(1191):         return sql, params
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.81 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.81 compiler.py(1264):         return placeholder_rows, param_rows
0.81 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.81 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.81 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.81 compiler.py(1315):         if can_bulk:
0.81 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.81 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.81 compiler.py(1336):                 cursor.execute(sql, params)
0.81 compiler.py(1335):             for sql, params in self.as_sql():
0.81 compiler.py(1337):             if not return_id:
0.81 compiler.py(1338):                 return
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(1758):         return not self.low_mark and self.high_mark is None
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.81 query.py(1331):         connector = q_object.connector
0.81 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.81 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.81 query.py(1334):         target_clause = self.where_class(connector=connector,
0.81 query.py(1335):                                          negated=q_object.negated)
0.81 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.81 query.py(2236):         self.connector = connector
0.81 query.py(2237):         self.negated = negated
0.81 query.py(2238):         if self.negated:
0.81 query.py(2244):             self.effective_connector = self.connector
0.81 query.py(2245):         self.num_children = num_children
0.81 query.py(2248):         self.votes = Counter()
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1338):             if isinstance(child, Node):
0.81 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.81 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.81 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.81 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.81 query.py(1214):         if isinstance(filter_expr, dict):
0.81 query.py(1216):         arg, value = filter_expr
0.81 query.py(1217):         if not arg:
0.81 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.81 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.81 query.py(1074):         if self.annotations:
0.81 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.81 query.py(290):         return self.model._meta
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.81 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.81 query.py(1085):         return lookup_parts, field_parts, False
0.81 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.81 query.py(1227):         if not allow_joins and len(parts) > 1:
0.81 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.81 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.81 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.81 query.py(1055):         elif isinstance(value, (list, tuple)):
0.81 query.py(1067):         return value
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1234):         clause = self.where_class()
0.81 query.py(1235):         if reffed_expression:
0.81 query.py(1240):         opts = self.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 query.py(1241):         alias = self.get_initial_alias()
0.81 query.py(912):         if self.alias_map:
0.81 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.81 query.py(290):         return self.model._meta
0.81 query.py(943):         if reuse_with_filtered_relation and reuse:
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(953):         if reuse_aliases:
0.81 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.81 query.py(735):         alias_list = self.table_map.get(table_name)
0.81 query.py(736):         if not create and alias_list:
0.81 query.py(742):         if alias_list:
0.81 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.81 query.py(748):             self.table_map[table_name] = [alias]
0.81 query.py(749):         self.alias_refcount[alias] = 1
0.81 query.py(750):         return alias, True
0.81 query.py(965):         if join.join_type:
0.81 query.py(971):         join.table_alias = alias
0.81 query.py(972):         self.alias_map[alias] = join
0.81 query.py(973):         return alias
0.81 query.py(917):         return alias
0.81 query.py(1242):         allow_many = not branch_negated or not split_subq
0.81 query.py(1244):         try:
0.81 query.py(1245):             join_info = self.setup_joins(
0.81 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.81 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.81 query.py(1518):         joins = [alias]
0.81 query.py(1524):         def final_transformer(field, alias):
0.81 query.py(1529):         last_field_exception = None
0.81 query.py(1530):         for pivot in range(len(names), 0, -1):
0.81 query.py(1531):             try:
0.81 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.81 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1545):                 transforms = names[pivot:]
0.81 query.py(1546):                 break
0.81 query.py(1547):         for name in transforms:
0.81 query.py(1562):         for join in path:
0.81 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.81 query.py(1251):             if isinstance(value, Iterator):
0.81 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.81 query.py(1100):         if field.is_relation:
0.81 query.py(1257):             self._lookup_joins = join_info.joins
0.81 query.py(1263):         used_joins.update(join_info.joins)
0.81 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.81 query.py(1601):         joins = joins[:]
0.81 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.81 query.py(1614):         return targets, joins[-1], joins
0.81 query.py(1265):         if can_reuse is not None:
0.81 query.py(1266):             can_reuse.update(join_list)
0.81 query.py(1268):         if join_info.final_field.is_relation:
0.81 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.81 query.py(72):     if simple_col:
0.81 query.py(74):     return target.get_col(alias, field)
0.81 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.81 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.81 query.py(1129):         for name in transforms:
0.81 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.81 query.py(1134):         if not lookup_class:
0.81 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.81 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.81 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.81 query.py(1161):         return lookup
0.81 query.py(1281):         lookup_type = condition.lookup_name
0.81 query.py(1282):         clause.add(condition, AND)
0.81 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.81 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.81 query.py(1302):         return clause, used_joins if not require_outer else ()
0.81 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.81 query.py(2255):         self.votes.update(votes)
0.81 query.py(1350):             if child_clause:
0.81 query.py(1351):                 target_clause.add(child_clause, connector)
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.81 query.py(2264):         to_promote = set()
0.81 query.py(2265):         to_demote = set()
0.81 query.py(2268):         for table, votes in self.votes.items():
0.81 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.81 query.py(2291):             if self.effective_connector == 'AND' or (
0.81 query.py(2293):                 to_demote.add(table)
0.81 query.py(2268):         for table, votes in self.votes.items():
0.81 query.py(2309):         query.promote_joins(to_promote)
0.81 query.py(771):         aliases = list(aliases)
0.81 query.py(772):         while aliases:
0.81 query.py(2310):         query.demote_joins(to_demote)
0.81 query.py(804):         aliases = list(aliases)
0.81 query.py(805):         while aliases:
0.81 query.py(806):             alias = aliases.pop(0)
0.81 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.81 query.py(805):         while aliases:
0.81 query.py(2311):         return to_demote
0.81 query.py(1353):         return target_clause, needed_inner
0.81 query.py(1320):         if clause:
0.81 query.py(1321):             self.where.add(clause, AND)
0.81 query.py(1322):         self.demote_joins(existing_inner)
0.81 query.py(804):         aliases = list(aliases)
0.81 query.py(805):         while aliases:
0.81 query.py(278):         if using is None and connection is None:
0.81 query.py(280):         if using:
0.81 query.py(281):             connection = connections[using]
0.81 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.81 compiler.py(25):         self.query = query
0.81 compiler.py(26):         self.connection = connection
0.81 compiler.py(27):         self.using = using
0.81 compiler.py(28):         self.quote_cache = {'*': '*'}
0.81 compiler.py(33):         self.select = None
0.81 compiler.py(34):         self.annotation_col_map = None
0.81 compiler.py(35):         self.klass_info = None
0.81 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.81 compiler.py(38):         self._meta_ordering = None
0.81 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.81 compiler.py(1081):         try:
0.81 compiler.py(1082):             sql, params = self.as_sql()
0.81 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.81 compiler.py(479):         try:
0.81 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.81 compiler.py(52):         self.setup_query()
0.81 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.81 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.81 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.81 compiler.py(202):         select = []
0.81 compiler.py(203):         klass_info = None
0.81 compiler.py(204):         annotations = {}
0.81 compiler.py(205):         select_idx = 0
0.81 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.81 compiler.py(211):         if self.query.default_cols:
0.81 compiler.py(212):             cols = self.get_default_columns()
0.81 compiler.py(644):         result = []
0.81 compiler.py(645):         if opts is None:
0.81 compiler.py(646):             opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(647):         only_load = self.deferred_to_columns()
0.81 compiler.py(1018):         columns = {}
0.81 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.81 query.py(655):         field_names, defer = self.deferred_loading
0.81 query.py(656):         if not field_names:
0.81 query.py(657):             return
0.81 compiler.py(1020):         return columns
0.81 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.81 query.py(912):         if self.alias_map:
0.81 query.py(913):             alias = self.base_table
0.81 query.py(250):         for alias in self.alias_map:
0.81 query.py(251):             return alias
0.81 query.py(914):             self.ref_alias(alias)
0.81 query.py(754):         self.alias_refcount[alias] += 1
0.81 query.py(917):         return alias
0.81 compiler.py(652):         seen_models = {None: start_alias}
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(655):             model = field.model._meta.concrete_model
0.81 compiler.py(658):             if model == opts.model:
0.81 compiler.py(659):                 model = None
0.81 compiler.py(660):             if from_parent and model is not None and issubclass(
0.81 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.81 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.81 compiler.py(671):                                                  seen_models)
0.81 query.py(984):         if model in seen:
0.81 query.py(985):             return seen[model]
0.81 compiler.py(672):             column = field.get_col(alias)
0.81 compiler.py(673):             result.append(column)
0.81 compiler.py(654):         for field in opts.concrete_fields:
0.81 compiler.py(674):         return result
0.81 compiler.py(217):         if cols:
0.81 compiler.py(218):             select_list = []
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(220):                 select_list.append(select_idx)
0.81 compiler.py(221):                 select.append((col, None))
0.81 compiler.py(222):                 select_idx += 1
0.81 compiler.py(219):             for col in cols:
0.81 compiler.py(224):                 'model': self.query.model,
0.81 compiler.py(225):                 'select_fields': select_list,
0.81 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.81 query.py(2075):         if self._annotation_select_cache is not None:
0.81 query.py(2077):         elif not self.annotations:
0.81 query.py(2078):             return {}
0.81 compiler.py(232):         if self.query.select_related:
0.81 compiler.py(244):         ret = []
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(246):             try:
0.81 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.81 compiler.py(397):                 name in self.query.extra_select or (
0.81 query.py(2090):         if self._extra_select_cache is not None:
0.81 query.py(2092):         if not self.extra:
0.81 query.py(2093):             return {}
0.81 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.81 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.81 compiler.py(402):         self.quote_cache[name] = r
0.81 compiler.py(403):         return r
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.81 compiler.py(251):             ret.append((col, (sql, params), alias))
0.81 compiler.py(245):         for col, alias in select:
0.81 compiler.py(252):         return ret, klass_info, annotations
0.81 compiler.py(44):         self.col_count = len(self.select)
0.81 compiler.py(53):         order_by = self.get_order_by()
0.81 compiler.py(263):         if self.query.extra_order_by:
0.81 compiler.py(265):         elif not self.query.default_ordering:
0.81 compiler.py(267):         elif self.query.order_by:
0.81 compiler.py(269):         elif self.query.get_meta().ordering:
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(273):             ordering = []
0.81 compiler.py(274):         if self.query.standard_ordering:
0.81 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.81 compiler.py(279):         order_by = []
0.81 compiler.py(280):         for field in ordering:
0.81 compiler.py(340):         result = []
0.81 compiler.py(341):         seen = set()
0.81 compiler.py(343):         for expr, is_ref in order_by:
0.81 compiler.py(376):         return result
0.81 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.81 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.81 compiler.py(379):         extra_select = []
0.81 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.81 compiler.py(386):         return extra_select
0.81 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.81 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.81 compiler.py(97):         if self.query.group_by is None:
0.81 compiler.py(98):             return []
0.81 compiler.py(58):         return extra_select, order_by, group_by
0.81 compiler.py(481):             for_update_part = None
0.81 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.81 compiler.py(484):             combinator = self.query.combinator
0.81 compiler.py(485):             features = self.connection.features
0.81 compiler.py(486):             if combinator:
0.81 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.81 compiler.py(683):         result = []
0.81 compiler.py(684):         params = []
0.81 compiler.py(685):         opts = self.query.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 compiler.py(687):         for name in self.query.distinct_fields:
0.81 compiler.py(698):         return result, params
0.81 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.81 compiler.py(755):         result = []
0.81 compiler.py(756):         params = []
0.81 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.81 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.81 compiler.py(760):             try:
0.81 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.81 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(767):             result.append(clause_sql)
0.81 compiler.py(768):             params.extend(clause_params)
0.81 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.81 compiler.py(769):         for t in self.query.extra_tables:
0.81 compiler.py(776):         return result, params
0.81 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.81 compiler.py(407):         if vendor_impl:
0.81 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(394):         if name in self.quote_cache:
0.81 compiler.py(395):             return self.quote_cache[name]
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.81 compiler.py(413):         return sql, params
0.81 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.81 compiler.py(497):                 result = ['SELECT']
0.81 compiler.py(498):                 params = []
0.81 compiler.py(500):                 if self.query.distinct:
0.81 compiler.py(508):                 out_cols = []
0.81 compiler.py(509):                 col_idx = 1
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(511):                     if alias:
0.81 compiler.py(513):                     elif with_col_aliases:
0.81 compiler.py(516):                     params.extend(s_params)
0.81 compiler.py(517):                     out_cols.append(s_sql)
0.81 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.81 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.81 compiler.py(520):                 params.extend(f_params)
0.81 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.81 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.81 compiler.py(552):                 if where:
0.81 compiler.py(553):                     result.append('WHERE %s' % where)
0.81 compiler.py(554):                     params.extend(w_params)
0.81 compiler.py(556):                 grouping = []
0.81 compiler.py(557):                 for g_sql, g_params in group_by:
0.81 compiler.py(560):                 if grouping:
0.81 compiler.py(577):                 if having:
0.81 compiler.py(581):             if self.query.explain_query:
0.81 compiler.py(587):             if order_by:
0.81 compiler.py(594):             if with_limit_offset:
0.81 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.81 compiler.py(600):             if self.query.subquery and extra_select:
0.81 compiler.py(627):             return ' '.join(result), tuple(params)
0.81 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.81 query.py(820):             self.unref_alias(alias, unref_amount)
0.81 query.py(758):         self.alias_refcount[alias] -= amount
0.81 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.81 compiler.py(1083):             if not sql:
0.81 compiler.py(1090):         if chunked_fetch:
0.81 compiler.py(1093):             cursor = self.connection.cursor()
0.81 compiler.py(1094):         try:
0.81 compiler.py(1095):             cursor.execute(sql, params)
0.81 compiler.py(1101):         if result_type == CURSOR:
0.81 compiler.py(1104):         if result_type == SINGLE:
0.81 compiler.py(1113):         if result_type == NO_RESULTS:
0.81 compiler.py(1117):         result = cursor_iter(
0.81 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.81 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.81 compiler.py(1120):             chunk_size,
0.81 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.81 compiler.py(1123):             try:
0.81 compiler.py(1128):                 return list(result)
0.81 compiler.py(1518):     try:
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.81 compiler.py(1522):         cursor.close()
0.81 compiler.py(1131):                 cursor.close()
0.81 compiler.py(1046):         if results is None:
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.81 compiler.py(1049):         converters = self.get_converters(fields)
0.81 compiler.py(1023):         converters = {}
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1025):             if expression:
0.81 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.81 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.81 compiler.py(1028):                 if backend_converters or field_converters:
0.81 compiler.py(1024):         for i, expression in enumerate(expressions):
0.81 compiler.py(1030):         return converters
0.81 compiler.py(1050):         rows = chain.from_iterable(results)
0.81 compiler.py(1051):         if converters:
0.81 compiler.py(1055):         return rows
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(154):         self.model = model
0.81 query.py(155):         self.alias_refcount = {}
0.81 query.py(161):         self.alias_map = {}
0.81 query.py(165):         self.external_aliases = set()
0.81 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.81 query.py(167):         self.default_cols = True
0.81 query.py(168):         self.default_ordering = True
0.81 query.py(169):         self.standard_ordering = True
0.81 query.py(170):         self.used_aliases = set()
0.81 query.py(171):         self.filter_is_sticky = False
0.81 query.py(172):         self.subquery = False
0.81 query.py(180):         self.select = ()
0.81 query.py(181):         self.where = where()
0.81 query.py(182):         self.where_class = where
0.81 query.py(189):         self.group_by = None
0.81 query.py(190):         self.order_by = ()
0.81 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.81 query.py(192):         self.distinct = False
0.81 query.py(193):         self.distinct_fields = ()
0.81 query.py(194):         self.select_for_update = False
0.81 query.py(195):         self.select_for_update_nowait = False
0.81 query.py(196):         self.select_for_update_skip_locked = False
0.81 query.py(197):         self.select_for_update_of = ()
0.81 query.py(199):         self.select_related = False
0.81 query.py(201):         self.max_depth = 5
0.81 query.py(205):         self.values_select = ()
0.81 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.81 query.py(209):         self.annotation_select_mask = None
0.81 query.py(210):         self._annotation_select_cache = None
0.81 query.py(213):         self.combinator = None
0.81 query.py(214):         self.combinator_all = False
0.81 query.py(215):         self.combined_queries = ()
0.81 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.81 query.py(220):         self.extra_select_mask = None
0.81 query.py(221):         self._extra_select_cache = None
0.81 query.py(223):         self.extra_tables = ()
0.81 query.py(224):         self.extra_order_by = ()
0.81 query.py(229):         self.deferred_loading = (frozenset(), True)
0.81 query.py(231):         self._filtered_relations = {}
0.81 query.py(233):         self.explain_query = False
0.81 query.py(234):         self.explain_format = None
0.81 query.py(235):         self.explain_options = {}
0.81 query.py(1758):         return not self.low_mark and self.high_mark is None
0.81 query.py(343):         obj = self.clone()
0.81 query.py(297):         obj = Empty()
0.81 query.py(298):         obj.__class__ = self.__class__
0.81 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.81 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.81 query.py(303):         obj.alias_map = self.alias_map.copy()
0.81 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.81 query.py(305):         obj.table_map = self.table_map.copy()
0.81 query.py(306):         obj.where = self.where.clone()
0.81 query.py(307):         obj.annotations = self.annotations.copy()
0.81 query.py(308):         if self.annotation_select_mask is None:
0.81 query.py(309):             obj.annotation_select_mask = None
0.81 query.py(317):         obj._annotation_select_cache = None
0.81 query.py(318):         obj.extra = self.extra.copy()
0.81 query.py(319):         if self.extra_select_mask is None:
0.81 query.py(320):             obj.extra_select_mask = None
0.81 query.py(323):         if self._extra_select_cache is None:
0.81 query.py(324):             obj._extra_select_cache = None
0.81 query.py(327):         if 'subq_aliases' in self.__dict__:
0.81 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.81 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.81 query.py(332):         try:
0.81 query.py(333):             del obj.base_table
0.81 query.py(334):         except AttributeError:
0.81 query.py(335):             pass
0.81 query.py(336):         return obj
0.81 query.py(344):         if klass and obj.__class__ != klass:
0.81 query.py(346):         if not obj.filter_is_sticky:
0.81 query.py(347):             obj.used_aliases = set()
0.81 query.py(348):         obj.filter_is_sticky = False
0.81 query.py(349):         if hasattr(obj, '_setup_query'):
0.81 query.py(351):         return obj
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.81 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.81 query.py(1331):         connector = q_object.connector
0.81 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.81 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.81 query.py(1334):         target_clause = self.where_class(connector=connector,
0.81 query.py(1335):                                          negated=q_object.negated)
0.81 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.81 query.py(2236):         self.connector = connector
0.81 query.py(2237):         self.negated = negated
0.81 query.py(2238):         if self.negated:
0.81 query.py(2244):             self.effective_connector = self.connector
0.81 query.py(2245):         self.num_children = num_children
0.81 query.py(2248):         self.votes = Counter()
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1338):             if isinstance(child, Node):
0.81 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.81 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.81 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.81 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.81 query.py(1214):         if isinstance(filter_expr, dict):
0.81 query.py(1216):         arg, value = filter_expr
0.81 query.py(1217):         if not arg:
0.81 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.81 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.81 query.py(1074):         if self.annotations:
0.81 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.81 query.py(290):         return self.model._meta
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.81 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.81 query.py(1085):         return lookup_parts, field_parts, False
0.81 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.81 query.py(1227):         if not allow_joins and len(parts) > 1:
0.81 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.81 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.81 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.81 query.py(1055):         elif isinstance(value, (list, tuple)):
0.81 query.py(1067):         return value
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1234):         clause = self.where_class()
0.81 query.py(1235):         if reffed_expression:
0.81 query.py(1240):         opts = self.get_meta()
0.81 query.py(290):         return self.model._meta
0.81 query.py(1241):         alias = self.get_initial_alias()
0.81 query.py(912):         if self.alias_map:
0.81 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.81 query.py(290):         return self.model._meta
0.81 query.py(943):         if reuse_with_filtered_relation and reuse:
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(950):                 a for a, j in self.alias_map.items()
0.81 query.py(953):         if reuse_aliases:
0.81 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.81 query.py(735):         alias_list = self.table_map.get(table_name)
0.81 query.py(736):         if not create and alias_list:
0.81 query.py(742):         if alias_list:
0.81 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.81 query.py(748):             self.table_map[table_name] = [alias]
0.81 query.py(749):         self.alias_refcount[alias] = 1
0.81 query.py(750):         return alias, True
0.81 query.py(965):         if join.join_type:
0.81 query.py(971):         join.table_alias = alias
0.81 query.py(972):         self.alias_map[alias] = join
0.81 query.py(973):         return alias
0.81 query.py(917):         return alias
0.81 query.py(1242):         allow_many = not branch_negated or not split_subq
0.81 query.py(1244):         try:
0.81 query.py(1245):             join_info = self.setup_joins(
0.81 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.81 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.81 query.py(1518):         joins = [alias]
0.81 query.py(1524):         def final_transformer(field, alias):
0.81 query.py(1529):         last_field_exception = None
0.81 query.py(1530):         for pivot in range(len(names), 0, -1):
0.81 query.py(1531):             try:
0.81 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.81 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1545):                 transforms = names[pivot:]
0.81 query.py(1546):                 break
0.81 query.py(1547):         for name in transforms:
0.81 query.py(1562):         for join in path:
0.81 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.81 query.py(1251):             if isinstance(value, Iterator):
0.81 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.81 query.py(1100):         if field.is_relation:
0.81 query.py(1257):             self._lookup_joins = join_info.joins
0.81 query.py(1263):         used_joins.update(join_info.joins)
0.81 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.81 query.py(1601):         joins = joins[:]
0.81 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.81 query.py(1614):         return targets, joins[-1], joins
0.81 query.py(1265):         if can_reuse is not None:
0.81 query.py(1266):             can_reuse.update(join_list)
0.81 query.py(1268):         if join_info.final_field.is_relation:
0.81 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.81 query.py(72):     if simple_col:
0.81 query.py(74):     return target.get_col(alias, field)
0.81 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.81 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.81 query.py(1129):         for name in transforms:
0.81 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.81 query.py(1134):         if not lookup_class:
0.81 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.81 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.81 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.81 query.py(1161):         return lookup
0.81 query.py(1281):         lookup_type = condition.lookup_name
0.81 query.py(1282):         clause.add(condition, AND)
0.81 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.81 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.81 query.py(1302):         return clause, used_joins if not require_outer else ()
0.81 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.81 query.py(2255):         self.votes.update(votes)
0.81 query.py(1350):             if child_clause:
0.81 query.py(1351):                 target_clause.add(child_clause, connector)
0.81 query.py(1337):         for child in q_object.children:
0.81 query.py(1338):             if isinstance(child, Node):
0.81 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.81 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.81 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.81 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.81 query.py(1214):         if isinstance(filter_expr, dict):
0.81 query.py(1216):         arg, value = filter_expr
0.81 query.py(1217):         if not arg:
0.81 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.81 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.81 query.py(1074):         if self.annotations:
0.81 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.81 query.py(290):         return self.model._meta
0.81 query.py(1405):         path, names_with_path = [], []
0.81 query.py(1406):         for pos, name in enumerate(names):
0.81 query.py(1407):             cur_names_with_path = (name, [])
0.81 query.py(1408):             if name == 'pk':
0.81 query.py(1411):             field = None
0.81 query.py(1412):             filtered_relation = None
0.81 query.py(1413):             try:
0.81 query.py(1414):                 field = opts.get_field(name)
0.81 query.py(1421):             if field is not None:
0.81 query.py(1425):                 if field.is_relation and not field.related_model:
0.81 query.py(1432):                 try:
0.81 query.py(1433):                     model = field.model._meta.concrete_model
0.81 query.py(1454):             if model is not opts.model:
0.81 query.py(1460):             if hasattr(field, 'get_path_info'):
0.81 query.py(1477):                 final_field = field
0.81 query.py(1478):                 targets = (field,)
0.81 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.81 query.py(1483):                 break
0.81 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.81 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.81 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.81 query.py(1085):         return lookup_parts, field_parts, False
0.81 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.81 query.py(1227):         if not allow_joins and len(parts) > 1:
0.81 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.81 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.81 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.81 query.py(1055):         elif isinstance(value, (list, tuple)):
0.81 query.py(1067):         return value
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.81 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.82 query.py(1234):         clause = self.where_class()
0.82 query.py(1235):         if reffed_expression:
0.82 query.py(1240):         opts = self.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 query.py(1241):         alias = self.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(250):         for alias in self.alias_map:
0.82 query.py(251):             return alias
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 query.py(1242):         allow_many = not branch_negated or not split_subq
0.82 query.py(1244):         try:
0.82 query.py(1245):             join_info = self.setup_joins(
0.82 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.82 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1477):                 final_field = field
0.82 query.py(1478):                 targets = (field,)
0.82 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.82 query.py(1483):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 query.py(1251):             if isinstance(value, Iterator):
0.82 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.82 query.py(1100):         if field.is_relation:
0.82 query.py(1257):             self._lookup_joins = join_info.joins
0.82 query.py(1263):         used_joins.update(join_info.joins)
0.82 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 query.py(1265):         if can_reuse is not None:
0.82 query.py(1266):             can_reuse.update(join_list)
0.82 query.py(1268):         if join_info.final_field.is_relation:
0.82 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.82 query.py(72):     if simple_col:
0.82 query.py(74):     return target.get_col(alias, field)
0.82 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.82 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.82 query.py(1129):         for name in transforms:
0.82 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.82 query.py(1134):         if not lookup_class:
0.82 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.82 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.82 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(1161):         return lookup
0.82 query.py(1281):         lookup_type = condition.lookup_name
0.82 query.py(1282):         clause.add(condition, AND)
0.82 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.82 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.82 query.py(1302):         return clause, used_joins if not require_outer else ()
0.82 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.82 query.py(2255):         self.votes.update(votes)
0.82 query.py(1350):             if child_clause:
0.82 query.py(1351):                 target_clause.add(child_clause, connector)
0.82 query.py(1337):         for child in q_object.children:
0.82 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.82 query.py(2264):         to_promote = set()
0.82 query.py(2265):         to_demote = set()
0.82 query.py(2268):         for table, votes in self.votes.items():
0.82 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.82 query.py(2291):             if self.effective_connector == 'AND' or (
0.82 query.py(2293):                 to_demote.add(table)
0.82 query.py(2268):         for table, votes in self.votes.items():
0.82 query.py(2309):         query.promote_joins(to_promote)
0.82 query.py(771):         aliases = list(aliases)
0.82 query.py(772):         while aliases:
0.82 query.py(2310):         query.demote_joins(to_demote)
0.82 query.py(804):         aliases = list(aliases)
0.82 query.py(805):         while aliases:
0.82 query.py(806):             alias = aliases.pop(0)
0.82 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.82 query.py(805):         while aliases:
0.82 query.py(2311):         return to_demote
0.82 query.py(1353):         return target_clause, needed_inner
0.82 query.py(1320):         if clause:
0.82 query.py(1321):             self.where.add(clause, AND)
0.82 query.py(1322):         self.demote_joins(existing_inner)
0.82 query.py(804):         aliases = list(aliases)
0.82 query.py(805):         while aliases:
0.82 query.py(1758):         return not self.low_mark and self.high_mark is None
0.82 query.py(1758):         return not self.low_mark and self.high_mark is None
0.82 query.py(343):         obj = self.clone()
0.82 query.py(297):         obj = Empty()
0.82 query.py(298):         obj.__class__ = self.__class__
0.82 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.82 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.82 query.py(303):         obj.alias_map = self.alias_map.copy()
0.82 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.82 query.py(305):         obj.table_map = self.table_map.copy()
0.82 query.py(306):         obj.where = self.where.clone()
0.82 query.py(307):         obj.annotations = self.annotations.copy()
0.82 query.py(308):         if self.annotation_select_mask is None:
0.82 query.py(309):             obj.annotation_select_mask = None
0.82 query.py(317):         obj._annotation_select_cache = None
0.82 query.py(318):         obj.extra = self.extra.copy()
0.82 query.py(319):         if self.extra_select_mask is None:
0.82 query.py(320):             obj.extra_select_mask = None
0.82 query.py(323):         if self._extra_select_cache is None:
0.82 query.py(324):             obj._extra_select_cache = None
0.82 query.py(327):         if 'subq_aliases' in self.__dict__:
0.82 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.82 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.82 query.py(332):         try:
0.82 query.py(333):             del obj.base_table
0.82 query.py(336):         return obj
0.82 query.py(344):         if klass and obj.__class__ != klass:
0.82 query.py(346):         if not obj.filter_is_sticky:
0.82 query.py(347):             obj.used_aliases = set()
0.82 query.py(348):         obj.filter_is_sticky = False
0.82 query.py(349):         if hasattr(obj, '_setup_query'):
0.82 query.py(351):         return obj
0.82 query.py(1860):         self.order_by = ()
0.82 query.py(1861):         self.extra_order_by = ()
0.82 query.py(1862):         if force_empty:
0.82 query.py(1839):         errors = []
0.82 query.py(1840):         for item in ordering:
0.82 query.py(1848):         if errors:
0.82 query.py(1850):         if ordering:
0.82 query.py(1853):             self.default_ordering = False
0.82 query.py(1731):         if high is not None:
0.82 query.py(1732):             if self.high_mark is not None:
0.82 query.py(1735):                 self.high_mark = self.low_mark + high
0.82 query.py(1736):         if low is not None:
0.82 query.py(1742):         if self.low_mark == self.high_mark:
0.82 query.py(278):         if using is None and connection is None:
0.82 query.py(280):         if using:
0.82 query.py(281):             connection = connections[using]
0.82 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.82 compiler.py(25):         self.query = query
0.82 compiler.py(26):         self.connection = connection
0.82 compiler.py(27):         self.using = using
0.82 compiler.py(28):         self.quote_cache = {'*': '*'}
0.82 compiler.py(33):         self.select = None
0.82 compiler.py(34):         self.annotation_col_map = None
0.82 compiler.py(35):         self.klass_info = None
0.82 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.82 compiler.py(38):         self._meta_ordering = None
0.82 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.82 compiler.py(1081):         try:
0.82 compiler.py(1082):             sql, params = self.as_sql()
0.82 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.82 compiler.py(479):         try:
0.82 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.82 compiler.py(52):         self.setup_query()
0.82 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.82 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.82 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.82 compiler.py(202):         select = []
0.82 compiler.py(203):         klass_info = None
0.82 compiler.py(204):         annotations = {}
0.82 compiler.py(205):         select_idx = 0
0.82 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.82 compiler.py(211):         if self.query.default_cols:
0.82 compiler.py(212):             cols = self.get_default_columns()
0.82 compiler.py(644):         result = []
0.82 compiler.py(645):         if opts is None:
0.82 compiler.py(646):             opts = self.query.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(647):         only_load = self.deferred_to_columns()
0.82 compiler.py(1018):         columns = {}
0.82 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.82 query.py(655):         field_names, defer = self.deferred_loading
0.82 query.py(656):         if not field_names:
0.82 query.py(657):             return
0.82 compiler.py(1020):         return columns
0.82 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(250):         for alias in self.alias_map:
0.82 query.py(251):             return alias
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 compiler.py(652):         seen_models = {None: start_alias}
0.82 compiler.py(654):         for field in opts.concrete_fields:
0.82 compiler.py(655):             model = field.model._meta.concrete_model
0.82 compiler.py(658):             if model == opts.model:
0.82 compiler.py(659):                 model = None
0.82 compiler.py(660):             if from_parent and model is not None and issubclass(
0.82 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.82 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.82 compiler.py(671):                                                  seen_models)
0.82 query.py(984):         if model in seen:
0.82 query.py(985):             return seen[model]
0.82 compiler.py(672):             column = field.get_col(alias)
0.82 compiler.py(673):             result.append(column)
0.82 compiler.py(654):         for field in opts.concrete_fields:
0.82 compiler.py(655):             model = field.model._meta.concrete_model
0.82 compiler.py(658):             if model == opts.model:
0.82 compiler.py(659):                 model = None
0.82 compiler.py(660):             if from_parent and model is not None and issubclass(
0.82 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.82 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.82 compiler.py(671):                                                  seen_models)
0.82 query.py(984):         if model in seen:
0.82 query.py(985):             return seen[model]
0.82 compiler.py(672):             column = field.get_col(alias)
0.82 compiler.py(673):             result.append(column)
0.82 compiler.py(654):         for field in opts.concrete_fields:
0.82 compiler.py(655):             model = field.model._meta.concrete_model
0.82 compiler.py(658):             if model == opts.model:
0.82 compiler.py(659):                 model = None
0.82 compiler.py(660):             if from_parent and model is not None and issubclass(
0.82 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.82 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.82 compiler.py(671):                                                  seen_models)
0.82 query.py(984):         if model in seen:
0.82 query.py(985):             return seen[model]
0.82 compiler.py(672):             column = field.get_col(alias)
0.82 compiler.py(673):             result.append(column)
0.82 compiler.py(654):         for field in opts.concrete_fields:
0.82 compiler.py(674):         return result
0.82 compiler.py(217):         if cols:
0.82 compiler.py(218):             select_list = []
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(220):                 select_list.append(select_idx)
0.82 compiler.py(221):                 select.append((col, None))
0.82 compiler.py(222):                 select_idx += 1
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(220):                 select_list.append(select_idx)
0.82 compiler.py(221):                 select.append((col, None))
0.82 compiler.py(222):                 select_idx += 1
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(220):                 select_list.append(select_idx)
0.82 compiler.py(221):                 select.append((col, None))
0.82 compiler.py(222):                 select_idx += 1
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(224):                 'model': self.query.model,
0.82 compiler.py(225):                 'select_fields': select_list,
0.82 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(232):         if self.query.select_related:
0.82 compiler.py(244):         ret = []
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(246):             try:
0.82 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.82 compiler.py(251):             ret.append((col, (sql, params), alias))
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(246):             try:
0.82 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.82 compiler.py(251):             ret.append((col, (sql, params), alias))
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(246):             try:
0.82 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.82 compiler.py(251):             ret.append((col, (sql, params), alias))
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(252):         return ret, klass_info, annotations
0.82 compiler.py(44):         self.col_count = len(self.select)
0.82 compiler.py(53):         order_by = self.get_order_by()
0.82 compiler.py(263):         if self.query.extra_order_by:
0.82 compiler.py(265):         elif not self.query.default_ordering:
0.82 compiler.py(266):             ordering = self.query.order_by
0.82 compiler.py(274):         if self.query.standard_ordering:
0.82 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.82 compiler.py(279):         order_by = []
0.82 compiler.py(280):         for field in ordering:
0.82 compiler.py(340):         result = []
0.82 compiler.py(341):         seen = set()
0.82 compiler.py(343):         for expr, is_ref in order_by:
0.82 compiler.py(376):         return result
0.82 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.82 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.82 compiler.py(379):         extra_select = []
0.82 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.82 compiler.py(386):         return extra_select
0.82 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.82 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.82 compiler.py(97):         if self.query.group_by is None:
0.82 compiler.py(98):             return []
0.82 compiler.py(58):         return extra_select, order_by, group_by
0.82 compiler.py(481):             for_update_part = None
0.82 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.82 compiler.py(484):             combinator = self.query.combinator
0.82 compiler.py(485):             features = self.connection.features
0.82 compiler.py(486):             if combinator:
0.82 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.82 compiler.py(683):         result = []
0.82 compiler.py(684):         params = []
0.82 compiler.py(685):         opts = self.query.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(687):         for name in self.query.distinct_fields:
0.82 compiler.py(698):         return result, params
0.82 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.82 compiler.py(755):         result = []
0.82 compiler.py(756):         params = []
0.82 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.82 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.82 compiler.py(760):             try:
0.82 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.82 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(767):             result.append(clause_sql)
0.82 compiler.py(768):             params.extend(clause_params)
0.82 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.82 compiler.py(769):         for t in self.query.extra_tables:
0.82 compiler.py(776):         return result, params
0.82 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.82 compiler.py(497):                 result = ['SELECT']
0.82 compiler.py(498):                 params = []
0.82 compiler.py(500):                 if self.query.distinct:
0.82 compiler.py(508):                 out_cols = []
0.82 compiler.py(509):                 col_idx = 1
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(511):                     if alias:
0.82 compiler.py(513):                     elif with_col_aliases:
0.82 compiler.py(516):                     params.extend(s_params)
0.82 compiler.py(517):                     out_cols.append(s_sql)
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(511):                     if alias:
0.82 compiler.py(513):                     elif with_col_aliases:
0.82 compiler.py(516):                     params.extend(s_params)
0.82 compiler.py(517):                     out_cols.append(s_sql)
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(511):                     if alias:
0.82 compiler.py(513):                     elif with_col_aliases:
0.82 compiler.py(516):                     params.extend(s_params)
0.82 compiler.py(517):                     out_cols.append(s_sql)
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.82 compiler.py(520):                 params.extend(f_params)
0.82 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.82 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.82 compiler.py(552):                 if where:
0.82 compiler.py(553):                     result.append('WHERE %s' % where)
0.82 compiler.py(554):                     params.extend(w_params)
0.82 compiler.py(556):                 grouping = []
0.82 compiler.py(557):                 for g_sql, g_params in group_by:
0.82 compiler.py(560):                 if grouping:
0.82 compiler.py(577):                 if having:
0.82 compiler.py(581):             if self.query.explain_query:
0.82 compiler.py(587):             if order_by:
0.82 compiler.py(594):             if with_limit_offset:
0.82 compiler.py(595):                 result.append(self.connection.ops.limit_offset_sql(self.query.low_mark, self.query.high_mark))
0.82 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.82 compiler.py(600):             if self.query.subquery and extra_select:
0.82 compiler.py(627):             return ' '.join(result), tuple(params)
0.82 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.82 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.82 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.82 query.py(820):             self.unref_alias(alias, unref_amount)
0.82 query.py(758):         self.alias_refcount[alias] -= amount
0.82 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.82 compiler.py(1083):             if not sql:
0.82 compiler.py(1090):         if chunked_fetch:
0.82 compiler.py(1093):             cursor = self.connection.cursor()
0.82 compiler.py(1094):         try:
0.82 compiler.py(1095):             cursor.execute(sql, params)
0.82 compiler.py(1101):         if result_type == CURSOR:
0.82 compiler.py(1104):         if result_type == SINGLE:
0.82 compiler.py(1113):         if result_type == NO_RESULTS:
0.82 compiler.py(1117):         result = cursor_iter(
0.82 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.82 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.82 compiler.py(1120):             chunk_size,
0.82 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.82 compiler.py(1123):             try:
0.82 compiler.py(1128):                 return list(result)
0.82 compiler.py(1518):     try:
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1522):         cursor.close()
0.82 compiler.py(1131):                 cursor.close()
0.82 compiler.py(1046):         if results is None:
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1049):         converters = self.get_converters(fields)
0.82 compiler.py(1023):         converters = {}
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1025):             if expression:
0.82 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.82 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.82 compiler.py(1028):                 if backend_converters or field_converters:
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1025):             if expression:
0.82 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.82 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.82 compiler.py(1028):                 if backend_converters or field_converters:
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1025):             if expression:
0.82 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.82 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.82 compiler.py(1028):                 if backend_converters or field_converters:
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1030):         return converters
0.82 compiler.py(1050):         rows = chain.from_iterable(results)
0.82 compiler.py(1051):         if converters:
0.82 compiler.py(1055):         return rows
0.82 query.py(154):         self.model = model
0.82 query.py(155):         self.alias_refcount = {}
0.82 query.py(161):         self.alias_map = {}
0.82 query.py(165):         self.external_aliases = set()
0.82 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.82 query.py(167):         self.default_cols = True
0.82 query.py(168):         self.default_ordering = True
0.82 query.py(169):         self.standard_ordering = True
0.82 query.py(170):         self.used_aliases = set()
0.82 query.py(171):         self.filter_is_sticky = False
0.82 query.py(172):         self.subquery = False
0.82 query.py(180):         self.select = ()
0.82 query.py(181):         self.where = where()
0.82 query.py(182):         self.where_class = where
0.82 query.py(189):         self.group_by = None
0.82 query.py(190):         self.order_by = ()
0.82 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.82 query.py(192):         self.distinct = False
0.82 query.py(193):         self.distinct_fields = ()
0.82 query.py(194):         self.select_for_update = False
0.82 query.py(195):         self.select_for_update_nowait = False
0.82 query.py(196):         self.select_for_update_skip_locked = False
0.82 query.py(197):         self.select_for_update_of = ()
0.82 query.py(199):         self.select_related = False
0.82 query.py(201):         self.max_depth = 5
0.82 query.py(205):         self.values_select = ()
0.82 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.82 query.py(209):         self.annotation_select_mask = None
0.82 query.py(210):         self._annotation_select_cache = None
0.82 query.py(213):         self.combinator = None
0.82 query.py(214):         self.combinator_all = False
0.82 query.py(215):         self.combined_queries = ()
0.82 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.82 query.py(220):         self.extra_select_mask = None
0.82 query.py(221):         self._extra_select_cache = None
0.82 query.py(223):         self.extra_tables = ()
0.82 query.py(224):         self.extra_order_by = ()
0.82 query.py(229):         self.deferred_loading = (frozenset(), True)
0.82 query.py(231):         self._filtered_relations = {}
0.82 query.py(233):         self.explain_query = False
0.82 query.py(234):         self.explain_format = None
0.82 query.py(235):         self.explain_options = {}
0.82 query.py(343):         obj = self.clone()
0.82 query.py(297):         obj = Empty()
0.82 query.py(298):         obj.__class__ = self.__class__
0.82 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.82 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.82 query.py(303):         obj.alias_map = self.alias_map.copy()
0.82 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.82 query.py(305):         obj.table_map = self.table_map.copy()
0.82 query.py(306):         obj.where = self.where.clone()
0.82 query.py(307):         obj.annotations = self.annotations.copy()
0.82 query.py(308):         if self.annotation_select_mask is None:
0.82 query.py(309):             obj.annotation_select_mask = None
0.82 query.py(317):         obj._annotation_select_cache = None
0.82 query.py(318):         obj.extra = self.extra.copy()
0.82 query.py(319):         if self.extra_select_mask is None:
0.82 query.py(320):             obj.extra_select_mask = None
0.82 query.py(323):         if self._extra_select_cache is None:
0.82 query.py(324):             obj._extra_select_cache = None
0.82 query.py(327):         if 'subq_aliases' in self.__dict__:
0.82 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.82 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.82 query.py(332):         try:
0.82 query.py(333):             del obj.base_table
0.82 query.py(334):         except AttributeError:
0.82 query.py(335):             pass
0.82 query.py(336):         return obj
0.82 query.py(344):         if klass and obj.__class__ != klass:
0.82 query.py(346):         if not obj.filter_is_sticky:
0.82 query.py(347):             obj.used_aliases = set()
0.82 query.py(348):         obj.filter_is_sticky = False
0.82 query.py(349):         if hasattr(obj, '_setup_query'):
0.82 query.py(351):         return obj
0.82 query.py(1758):         return not self.low_mark and self.high_mark is None
0.82 query.py(343):         obj = self.clone()
0.82 query.py(297):         obj = Empty()
0.82 query.py(298):         obj.__class__ = self.__class__
0.82 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.82 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.82 query.py(303):         obj.alias_map = self.alias_map.copy()
0.82 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.82 query.py(305):         obj.table_map = self.table_map.copy()
0.82 query.py(306):         obj.where = self.where.clone()
0.82 query.py(307):         obj.annotations = self.annotations.copy()
0.82 query.py(308):         if self.annotation_select_mask is None:
0.82 query.py(309):             obj.annotation_select_mask = None
0.82 query.py(317):         obj._annotation_select_cache = None
0.82 query.py(318):         obj.extra = self.extra.copy()
0.82 query.py(319):         if self.extra_select_mask is None:
0.82 query.py(320):             obj.extra_select_mask = None
0.82 query.py(323):         if self._extra_select_cache is None:
0.82 query.py(324):             obj._extra_select_cache = None
0.82 query.py(327):         if 'subq_aliases' in self.__dict__:
0.82 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.82 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.82 query.py(332):         try:
0.82 query.py(333):             del obj.base_table
0.82 query.py(334):         except AttributeError:
0.82 query.py(335):             pass
0.82 query.py(336):         return obj
0.82 query.py(344):         if klass and obj.__class__ != klass:
0.82 query.py(346):         if not obj.filter_is_sticky:
0.82 query.py(347):             obj.used_aliases = set()
0.82 query.py(348):         obj.filter_is_sticky = False
0.82 query.py(349):         if hasattr(obj, '_setup_query'):
0.82 query.py(351):         return obj
0.82 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.82 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.82 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.82 query.py(1331):         connector = q_object.connector
0.82 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.82 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.82 query.py(1334):         target_clause = self.where_class(connector=connector,
0.82 query.py(1335):                                          negated=q_object.negated)
0.82 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.82 query.py(2236):         self.connector = connector
0.82 query.py(2237):         self.negated = negated
0.82 query.py(2238):         if self.negated:
0.82 query.py(2244):             self.effective_connector = self.connector
0.82 query.py(2245):         self.num_children = num_children
0.82 query.py(2248):         self.votes = Counter()
0.82 query.py(1337):         for child in q_object.children:
0.82 query.py(1338):             if isinstance(child, Node):
0.82 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.82 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.82 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.82 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.82 query.py(1214):         if isinstance(filter_expr, dict):
0.82 query.py(1216):         arg, value = filter_expr
0.82 query.py(1217):         if not arg:
0.82 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.82 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.82 query.py(1074):         if self.annotations:
0.82 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.82 query.py(290):         return self.model._meta
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.82 query.py(1462):                 if not allow_many:
0.82 query.py(1468):                 last = pathinfos[-1]
0.82 query.py(1469):                 path.extend(pathinfos)
0.82 query.py(1470):                 final_field = last.join_field
0.82 query.py(1471):                 opts = last.to_opts
0.82 query.py(1472):                 targets = last.target_fields
0.82 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.82 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1415):             except FieldDoesNotExist:
0.82 query.py(1416):                 if name in self.annotation_select:
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 query.py(1418):                 elif name in self._filtered_relations and pos == 0:
0.82 query.py(1421):             if field is not None:
0.82 query.py(1441):                 pos -= 1
0.82 query.py(1442):                 if pos == -1 or fail_on_missing:
0.82 query.py(1450):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.82 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.82 query.py(1085):         return lookup_parts, field_parts, False
0.82 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.82 query.py(1227):         if not allow_joins and len(parts) > 1:
0.82 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.82 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.82 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.82 query.py(1055):         elif isinstance(value, (list, tuple)):
0.82 query.py(1067):         return value
0.82 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.82 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.82 query.py(1234):         clause = self.where_class()
0.82 query.py(1235):         if reffed_expression:
0.82 query.py(1240):         opts = self.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 query.py(1241):         alias = self.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.82 query.py(290):         return self.model._meta
0.82 query.py(943):         if reuse_with_filtered_relation and reuse:
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(953):         if reuse_aliases:
0.82 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.82 query.py(735):         alias_list = self.table_map.get(table_name)
0.82 query.py(736):         if not create and alias_list:
0.82 query.py(742):         if alias_list:
0.82 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.82 query.py(748):             self.table_map[table_name] = [alias]
0.82 query.py(749):         self.alias_refcount[alias] = 1
0.82 query.py(750):         return alias, True
0.82 query.py(965):         if join.join_type:
0.82 query.py(971):         join.table_alias = alias
0.82 query.py(972):         self.alias_map[alias] = join
0.82 query.py(973):         return alias
0.82 query.py(917):         return alias
0.82 query.py(1242):         allow_many = not branch_negated or not split_subq
0.82 query.py(1244):         try:
0.82 query.py(1245):             join_info = self.setup_joins(
0.82 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.82 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.82 query.py(1462):                 if not allow_many:
0.82 query.py(1468):                 last = pathinfos[-1]
0.82 query.py(1469):                 path.extend(pathinfos)
0.82 query.py(1470):                 final_field = last.join_field
0.82 query.py(1471):                 opts = last.to_opts
0.82 query.py(1472):                 targets = last.target_fields
0.82 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.82 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1563):             if join.filtered_relation:
0.82 query.py(1567):                 filtered_relation = None
0.82 query.py(1568):                 table_alias = None
0.82 query.py(1569):             opts = join.to_opts
0.82 query.py(1570):             if join.direct:
0.82 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.82 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(2193):         ) or field.null
0.82 query.py(1574):             connection = Join(
0.82 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.82 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.82 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.82 query.py(1579):             alias = self.join(
0.82 query.py(1580):                 connection, reuse=reuse,
0.82 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(943):         if reuse_with_filtered_relation and reuse:
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(953):         if reuse_aliases:
0.82 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.82 query.py(735):         alias_list = self.table_map.get(table_name)
0.82 query.py(736):         if not create and alias_list:
0.82 query.py(742):         if alias_list:
0.82 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.82 query.py(748):             self.table_map[table_name] = [alias]
0.82 query.py(749):         self.alias_refcount[alias] = 1
0.82 query.py(750):         return alias, True
0.82 query.py(965):         if join.join_type:
0.82 query.py(966):             if self.alias_map[join.parent_alias].join_type == LOUTER or join.nullable:
0.82 query.py(969):                 join_type = INNER
0.82 query.py(970):             join.join_type = join_type
0.82 query.py(971):         join.table_alias = alias
0.82 query.py(972):         self.alias_map[alias] = join
0.82 query.py(973):         return alias
0.82 query.py(1583):             joins.append(alias)
0.82 query.py(1584):             if filtered_relation:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 query.py(1251):             if isinstance(value, Iterator):
0.82 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.82 query.py(1100):         if field.is_relation:
0.82 query.py(1106):             if (isinstance(value, Query) and not value.has_select_fields and
0.82 query.py(1112):             elif hasattr(value, '_meta'):
0.82 query.py(1114):             elif hasattr(value, '__iter__'):
0.82 query.py(1115):                 for v in value:
0.82 query.py(1116):                     self.check_query_object_type(v, opts, field)
0.82 query.py(1092):         if hasattr(value, '_meta'):
0.82 query.py(1093):             if not check_rel_lookup_compatibility(value._meta.model, opts, field):
0.82 query.py(1115):                 for v in value:
0.82 query.py(1257):             self._lookup_joins = join_info.joins
0.82 query.py(1263):         used_joins.update(join_info.joins)
0.82 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1603):             if len(joins) == 1 or not info.direct:
0.82 query.py(1605):             if info.filtered_relation:
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1609):             if not cur_targets.issubset(join_targets):
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1613):             self.unref_alias(joins.pop())
0.82 query.py(758):         self.alias_refcount[alias] -= amount
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 query.py(1265):         if can_reuse is not None:
0.82 query.py(1266):             can_reuse.update(join_list)
0.82 query.py(1268):         if join_info.final_field.is_relation:
0.82 query.py(1270):             num_lookups = len(lookups)
0.82 query.py(1271):             if num_lookups > 1:
0.82 query.py(1273):             if len(targets) == 1:
0.82 query.py(1274):                 col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.82 query.py(72):     if simple_col:
0.82 query.py(74):     return target.get_col(alias, field)
0.82 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.82 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.82 query.py(1129):         for name in transforms:
0.82 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.82 query.py(1134):         if not lookup_class:
0.82 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.82 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.82 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(1161):         return lookup
0.82 query.py(1281):         lookup_type = condition.lookup_name
0.82 query.py(1282):         clause.add(condition, AND)
0.82 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.82 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.82 query.py(1302):         return clause, used_joins if not require_outer else ()
0.82 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.82 query.py(2255):         self.votes.update(votes)
0.82 query.py(1350):             if child_clause:
0.82 query.py(1351):                 target_clause.add(child_clause, connector)
0.82 query.py(1337):         for child in q_object.children:
0.82 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.82 query.py(2264):         to_promote = set()
0.82 query.py(2265):         to_demote = set()
0.82 query.py(2268):         for table, votes in self.votes.items():
0.82 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.82 query.py(2291):             if self.effective_connector == 'AND' or (
0.82 query.py(2293):                 to_demote.add(table)
0.82 query.py(2268):         for table, votes in self.votes.items():
0.82 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.82 query.py(2291):             if self.effective_connector == 'AND' or (
0.82 query.py(2293):                 to_demote.add(table)
0.82 query.py(2268):         for table, votes in self.votes.items():
0.82 query.py(2309):         query.promote_joins(to_promote)
0.82 query.py(771):         aliases = list(aliases)
0.82 query.py(772):         while aliases:
0.82 query.py(2310):         query.demote_joins(to_demote)
0.82 query.py(804):         aliases = list(aliases)
0.82 query.py(805):         while aliases:
0.82 query.py(806):             alias = aliases.pop(0)
0.82 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.82 query.py(805):         while aliases:
0.82 query.py(806):             alias = aliases.pop(0)
0.82 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.82 query.py(805):         while aliases:
0.82 query.py(2311):         return to_demote
0.82 query.py(1353):         return target_clause, needed_inner
0.82 query.py(1320):         if clause:
0.82 query.py(1321):             self.where.add(clause, AND)
0.82 query.py(1322):         self.demote_joins(existing_inner)
0.82 query.py(804):         aliases = list(aliases)
0.82 query.py(805):         while aliases:
0.82 query.py(343):         obj = self.clone()
0.82 query.py(297):         obj = Empty()
0.82 query.py(298):         obj.__class__ = self.__class__
0.82 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.82 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.82 query.py(303):         obj.alias_map = self.alias_map.copy()
0.82 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.82 query.py(305):         obj.table_map = self.table_map.copy()
0.82 query.py(306):         obj.where = self.where.clone()
0.82 query.py(307):         obj.annotations = self.annotations.copy()
0.82 query.py(308):         if self.annotation_select_mask is None:
0.82 query.py(309):             obj.annotation_select_mask = None
0.82 query.py(317):         obj._annotation_select_cache = None
0.82 query.py(318):         obj.extra = self.extra.copy()
0.82 query.py(319):         if self.extra_select_mask is None:
0.82 query.py(320):             obj.extra_select_mask = None
0.82 query.py(323):         if self._extra_select_cache is None:
0.82 query.py(324):             obj._extra_select_cache = None
0.82 query.py(327):         if 'subq_aliases' in self.__dict__:
0.82 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.82 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.82 query.py(332):         try:
0.82 query.py(333):             del obj.base_table
0.82 query.py(334):         except AttributeError:
0.82 query.py(335):             pass
0.82 query.py(336):         return obj
0.82 query.py(344):         if klass and obj.__class__ != klass:
0.82 query.py(346):         if not obj.filter_is_sticky:
0.82 query.py(347):             obj.used_aliases = set()
0.82 query.py(348):         obj.filter_is_sticky = False
0.82 query.py(349):         if hasattr(obj, '_setup_query'):
0.82 query.py(351):         return obj
0.82 query.py(2035):         self.select_related = False
0.82 query.py(2036):         self.clear_deferred_loading()
0.82 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.82 query.py(2037):         self.clear_select_fields()
0.82 query.py(1774):         self.select = ()
0.82 query.py(1775):         self.values_select = ()
0.82 query.py(2039):         if self.group_by is True:
0.82 query.py(2044):         if fields:
0.82 query.py(2045):             field_names = []
0.82 query.py(2046):             extra_names = []
0.82 query.py(2047):             annotation_names = []
0.82 query.py(2048):             if not self.extra and not self.annotations:
0.82 query.py(2051):                 field_names = list(fields)
0.82 query.py(2061):             self.set_extra_mask(extra_names)
0.82 query.py(2028):         if names is None:
0.82 query.py(2031):             self.extra_select_mask = set(names)
0.82 query.py(2032):         self._extra_select_cache = None
0.82 query.py(2062):             self.set_annotation_mask(annotation_names)
0.82 query.py(2013):         if names is None:
0.82 query.py(2016):             self.annotation_select_mask = set(names)
0.82 query.py(2017):         self._annotation_select_cache = None
0.82 query.py(2066):         self.values_select = tuple(field_names)
0.82 query.py(2067):         self.add_fields(field_names, True)
0.82 query.py(1797):         alias = self.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(250):         for alias in self.alias_map:
0.82 query.py(251):             return alias
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 query.py(1798):         opts = self.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 query.py(1800):         try:
0.82 query.py(1801):             cols = []
0.82 query.py(1802):             for name in field_names:
0.82 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.82 query.py(1462):                 if not allow_many:
0.82 query.py(1468):                 last = pathinfos[-1]
0.82 query.py(1469):                 path.extend(pathinfos)
0.82 query.py(1470):                 final_field = last.join_field
0.82 query.py(1471):                 opts = last.to_opts
0.82 query.py(1472):                 targets = last.target_fields
0.82 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.82 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1563):             if join.filtered_relation:
0.82 query.py(1567):                 filtered_relation = None
0.82 query.py(1568):                 table_alias = None
0.82 query.py(1569):             opts = join.to_opts
0.82 query.py(1570):             if join.direct:
0.82 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.82 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(2193):         ) or field.null
0.82 query.py(1574):             connection = Join(
0.82 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.82 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.82 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.82 query.py(1579):             alias = self.join(
0.82 query.py(1580):                 connection, reuse=reuse,
0.82 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(943):         if reuse_with_filtered_relation and reuse:
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(953):         if reuse_aliases:
0.82 query.py(954):             if join.table_alias in reuse_aliases:
0.82 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.82 query.py(960):             self.ref_alias(reuse_alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(961):             return reuse_alias
0.82 query.py(1583):             joins.append(alias)
0.82 query.py(1584):             if filtered_relation:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.82 query.py(1807):                     join_info.targets,
0.82 query.py(1808):                     join_info.joins,
0.82 query.py(1809):                     join_info.path,
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1603):             if len(joins) == 1 or not info.direct:
0.82 query.py(1605):             if info.filtered_relation:
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1609):             if not cur_targets.issubset(join_targets):
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1611):             targets_dict = {r[1].column: r[0] for r in info.join_field.related_fields if r[1].column in cur_targets}
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1612):             targets = tuple(targets_dict[t.column] for t in targets)
0.82 query.py(1613):             self.unref_alias(joins.pop())
0.82 query.py(758):         self.alias_refcount[alias] -= amount
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 query.py(1811):                 for target in targets:
0.82 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.82 query.py(1525):             return field.get_col(alias)
0.82 query.py(1811):                 for target in targets:
0.82 query.py(1802):             for name in field_names:
0.82 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1477):                 final_field = field
0.82 query.py(1478):                 targets = (field,)
0.82 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.82 query.py(1483):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.82 query.py(1807):                     join_info.targets,
0.82 query.py(1808):                     join_info.joins,
0.82 query.py(1809):                     join_info.path,
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 query.py(1811):                 for target in targets:
0.82 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.82 query.py(1525):             return field.get_col(alias)
0.82 query.py(1811):                 for target in targets:
0.82 query.py(1802):             for name in field_names:
0.82 query.py(1813):             if cols:
0.82 query.py(1814):                 self.set_select(cols)
0.82 query.py(1782):         self.default_cols = False
0.82 query.py(1783):         self.select = tuple(cols)
0.82 query.py(278):         if using is None and connection is None:
0.82 query.py(280):         if using:
0.82 query.py(281):             connection = connections[using]
0.82 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.82 compiler.py(25):         self.query = query
0.82 compiler.py(26):         self.connection = connection
0.82 compiler.py(27):         self.using = using
0.82 compiler.py(28):         self.quote_cache = {'*': '*'}
0.82 compiler.py(33):         self.select = None
0.82 compiler.py(34):         self.annotation_col_map = None
0.82 compiler.py(35):         self.klass_info = None
0.82 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.82 compiler.py(38):         self._meta_ordering = None
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(1046):         if results is None:
0.82 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.82 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.82 compiler.py(1081):         try:
0.82 compiler.py(1082):             sql, params = self.as_sql()
0.82 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.82 compiler.py(479):         try:
0.82 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.82 compiler.py(52):         self.setup_query()
0.82 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.82 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.82 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.82 compiler.py(202):         select = []
0.82 compiler.py(203):         klass_info = None
0.82 compiler.py(204):         annotations = {}
0.82 compiler.py(205):         select_idx = 0
0.82 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.82 compiler.py(211):         if self.query.default_cols:
0.82 compiler.py(216):             cols = self.query.select
0.82 compiler.py(217):         if cols:
0.82 compiler.py(218):             select_list = []
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(220):                 select_list.append(select_idx)
0.82 compiler.py(221):                 select.append((col, None))
0.82 compiler.py(222):                 select_idx += 1
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(220):                 select_list.append(select_idx)
0.82 compiler.py(221):                 select.append((col, None))
0.82 compiler.py(222):                 select_idx += 1
0.82 compiler.py(219):             for col in cols:
0.82 compiler.py(224):                 'model': self.query.model,
0.82 compiler.py(225):                 'select_fields': select_list,
0.82 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(232):         if self.query.select_related:
0.82 compiler.py(244):         ret = []
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(246):             try:
0.82 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.82 compiler.py(251):             ret.append((col, (sql, params), alias))
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(246):             try:
0.82 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.82 compiler.py(251):             ret.append((col, (sql, params), alias))
0.82 compiler.py(245):         for col, alias in select:
0.82 compiler.py(252):         return ret, klass_info, annotations
0.82 compiler.py(44):         self.col_count = len(self.select)
0.82 compiler.py(53):         order_by = self.get_order_by()
0.82 compiler.py(263):         if self.query.extra_order_by:
0.82 compiler.py(265):         elif not self.query.default_ordering:
0.82 compiler.py(267):         elif self.query.order_by:
0.82 compiler.py(269):         elif self.query.get_meta().ordering:
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(270):             ordering = self.query.get_meta().ordering
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(271):             self._meta_ordering = ordering
0.82 compiler.py(274):         if self.query.standard_ordering:
0.82 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.82 compiler.py(279):         order_by = []
0.82 compiler.py(280):         for field in ordering:
0.82 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.82 compiler.py(292):             if field == '?':  # random
0.82 compiler.py(296):             col, order = get_order_dir(field, asc)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(297):             descending = order == 'DESC'
0.82 compiler.py(299):             if col in self.query.annotation_select:
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(305):             if col in self.query.annotations:
0.82 compiler.py(315):             if '.' in field:
0.82 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.82 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.82 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(708):         descending = order == 'DESC'
0.82 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.82 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.82 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.82 query.py(1462):                 if not allow_many:
0.82 query.py(1468):                 last = pathinfos[-1]
0.82 query.py(1469):                 path.extend(pathinfos)
0.82 query.py(1470):                 final_field = last.join_field
0.82 query.py(1471):                 opts = last.to_opts
0.82 query.py(1472):                 targets = last.target_fields
0.82 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.82 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1477):                 final_field = field
0.82 query.py(1478):                 targets = (field,)
0.82 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.82 query.py(1483):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1563):             if join.filtered_relation:
0.82 query.py(1567):                 filtered_relation = None
0.82 query.py(1568):                 table_alias = None
0.82 query.py(1569):             opts = join.to_opts
0.82 query.py(1570):             if join.direct:
0.82 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.82 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(2193):         ) or field.null
0.82 query.py(1574):             connection = Join(
0.82 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.82 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.82 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.82 query.py(1579):             alias = self.join(
0.82 query.py(1580):                 connection, reuse=reuse,
0.82 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(943):         if reuse_with_filtered_relation and reuse:
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(953):         if reuse_aliases:
0.82 query.py(954):             if join.table_alias in reuse_aliases:
0.82 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.82 query.py(960):             self.ref_alias(reuse_alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(961):             return reuse_alias
0.82 query.py(1583):             joins.append(alias)
0.82 query.py(1584):             if filtered_relation:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 compiler.py(741):         alias = joins[-1]
0.82 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.82 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.82 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1603):             if len(joins) == 1 or not info.direct:
0.82 query.py(1605):             if info.filtered_relation:
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1609):             if not cur_targets.issubset(join_targets):
0.82 query.py(1610):                 break
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 query.py(1525):             return field.get_col(alias)
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(280):         for field in ordering:
0.82 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.82 compiler.py(292):             if field == '?':  # random
0.82 compiler.py(296):             col, order = get_order_dir(field, asc)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(297):             descending = order == 'DESC'
0.82 compiler.py(299):             if col in self.query.annotation_select:
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(305):             if col in self.query.annotations:
0.82 compiler.py(315):             if '.' in field:
0.82 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.82 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.82 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(708):         descending = order == 'DESC'
0.82 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.82 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.82 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1461):                 pathinfos = field.get_path_info(filtered_relation)
0.82 query.py(1462):                 if not allow_many:
0.82 query.py(1468):                 last = pathinfos[-1]
0.82 query.py(1469):                 path.extend(pathinfos)
0.82 query.py(1470):                 final_field = last.join_field
0.82 query.py(1471):                 opts = last.to_opts
0.82 query.py(1472):                 targets = last.target_fields
0.82 query.py(1473):                 cur_names_with_path[1].extend(pathinfos)
0.82 query.py(1474):                 names_with_path.append(cur_names_with_path)
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1477):                 final_field = field
0.82 query.py(1478):                 targets = (field,)
0.82 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.82 query.py(1483):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1563):             if join.filtered_relation:
0.82 query.py(1567):                 filtered_relation = None
0.82 query.py(1568):                 table_alias = None
0.82 query.py(1569):             opts = join.to_opts
0.82 query.py(1570):             if join.direct:
0.82 query.py(1571):                 nullable = self.is_nullable(join.join_field)
0.82 query.py(2191):             connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.82 query.py(2193):         ) or field.null
0.82 query.py(1574):             connection = Join(
0.82 query.py(1575):                 opts.db_table, alias, table_alias, INNER, join.join_field,
0.82 query.py(1576):                 nullable, filtered_relation=filtered_relation,
0.82 query.py(1578):             reuse = can_reuse if join.m2m or reuse_with_filtered_relation else None
0.82 query.py(1579):             alias = self.join(
0.82 query.py(1580):                 connection, reuse=reuse,
0.82 query.py(1581):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.82 query.py(943):         if reuse_with_filtered_relation and reuse:
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(951):                 if (reuse is None or a in reuse) and j == join
0.82 query.py(950):                 a for a, j in self.alias_map.items()
0.82 query.py(953):         if reuse_aliases:
0.82 query.py(954):             if join.table_alias in reuse_aliases:
0.82 query.py(959):                 reuse_alias = reuse_aliases[-1]
0.82 query.py(960):             self.ref_alias(reuse_alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(961):             return reuse_alias
0.82 query.py(1583):             joins.append(alias)
0.82 query.py(1584):             if filtered_relation:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 compiler.py(741):         alias = joins[-1]
0.82 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.82 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.82 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1603):             if len(joins) == 1 or not info.direct:
0.82 query.py(1605):             if info.filtered_relation:
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1607):             join_targets = {t.column for t in info.join_field.foreign_related_fields}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1608):             cur_targets = {t.column for t in targets}
0.82 query.py(1609):             if not cur_targets.issubset(join_targets):
0.82 query.py(1610):                 break
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 query.py(1525):             return field.get_col(alias)
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(280):         for field in ordering:
0.82 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.82 compiler.py(292):             if field == '?':  # random
0.82 compiler.py(296):             col, order = get_order_dir(field, asc)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(297):             descending = order == 'DESC'
0.82 compiler.py(299):             if col in self.query.annotation_select:
0.82 query.py(2075):         if self._annotation_select_cache is not None:
0.82 query.py(2077):         elif not self.annotations:
0.82 query.py(2078):             return {}
0.82 compiler.py(305):             if col in self.query.annotations:
0.82 compiler.py(315):             if '.' in field:
0.82 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.82 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.82 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.82 query.py(2204):     dirn = ORDER_DIR[default]
0.82 query.py(2205):     if field[0] == '-':
0.82 query.py(2207):     return field, dirn[0]
0.82 compiler.py(708):         descending = order == 'DESC'
0.82 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.82 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.82 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.82 query.py(912):         if self.alias_map:
0.82 query.py(913):             alias = self.base_table
0.82 query.py(914):             self.ref_alias(alias)
0.82 query.py(754):         self.alias_refcount[alias] += 1
0.82 query.py(917):         return alias
0.82 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.82 query.py(1518):         joins = [alias]
0.82 query.py(1524):         def final_transformer(field, alias):
0.82 query.py(1529):         last_field_exception = None
0.82 query.py(1530):         for pivot in range(len(names), 0, -1):
0.82 query.py(1531):             try:
0.82 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.82 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.82 query.py(1405):         path, names_with_path = [], []
0.82 query.py(1406):         for pos, name in enumerate(names):
0.82 query.py(1407):             cur_names_with_path = (name, [])
0.82 query.py(1408):             if name == 'pk':
0.82 query.py(1411):             field = None
0.82 query.py(1412):             filtered_relation = None
0.82 query.py(1413):             try:
0.82 query.py(1414):                 field = opts.get_field(name)
0.82 query.py(1421):             if field is not None:
0.82 query.py(1425):                 if field.is_relation and not field.related_model:
0.82 query.py(1432):                 try:
0.82 query.py(1433):                     model = field.model._meta.concrete_model
0.82 query.py(1454):             if model is not opts.model:
0.82 query.py(1460):             if hasattr(field, 'get_path_info'):
0.82 query.py(1477):                 final_field = field
0.82 query.py(1478):                 targets = (field,)
0.82 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.82 query.py(1483):                 break
0.82 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.82 query.py(1545):                 transforms = names[pivot:]
0.82 query.py(1546):                 break
0.82 query.py(1547):         for name in transforms:
0.82 query.py(1562):         for join in path:
0.82 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.82 compiler.py(741):         alias = joins[-1]
0.82 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.82 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.82 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.82 query.py(1601):         joins = joins[:]
0.82 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.82 query.py(1614):         return targets, joins[-1], joins
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 query.py(1525):             return field.get_col(alias)
0.82 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.82 compiler.py(280):         for field in ordering:
0.82 compiler.py(340):         result = []
0.82 compiler.py(341):         seen = set()
0.82 compiler.py(343):         for expr, is_ref in order_by:
0.82 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.82 compiler.py(345):             if self.query.combinator:
0.82 compiler.py(365):             sql, params = self.compile(resolved)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.82 compiler.py(371):             params_hash = make_hashable(params)
0.82 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.82 compiler.py(374):             seen.add((without_ordering, params_hash))
0.82 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.82 compiler.py(343):         for expr, is_ref in order_by:
0.82 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.82 compiler.py(345):             if self.query.combinator:
0.82 compiler.py(365):             sql, params = self.compile(resolved)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.82 compiler.py(397):                 name in self.query.extra_select or (
0.82 query.py(2090):         if self._extra_select_cache is not None:
0.82 query.py(2092):         if not self.extra:
0.82 query.py(2093):             return {}
0.82 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.82 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.82 compiler.py(402):         self.quote_cache[name] = r
0.82 compiler.py(403):         return r
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.82 compiler.py(371):             params_hash = make_hashable(params)
0.82 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.82 compiler.py(374):             seen.add((without_ordering, params_hash))
0.82 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.82 compiler.py(343):         for expr, is_ref in order_by:
0.82 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.82 compiler.py(345):             if self.query.combinator:
0.82 compiler.py(365):             sql, params = self.compile(resolved)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.82 compiler.py(371):             params_hash = make_hashable(params)
0.82 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.82 compiler.py(374):             seen.add((without_ordering, params_hash))
0.82 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.82 compiler.py(343):         for expr, is_ref in order_by:
0.82 compiler.py(376):         return result
0.82 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.82 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.82 compiler.py(379):         extra_select = []
0.82 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.82 compiler.py(386):         return extra_select
0.82 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.82 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.82 compiler.py(97):         if self.query.group_by is None:
0.82 compiler.py(98):             return []
0.82 compiler.py(58):         return extra_select, order_by, group_by
0.82 compiler.py(481):             for_update_part = None
0.82 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.82 compiler.py(484):             combinator = self.query.combinator
0.82 compiler.py(485):             features = self.connection.features
0.82 compiler.py(486):             if combinator:
0.82 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.82 compiler.py(683):         result = []
0.82 compiler.py(684):         params = []
0.82 compiler.py(685):         opts = self.query.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(687):         for name in self.query.distinct_fields:
0.82 compiler.py(698):         return result, params
0.82 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.82 compiler.py(755):         result = []
0.82 compiler.py(756):         params = []
0.82 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.82 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.82 compiler.py(760):             try:
0.82 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.82 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(767):             result.append(clause_sql)
0.82 compiler.py(768):             params.extend(clause_params)
0.82 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.82 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.82 compiler.py(760):             try:
0.82 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.82 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(767):             result.append(clause_sql)
0.82 compiler.py(768):             params.extend(clause_params)
0.82 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.82 compiler.py(769):         for t in self.query.extra_tables:
0.82 compiler.py(776):         return result, params
0.82 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.82 compiler.py(407):         if vendor_impl:
0.82 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(394):         if name in self.quote_cache:
0.82 compiler.py(395):             return self.quote_cache[name]
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.82 compiler.py(413):         return sql, params
0.82 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.82 compiler.py(497):                 result = ['SELECT']
0.82 compiler.py(498):                 params = []
0.82 compiler.py(500):                 if self.query.distinct:
0.82 compiler.py(508):                 out_cols = []
0.82 compiler.py(509):                 col_idx = 1
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(511):                     if alias:
0.82 compiler.py(513):                     elif with_col_aliases:
0.82 compiler.py(516):                     params.extend(s_params)
0.82 compiler.py(517):                     out_cols.append(s_sql)
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(511):                     if alias:
0.82 compiler.py(513):                     elif with_col_aliases:
0.82 compiler.py(516):                     params.extend(s_params)
0.82 compiler.py(517):                     out_cols.append(s_sql)
0.82 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.82 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.82 compiler.py(520):                 params.extend(f_params)
0.82 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.82 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.82 compiler.py(552):                 if where:
0.82 compiler.py(553):                     result.append('WHERE %s' % where)
0.82 compiler.py(554):                     params.extend(w_params)
0.82 compiler.py(556):                 grouping = []
0.82 compiler.py(557):                 for g_sql, g_params in group_by:
0.82 compiler.py(560):                 if grouping:
0.82 compiler.py(577):                 if having:
0.82 compiler.py(581):             if self.query.explain_query:
0.82 compiler.py(587):             if order_by:
0.82 compiler.py(588):                 ordering = []
0.82 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.82 compiler.py(590):                     ordering.append(o_sql)
0.82 compiler.py(591):                     params.extend(o_params)
0.82 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.82 compiler.py(590):                     ordering.append(o_sql)
0.82 compiler.py(591):                     params.extend(o_params)
0.82 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.82 compiler.py(590):                     ordering.append(o_sql)
0.82 compiler.py(591):                     params.extend(o_params)
0.82 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.82 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.82 compiler.py(594):             if with_limit_offset:
0.82 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.82 compiler.py(600):             if self.query.subquery and extra_select:
0.82 compiler.py(627):             return ' '.join(result), tuple(params)
0.82 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.82 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.82 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.82 query.py(820):             self.unref_alias(alias, unref_amount)
0.82 query.py(758):         self.alias_refcount[alias] -= amount
0.82 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.82 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.82 query.py(820):             self.unref_alias(alias, unref_amount)
0.82 query.py(758):         self.alias_refcount[alias] -= amount
0.82 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.82 compiler.py(1083):             if not sql:
0.82 compiler.py(1090):         if chunked_fetch:
0.82 compiler.py(1093):             cursor = self.connection.cursor()
0.82 compiler.py(1094):         try:
0.82 compiler.py(1095):             cursor.execute(sql, params)
0.82 compiler.py(1101):         if result_type == CURSOR:
0.82 compiler.py(1104):         if result_type == SINGLE:
0.82 compiler.py(1113):         if result_type == NO_RESULTS:
0.82 compiler.py(1117):         result = cursor_iter(
0.82 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.82 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.82 compiler.py(1120):             chunk_size,
0.82 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.82 compiler.py(1123):             try:
0.82 compiler.py(1128):                 return list(result)
0.82 compiler.py(1518):     try:
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.82 compiler.py(1522):         cursor.close()
0.82 compiler.py(1131):                 cursor.close()
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.82 compiler.py(1049):         converters = self.get_converters(fields)
0.82 compiler.py(1023):         converters = {}
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1025):             if expression:
0.82 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.82 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.82 compiler.py(1028):                 if backend_converters or field_converters:
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1025):             if expression:
0.82 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.82 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.82 compiler.py(1028):                 if backend_converters or field_converters:
0.82 compiler.py(1024):         for i, expression in enumerate(expressions):
0.82 compiler.py(1030):         return converters
0.82 compiler.py(1050):         rows = chain.from_iterable(results)
0.82 compiler.py(1051):         if converters:
0.82 compiler.py(1055):         return rows
0.82 query.py(154):         self.model = model
0.82 query.py(155):         self.alias_refcount = {}
0.82 query.py(161):         self.alias_map = {}
0.82 query.py(165):         self.external_aliases = set()
0.82 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.82 query.py(167):         self.default_cols = True
0.82 query.py(168):         self.default_ordering = True
0.82 query.py(169):         self.standard_ordering = True
0.82 query.py(170):         self.used_aliases = set()
0.82 query.py(171):         self.filter_is_sticky = False
0.82 query.py(172):         self.subquery = False
0.82 query.py(180):         self.select = ()
0.82 query.py(181):         self.where = where()
0.82 query.py(182):         self.where_class = where
0.82 query.py(189):         self.group_by = None
0.82 query.py(190):         self.order_by = ()
0.82 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.82 query.py(192):         self.distinct = False
0.82 query.py(193):         self.distinct_fields = ()
0.82 query.py(194):         self.select_for_update = False
0.82 query.py(195):         self.select_for_update_nowait = False
0.82 query.py(196):         self.select_for_update_skip_locked = False
0.82 query.py(197):         self.select_for_update_of = ()
0.82 query.py(199):         self.select_related = False
0.82 query.py(201):         self.max_depth = 5
0.82 query.py(205):         self.values_select = ()
0.82 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.82 query.py(209):         self.annotation_select_mask = None
0.82 query.py(210):         self._annotation_select_cache = None
0.82 query.py(213):         self.combinator = None
0.82 query.py(214):         self.combinator_all = False
0.82 query.py(215):         self.combined_queries = ()
0.82 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.82 query.py(220):         self.extra_select_mask = None
0.82 query.py(221):         self._extra_select_cache = None
0.82 query.py(223):         self.extra_tables = ()
0.82 query.py(224):         self.extra_order_by = ()
0.82 query.py(229):         self.deferred_loading = (frozenset(), True)
0.82 query.py(231):         self._filtered_relations = {}
0.82 query.py(233):         self.explain_query = False
0.82 query.py(234):         self.explain_format = None
0.82 query.py(235):         self.explain_options = {}
0.82 query.py(343):         obj = self.clone()
0.82 query.py(297):         obj = Empty()
0.82 query.py(298):         obj.__class__ = self.__class__
0.82 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.82 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.82 query.py(303):         obj.alias_map = self.alias_map.copy()
0.82 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.82 query.py(305):         obj.table_map = self.table_map.copy()
0.82 query.py(306):         obj.where = self.where.clone()
0.82 query.py(307):         obj.annotations = self.annotations.copy()
0.82 query.py(308):         if self.annotation_select_mask is None:
0.82 query.py(309):             obj.annotation_select_mask = None
0.82 query.py(317):         obj._annotation_select_cache = None
0.82 query.py(318):         obj.extra = self.extra.copy()
0.82 query.py(319):         if self.extra_select_mask is None:
0.82 query.py(320):             obj.extra_select_mask = None
0.82 query.py(323):         if self._extra_select_cache is None:
0.82 query.py(324):             obj._extra_select_cache = None
0.82 query.py(327):         if 'subq_aliases' in self.__dict__:
0.82 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.82 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.82 query.py(332):         try:
0.82 query.py(333):             del obj.base_table
0.82 query.py(334):         except AttributeError:
0.82 query.py(335):             pass
0.82 query.py(336):         return obj
0.82 query.py(344):         if klass and obj.__class__ != klass:
0.82 query.py(346):         if not obj.filter_is_sticky:
0.82 query.py(347):             obj.used_aliases = set()
0.82 query.py(348):         obj.filter_is_sticky = False
0.82 query.py(349):         if hasattr(obj, '_setup_query'):
0.82 query.py(351):         return obj
0.82 query.py(154):         self.model = model
0.82 query.py(155):         self.alias_refcount = {}
0.82 query.py(161):         self.alias_map = {}
0.82 query.py(165):         self.external_aliases = set()
0.82 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.82 query.py(167):         self.default_cols = True
0.82 query.py(168):         self.default_ordering = True
0.82 query.py(169):         self.standard_ordering = True
0.82 query.py(170):         self.used_aliases = set()
0.82 query.py(171):         self.filter_is_sticky = False
0.82 query.py(172):         self.subquery = False
0.82 query.py(180):         self.select = ()
0.82 query.py(181):         self.where = where()
0.82 query.py(182):         self.where_class = where
0.82 query.py(189):         self.group_by = None
0.82 query.py(190):         self.order_by = ()
0.82 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.82 query.py(192):         self.distinct = False
0.82 query.py(193):         self.distinct_fields = ()
0.82 query.py(194):         self.select_for_update = False
0.82 query.py(195):         self.select_for_update_nowait = False
0.82 query.py(196):         self.select_for_update_skip_locked = False
0.82 query.py(197):         self.select_for_update_of = ()
0.82 query.py(199):         self.select_related = False
0.82 query.py(201):         self.max_depth = 5
0.82 query.py(205):         self.values_select = ()
0.82 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.82 query.py(209):         self.annotation_select_mask = None
0.82 query.py(210):         self._annotation_select_cache = None
0.82 query.py(213):         self.combinator = None
0.82 query.py(214):         self.combinator_all = False
0.82 query.py(215):         self.combined_queries = ()
0.82 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.82 query.py(220):         self.extra_select_mask = None
0.82 query.py(221):         self._extra_select_cache = None
0.82 query.py(223):         self.extra_tables = ()
0.82 query.py(224):         self.extra_order_by = ()
0.82 query.py(229):         self.deferred_loading = (frozenset(), True)
0.82 query.py(231):         self._filtered_relations = {}
0.82 query.py(233):         self.explain_query = False
0.82 query.py(234):         self.explain_format = None
0.82 query.py(235):         self.explain_options = {}
0.82 query.py(278):         if using is None and connection is None:
0.82 query.py(280):         if using:
0.82 query.py(281):             connection = connections[using]
0.82 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.82 compiler.py(25):         self.query = query
0.82 compiler.py(26):         self.connection = connection
0.82 compiler.py(27):         self.using = using
0.82 compiler.py(28):         self.quote_cache = {'*': '*'}
0.82 compiler.py(33):         self.select = None
0.82 compiler.py(34):         self.annotation_col_map = None
0.82 compiler.py(35):         self.klass_info = None
0.82 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.82 compiler.py(38):         self._meta_ordering = None
0.82 compiler.py(1330):             return_id and len(self.query.objs) != 1 and
0.82 compiler.py(1333):         self.return_id = return_id
0.82 compiler.py(1334):         with self.connection.cursor() as cursor:
0.82 compiler.py(1335):             for sql, params in self.as_sql():
0.82 compiler.py(1269):         qn = self.connection.ops.quote_name
0.82 compiler.py(1270):         opts = self.query.get_meta()
0.82 query.py(290):         return self.model._meta
0.82 compiler.py(1271):         insert_statement = self.connection.ops.insert_statement(ignore_conflicts=self.query.ignore_conflicts)
0.82 compiler.py(1272):         result = ['%s %s' % (insert_statement, qn(opts.db_table))]
0.82 compiler.py(1273):         fields = self.query.fields or [opts.pk]
0.82 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.82 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.82 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.82 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.82 compiler.py(1274):         result.append('(%s)' % ', '.join(qn(f.column) for f in fields))
0.82 compiler.py(1276):         if self.query.fields:
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1279):                 for obj in self.query.objs
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1279):                 for obj in self.query.objs
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1279):                 for obj in self.query.objs
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1279):                 for obj in self.query.objs
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1279):                 for obj in self.query.objs
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1227):         if self.query.raw:
0.82 compiler.py(1229):         return field.pre_save(obj, add=True)
0.82 compiler.py(1198):         if hasattr(value, 'resolve_expression'):
0.82 compiler.py(1219):             value = field.get_db_prep_save(value, connection=self.connection)
0.82 compiler.py(1220):         return value
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1278):                 [self.prepare_value(field, self.pre_save_val(field, obj)) for field in fields]
0.82 compiler.py(1290):         can_bulk = (not self.return_id and self.connection.features.has_bulk_insert)
0.82 compiler.py(1292):         placeholder_rows, param_rows = self.assemble_as_sql(fields, value_rows)
0.82 compiler.py(1243):         if not value_rows:
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1250):             for row in value_rows
0.82 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.82 compiler.py(1259):         placeholder_rows, param_rows = zip(*sql_and_param_pair_rows)
0.82 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1250):             for row in value_rows
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1250):             for row in value_rows
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.82 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.82 compiler.py(1182):             sql, params = '%s', [val]
0.82 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.82 compiler.py(1191):         return sql, params
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1250):             for row in value_rows
0.82 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.82 compiler.py(1170):         if field is None:
0.82 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1170):         if field is None:
0.83 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1170):         if field is None:
0.83 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1250):             for row in value_rows
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1170):         if field is None:
0.83 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1170):         if field is None:
0.83 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1170):         if field is None:
0.83 compiler.py(1173):         elif hasattr(val, 'as_sql'):
0.83 compiler.py(1176):         elif hasattr(field, 'get_placeholder'):
0.83 compiler.py(1182):             sql, params = '%s', [val]
0.83 compiler.py(1189):         params = self.connection.ops.modify_insert_params(sql, params)
0.83 compiler.py(1191):         return sql, params
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1255):         sql_and_param_pair_rows = (zip(*row) for row in rows_of_fields_as_sql)
0.83 compiler.py(1249):             (self.field_as_sql(field, v) for field, v in zip(fields, row))
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1262):         param_rows = [[p for ps in row for p in ps] for row in param_rows]
0.83 compiler.py(1264):         return placeholder_rows, param_rows
0.83 compiler.py(1294):         ignore_conflicts_suffix_sql = self.connection.ops.ignore_conflicts_suffix_sql(
0.83 compiler.py(1295):             ignore_conflicts=self.query.ignore_conflicts
0.83 compiler.py(1297):         if self.return_id and self.connection.features.can_return_columns_from_insert:
0.83 compiler.py(1315):         if can_bulk:
0.83 compiler.py(1316):             result.append(self.connection.ops.bulk_insert_sql(fields, placeholder_rows))
0.83 compiler.py(1317):             if ignore_conflicts_suffix_sql:
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1319):             return [(" ".join(result), tuple(p for ps in param_rows for p in ps))]
0.83 compiler.py(1336):                 cursor.execute(sql, params)
0.83 compiler.py(1335):             for sql, params in self.as_sql():
0.83 compiler.py(1337):             if not return_id:
0.83 compiler.py(1338):                 return
0.83 query.py(154):         self.model = model
0.83 query.py(155):         self.alias_refcount = {}
0.83 query.py(161):         self.alias_map = {}
0.83 query.py(165):         self.external_aliases = set()
0.83 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.83 query.py(167):         self.default_cols = True
0.83 query.py(168):         self.default_ordering = True
0.83 query.py(169):         self.standard_ordering = True
0.83 query.py(170):         self.used_aliases = set()
0.83 query.py(171):         self.filter_is_sticky = False
0.83 query.py(172):         self.subquery = False
0.83 query.py(180):         self.select = ()
0.83 query.py(181):         self.where = where()
0.83 query.py(182):         self.where_class = where
0.83 query.py(189):         self.group_by = None
0.83 query.py(190):         self.order_by = ()
0.83 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.83 query.py(192):         self.distinct = False
0.83 query.py(193):         self.distinct_fields = ()
0.83 query.py(194):         self.select_for_update = False
0.83 query.py(195):         self.select_for_update_nowait = False
0.83 query.py(196):         self.select_for_update_skip_locked = False
0.83 query.py(197):         self.select_for_update_of = ()
0.83 query.py(199):         self.select_related = False
0.83 query.py(201):         self.max_depth = 5
0.83 query.py(205):         self.values_select = ()
0.83 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.83 query.py(209):         self.annotation_select_mask = None
0.83 query.py(210):         self._annotation_select_cache = None
0.83 query.py(213):         self.combinator = None
0.83 query.py(214):         self.combinator_all = False
0.83 query.py(215):         self.combined_queries = ()
0.83 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.83 query.py(220):         self.extra_select_mask = None
0.83 query.py(221):         self._extra_select_cache = None
0.83 query.py(223):         self.extra_tables = ()
0.83 query.py(224):         self.extra_order_by = ()
0.83 query.py(229):         self.deferred_loading = (frozenset(), True)
0.83 query.py(231):         self._filtered_relations = {}
0.83 query.py(233):         self.explain_query = False
0.83 query.py(234):         self.explain_format = None
0.83 query.py(235):         self.explain_options = {}
0.83 query.py(343):         obj = self.clone()
0.83 query.py(297):         obj = Empty()
0.83 query.py(298):         obj.__class__ = self.__class__
0.83 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.83 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.83 query.py(303):         obj.alias_map = self.alias_map.copy()
0.83 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.83 query.py(305):         obj.table_map = self.table_map.copy()
0.83 query.py(306):         obj.where = self.where.clone()
0.83 query.py(307):         obj.annotations = self.annotations.copy()
0.83 query.py(308):         if self.annotation_select_mask is None:
0.83 query.py(309):             obj.annotation_select_mask = None
0.83 query.py(317):         obj._annotation_select_cache = None
0.83 query.py(318):         obj.extra = self.extra.copy()
0.83 query.py(319):         if self.extra_select_mask is None:
0.83 query.py(320):             obj.extra_select_mask = None
0.83 query.py(323):         if self._extra_select_cache is None:
0.83 query.py(324):             obj._extra_select_cache = None
0.83 query.py(327):         if 'subq_aliases' in self.__dict__:
0.83 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.83 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.83 query.py(332):         try:
0.83 query.py(333):             del obj.base_table
0.83 query.py(334):         except AttributeError:
0.83 query.py(335):             pass
0.83 query.py(336):         return obj
0.83 query.py(344):         if klass and obj.__class__ != klass:
0.83 query.py(346):         if not obj.filter_is_sticky:
0.83 query.py(347):             obj.used_aliases = set()
0.83 query.py(348):         obj.filter_is_sticky = False
0.83 query.py(349):         if hasattr(obj, '_setup_query'):
0.83 query.py(351):         return obj
0.83 query.py(278):         if using is None and connection is None:
0.83 query.py(280):         if using:
0.83 query.py(281):             connection = connections[using]
0.83 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.83 compiler.py(25):         self.query = query
0.83 compiler.py(26):         self.connection = connection
0.83 compiler.py(27):         self.using = using
0.83 compiler.py(28):         self.quote_cache = {'*': '*'}
0.83 compiler.py(33):         self.select = None
0.83 compiler.py(34):         self.annotation_col_map = None
0.83 compiler.py(35):         self.klass_info = None
0.83 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.83 compiler.py(38):         self._meta_ordering = None
0.83 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.83 compiler.py(1081):         try:
0.83 compiler.py(1082):             sql, params = self.as_sql()
0.83 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.83 compiler.py(479):         try:
0.83 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.83 compiler.py(52):         self.setup_query()
0.83 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.83 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.83 compiler.py(42):             self.query.get_initial_alias()
0.83 query.py(912):         if self.alias_map:
0.83 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.83 query.py(290):         return self.model._meta
0.83 query.py(943):         if reuse_with_filtered_relation and reuse:
0.83 query.py(950):                 a for a, j in self.alias_map.items()
0.83 query.py(950):                 a for a, j in self.alias_map.items()
0.83 query.py(953):         if reuse_aliases:
0.83 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.83 query.py(735):         alias_list = self.table_map.get(table_name)
0.83 query.py(736):         if not create and alias_list:
0.83 query.py(742):         if alias_list:
0.83 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.83 query.py(748):             self.table_map[table_name] = [alias]
0.83 query.py(749):         self.alias_refcount[alias] = 1
0.83 query.py(750):         return alias, True
0.83 query.py(965):         if join.join_type:
0.83 query.py(971):         join.table_alias = alias
0.83 query.py(972):         self.alias_map[alias] = join
0.83 query.py(973):         return alias
0.83 query.py(917):         return alias
0.83 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.83 compiler.py(202):         select = []
0.83 compiler.py(203):         klass_info = None
0.83 compiler.py(204):         annotations = {}
0.83 compiler.py(205):         select_idx = 0
0.83 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.83 compiler.py(211):         if self.query.default_cols:
0.83 compiler.py(212):             cols = self.get_default_columns()
0.83 compiler.py(644):         result = []
0.83 compiler.py(645):         if opts is None:
0.83 compiler.py(646):             opts = self.query.get_meta()
0.83 query.py(290):         return self.model._meta
0.83 compiler.py(647):         only_load = self.deferred_to_columns()
0.83 compiler.py(1018):         columns = {}
0.83 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.83 query.py(655):         field_names, defer = self.deferred_loading
0.83 query.py(656):         if not field_names:
0.83 query.py(657):             return
0.83 compiler.py(1020):         return columns
0.83 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.83 query.py(912):         if self.alias_map:
0.83 query.py(913):             alias = self.base_table
0.83 query.py(250):         for alias in self.alias_map:
0.83 query.py(251):             return alias
0.83 query.py(914):             self.ref_alias(alias)
0.83 query.py(754):         self.alias_refcount[alias] += 1
0.83 query.py(917):         return alias
0.83 compiler.py(652):         seen_models = {None: start_alias}
0.83 compiler.py(654):         for field in opts.concrete_fields:
0.83 compiler.py(655):             model = field.model._meta.concrete_model
0.83 compiler.py(658):             if model == opts.model:
0.83 compiler.py(659):                 model = None
0.83 compiler.py(660):             if from_parent and model is not None and issubclass(
0.83 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.83 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.83 compiler.py(671):                                                  seen_models)
0.83 query.py(984):         if model in seen:
0.83 query.py(985):             return seen[model]
0.83 compiler.py(672):             column = field.get_col(alias)
0.83 compiler.py(673):             result.append(column)
0.83 compiler.py(654):         for field in opts.concrete_fields:
0.83 compiler.py(655):             model = field.model._meta.concrete_model
0.83 compiler.py(658):             if model == opts.model:
0.83 compiler.py(659):                 model = None
0.83 compiler.py(660):             if from_parent and model is not None and issubclass(
0.83 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.83 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.83 compiler.py(671):                                                  seen_models)
0.83 query.py(984):         if model in seen:
0.83 query.py(985):             return seen[model]
0.83 compiler.py(672):             column = field.get_col(alias)
0.83 compiler.py(673):             result.append(column)
0.83 compiler.py(654):         for field in opts.concrete_fields:
0.83 compiler.py(655):             model = field.model._meta.concrete_model
0.83 compiler.py(658):             if model == opts.model:
0.83 compiler.py(659):                 model = None
0.83 compiler.py(660):             if from_parent and model is not None and issubclass(
0.83 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.83 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.83 compiler.py(671):                                                  seen_models)
0.83 query.py(984):         if model in seen:
0.83 query.py(985):             return seen[model]
0.83 compiler.py(672):             column = field.get_col(alias)
0.83 compiler.py(673):             result.append(column)
0.83 compiler.py(654):         for field in opts.concrete_fields:
0.83 compiler.py(655):             model = field.model._meta.concrete_model
0.83 compiler.py(658):             if model == opts.model:
0.83 compiler.py(659):                 model = None
0.83 compiler.py(660):             if from_parent and model is not None and issubclass(
0.83 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.83 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.83 compiler.py(671):                                                  seen_models)
0.83 query.py(984):         if model in seen:
0.83 query.py(985):             return seen[model]
0.83 compiler.py(672):             column = field.get_col(alias)
0.83 compiler.py(673):             result.append(column)
0.83 compiler.py(654):         for field in opts.concrete_fields:
0.83 compiler.py(674):         return result
0.83 compiler.py(217):         if cols:
0.83 compiler.py(218):             select_list = []
0.83 compiler.py(219):             for col in cols:
0.83 compiler.py(220):                 select_list.append(select_idx)
0.83 compiler.py(221):                 select.append((col, None))
0.83 compiler.py(222):                 select_idx += 1
0.83 compiler.py(219):             for col in cols:
0.83 compiler.py(220):                 select_list.append(select_idx)
0.83 compiler.py(221):                 select.append((col, None))
0.83 compiler.py(222):                 select_idx += 1
0.83 compiler.py(219):             for col in cols:
0.83 compiler.py(220):                 select_list.append(select_idx)
0.83 compiler.py(221):                 select.append((col, None))
0.83 compiler.py(222):                 select_idx += 1
0.83 compiler.py(219):             for col in cols:
0.83 compiler.py(220):                 select_list.append(select_idx)
0.83 compiler.py(221):                 select.append((col, None))
0.83 compiler.py(222):                 select_idx += 1
0.83 compiler.py(219):             for col in cols:
0.83 compiler.py(224):                 'model': self.query.model,
0.83 compiler.py(225):                 'select_fields': select_list,
0.83 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.83 query.py(2075):         if self._annotation_select_cache is not None:
0.83 query.py(2077):         elif not self.annotations:
0.83 query.py(2078):             return {}
0.83 compiler.py(232):         if self.query.select_related:
0.83 compiler.py(244):         ret = []
0.83 compiler.py(245):         for col, alias in select:
0.83 compiler.py(246):             try:
0.83 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.83 compiler.py(397):                 name in self.query.extra_select or (
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.83 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.83 compiler.py(402):         self.quote_cache[name] = r
0.83 compiler.py(403):         return r
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.83 compiler.py(397):                 name in self.query.extra_select or (
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.83 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.83 compiler.py(402):         self.quote_cache[name] = r
0.83 compiler.py(403):         return r
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.83 compiler.py(251):             ret.append((col, (sql, params), alias))
0.83 compiler.py(245):         for col, alias in select:
0.83 compiler.py(246):             try:
0.83 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(395):             return self.quote_cache[name]
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.83 compiler.py(397):                 name in self.query.extra_select or (
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.83 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.83 compiler.py(402):         self.quote_cache[name] = r
0.83 compiler.py(403):         return r
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.83 compiler.py(251):             ret.append((col, (sql, params), alias))
0.83 compiler.py(245):         for col, alias in select:
0.83 compiler.py(246):             try:
0.83 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(395):             return self.quote_cache[name]
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.83 compiler.py(397):                 name in self.query.extra_select or (
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.83 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.83 compiler.py(402):         self.quote_cache[name] = r
0.83 compiler.py(403):         return r
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.83 compiler.py(251):             ret.append((col, (sql, params), alias))
0.83 compiler.py(245):         for col, alias in select:
0.83 compiler.py(246):             try:
0.83 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(395):             return self.quote_cache[name]
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.83 compiler.py(397):                 name in self.query.extra_select or (
0.83 query.py(2090):         if self._extra_select_cache is not None:
0.83 query.py(2092):         if not self.extra:
0.83 query.py(2093):             return {}
0.83 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.83 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.83 compiler.py(402):         self.quote_cache[name] = r
0.83 compiler.py(403):         return r
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.83 compiler.py(251):             ret.append((col, (sql, params), alias))
0.83 compiler.py(245):         for col, alias in select:
0.83 compiler.py(252):         return ret, klass_info, annotations
0.83 compiler.py(44):         self.col_count = len(self.select)
0.83 compiler.py(53):         order_by = self.get_order_by()
0.83 compiler.py(263):         if self.query.extra_order_by:
0.83 compiler.py(265):         elif not self.query.default_ordering:
0.83 compiler.py(267):         elif self.query.order_by:
0.83 compiler.py(269):         elif self.query.get_meta().ordering:
0.83 query.py(290):         return self.model._meta
0.83 compiler.py(273):             ordering = []
0.83 compiler.py(274):         if self.query.standard_ordering:
0.83 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.83 compiler.py(279):         order_by = []
0.83 compiler.py(280):         for field in ordering:
0.83 compiler.py(340):         result = []
0.83 compiler.py(341):         seen = set()
0.83 compiler.py(343):         for expr, is_ref in order_by:
0.83 compiler.py(376):         return result
0.83 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.83 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.83 compiler.py(379):         extra_select = []
0.83 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.83 compiler.py(386):         return extra_select
0.83 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.83 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.83 compiler.py(97):         if self.query.group_by is None:
0.83 compiler.py(98):             return []
0.83 compiler.py(58):         return extra_select, order_by, group_by
0.83 compiler.py(481):             for_update_part = None
0.83 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.83 compiler.py(484):             combinator = self.query.combinator
0.83 compiler.py(485):             features = self.connection.features
0.83 compiler.py(486):             if combinator:
0.83 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.83 compiler.py(683):         result = []
0.83 compiler.py(684):         params = []
0.83 compiler.py(685):         opts = self.query.get_meta()
0.83 query.py(290):         return self.model._meta
0.83 compiler.py(687):         for name in self.query.distinct_fields:
0.83 compiler.py(698):         return result, params
0.83 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.83 compiler.py(755):         result = []
0.83 compiler.py(756):         params = []
0.83 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.83 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.83 compiler.py(760):             try:
0.83 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.83 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(394):         if name in self.quote_cache:
0.83 compiler.py(395):             return self.quote_cache[name]
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(413):         return sql, params
0.83 compiler.py(767):             result.append(clause_sql)
0.83 compiler.py(768):             params.extend(clause_params)
0.83 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.83 compiler.py(769):         for t in self.query.extra_tables:
0.83 compiler.py(776):         return result, params
0.83 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.83 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.83 compiler.py(407):         if vendor_impl:
0.83 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.83 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.83 compiler.py(413):         return sql, params
0.83 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.83 compiler.py(497):                 result = ['SELECT']
0.83 compiler.py(498):                 params = []
0.83 compiler.py(500):                 if self.query.distinct:
0.83 compiler.py(508):                 out_cols = []
0.83 compiler.py(509):                 col_idx = 1
0.83 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.83 compiler.py(511):                     if alias:
0.83 compiler.py(513):                     elif with_col_aliases:
0.83 compiler.py(516):                     params.extend(s_params)
0.83 compiler.py(517):                     out_cols.append(s_sql)
0.83 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.83 compiler.py(511):                     if alias:
0.83 compiler.py(513):                     elif with_col_aliases:
0.83 compiler.py(516):                     params.extend(s_params)
0.83 compiler.py(517):                     out_cols.append(s_sql)
0.83 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.83 compiler.py(511):                     if alias:
0.83 compiler.py(513):                     elif with_col_aliases:
0.83 compiler.py(516):                     params.extend(s_params)
0.83 compiler.py(517):                     out_cols.append(s_sql)
0.83 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.83 compiler.py(511):                     if alias:
0.83 compiler.py(513):                     elif with_col_aliases:
0.83 compiler.py(516):                     params.extend(s_params)
0.83 compiler.py(517):                     out_cols.append(s_sql)
0.83 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.83 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.83 compiler.py(520):                 params.extend(f_params)
0.83 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.83 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.83 compiler.py(552):                 if where:
0.83 compiler.py(556):                 grouping = []
0.83 compiler.py(557):                 for g_sql, g_params in group_by:
0.83 compiler.py(560):                 if grouping:
0.83 compiler.py(577):                 if having:
0.83 compiler.py(581):             if self.query.explain_query:
0.83 compiler.py(587):             if order_by:
0.83 compiler.py(594):             if with_limit_offset:
0.83 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.83 compiler.py(600):             if self.query.subquery and extra_select:
0.83 compiler.py(627):             return ' '.join(result), tuple(params)
0.83 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.83 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.83 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.83 query.py(820):             self.unref_alias(alias, unref_amount)
0.83 query.py(758):         self.alias_refcount[alias] -= amount
0.83 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.83 compiler.py(1083):             if not sql:
0.83 compiler.py(1090):         if chunked_fetch:
0.83 compiler.py(1093):             cursor = self.connection.cursor()
0.83 compiler.py(1094):         try:
0.83 compiler.py(1095):             cursor.execute(sql, params)
0.83 compiler.py(1101):         if result_type == CURSOR:
0.83 compiler.py(1104):         if result_type == SINGLE:
0.83 compiler.py(1113):         if result_type == NO_RESULTS:
0.83 compiler.py(1117):         result = cursor_iter(
0.83 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.83 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.83 compiler.py(1120):             chunk_size,
0.83 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.83 compiler.py(1123):             try:
0.83 compiler.py(1128):                 return list(result)
0.83 compiler.py(1518):     try:
0.83 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.83 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.83 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.83 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.83 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.83 compiler.py(1522):         cursor.close()
0.83 compiler.py(1131):                 cursor.close()
0.83 compiler.py(1046):         if results is None:
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.83 compiler.py(1049):         converters = self.get_converters(fields)
0.83 compiler.py(1023):         converters = {}
0.83 compiler.py(1024):         for i, expression in enumerate(expressions):
0.83 compiler.py(1025):             if expression:
0.83 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.83 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.83 compiler.py(1028):                 if backend_converters or field_converters:
0.83 compiler.py(1024):         for i, expression in enumerate(expressions):
0.83 compiler.py(1025):             if expression:
0.83 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.83 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.83 compiler.py(1028):                 if backend_converters or field_converters:
0.83 compiler.py(1024):         for i, expression in enumerate(expressions):
0.83 compiler.py(1025):             if expression:
0.83 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.83 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.83 compiler.py(1028):                 if backend_converters or field_converters:
0.83 compiler.py(1024):         for i, expression in enumerate(expressions):
0.83 compiler.py(1025):             if expression:
0.83 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.83 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.83 compiler.py(1028):                 if backend_converters or field_converters:
0.83 compiler.py(1029):                     converters[i] = (backend_converters + field_converters, expression)
0.83 compiler.py(1024):         for i, expression in enumerate(expressions):
0.83 compiler.py(1030):         return converters
0.83 compiler.py(1050):         rows = chain.from_iterable(results)
0.83 compiler.py(1051):         if converters:
0.83 compiler.py(1052):             rows = self.apply_converters(rows, converters)
0.83 compiler.py(1053):             if tuple_expected:
0.83 compiler.py(1055):         return rows
0.83 compiler.py(1033):         connection = self.connection
0.83 compiler.py(1034):         converters = list(converters.items())
0.83 compiler.py(1035):         for row in map(list, rows):
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1037):                 value = row[pos]
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1039):                     value = converter(value, expression, connection)
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1040):                 row[pos] = value
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1041):             yield row
0.83 compiler.py(1035):         for row in map(list, rows):
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1037):                 value = row[pos]
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1039):                     value = converter(value, expression, connection)
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1040):                 row[pos] = value
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1041):             yield row
0.83 compiler.py(1035):         for row in map(list, rows):
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1037):                 value = row[pos]
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1039):                     value = converter(value, expression, connection)
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1040):                 row[pos] = value
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1041):             yield row
0.83 compiler.py(1035):         for row in map(list, rows):
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1037):                 value = row[pos]
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1039):                     value = converter(value, expression, connection)
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1040):                 row[pos] = value
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1041):             yield row
0.83 compiler.py(1035):         for row in map(list, rows):
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1037):                 value = row[pos]
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1039):                     value = converter(value, expression, connection)
0.83 compiler.py(1038):                 for converter in convs:
0.83 compiler.py(1040):                 row[pos] = value
0.83 compiler.py(1036):             for pos, (convs, expression) in converters:
0.83 compiler.py(1041):             yield row
0.83 compiler.py(1035):         for row in map(list, rows):
0.86 query.py(154):         self.model = model
0.86 query.py(155):         self.alias_refcount = {}
0.86 query.py(161):         self.alias_map = {}
0.86 query.py(165):         self.external_aliases = set()
0.86 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.86 query.py(167):         self.default_cols = True
0.86 query.py(168):         self.default_ordering = True
0.86 query.py(169):         self.standard_ordering = True
0.86 query.py(170):         self.used_aliases = set()
0.86 query.py(171):         self.filter_is_sticky = False
0.86 query.py(172):         self.subquery = False
0.86 query.py(180):         self.select = ()
0.86 query.py(181):         self.where = where()
0.86 query.py(182):         self.where_class = where
0.86 query.py(189):         self.group_by = None
0.86 query.py(190):         self.order_by = ()
0.86 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.86 query.py(192):         self.distinct = False
0.86 query.py(193):         self.distinct_fields = ()
0.86 query.py(194):         self.select_for_update = False
0.86 query.py(195):         self.select_for_update_nowait = False
0.86 query.py(196):         self.select_for_update_skip_locked = False
0.86 query.py(197):         self.select_for_update_of = ()
0.86 query.py(199):         self.select_related = False
0.86 query.py(201):         self.max_depth = 5
0.86 query.py(205):         self.values_select = ()
0.86 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.86 query.py(209):         self.annotation_select_mask = None
0.86 query.py(210):         self._annotation_select_cache = None
0.86 query.py(213):         self.combinator = None
0.86 query.py(214):         self.combinator_all = False
0.86 query.py(215):         self.combined_queries = ()
0.86 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.86 query.py(220):         self.extra_select_mask = None
0.86 query.py(221):         self._extra_select_cache = None
0.86 query.py(223):         self.extra_tables = ()
0.86 query.py(224):         self.extra_order_by = ()
0.86 query.py(229):         self.deferred_loading = (frozenset(), True)
0.86 query.py(231):         self._filtered_relations = {}
0.86 query.py(233):         self.explain_query = False
0.86 query.py(234):         self.explain_format = None
0.86 query.py(235):         self.explain_options = {}
0.86 query.py(343):         obj = self.clone()
0.86 query.py(297):         obj = Empty()
0.86 query.py(298):         obj.__class__ = self.__class__
0.86 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.86 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.86 query.py(303):         obj.alias_map = self.alias_map.copy()
0.86 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.86 query.py(305):         obj.table_map = self.table_map.copy()
0.86 query.py(306):         obj.where = self.where.clone()
0.86 query.py(307):         obj.annotations = self.annotations.copy()
0.86 query.py(308):         if self.annotation_select_mask is None:
0.86 query.py(309):             obj.annotation_select_mask = None
0.86 query.py(317):         obj._annotation_select_cache = None
0.86 query.py(318):         obj.extra = self.extra.copy()
0.86 query.py(319):         if self.extra_select_mask is None:
0.86 query.py(320):             obj.extra_select_mask = None
0.86 query.py(323):         if self._extra_select_cache is None:
0.86 query.py(324):             obj._extra_select_cache = None
0.86 query.py(327):         if 'subq_aliases' in self.__dict__:
0.86 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.86 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.86 query.py(332):         try:
0.86 query.py(333):             del obj.base_table
0.86 query.py(334):         except AttributeError:
0.86 query.py(335):             pass
0.86 query.py(336):         return obj
0.86 query.py(344):         if klass and obj.__class__ != klass:
0.86 query.py(346):         if not obj.filter_is_sticky:
0.86 query.py(347):             obj.used_aliases = set()
0.86 query.py(348):         obj.filter_is_sticky = False
0.86 query.py(349):         if hasattr(obj, '_setup_query'):
0.86 query.py(351):         return obj
0.86 query.py(1758):         return not self.low_mark and self.high_mark is None
0.86 query.py(343):         obj = self.clone()
0.86 query.py(297):         obj = Empty()
0.86 query.py(298):         obj.__class__ = self.__class__
0.86 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.86 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.86 query.py(303):         obj.alias_map = self.alias_map.copy()
0.86 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.86 query.py(305):         obj.table_map = self.table_map.copy()
0.86 query.py(306):         obj.where = self.where.clone()
0.86 query.py(307):         obj.annotations = self.annotations.copy()
0.86 query.py(308):         if self.annotation_select_mask is None:
0.86 query.py(309):             obj.annotation_select_mask = None
0.86 query.py(317):         obj._annotation_select_cache = None
0.86 query.py(318):         obj.extra = self.extra.copy()
0.86 query.py(319):         if self.extra_select_mask is None:
0.86 query.py(320):             obj.extra_select_mask = None
0.86 query.py(323):         if self._extra_select_cache is None:
0.86 query.py(324):             obj._extra_select_cache = None
0.86 query.py(327):         if 'subq_aliases' in self.__dict__:
0.86 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.86 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.86 query.py(332):         try:
0.86 query.py(333):             del obj.base_table
0.86 query.py(334):         except AttributeError:
0.86 query.py(335):             pass
0.86 query.py(336):         return obj
0.86 query.py(344):         if klass and obj.__class__ != klass:
0.86 query.py(346):         if not obj.filter_is_sticky:
0.86 query.py(347):             obj.used_aliases = set()
0.86 query.py(348):         obj.filter_is_sticky = False
0.86 query.py(349):         if hasattr(obj, '_setup_query'):
0.86 query.py(351):         return obj
0.86 query.py(1860):         self.order_by = ()
0.86 query.py(1861):         self.extra_order_by = ()
0.86 query.py(1862):         if force_empty:
0.86 query.py(1839):         errors = []
0.86 query.py(1840):         for item in ordering:
0.86 query.py(1841):             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):
0.87 query.py(1843):             if getattr(item, 'contains_aggregate', False):
0.87 query.py(1840):         for item in ordering:
0.87 query.py(1848):         if errors:
0.87 query.py(1850):         if ordering:
0.87 query.py(1851):             self.order_by += ordering
0.87 query.py(278):         if using is None and connection is None:
0.87 query.py(280):         if using:
0.87 query.py(281):             connection = connections[using]
0.87 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.87 compiler.py(25):         self.query = query
0.87 compiler.py(26):         self.connection = connection
0.87 compiler.py(27):         self.using = using
0.87 compiler.py(28):         self.quote_cache = {'*': '*'}
0.87 compiler.py(33):         self.select = None
0.87 compiler.py(34):         self.annotation_col_map = None
0.87 compiler.py(35):         self.klass_info = None
0.87 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.87 compiler.py(38):         self._meta_ordering = None
0.87 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.87 compiler.py(1081):         try:
0.87 compiler.py(1082):             sql, params = self.as_sql()
0.87 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.87 compiler.py(479):         try:
0.87 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.87 compiler.py(52):         self.setup_query()
0.87 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.87 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.87 compiler.py(42):             self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.87 query.py(290):         return self.model._meta
0.87 query.py(943):         if reuse_with_filtered_relation and reuse:
0.87 query.py(950):                 a for a, j in self.alias_map.items()
0.87 query.py(950):                 a for a, j in self.alias_map.items()
0.87 query.py(953):         if reuse_aliases:
0.87 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.87 query.py(735):         alias_list = self.table_map.get(table_name)
0.87 query.py(736):         if not create and alias_list:
0.87 query.py(742):         if alias_list:
0.87 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.87 query.py(748):             self.table_map[table_name] = [alias]
0.87 query.py(749):         self.alias_refcount[alias] = 1
0.87 query.py(750):         return alias, True
0.87 query.py(965):         if join.join_type:
0.87 query.py(971):         join.table_alias = alias
0.87 query.py(972):         self.alias_map[alias] = join
0.87 query.py(973):         return alias
0.87 query.py(917):         return alias
0.87 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.87 compiler.py(202):         select = []
0.87 compiler.py(203):         klass_info = None
0.87 compiler.py(204):         annotations = {}
0.87 compiler.py(205):         select_idx = 0
0.87 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.87 compiler.py(211):         if self.query.default_cols:
0.87 compiler.py(212):             cols = self.get_default_columns()
0.87 compiler.py(644):         result = []
0.87 compiler.py(645):         if opts is None:
0.87 compiler.py(646):             opts = self.query.get_meta()
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(647):         only_load = self.deferred_to_columns()
0.87 compiler.py(1018):         columns = {}
0.87 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.87 query.py(655):         field_names, defer = self.deferred_loading
0.87 query.py(656):         if not field_names:
0.87 query.py(657):             return
0.87 compiler.py(1020):         return columns
0.87 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(913):             alias = self.base_table
0.87 query.py(250):         for alias in self.alias_map:
0.87 query.py(251):             return alias
0.87 query.py(914):             self.ref_alias(alias)
0.87 query.py(754):         self.alias_refcount[alias] += 1
0.87 query.py(917):         return alias
0.87 compiler.py(652):         seen_models = {None: start_alias}
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(674):         return result
0.87 compiler.py(217):         if cols:
0.87 compiler.py(218):             select_list = []
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(224):                 'model': self.query.model,
0.87 compiler.py(225):                 'select_fields': select_list,
0.87 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.87 query.py(2075):         if self._annotation_select_cache is not None:
0.87 query.py(2077):         elif not self.annotations:
0.87 query.py(2078):             return {}
0.87 compiler.py(232):         if self.query.select_related:
0.87 compiler.py(244):         ret = []
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(252):         return ret, klass_info, annotations
0.87 compiler.py(44):         self.col_count = len(self.select)
0.87 compiler.py(53):         order_by = self.get_order_by()
0.87 compiler.py(263):         if self.query.extra_order_by:
0.87 compiler.py(265):         elif not self.query.default_ordering:
0.87 compiler.py(267):         elif self.query.order_by:
0.87 compiler.py(268):             ordering = self.query.order_by
0.87 compiler.py(274):         if self.query.standard_ordering:
0.87 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.87 compiler.py(279):         order_by = []
0.87 compiler.py(280):         for field in ordering:
0.87 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.87 compiler.py(292):             if field == '?':  # random
0.87 compiler.py(296):             col, order = get_order_dir(field, asc)
0.87 query.py(2204):     dirn = ORDER_DIR[default]
0.87 query.py(2205):     if field[0] == '-':
0.87 query.py(2207):     return field, dirn[0]
0.87 compiler.py(297):             descending = order == 'DESC'
0.87 compiler.py(299):             if col in self.query.annotation_select:
0.87 query.py(2075):         if self._annotation_select_cache is not None:
0.87 query.py(2077):         elif not self.annotations:
0.87 query.py(2078):             return {}
0.87 compiler.py(305):             if col in self.query.annotations:
0.87 compiler.py(315):             if '.' in field:
0.87 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.87 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.87 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.87 query.py(2204):     dirn = ORDER_DIR[default]
0.87 query.py(2205):     if field[0] == '-':
0.87 query.py(2207):     return field, dirn[0]
0.87 compiler.py(708):         descending = order == 'DESC'
0.87 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.87 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.87 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(913):             alias = self.base_table
0.87 query.py(914):             self.ref_alias(alias)
0.87 query.py(754):         self.alias_refcount[alias] += 1
0.87 query.py(917):         return alias
0.87 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.87 query.py(1518):         joins = [alias]
0.87 query.py(1524):         def final_transformer(field, alias):
0.87 query.py(1529):         last_field_exception = None
0.87 query.py(1530):         for pivot in range(len(names), 0, -1):
0.87 query.py(1531):             try:
0.87 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.87 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.87 query.py(1405):         path, names_with_path = [], []
0.87 query.py(1406):         for pos, name in enumerate(names):
0.87 query.py(1407):             cur_names_with_path = (name, [])
0.87 query.py(1408):             if name == 'pk':
0.87 query.py(1411):             field = None
0.87 query.py(1412):             filtered_relation = None
0.87 query.py(1413):             try:
0.87 query.py(1414):                 field = opts.get_field(name)
0.87 query.py(1421):             if field is not None:
0.87 query.py(1425):                 if field.is_relation and not field.related_model:
0.87 query.py(1432):                 try:
0.87 query.py(1433):                     model = field.model._meta.concrete_model
0.87 query.py(1454):             if model is not opts.model:
0.87 query.py(1460):             if hasattr(field, 'get_path_info'):
0.87 query.py(1477):                 final_field = field
0.87 query.py(1478):                 targets = (field,)
0.87 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.87 query.py(1483):                 break
0.87 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.87 query.py(1545):                 transforms = names[pivot:]
0.87 query.py(1546):                 break
0.87 query.py(1547):         for name in transforms:
0.87 query.py(1562):         for join in path:
0.87 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.87 compiler.py(741):         alias = joins[-1]
0.87 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.87 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.87 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.87 query.py(1601):         joins = joins[:]
0.87 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.87 query.py(1614):         return targets, joins[-1], joins
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 query.py(1525):             return field.get_col(alias)
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 compiler.py(280):         for field in ordering:
0.87 compiler.py(340):         result = []
0.87 compiler.py(341):         seen = set()
0.87 compiler.py(343):         for expr, is_ref in order_by:
0.87 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.87 compiler.py(345):             if self.query.combinator:
0.87 compiler.py(365):             sql, params = self.compile(resolved)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.87 compiler.py(371):             params_hash = make_hashable(params)
0.87 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.87 compiler.py(374):             seen.add((without_ordering, params_hash))
0.87 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.87 compiler.py(343):         for expr, is_ref in order_by:
0.87 compiler.py(376):         return result
0.87 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.87 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.87 compiler.py(379):         extra_select = []
0.87 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.87 compiler.py(386):         return extra_select
0.87 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.87 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.87 compiler.py(97):         if self.query.group_by is None:
0.87 compiler.py(98):             return []
0.87 compiler.py(58):         return extra_select, order_by, group_by
0.87 compiler.py(481):             for_update_part = None
0.87 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.87 compiler.py(484):             combinator = self.query.combinator
0.87 compiler.py(485):             features = self.connection.features
0.87 compiler.py(486):             if combinator:
0.87 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.87 compiler.py(683):         result = []
0.87 compiler.py(684):         params = []
0.87 compiler.py(685):         opts = self.query.get_meta()
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(687):         for name in self.query.distinct_fields:
0.87 compiler.py(698):         return result, params
0.87 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.87 compiler.py(755):         result = []
0.87 compiler.py(756):         params = []
0.87 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.87 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.87 compiler.py(760):             try:
0.87 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.87 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(767):             result.append(clause_sql)
0.87 compiler.py(768):             params.extend(clause_params)
0.87 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.87 compiler.py(769):         for t in self.query.extra_tables:
0.87 compiler.py(776):         return result, params
0.87 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.87 compiler.py(497):                 result = ['SELECT']
0.87 compiler.py(498):                 params = []
0.87 compiler.py(500):                 if self.query.distinct:
0.87 compiler.py(508):                 out_cols = []
0.87 compiler.py(509):                 col_idx = 1
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.87 compiler.py(520):                 params.extend(f_params)
0.87 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.87 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.87 compiler.py(552):                 if where:
0.87 compiler.py(556):                 grouping = []
0.87 compiler.py(557):                 for g_sql, g_params in group_by:
0.87 compiler.py(560):                 if grouping:
0.87 compiler.py(577):                 if having:
0.87 compiler.py(581):             if self.query.explain_query:
0.87 compiler.py(587):             if order_by:
0.87 compiler.py(588):                 ordering = []
0.87 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.87 compiler.py(590):                     ordering.append(o_sql)
0.87 compiler.py(591):                     params.extend(o_params)
0.87 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.87 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.87 compiler.py(594):             if with_limit_offset:
0.87 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.87 compiler.py(600):             if self.query.subquery and extra_select:
0.87 compiler.py(627):             return ' '.join(result), tuple(params)
0.87 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.87 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.87 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.87 query.py(820):             self.unref_alias(alias, unref_amount)
0.87 query.py(758):         self.alias_refcount[alias] -= amount
0.87 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.87 compiler.py(1083):             if not sql:
0.87 compiler.py(1090):         if chunked_fetch:
0.87 compiler.py(1091):             cursor = self.connection.chunked_cursor()
0.87 compiler.py(1094):         try:
0.87 compiler.py(1095):             cursor.execute(sql, params)
0.87 compiler.py(1101):         if result_type == CURSOR:
0.87 compiler.py(1104):         if result_type == SINGLE:
0.87 compiler.py(1113):         if result_type == NO_RESULTS:
0.87 compiler.py(1117):         result = cursor_iter(
0.87 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.87 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.87 compiler.py(1120):             chunk_size,
0.87 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.87 compiler.py(1132):         return result
0.87 compiler.py(1046):         if results is None:
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1049):         converters = self.get_converters(fields)
0.87 compiler.py(1023):         converters = {}
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1030):         return converters
0.87 compiler.py(1050):         rows = chain.from_iterable(results)
0.87 compiler.py(1051):         if converters:
0.87 compiler.py(1055):         return rows
0.87 compiler.py(1518):     try:
0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1520):             yield rows if col_count is None else [r[:col_count] for r in rows]
0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1522):         cursor.close()
0.87 query.py(154):         self.model = model
0.87 query.py(155):         self.alias_refcount = {}
0.87 query.py(161):         self.alias_map = {}
0.87 query.py(165):         self.external_aliases = set()
0.87 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.87 query.py(167):         self.default_cols = True
0.87 query.py(168):         self.default_ordering = True
0.87 query.py(169):         self.standard_ordering = True
0.87 query.py(170):         self.used_aliases = set()
0.87 query.py(171):         self.filter_is_sticky = False
0.87 query.py(172):         self.subquery = False
0.87 query.py(180):         self.select = ()
0.87 query.py(181):         self.where = where()
0.87 query.py(182):         self.where_class = where
0.87 query.py(189):         self.group_by = None
0.87 query.py(190):         self.order_by = ()
0.87 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.87 query.py(192):         self.distinct = False
0.87 query.py(193):         self.distinct_fields = ()
0.87 query.py(194):         self.select_for_update = False
0.87 query.py(195):         self.select_for_update_nowait = False
0.87 query.py(196):         self.select_for_update_skip_locked = False
0.87 query.py(197):         self.select_for_update_of = ()
0.87 query.py(199):         self.select_related = False
0.87 query.py(201):         self.max_depth = 5
0.87 query.py(205):         self.values_select = ()
0.87 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.87 query.py(209):         self.annotation_select_mask = None
0.87 query.py(210):         self._annotation_select_cache = None
0.87 query.py(213):         self.combinator = None
0.87 query.py(214):         self.combinator_all = False
0.87 query.py(215):         self.combined_queries = ()
0.87 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.87 query.py(220):         self.extra_select_mask = None
0.87 query.py(221):         self._extra_select_cache = None
0.87 query.py(223):         self.extra_tables = ()
0.87 query.py(224):         self.extra_order_by = ()
0.87 query.py(229):         self.deferred_loading = (frozenset(), True)
0.87 query.py(231):         self._filtered_relations = {}
0.87 query.py(233):         self.explain_query = False
0.87 query.py(234):         self.explain_format = None
0.87 query.py(235):         self.explain_options = {}
0.87 query.py(343):         obj = self.clone()
0.87 query.py(297):         obj = Empty()
0.87 query.py(298):         obj.__class__ = self.__class__
0.87 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.87 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.87 query.py(303):         obj.alias_map = self.alias_map.copy()
0.87 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.87 query.py(305):         obj.table_map = self.table_map.copy()
0.87 query.py(306):         obj.where = self.where.clone()
0.87 query.py(307):         obj.annotations = self.annotations.copy()
0.87 query.py(308):         if self.annotation_select_mask is None:
0.87 query.py(309):             obj.annotation_select_mask = None
0.87 query.py(317):         obj._annotation_select_cache = None
0.87 query.py(318):         obj.extra = self.extra.copy()
0.87 query.py(319):         if self.extra_select_mask is None:
0.87 query.py(320):             obj.extra_select_mask = None
0.87 query.py(323):         if self._extra_select_cache is None:
0.87 query.py(324):             obj._extra_select_cache = None
0.87 query.py(327):         if 'subq_aliases' in self.__dict__:
0.87 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.87 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.87 query.py(332):         try:
0.87 query.py(333):             del obj.base_table
0.87 query.py(334):         except AttributeError:
0.87 query.py(335):             pass
0.87 query.py(336):         return obj
0.87 query.py(344):         if klass and obj.__class__ != klass:
0.87 query.py(346):         if not obj.filter_is_sticky:
0.87 query.py(347):             obj.used_aliases = set()
0.87 query.py(348):         obj.filter_is_sticky = False
0.87 query.py(349):         if hasattr(obj, '_setup_query'):
0.87 query.py(351):         return obj
0.87 query.py(1758):         return not self.low_mark and self.high_mark is None
0.87 query.py(343):         obj = self.clone()
0.87 query.py(297):         obj = Empty()
0.87 query.py(298):         obj.__class__ = self.__class__
0.87 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.87 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.87 query.py(303):         obj.alias_map = self.alias_map.copy()
0.87 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.87 query.py(305):         obj.table_map = self.table_map.copy()
0.87 query.py(306):         obj.where = self.where.clone()
0.87 query.py(307):         obj.annotations = self.annotations.copy()
0.87 query.py(308):         if self.annotation_select_mask is None:
0.87 query.py(309):             obj.annotation_select_mask = None
0.87 query.py(317):         obj._annotation_select_cache = None
0.87 query.py(318):         obj.extra = self.extra.copy()
0.87 query.py(319):         if self.extra_select_mask is None:
0.87 query.py(320):             obj.extra_select_mask = None
0.87 query.py(323):         if self._extra_select_cache is None:
0.87 query.py(324):             obj._extra_select_cache = None
0.87 query.py(327):         if 'subq_aliases' in self.__dict__:
0.87 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.87 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.87 query.py(332):         try:
0.87 query.py(333):             del obj.base_table
0.87 query.py(334):         except AttributeError:
0.87 query.py(335):             pass
0.87 query.py(336):         return obj
0.87 query.py(344):         if klass and obj.__class__ != klass:
0.87 query.py(346):         if not obj.filter_is_sticky:
0.87 query.py(347):             obj.used_aliases = set()
0.87 query.py(348):         obj.filter_is_sticky = False
0.87 query.py(349):         if hasattr(obj, '_setup_query'):
0.87 query.py(351):         return obj
0.87 query.py(1860):         self.order_by = ()
0.87 query.py(1861):         self.extra_order_by = ()
0.87 query.py(1862):         if force_empty:
0.87 query.py(1839):         errors = []
0.87 query.py(1840):         for item in ordering:
0.87 query.py(1841):             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):
0.87 query.py(1843):             if getattr(item, 'contains_aggregate', False):
0.87 query.py(1840):         for item in ordering:
0.87 query.py(1848):         if errors:
0.87 query.py(1850):         if ordering:
0.87 query.py(1851):             self.order_by += ordering
0.87 query.py(278):         if using is None and connection is None:
0.87 query.py(280):         if using:
0.87 query.py(281):             connection = connections[using]
0.87 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.87 compiler.py(25):         self.query = query
0.87 compiler.py(26):         self.connection = connection
0.87 compiler.py(27):         self.using = using
0.87 compiler.py(28):         self.quote_cache = {'*': '*'}
0.87 compiler.py(33):         self.select = None
0.87 compiler.py(34):         self.annotation_col_map = None
0.87 compiler.py(35):         self.klass_info = None
0.87 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.87 compiler.py(38):         self._meta_ordering = None
0.87 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.87 compiler.py(1081):         try:
0.87 compiler.py(1082):             sql, params = self.as_sql()
0.87 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.87 compiler.py(479):         try:
0.87 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.87 compiler.py(52):         self.setup_query()
0.87 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.87 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.87 compiler.py(42):             self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.87 query.py(290):         return self.model._meta
0.87 query.py(943):         if reuse_with_filtered_relation and reuse:
0.87 query.py(950):                 a for a, j in self.alias_map.items()
0.87 query.py(950):                 a for a, j in self.alias_map.items()
0.87 query.py(953):         if reuse_aliases:
0.87 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.87 query.py(735):         alias_list = self.table_map.get(table_name)
0.87 query.py(736):         if not create and alias_list:
0.87 query.py(742):         if alias_list:
0.87 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.87 query.py(748):             self.table_map[table_name] = [alias]
0.87 query.py(749):         self.alias_refcount[alias] = 1
0.87 query.py(750):         return alias, True
0.87 query.py(965):         if join.join_type:
0.87 query.py(971):         join.table_alias = alias
0.87 query.py(972):         self.alias_map[alias] = join
0.87 query.py(973):         return alias
0.87 query.py(917):         return alias
0.87 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.87 compiler.py(202):         select = []
0.87 compiler.py(203):         klass_info = None
0.87 compiler.py(204):         annotations = {}
0.87 compiler.py(205):         select_idx = 0
0.87 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.87 compiler.py(211):         if self.query.default_cols:
0.87 compiler.py(212):             cols = self.get_default_columns()
0.87 compiler.py(644):         result = []
0.87 compiler.py(645):         if opts is None:
0.87 compiler.py(646):             opts = self.query.get_meta()
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(647):         only_load = self.deferred_to_columns()
0.87 compiler.py(1018):         columns = {}
0.87 compiler.py(1019):         self.query.deferred_to_data(columns, self.query.get_loaded_field_names_cb)
0.87 query.py(655):         field_names, defer = self.deferred_loading
0.87 query.py(656):         if not field_names:
0.87 query.py(657):             return
0.87 compiler.py(1020):         return columns
0.87 compiler.py(648):         start_alias = start_alias or self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(913):             alias = self.base_table
0.87 query.py(250):         for alias in self.alias_map:
0.87 query.py(251):             return alias
0.87 query.py(914):             self.ref_alias(alias)
0.87 query.py(754):         self.alias_refcount[alias] += 1
0.87 query.py(917):         return alias
0.87 compiler.py(652):         seen_models = {None: start_alias}
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(655):             model = field.model._meta.concrete_model
0.87 compiler.py(658):             if model == opts.model:
0.87 compiler.py(659):                 model = None
0.87 compiler.py(660):             if from_parent and model is not None and issubclass(
0.87 compiler.py(668):             if field.model in only_load and field.attname not in only_load[field.model]:
0.87 compiler.py(670):             alias = self.query.join_parent_model(opts, model, start_alias,
0.87 compiler.py(671):                                                  seen_models)
0.87 query.py(984):         if model in seen:
0.87 query.py(985):             return seen[model]
0.87 compiler.py(672):             column = field.get_col(alias)
0.87 compiler.py(673):             result.append(column)
0.87 compiler.py(654):         for field in opts.concrete_fields:
0.87 compiler.py(674):         return result
0.87 compiler.py(217):         if cols:
0.87 compiler.py(218):             select_list = []
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(220):                 select_list.append(select_idx)
0.87 compiler.py(221):                 select.append((col, None))
0.87 compiler.py(222):                 select_idx += 1
0.87 compiler.py(219):             for col in cols:
0.87 compiler.py(224):                 'model': self.query.model,
0.87 compiler.py(225):                 'select_fields': select_list,
0.87 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.87 query.py(2075):         if self._annotation_select_cache is not None:
0.87 query.py(2077):         elif not self.annotations:
0.87 query.py(2078):             return {}
0.87 compiler.py(232):         if self.query.select_related:
0.87 compiler.py(244):         ret = []
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(246):             try:
0.87 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.87 compiler.py(397):                 name in self.query.extra_select or (
0.87 query.py(2090):         if self._extra_select_cache is not None:
0.87 query.py(2092):         if not self.extra:
0.87 query.py(2093):             return {}
0.87 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.87 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.87 compiler.py(402):         self.quote_cache[name] = r
0.87 compiler.py(403):         return r
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.87 compiler.py(251):             ret.append((col, (sql, params), alias))
0.87 compiler.py(245):         for col, alias in select:
0.87 compiler.py(252):         return ret, klass_info, annotations
0.87 compiler.py(44):         self.col_count = len(self.select)
0.87 compiler.py(53):         order_by = self.get_order_by()
0.87 compiler.py(263):         if self.query.extra_order_by:
0.87 compiler.py(265):         elif not self.query.default_ordering:
0.87 compiler.py(267):         elif self.query.order_by:
0.87 compiler.py(268):             ordering = self.query.order_by
0.87 compiler.py(274):         if self.query.standard_ordering:
0.87 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.87 compiler.py(279):         order_by = []
0.87 compiler.py(280):         for field in ordering:
0.87 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.87 compiler.py(292):             if field == '?':  # random
0.87 compiler.py(296):             col, order = get_order_dir(field, asc)
0.87 query.py(2204):     dirn = ORDER_DIR[default]
0.87 query.py(2205):     if field[0] == '-':
0.87 query.py(2207):     return field, dirn[0]
0.87 compiler.py(297):             descending = order == 'DESC'
0.87 compiler.py(299):             if col in self.query.annotation_select:
0.87 query.py(2075):         if self._annotation_select_cache is not None:
0.87 query.py(2077):         elif not self.annotations:
0.87 query.py(2078):             return {}
0.87 compiler.py(305):             if col in self.query.annotations:
0.87 compiler.py(315):             if '.' in field:
0.87 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.87 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.87 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.87 query.py(2204):     dirn = ORDER_DIR[default]
0.87 query.py(2205):     if field[0] == '-':
0.87 query.py(2207):     return field, dirn[0]
0.87 compiler.py(708):         descending = order == 'DESC'
0.87 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.87 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.87 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.87 query.py(912):         if self.alias_map:
0.87 query.py(913):             alias = self.base_table
0.87 query.py(914):             self.ref_alias(alias)
0.87 query.py(754):         self.alias_refcount[alias] += 1
0.87 query.py(917):         return alias
0.87 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.87 query.py(1518):         joins = [alias]
0.87 query.py(1524):         def final_transformer(field, alias):
0.87 query.py(1529):         last_field_exception = None
0.87 query.py(1530):         for pivot in range(len(names), 0, -1):
0.87 query.py(1531):             try:
0.87 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.87 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.87 query.py(1405):         path, names_with_path = [], []
0.87 query.py(1406):         for pos, name in enumerate(names):
0.87 query.py(1407):             cur_names_with_path = (name, [])
0.87 query.py(1408):             if name == 'pk':
0.87 query.py(1411):             field = None
0.87 query.py(1412):             filtered_relation = None
0.87 query.py(1413):             try:
0.87 query.py(1414):                 field = opts.get_field(name)
0.87 query.py(1421):             if field is not None:
0.87 query.py(1425):                 if field.is_relation and not field.related_model:
0.87 query.py(1432):                 try:
0.87 query.py(1433):                     model = field.model._meta.concrete_model
0.87 query.py(1454):             if model is not opts.model:
0.87 query.py(1460):             if hasattr(field, 'get_path_info'):
0.87 query.py(1477):                 final_field = field
0.87 query.py(1478):                 targets = (field,)
0.87 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.87 query.py(1483):                 break
0.87 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.87 query.py(1545):                 transforms = names[pivot:]
0.87 query.py(1546):                 break
0.87 query.py(1547):         for name in transforms:
0.87 query.py(1562):         for join in path:
0.87 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.87 compiler.py(741):         alias = joins[-1]
0.87 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.87 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.87 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.87 query.py(1601):         joins = joins[:]
0.87 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.87 query.py(1614):         return targets, joins[-1], joins
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 query.py(1525):             return field.get_col(alias)
0.87 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.87 compiler.py(280):         for field in ordering:
0.87 compiler.py(340):         result = []
0.87 compiler.py(341):         seen = set()
0.87 compiler.py(343):         for expr, is_ref in order_by:
0.87 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.87 compiler.py(345):             if self.query.combinator:
0.87 compiler.py(365):             sql, params = self.compile(resolved)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.87 compiler.py(371):             params_hash = make_hashable(params)
0.87 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.87 compiler.py(374):             seen.add((without_ordering, params_hash))
0.87 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.87 compiler.py(343):         for expr, is_ref in order_by:
0.87 compiler.py(376):         return result
0.87 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.87 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.87 compiler.py(379):         extra_select = []
0.87 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.87 compiler.py(386):         return extra_select
0.87 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.87 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.87 compiler.py(97):         if self.query.group_by is None:
0.87 compiler.py(98):             return []
0.87 compiler.py(58):         return extra_select, order_by, group_by
0.87 compiler.py(481):             for_update_part = None
0.87 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.87 compiler.py(484):             combinator = self.query.combinator
0.87 compiler.py(485):             features = self.connection.features
0.87 compiler.py(486):             if combinator:
0.87 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.87 compiler.py(683):         result = []
0.87 compiler.py(684):         params = []
0.87 compiler.py(685):         opts = self.query.get_meta()
0.87 query.py(290):         return self.model._meta
0.87 compiler.py(687):         for name in self.query.distinct_fields:
0.87 compiler.py(698):         return result, params
0.87 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.87 compiler.py(755):         result = []
0.87 compiler.py(756):         params = []
0.87 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.87 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.87 compiler.py(760):             try:
0.87 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.87 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(394):         if name in self.quote_cache:
0.87 compiler.py(395):             return self.quote_cache[name]
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(767):             result.append(clause_sql)
0.87 compiler.py(768):             params.extend(clause_params)
0.87 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.87 compiler.py(769):         for t in self.query.extra_tables:
0.87 compiler.py(776):         return result, params
0.87 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.87 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.87 compiler.py(407):         if vendor_impl:
0.87 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.87 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.87 compiler.py(413):         return sql, params
0.87 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.87 compiler.py(497):                 result = ['SELECT']
0.87 compiler.py(498):                 params = []
0.87 compiler.py(500):                 if self.query.distinct:
0.87 compiler.py(508):                 out_cols = []
0.87 compiler.py(509):                 col_idx = 1
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(511):                     if alias:
0.87 compiler.py(513):                     elif with_col_aliases:
0.87 compiler.py(516):                     params.extend(s_params)
0.87 compiler.py(517):                     out_cols.append(s_sql)
0.87 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.87 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.87 compiler.py(520):                 params.extend(f_params)
0.87 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.87 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.87 compiler.py(552):                 if where:
0.87 compiler.py(556):                 grouping = []
0.87 compiler.py(557):                 for g_sql, g_params in group_by:
0.87 compiler.py(560):                 if grouping:
0.87 compiler.py(577):                 if having:
0.87 compiler.py(581):             if self.query.explain_query:
0.87 compiler.py(587):             if order_by:
0.87 compiler.py(588):                 ordering = []
0.87 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.87 compiler.py(590):                     ordering.append(o_sql)
0.87 compiler.py(591):                     params.extend(o_params)
0.87 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.87 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.87 compiler.py(594):             if with_limit_offset:
0.87 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.87 compiler.py(600):             if self.query.subquery and extra_select:
0.87 compiler.py(627):             return ' '.join(result), tuple(params)
0.87 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.87 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.87 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.87 query.py(820):             self.unref_alias(alias, unref_amount)
0.87 query.py(758):         self.alias_refcount[alias] -= amount
0.87 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.87 compiler.py(1083):             if not sql:
0.87 compiler.py(1090):         if chunked_fetch:
0.87 compiler.py(1091):             cursor = self.connection.chunked_cursor()
0.87 compiler.py(1094):         try:
0.87 compiler.py(1095):             cursor.execute(sql, params)
0.87 compiler.py(1101):         if result_type == CURSOR:
0.87 compiler.py(1104):         if result_type == SINGLE:
0.87 compiler.py(1113):         if result_type == NO_RESULTS:
0.87 compiler.py(1117):         result = cursor_iter(
0.87 compiler.py(1118):             cursor, self.connection.features.empty_fetchmany_value,
0.87 compiler.py(1119):             self.col_count if self.has_extra_select else None,
0.87 compiler.py(1120):             chunk_size,
0.87 compiler.py(1122):         if not chunked_fetch or not self.connection.features.can_use_chunked_reads:
0.87 compiler.py(1132):         return result
0.87 compiler.py(1046):         if results is None:
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1048):         fields = [s[0] for s in self.select[0:self.col_count]]
0.87 compiler.py(1049):         converters = self.get_converters(fields)
0.87 compiler.py(1023):         converters = {}
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1029):                     converters[i] = (backend_converters + field_converters, expression)
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1025):             if expression:
0.87 compiler.py(1026):                 backend_converters = self.connection.ops.get_db_converters(expression)
0.87 compiler.py(1027):                 field_converters = expression.get_db_converters(self.connection)
0.87 compiler.py(1028):                 if backend_converters or field_converters:
0.87 compiler.py(1024):         for i, expression in enumerate(expressions):
0.87 compiler.py(1030):         return converters
0.87 compiler.py(1050):         rows = chain.from_iterable(results)
0.87 compiler.py(1051):         if converters:
0.87 compiler.py(1052):             rows = self.apply_converters(rows, converters)
0.87 compiler.py(1053):             if tuple_expected:
0.87 compiler.py(1055):         return rows
0.87 compiler.py(1033):         connection = self.connection
0.87 compiler.py(1034):         converters = list(converters.items())
0.87 compiler.py(1035):         for row in map(list, rows):
0.87 compiler.py(1518):     try:
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
test_union_queryset_ordering_bug (test_coverup_django__django-10554.UnionQuerysetOrderingTests) ... 0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1519):         for rows in iter((lambda: cursor.fetchmany(itersize)), sentinel):
0.87 compiler.py(1522):         cursor.close()
System check identified no issues (0 silenced).
0.91 query.py(154):         self.model = model
0.91 query.py(155):         self.alias_refcount = {}
0.91 query.py(161):         self.alias_map = {}
0.91 query.py(165):         self.external_aliases = set()
0.91 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.91 query.py(167):         self.default_cols = True
0.91 query.py(168):         self.default_ordering = True
0.91 query.py(169):         self.standard_ordering = True
0.91 query.py(170):         self.used_aliases = set()
0.91 query.py(171):         self.filter_is_sticky = False
0.91 query.py(172):         self.subquery = False
0.91 query.py(180):         self.select = ()
0.91 query.py(181):         self.where = where()
0.91 query.py(182):         self.where_class = where
0.91 query.py(189):         self.group_by = None
0.91 query.py(190):         self.order_by = ()
0.91 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.91 query.py(192):         self.distinct = False
0.91 query.py(193):         self.distinct_fields = ()
0.91 query.py(194):         self.select_for_update = False
0.91 query.py(195):         self.select_for_update_nowait = False
0.91 query.py(196):         self.select_for_update_skip_locked = False
0.91 query.py(197):         self.select_for_update_of = ()
0.91 query.py(199):         self.select_related = False
0.91 query.py(201):         self.max_depth = 5
0.91 query.py(205):         self.values_select = ()
0.91 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.91 query.py(209):         self.annotation_select_mask = None
0.91 query.py(210):         self._annotation_select_cache = None
0.91 query.py(213):         self.combinator = None
0.91 query.py(214):         self.combinator_all = False
0.91 query.py(215):         self.combined_queries = ()
0.91 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.91 query.py(220):         self.extra_select_mask = None
0.91 query.py(221):         self._extra_select_cache = None
0.91 query.py(223):         self.extra_tables = ()
0.91 query.py(224):         self.extra_order_by = ()
0.91 query.py(229):         self.deferred_loading = (frozenset(), True)
0.91 query.py(231):         self._filtered_relations = {}
0.91 query.py(233):         self.explain_query = False
0.91 query.py(234):         self.explain_format = None
0.91 query.py(235):         self.explain_options = {}
0.91 query.py(1758):         return not self.low_mark and self.high_mark is None
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(309):             obj.annotation_select_mask = None
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(320):             obj.extra_select_mask = None
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(334):         except AttributeError:
0.91 query.py(335):             pass
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.91 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.91 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.91 query.py(1331):         connector = q_object.connector
0.91 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.91 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.91 query.py(1334):         target_clause = self.where_class(connector=connector,
0.91 query.py(1335):                                          negated=q_object.negated)
0.91 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.91 query.py(2236):         self.connector = connector
0.91 query.py(2237):         self.negated = negated
0.91 query.py(2238):         if self.negated:
0.91 query.py(2244):             self.effective_connector = self.connector
0.91 query.py(2245):         self.num_children = num_children
0.91 query.py(2248):         self.votes = Counter()
0.91 query.py(1337):         for child in q_object.children:
0.91 query.py(1338):             if isinstance(child, Node):
0.91 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.91 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.91 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.91 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.91 query.py(1214):         if isinstance(filter_expr, dict):
0.91 query.py(1216):         arg, value = filter_expr
0.91 query.py(1217):         if not arg:
0.91 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.91 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.91 query.py(1074):         if self.annotations:
0.91 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.91 query.py(290):         return self.model._meta
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1409):                 name = opts.pk.name
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.91 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.91 query.py(1085):         return lookup_parts, field_parts, False
0.91 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.91 query.py(1227):         if not allow_joins and len(parts) > 1:
0.91 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.91 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.91 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.91 query.py(1055):         elif isinstance(value, (list, tuple)):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1059):                 if hasattr(sub_value, 'resolve_expression'):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1059):                 if hasattr(sub_value, 'resolve_expression'):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1067):         return value
0.91 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.91 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.91 query.py(1234):         clause = self.where_class()
0.91 query.py(1235):         if reffed_expression:
0.91 query.py(1240):         opts = self.get_meta()
0.91 query.py(290):         return self.model._meta
0.91 query.py(1241):         alias = self.get_initial_alias()
0.91 query.py(912):         if self.alias_map:
0.91 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.91 query.py(290):         return self.model._meta
0.91 query.py(943):         if reuse_with_filtered_relation and reuse:
0.91 query.py(950):                 a for a, j in self.alias_map.items()
0.91 query.py(950):                 a for a, j in self.alias_map.items()
0.91 query.py(953):         if reuse_aliases:
0.91 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.91 query.py(735):         alias_list = self.table_map.get(table_name)
0.91 query.py(736):         if not create and alias_list:
0.91 query.py(742):         if alias_list:
0.91 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.91 query.py(748):             self.table_map[table_name] = [alias]
0.91 query.py(749):         self.alias_refcount[alias] = 1
0.91 query.py(750):         return alias, True
0.91 query.py(965):         if join.join_type:
0.91 query.py(971):         join.table_alias = alias
0.91 query.py(972):         self.alias_map[alias] = join
0.91 query.py(973):         return alias
0.91 query.py(917):         return alias
0.91 query.py(1242):         allow_many = not branch_negated or not split_subq
0.91 query.py(1244):         try:
0.91 query.py(1245):             join_info = self.setup_joins(
0.91 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.91 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.91 query.py(1518):         joins = [alias]
0.91 query.py(1524):         def final_transformer(field, alias):
0.91 query.py(1529):         last_field_exception = None
0.91 query.py(1530):         for pivot in range(len(names), 0, -1):
0.91 query.py(1531):             try:
0.91 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.91 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1409):                 name = opts.pk.name
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1545):                 transforms = names[pivot:]
0.91 query.py(1546):                 break
0.91 query.py(1547):         for name in transforms:
0.91 query.py(1562):         for join in path:
0.91 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.91 query.py(1251):             if isinstance(value, Iterator):
0.91 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.91 query.py(1100):         if field.is_relation:
0.91 query.py(1257):             self._lookup_joins = join_info.joins
0.91 query.py(1263):         used_joins.update(join_info.joins)
0.91 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.91 query.py(1601):         joins = joins[:]
0.91 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.91 query.py(1614):         return targets, joins[-1], joins
0.91 query.py(1265):         if can_reuse is not None:
0.91 query.py(1266):             can_reuse.update(join_list)
0.91 query.py(1268):         if join_info.final_field.is_relation:
0.91 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.91 query.py(72):     if simple_col:
0.91 query.py(74):     return target.get_col(alias, field)
0.91 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.91 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.91 query.py(1129):         for name in transforms:
0.91 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.91 query.py(1134):         if not lookup_class:
0.91 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.91 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.91 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.91 query.py(1161):         return lookup
0.91 query.py(1281):         lookup_type = condition.lookup_name
0.91 query.py(1282):         clause.add(condition, AND)
0.91 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.91 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.91 query.py(1302):         return clause, used_joins if not require_outer else ()
0.91 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.91 query.py(2255):         self.votes.update(votes)
0.91 query.py(1350):             if child_clause:
0.91 query.py(1351):                 target_clause.add(child_clause, connector)
0.91 query.py(1337):         for child in q_object.children:
0.91 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.91 query.py(2264):         to_promote = set()
0.91 query.py(2265):         to_demote = set()
0.91 query.py(2268):         for table, votes in self.votes.items():
0.91 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.91 query.py(2291):             if self.effective_connector == 'AND' or (
0.91 query.py(2293):                 to_demote.add(table)
0.91 query.py(2268):         for table, votes in self.votes.items():
0.91 query.py(2309):         query.promote_joins(to_promote)
0.91 query.py(771):         aliases = list(aliases)
0.91 query.py(772):         while aliases:
0.91 query.py(2310):         query.demote_joins(to_demote)
0.91 query.py(804):         aliases = list(aliases)
0.91 query.py(805):         while aliases:
0.91 query.py(806):             alias = aliases.pop(0)
0.91 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.91 query.py(805):         while aliases:
0.91 query.py(2311):         return to_demote
0.91 query.py(1353):         return target_clause, needed_inner
0.91 query.py(1320):         if clause:
0.91 query.py(1321):             self.where.add(clause, AND)
0.91 query.py(1322):         self.demote_joins(existing_inner)
0.91 query.py(804):         aliases = list(aliases)
0.91 query.py(805):         while aliases:
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(309):             obj.annotation_select_mask = None
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(320):             obj.extra_select_mask = None
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(334):         except AttributeError:
0.91 query.py(335):             pass
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(2035):         self.select_related = False
0.91 query.py(2036):         self.clear_deferred_loading()
0.91 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.91 query.py(2037):         self.clear_select_fields()
0.91 query.py(1774):         self.select = ()
0.91 query.py(1775):         self.values_select = ()
0.91 query.py(2039):         if self.group_by is True:
0.91 query.py(2044):         if fields:
0.91 query.py(2045):             field_names = []
0.91 query.py(2046):             extra_names = []
0.91 query.py(2047):             annotation_names = []
0.91 query.py(2048):             if not self.extra and not self.annotations:
0.91 query.py(2051):                 field_names = list(fields)
0.91 query.py(2061):             self.set_extra_mask(extra_names)
0.91 query.py(2028):         if names is None:
0.91 query.py(2031):             self.extra_select_mask = set(names)
0.91 query.py(2032):         self._extra_select_cache = None
0.91 query.py(2062):             self.set_annotation_mask(annotation_names)
0.91 query.py(2013):         if names is None:
0.91 query.py(2016):             self.annotation_select_mask = set(names)
0.91 query.py(2017):         self._annotation_select_cache = None
0.91 query.py(2066):         self.values_select = tuple(field_names)
0.91 query.py(2067):         self.add_fields(field_names, True)
0.91 query.py(1797):         alias = self.get_initial_alias()
0.91 query.py(912):         if self.alias_map:
0.91 query.py(913):             alias = self.base_table
0.91 query.py(250):         for alias in self.alias_map:
0.91 query.py(251):             return alias
0.91 query.py(914):             self.ref_alias(alias)
0.91 query.py(754):         self.alias_refcount[alias] += 1
0.91 query.py(917):         return alias
0.91 query.py(1798):         opts = self.get_meta()
0.91 query.py(290):         return self.model._meta
0.91 query.py(1800):         try:
0.91 query.py(1801):             cols = []
0.91 query.py(1802):             for name in field_names:
0.91 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.91 query.py(1518):         joins = [alias]
0.91 query.py(1524):         def final_transformer(field, alias):
0.91 query.py(1529):         last_field_exception = None
0.91 query.py(1530):         for pivot in range(len(names), 0, -1):
0.91 query.py(1531):             try:
0.91 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.91 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1545):                 transforms = names[pivot:]
0.91 query.py(1546):                 break
0.91 query.py(1547):         for name in transforms:
0.91 query.py(1562):         for join in path:
0.91 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.91 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.91 query.py(1807):                     join_info.targets,
0.91 query.py(1808):                     join_info.joins,
0.91 query.py(1809):                     join_info.path,
0.91 query.py(1601):         joins = joins[:]
0.91 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.91 query.py(1614):         return targets, joins[-1], joins
0.91 query.py(1811):                 for target in targets:
0.91 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.91 query.py(1525):             return field.get_col(alias)
0.91 query.py(1811):                 for target in targets:
0.91 query.py(1802):             for name in field_names:
0.91 query.py(1813):             if cols:
0.91 query.py(1814):                 self.set_select(cols)
0.91 query.py(1782):         self.default_cols = False
0.91 query.py(1783):         self.select = tuple(cols)
0.91 query.py(154):         self.model = model
0.91 query.py(155):         self.alias_refcount = {}
0.91 query.py(161):         self.alias_map = {}
0.91 query.py(165):         self.external_aliases = set()
0.91 query.py(166):         self.table_map = {}     # Maps table names to list of aliases.
0.91 query.py(167):         self.default_cols = True
0.91 query.py(168):         self.default_ordering = True
0.91 query.py(169):         self.standard_ordering = True
0.91 query.py(170):         self.used_aliases = set()
0.91 query.py(171):         self.filter_is_sticky = False
0.91 query.py(172):         self.subquery = False
0.91 query.py(180):         self.select = ()
0.91 query.py(181):         self.where = where()
0.91 query.py(182):         self.where_class = where
0.91 query.py(189):         self.group_by = None
0.91 query.py(190):         self.order_by = ()
0.91 query.py(191):         self.low_mark, self.high_mark = 0, None  # Used for offset/limit
0.91 query.py(192):         self.distinct = False
0.91 query.py(193):         self.distinct_fields = ()
0.91 query.py(194):         self.select_for_update = False
0.91 query.py(195):         self.select_for_update_nowait = False
0.91 query.py(196):         self.select_for_update_skip_locked = False
0.91 query.py(197):         self.select_for_update_of = ()
0.91 query.py(199):         self.select_related = False
0.91 query.py(201):         self.max_depth = 5
0.91 query.py(205):         self.values_select = ()
0.91 query.py(208):         self.annotations = {}  # Maps alias -> Annotation Expression
0.91 query.py(209):         self.annotation_select_mask = None
0.91 query.py(210):         self._annotation_select_cache = None
0.91 query.py(213):         self.combinator = None
0.91 query.py(214):         self.combinator_all = False
0.91 query.py(215):         self.combined_queries = ()
0.91 query.py(219):         self.extra = {}  # Maps col_alias -> (col_sql, params).
0.91 query.py(220):         self.extra_select_mask = None
0.91 query.py(221):         self._extra_select_cache = None
0.91 query.py(223):         self.extra_tables = ()
0.91 query.py(224):         self.extra_order_by = ()
0.91 query.py(229):         self.deferred_loading = (frozenset(), True)
0.91 query.py(231):         self._filtered_relations = {}
0.91 query.py(233):         self.explain_query = False
0.91 query.py(234):         self.explain_format = None
0.91 query.py(235):         self.explain_options = {}
0.91 query.py(1758):         return not self.low_mark and self.high_mark is None
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(309):             obj.annotation_select_mask = None
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(320):             obj.extra_select_mask = None
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(334):         except AttributeError:
0.91 query.py(335):             pass
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.91 query.py(1318):         existing_inner = {a for a in self.alias_map if self.alias_map[a].join_type == INNER}
0.91 query.py(1319):         clause, _ = self._add_q(q_object, self.used_aliases)
0.91 query.py(1331):         connector = q_object.connector
0.91 query.py(1332):         current_negated = current_negated ^ q_object.negated
0.91 query.py(1333):         branch_negated = branch_negated or q_object.negated
0.91 query.py(1334):         target_clause = self.where_class(connector=connector,
0.91 query.py(1335):                                          negated=q_object.negated)
0.91 query.py(1336):         joinpromoter = JoinPromoter(q_object.connector, len(q_object.children), current_negated)
0.91 query.py(2236):         self.connector = connector
0.91 query.py(2237):         self.negated = negated
0.91 query.py(2238):         if self.negated:
0.91 query.py(2244):             self.effective_connector = self.connector
0.91 query.py(2245):         self.num_children = num_children
0.91 query.py(2248):         self.votes = Counter()
0.91 query.py(1337):         for child in q_object.children:
0.91 query.py(1338):             if isinstance(child, Node):
0.91 query.py(1344):                 child_clause, needed_inner = self.build_filter(
0.91 query.py(1345):                     child, can_reuse=used_aliases, branch_negated=branch_negated,
0.91 query.py(1346):                     current_negated=current_negated, allow_joins=allow_joins,
0.91 query.py(1347):                     split_subq=split_subq, simple_col=simple_col,
0.91 query.py(1214):         if isinstance(filter_expr, dict):
0.91 query.py(1216):         arg, value = filter_expr
0.91 query.py(1217):         if not arg:
0.91 query.py(1219):         lookups, parts, reffed_expression = self.solve_lookup_type(arg)
0.91 query.py(1073):         lookup_splitted = lookup.split(LOOKUP_SEP)
0.91 query.py(1074):         if self.annotations:
0.91 query.py(1078):         _, field, _, lookup_parts = self.names_to_path(lookup_splitted, self.get_meta())
0.91 query.py(290):         return self.model._meta
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1409):                 name = opts.pk.name
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1079):         field_parts = lookup_splitted[0:len(lookup_splitted) - len(lookup_parts)]
0.91 query.py(1080):         if len(lookup_parts) > 1 and not field_parts:
0.91 query.py(1085):         return lookup_parts, field_parts, False
0.91 query.py(1221):         if not getattr(reffed_expression, 'filterable', True):
0.91 query.py(1227):         if not allow_joins and len(parts) > 1:
0.91 query.py(1230):         pre_joins = self.alias_refcount.copy()
0.91 query.py(1231):         value = self.resolve_lookup_value(value, can_reuse, allow_joins, simple_col)
0.91 query.py(1050):         if hasattr(value, 'resolve_expression'):
0.91 query.py(1055):         elif isinstance(value, (list, tuple)):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1059):                 if hasattr(sub_value, 'resolve_expression'):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1059):                 if hasattr(sub_value, 'resolve_expression'):
0.91 query.py(1058):             for sub_value in value:
0.91 query.py(1067):         return value
0.91 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.91 query.py(1232):         used_joins = {k for k, v in self.alias_refcount.items() if v > pre_joins.get(k, 0)}
0.91 query.py(1234):         clause = self.where_class()
0.91 query.py(1235):         if reffed_expression:
0.91 query.py(1240):         opts = self.get_meta()
0.91 query.py(290):         return self.model._meta
0.91 query.py(1241):         alias = self.get_initial_alias()
0.91 query.py(912):         if self.alias_map:
0.91 query.py(916):             alias = self.join(BaseTable(self.get_meta().db_table, None))
0.91 query.py(290):         return self.model._meta
0.91 query.py(943):         if reuse_with_filtered_relation and reuse:
0.91 query.py(950):                 a for a, j in self.alias_map.items()
0.91 query.py(950):                 a for a, j in self.alias_map.items()
0.91 query.py(953):         if reuse_aliases:
0.91 query.py(964):         alias, _ = self.table_alias(join.table_name, create=True, filtered_relation=join.filtered_relation)
0.91 query.py(735):         alias_list = self.table_map.get(table_name)
0.91 query.py(736):         if not create and alias_list:
0.91 query.py(742):         if alias_list:
0.91 query.py(747):             alias = filtered_relation.alias if filtered_relation is not None else table_name
0.91 query.py(748):             self.table_map[table_name] = [alias]
0.91 query.py(749):         self.alias_refcount[alias] = 1
0.91 query.py(750):         return alias, True
0.91 query.py(965):         if join.join_type:
0.91 query.py(971):         join.table_alias = alias
0.91 query.py(972):         self.alias_map[alias] = join
0.91 query.py(973):         return alias
0.91 query.py(917):         return alias
0.91 query.py(1242):         allow_many = not branch_negated or not split_subq
0.91 query.py(1244):         try:
0.91 query.py(1245):             join_info = self.setup_joins(
0.91 query.py(1246):                 parts, opts, alias, can_reuse=can_reuse, allow_many=allow_many,
0.91 query.py(1247):                 reuse_with_filtered_relation=reuse_with_filtered_relation,
0.91 query.py(1518):         joins = [alias]
0.91 query.py(1524):         def final_transformer(field, alias):
0.91 query.py(1529):         last_field_exception = None
0.91 query.py(1530):         for pivot in range(len(names), 0, -1):
0.91 query.py(1531):             try:
0.91 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.91 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1409):                 name = opts.pk.name
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1545):                 transforms = names[pivot:]
0.91 query.py(1546):                 break
0.91 query.py(1547):         for name in transforms:
0.91 query.py(1562):         for join in path:
0.91 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.91 query.py(1251):             if isinstance(value, Iterator):
0.91 query.py(1253):             self.check_related_objects(join_info.final_field, value, join_info.opts)
0.91 query.py(1100):         if field.is_relation:
0.91 query.py(1257):             self._lookup_joins = join_info.joins
0.91 query.py(1263):         used_joins.update(join_info.joins)
0.91 query.py(1264):         targets, alias, join_list = self.trim_joins(join_info.targets, join_info.joins, join_info.path)
0.91 query.py(1601):         joins = joins[:]
0.91 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.91 query.py(1614):         return targets, joins[-1], joins
0.91 query.py(1265):         if can_reuse is not None:
0.91 query.py(1266):             can_reuse.update(join_list)
0.91 query.py(1268):         if join_info.final_field.is_relation:
0.91 query.py(1278):             col = _get_col(targets[0], join_info.final_field, alias, simple_col)
0.91 query.py(72):     if simple_col:
0.91 query.py(74):     return target.get_col(alias, field)
0.91 query.py(1280):         condition = self.build_lookup(lookups, col, value)
0.91 query.py(1128):         *transforms, lookup_name = lookups or ['exact']
0.91 query.py(1129):         for name in transforms:
0.91 query.py(1133):         lookup_class = lhs.get_lookup(lookup_name)
0.91 query.py(1134):         if not lookup_class:
0.91 query.py(1145):         lookup = lookup_class(lhs, rhs)
0.91 query.py(1148):         if lookup.rhs is None and not lookup.can_use_none_as_rhs:
0.91 query.py(1157):         if (connections[DEFAULT_DB_ALIAS].features.interprets_empty_strings_as_nulls and
0.91 query.py(1161):         return lookup
0.91 query.py(1281):         lookup_type = condition.lookup_name
0.91 query.py(1282):         clause.add(condition, AND)
0.91 query.py(1284):         require_outer = lookup_type == 'isnull' and condition.rhs is True and not current_negated
0.91 query.py(1285):         if current_negated and (lookup_type != 'isnull' or condition.rhs is False) and condition.rhs is not None:
0.91 query.py(1302):         return clause, used_joins if not require_outer else ()
0.91 query.py(1349):                 joinpromoter.add_votes(needed_inner)
0.91 query.py(2255):         self.votes.update(votes)
0.91 query.py(1350):             if child_clause:
0.91 query.py(1351):                 target_clause.add(child_clause, connector)
0.91 query.py(1337):         for child in q_object.children:
0.91 query.py(1352):         needed_inner = joinpromoter.update_join_types(self)
0.91 query.py(2264):         to_promote = set()
0.91 query.py(2265):         to_demote = set()
0.91 query.py(2268):         for table, votes in self.votes.items():
0.91 query.py(2279):             if self.effective_connector == 'OR' and votes < self.num_children:
0.91 query.py(2291):             if self.effective_connector == 'AND' or (
0.91 query.py(2293):                 to_demote.add(table)
0.91 query.py(2268):         for table, votes in self.votes.items():
0.91 query.py(2309):         query.promote_joins(to_promote)
0.91 query.py(771):         aliases = list(aliases)
0.91 query.py(772):         while aliases:
0.91 query.py(2310):         query.demote_joins(to_demote)
0.91 query.py(804):         aliases = list(aliases)
0.91 query.py(805):         while aliases:
0.91 query.py(806):             alias = aliases.pop(0)
0.91 query.py(807):             if self.alias_map[alias].join_type == LOUTER:
0.91 query.py(805):         while aliases:
0.91 query.py(2311):         return to_demote
0.91 query.py(1353):         return target_clause, needed_inner
0.91 query.py(1320):         if clause:
0.91 query.py(1321):             self.where.add(clause, AND)
0.91 query.py(1322):         self.demote_joins(existing_inner)
0.91 query.py(804):         aliases = list(aliases)
0.91 query.py(805):         while aliases:
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(309):             obj.annotation_select_mask = None
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(320):             obj.extra_select_mask = None
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(334):         except AttributeError:
0.91 query.py(335):             pass
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(2035):         self.select_related = False
0.91 query.py(2036):         self.clear_deferred_loading()
0.91 query.py(1942):         self.deferred_loading = (frozenset(), True)
0.91 query.py(2037):         self.clear_select_fields()
0.91 query.py(1774):         self.select = ()
0.91 query.py(1775):         self.values_select = ()
0.91 query.py(2039):         if self.group_by is True:
0.91 query.py(2044):         if fields:
0.91 query.py(2045):             field_names = []
0.91 query.py(2046):             extra_names = []
0.91 query.py(2047):             annotation_names = []
0.91 query.py(2048):             if not self.extra and not self.annotations:
0.91 query.py(2051):                 field_names = list(fields)
0.91 query.py(2061):             self.set_extra_mask(extra_names)
0.91 query.py(2028):         if names is None:
0.91 query.py(2031):             self.extra_select_mask = set(names)
0.91 query.py(2032):         self._extra_select_cache = None
0.91 query.py(2062):             self.set_annotation_mask(annotation_names)
0.91 query.py(2013):         if names is None:
0.91 query.py(2016):             self.annotation_select_mask = set(names)
0.91 query.py(2017):         self._annotation_select_cache = None
0.91 query.py(2066):         self.values_select = tuple(field_names)
0.91 query.py(2067):         self.add_fields(field_names, True)
0.91 query.py(1797):         alias = self.get_initial_alias()
0.91 query.py(912):         if self.alias_map:
0.91 query.py(913):             alias = self.base_table
0.91 query.py(250):         for alias in self.alias_map:
0.91 query.py(251):             return alias
0.91 query.py(914):             self.ref_alias(alias)
0.91 query.py(754):         self.alias_refcount[alias] += 1
0.91 query.py(917):         return alias
0.91 query.py(1798):         opts = self.get_meta()
0.91 query.py(290):         return self.model._meta
0.91 query.py(1800):         try:
0.91 query.py(1801):             cols = []
0.91 query.py(1802):             for name in field_names:
0.91 query.py(1805):                 join_info = self.setup_joins(name.split(LOOKUP_SEP), opts, alias, allow_many=allow_m2m)
0.91 query.py(1518):         joins = [alias]
0.91 query.py(1524):         def final_transformer(field, alias):
0.91 query.py(1529):         last_field_exception = None
0.91 query.py(1530):         for pivot in range(len(names), 0, -1):
0.91 query.py(1531):             try:
0.91 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.91 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.91 query.py(1405):         path, names_with_path = [], []
0.91 query.py(1406):         for pos, name in enumerate(names):
0.91 query.py(1407):             cur_names_with_path = (name, [])
0.91 query.py(1408):             if name == 'pk':
0.91 query.py(1411):             field = None
0.91 query.py(1412):             filtered_relation = None
0.91 query.py(1413):             try:
0.91 query.py(1414):                 field = opts.get_field(name)
0.91 query.py(1421):             if field is not None:
0.91 query.py(1425):                 if field.is_relation and not field.related_model:
0.91 query.py(1432):                 try:
0.91 query.py(1433):                     model = field.model._meta.concrete_model
0.91 query.py(1454):             if model is not opts.model:
0.91 query.py(1460):             if hasattr(field, 'get_path_info'):
0.91 query.py(1477):                 final_field = field
0.91 query.py(1478):                 targets = (field,)
0.91 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.91 query.py(1483):                 break
0.91 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.91 query.py(1545):                 transforms = names[pivot:]
0.91 query.py(1546):                 break
0.91 query.py(1547):         for name in transforms:
0.91 query.py(1562):         for join in path:
0.91 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.91 query.py(1806):                 targets, final_alias, joins = self.trim_joins(
0.91 query.py(1807):                     join_info.targets,
0.91 query.py(1808):                     join_info.joins,
0.91 query.py(1809):                     join_info.path,
0.91 query.py(1601):         joins = joins[:]
0.91 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.91 query.py(1614):         return targets, joins[-1], joins
0.91 query.py(1811):                 for target in targets:
0.91 query.py(1812):                     cols.append(join_info.transform_function(target, final_alias))
0.91 query.py(1525):             return field.get_col(alias)
0.91 query.py(1811):                 for target in targets:
0.91 query.py(1802):             for name in field_names:
0.91 query.py(1813):             if cols:
0.91 query.py(1814):                 self.set_select(cols)
0.91 query.py(1782):         self.default_cols = False
0.91 query.py(1783):         self.select = tuple(cols)
0.91 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.91 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.91 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(311):             obj.annotation_select_mask = self.annotation_select_mask.copy()
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(322):             obj.extra_select_mask = self.extra_select_mask.copy()
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(1860):         self.order_by = ()
0.91 query.py(1861):         self.extra_order_by = ()
0.91 query.py(1862):         if force_empty:
0.91 query.py(1863):             self.default_ordering = False
0.91 query.py(1747):         self.low_mark, self.high_mark = 0, None
0.91 query.py(1758):         return not self.low_mark and self.high_mark is None
0.91 query.py(343):         obj = self.clone()
0.91 query.py(297):         obj = Empty()
0.91 query.py(298):         obj.__class__ = self.__class__
0.91 query.py(300):         obj.__dict__ = self.__dict__.copy()
0.91 query.py(302):         obj.alias_refcount = self.alias_refcount.copy()
0.91 query.py(303):         obj.alias_map = self.alias_map.copy()
0.91 query.py(304):         obj.external_aliases = self.external_aliases.copy()
0.91 query.py(305):         obj.table_map = self.table_map.copy()
0.91 query.py(306):         obj.where = self.where.clone()
0.91 query.py(307):         obj.annotations = self.annotations.copy()
0.91 query.py(308):         if self.annotation_select_mask is None:
0.91 query.py(311):             obj.annotation_select_mask = self.annotation_select_mask.copy()
0.91 query.py(317):         obj._annotation_select_cache = None
0.91 query.py(318):         obj.extra = self.extra.copy()
0.91 query.py(319):         if self.extra_select_mask is None:
0.91 query.py(322):             obj.extra_select_mask = self.extra_select_mask.copy()
0.91 query.py(323):         if self._extra_select_cache is None:
0.91 query.py(324):             obj._extra_select_cache = None
0.91 query.py(327):         if 'subq_aliases' in self.__dict__:
0.91 query.py(329):         obj.used_aliases = self.used_aliases.copy()
0.91 query.py(330):         obj._filtered_relations = self._filtered_relations.copy()
0.91 query.py(332):         try:
0.91 query.py(333):             del obj.base_table
0.91 query.py(334):         except AttributeError:
0.91 query.py(335):             pass
0.91 query.py(336):         return obj
0.91 query.py(344):         if klass and obj.__class__ != klass:
0.91 query.py(346):         if not obj.filter_is_sticky:
0.91 query.py(347):             obj.used_aliases = set()
0.91 query.py(348):         obj.filter_is_sticky = False
0.91 query.py(349):         if hasattr(obj, '_setup_query'):
0.91 query.py(351):         return obj
0.91 query.py(1860):         self.order_by = ()
0.91 query.py(1861):         self.extra_order_by = ()
0.91 query.py(1862):         if force_empty:
0.91 query.py(1839):         errors = []
0.91 query.py(1840):         for item in ordering:
0.91 query.py(1841):             if not hasattr(item, 'resolve_expression') and not ORDER_PATTERN.match(item):
0.91 query.py(1843):             if getattr(item, 'contains_aggregate', False):
0.91 query.py(1840):         for item in ordering:
0.91 query.py(1848):         if errors:
0.91 query.py(1850):         if ordering:
0.91 query.py(1851):             self.order_by += ordering
0.91 query.py(278):         if using is None and connection is None:
0.91 query.py(280):         if using:
0.91 query.py(281):             connection = connections[using]
0.91 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.91 compiler.py(25):         self.query = query
0.91 compiler.py(26):         self.connection = connection
0.91 compiler.py(27):         self.using = using
0.91 compiler.py(28):         self.quote_cache = {'*': '*'}
0.91 compiler.py(33):         self.select = None
0.91 compiler.py(34):         self.annotation_col_map = None
0.91 compiler.py(35):         self.klass_info = None
0.91 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.91 compiler.py(38):         self._meta_ordering = None
0.91 compiler.py(1046):         if results is None:
0.91 compiler.py(1047):             results = self.execute_sql(MULTI, chunked_fetch=chunked_fetch, chunk_size=chunk_size)
0.91 compiler.py(1080):         result_type = result_type or NO_RESULTS
0.91 compiler.py(1081):         try:
0.91 compiler.py(1082):             sql, params = self.as_sql()
0.92 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.92 compiler.py(479):         try:
0.92 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.92 compiler.py(52):         self.setup_query()
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.92 compiler.py(202):         select = []
0.92 compiler.py(203):         klass_info = None
0.92 compiler.py(204):         annotations = {}
0.92 compiler.py(205):         select_idx = 0
0.92 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.92 compiler.py(211):         if self.query.default_cols:
0.92 compiler.py(216):             cols = self.query.select
0.92 compiler.py(217):         if cols:
0.92 compiler.py(218):             select_list = []
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(220):                 select_list.append(select_idx)
0.92 compiler.py(221):                 select.append((col, None))
0.92 compiler.py(222):                 select_idx += 1
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(224):                 'model': self.query.model,
0.92 compiler.py(225):                 'select_fields': select_list,
0.92 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.92 query.py(2075):         if self._annotation_select_cache is not None:
0.92 query.py(2077):         elif not self.annotations:
0.92 query.py(2078):             return {}
0.92 compiler.py(232):         if self.query.select_related:
0.92 compiler.py(244):         ret = []
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(246):             try:
0.92 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.92 compiler.py(251):             ret.append((col, (sql, params), alias))
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(252):         return ret, klass_info, annotations
0.92 compiler.py(44):         self.col_count = len(self.select)
0.92 compiler.py(53):         order_by = self.get_order_by()
0.92 compiler.py(263):         if self.query.extra_order_by:
0.92 compiler.py(265):         elif not self.query.default_ordering:
0.92 compiler.py(266):             ordering = self.query.order_by
0.92 compiler.py(274):         if self.query.standard_ordering:
0.92 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.92 compiler.py(279):         order_by = []
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(281):             if hasattr(field, 'resolve_expression'):
0.92 compiler.py(292):             if field == '?':  # random
0.92 compiler.py(296):             col, order = get_order_dir(field, asc)
0.92 query.py(2204):     dirn = ORDER_DIR[default]
0.92 query.py(2205):     if field[0] == '-':
0.92 query.py(2207):     return field, dirn[0]
0.92 compiler.py(297):             descending = order == 'DESC'
0.92 compiler.py(299):             if col in self.query.annotation_select:
0.92 query.py(2075):         if self._annotation_select_cache is not None:
0.92 query.py(2077):         elif not self.annotations:
0.92 query.py(2078):             return {}
0.92 compiler.py(305):             if col in self.query.annotations:
0.92 compiler.py(315):             if '.' in field:
0.92 compiler.py(326):             if not self.query.extra or col not in self.query.extra:
0.92 compiler.py(329):                 order_by.extend(self.find_ordering_name(
0.92 compiler.py(330):                     field, self.query.get_meta(), default_order=asc))
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(707):         name, order = get_order_dir(name, default_order)
0.92 query.py(2204):     dirn = ORDER_DIR[default]
0.92 query.py(2205):     if field[0] == '-':
0.92 query.py(2207):     return field, dirn[0]
0.92 compiler.py(708):         descending = order == 'DESC'
0.92 compiler.py(709):         pieces = name.split(LOOKUP_SEP)
0.92 compiler.py(710):         field, targets, alias, joins, path, opts, transform_function = self._setup_joins(pieces, opts, alias)
0.92 compiler.py(739):         alias = alias or self.query.get_initial_alias()
0.92 query.py(912):         if self.alias_map:
0.92 query.py(913):             alias = self.base_table
0.92 query.py(250):         for alias in self.alias_map:
0.92 query.py(251):             return alias
0.92 query.py(914):             self.ref_alias(alias)
0.92 query.py(754):         self.alias_refcount[alias] += 1
0.92 query.py(917):         return alias
0.92 compiler.py(740):         field, targets, opts, joins, path, transform_function = self.query.setup_joins(pieces, opts, alias)
0.92 query.py(1518):         joins = [alias]
0.92 query.py(1524):         def final_transformer(field, alias):
0.92 query.py(1529):         last_field_exception = None
0.92 query.py(1530):         for pivot in range(len(names), 0, -1):
0.92 query.py(1531):             try:
0.92 query.py(1532):                 path, final_field, targets, rest = self.names_to_path(
0.92 query.py(1533):                     names[:pivot], opts, allow_many, fail_on_missing=True,
0.92 query.py(1405):         path, names_with_path = [], []
0.92 query.py(1406):         for pos, name in enumerate(names):
0.92 query.py(1407):             cur_names_with_path = (name, [])
0.92 query.py(1408):             if name == 'pk':
0.92 query.py(1411):             field = None
0.92 query.py(1412):             filtered_relation = None
0.92 query.py(1413):             try:
0.92 query.py(1414):                 field = opts.get_field(name)
0.92 query.py(1421):             if field is not None:
0.92 query.py(1425):                 if field.is_relation and not field.related_model:
0.92 query.py(1432):                 try:
0.92 query.py(1433):                     model = field.model._meta.concrete_model
0.92 query.py(1454):             if model is not opts.model:
0.92 query.py(1460):             if hasattr(field, 'get_path_info'):
0.92 query.py(1477):                 final_field = field
0.92 query.py(1478):                 targets = (field,)
0.92 query.py(1479):                 if fail_on_missing and pos + 1 != len(names):
0.92 query.py(1483):                 break
0.92 query.py(1484):         return path, final_field, targets, names[pos + 1:]
0.92 query.py(1545):                 transforms = names[pivot:]
0.92 query.py(1546):                 break
0.92 query.py(1547):         for name in transforms:
0.92 query.py(1562):         for join in path:
0.92 query.py(1586):         return JoinInfo(final_field, targets, opts, joins, path, final_transformer)
0.92 compiler.py(741):         alias = joins[-1]
0.92 compiler.py(742):         return field, targets, alias, joins, path, opts, transform_function
0.92 compiler.py(715):         if field.is_relation and opts.ordering and getattr(field, 'attname', None) != name:
0.92 compiler.py(728):         targets, alias, _ = self.query.trim_joins(targets, joins, path)
0.92 query.py(1601):         joins = joins[:]
0.92 query.py(1602):         for pos, info in enumerate(reversed(path)):
0.92 query.py(1614):         return targets, joins[-1], joins
0.92 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.92 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.92 query.py(1525):             return field.get_col(alias)
0.92 compiler.py(729):         return [(OrderBy(transform_function(t, alias), descending=descending), False) for t in targets]
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(340):         result = []
0.92 compiler.py(341):         seen = set()
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(344):             resolved = expr.resolve_expression(self.query, allow_joins=True, reuse=None)
0.92 compiler.py(345):             if self.query.combinator:
0.92 compiler.py(346):                 src = resolved.get_source_expressions()[0]
0.92 compiler.py(350):                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
0.92 compiler.py(351):                     if is_ref and col_alias == src.refs:
0.92 compiler.py(353):                     elif col_alias:
0.92 compiler.py(355):                     if src == sel_expr:
0.92 compiler.py(350):                 for idx, (sel_expr, _, col_alias) in enumerate(self.select):
0.92 compiler.py(359):                     if col_alias:
0.92 compiler.py(363):                     self.query.add_select_col(src)
0.92 query.py(1778):         self.select += col,
0.92 query.py(1779):         self.values_select += col.output_field.name,
0.92 compiler.py(364):                     resolved.set_source_expressions([RawSQL('%d' % len(self.query.select), ())])
0.92 compiler.py(365):             sql, params = self.compile(resolved)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(408):             sql, params = vendor_impl(self, self.connection)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(370):             without_ordering = self.ordering_parts.search(sql).group(1)
0.92 compiler.py(371):             params_hash = make_hashable(params)
0.92 compiler.py(372):             if (without_ordering, params_hash) in seen:
0.92 compiler.py(374):             seen.add((without_ordering, params_hash))
0.92 compiler.py(375):             result.append((resolved, (sql, params, is_ref)))
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(376):         return result
0.92 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.92 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.92 compiler.py(379):         extra_select = []
0.92 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.92 compiler.py(386):         return extra_select
0.92 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.92 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.92 compiler.py(97):         if self.query.group_by is None:
0.92 compiler.py(98):             return []
0.92 compiler.py(58):         return extra_select, order_by, group_by
0.92 compiler.py(481):             for_update_part = None
0.92 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.92 compiler.py(484):             combinator = self.query.combinator
0.92 compiler.py(485):             features = self.connection.features
0.92 compiler.py(486):             if combinator:
0.92 compiler.py(487):                 if not getattr(features, 'supports_select_{}'.format(combinator)):
0.92 compiler.py(489):                 result, params = self.get_combinator_sql(combinator, self.query.combinator_all)
0.92 compiler.py(416):         features = self.connection.features
0.92 compiler.py(418):             query.get_compiler(self.using, self.connection)
0.92 compiler.py(419):             for query in self.query.combined_queries if not query.is_empty()
0.92 compiler.py(418):             query.get_compiler(self.using, self.connection)
0.92 compiler.py(419):             for query in self.query.combined_queries if not query.is_empty()
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(278):         if using is None and connection is None:
0.92 query.py(280):         if using:
0.92 query.py(281):             connection = connections[using]
0.92 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.92 compiler.py(25):         self.query = query
0.92 compiler.py(26):         self.connection = connection
0.92 compiler.py(27):         self.using = using
0.92 compiler.py(28):         self.quote_cache = {'*': '*'}
0.92 compiler.py(33):         self.select = None
0.92 compiler.py(34):         self.annotation_col_map = None
0.92 compiler.py(35):         self.klass_info = None
0.92 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.92 compiler.py(38):         self._meta_ordering = None
0.92 compiler.py(418):             query.get_compiler(self.using, self.connection)
0.92 compiler.py(419):             for query in self.query.combined_queries if not query.is_empty()
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(1720):         return any(isinstance(c, NothingNode) for c in self.where.children)
0.92 query.py(278):         if using is None and connection is None:
0.92 query.py(280):         if using:
0.92 query.py(281):             connection = connections[using]
0.92 query.py(282):         return connection.ops.compiler(self.compiler)(self, connection, using)
0.92 compiler.py(25):         self.query = query
0.92 compiler.py(26):         self.connection = connection
0.92 compiler.py(27):         self.using = using
0.92 compiler.py(28):         self.quote_cache = {'*': '*'}
0.92 compiler.py(33):         self.select = None
0.92 compiler.py(34):         self.annotation_col_map = None
0.92 compiler.py(35):         self.klass_info = None
0.92 compiler.py(37):         self.ordering_parts = re.compile(r'^(.*)\s(ASC|DESC)(.*)', re.MULTILINE | re.DOTALL)
0.92 compiler.py(38):         self._meta_ordering = None
0.92 compiler.py(418):             query.get_compiler(self.using, self.connection)
0.92 compiler.py(421):         if not features.supports_slicing_ordering_in_compound:
0.92 compiler.py(422):             for query, compiler in zip(self.query.combined_queries, compilers):
0.92 compiler.py(423):                 if query.low_mark or query.high_mark:
0.92 compiler.py(425):                 if compiler.get_order_by():
0.92 compiler.py(263):         if self.query.extra_order_by:
0.92 compiler.py(265):         elif not self.query.default_ordering:
0.92 compiler.py(267):         elif self.query.order_by:
0.92 compiler.py(269):         elif self.query.get_meta().ordering:
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(273):             ordering = []
0.92 compiler.py(274):         if self.query.standard_ordering:
0.92 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.92 compiler.py(279):         order_by = []
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(340):         result = []
0.92 compiler.py(341):         seen = set()
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(376):         return result
0.92 compiler.py(422):             for query, compiler in zip(self.query.combined_queries, compilers):
0.92 compiler.py(423):                 if query.low_mark or query.high_mark:
0.92 compiler.py(425):                 if compiler.get_order_by():
0.92 compiler.py(263):         if self.query.extra_order_by:
0.92 compiler.py(265):         elif not self.query.default_ordering:
0.92 compiler.py(267):         elif self.query.order_by:
0.92 compiler.py(269):         elif self.query.get_meta().ordering:
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(273):             ordering = []
0.92 compiler.py(274):         if self.query.standard_ordering:
0.92 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.92 compiler.py(279):         order_by = []
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(340):         result = []
0.92 compiler.py(341):         seen = set()
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(376):         return result
0.92 compiler.py(422):             for query, compiler in zip(self.query.combined_queries, compilers):
0.92 compiler.py(427):         parts = ()
0.92 compiler.py(428):         for compiler in compilers:
0.92 compiler.py(429):             try:
0.92 compiler.py(433):                 if not compiler.query.values_select and self.query.values_select:
0.92 compiler.py(440):                 part_sql, part_args = compiler.as_sql()
0.92 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.92 compiler.py(479):         try:
0.92 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.92 compiler.py(52):         self.setup_query()
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.92 compiler.py(202):         select = []
0.92 compiler.py(203):         klass_info = None
0.92 compiler.py(204):         annotations = {}
0.92 compiler.py(205):         select_idx = 0
0.92 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.92 compiler.py(211):         if self.query.default_cols:
0.92 compiler.py(216):             cols = self.query.select
0.92 compiler.py(217):         if cols:
0.92 compiler.py(218):             select_list = []
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(220):                 select_list.append(select_idx)
0.92 compiler.py(221):                 select.append((col, None))
0.92 compiler.py(222):                 select_idx += 1
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(224):                 'model': self.query.model,
0.92 compiler.py(225):                 'select_fields': select_list,
0.92 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.92 query.py(2075):         if self._annotation_select_cache is not None:
0.92 query.py(2077):         elif not self.annotations:
0.92 query.py(2078):             return {}
0.92 compiler.py(232):         if self.query.select_related:
0.92 compiler.py(244):         ret = []
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(246):             try:
0.92 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.92 compiler.py(251):             ret.append((col, (sql, params), alias))
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(252):         return ret, klass_info, annotations
0.92 compiler.py(44):         self.col_count = len(self.select)
0.92 compiler.py(53):         order_by = self.get_order_by()
0.92 compiler.py(263):         if self.query.extra_order_by:
0.92 compiler.py(265):         elif not self.query.default_ordering:
0.92 compiler.py(267):         elif self.query.order_by:
0.92 compiler.py(269):         elif self.query.get_meta().ordering:
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(273):             ordering = []
0.92 compiler.py(274):         if self.query.standard_ordering:
0.92 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.92 compiler.py(279):         order_by = []
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(340):         result = []
0.92 compiler.py(341):         seen = set()
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(376):         return result
0.92 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.92 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.92 compiler.py(379):         extra_select = []
0.92 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.92 compiler.py(386):         return extra_select
0.92 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.92 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.92 compiler.py(97):         if self.query.group_by is None:
0.92 compiler.py(98):             return []
0.92 compiler.py(58):         return extra_select, order_by, group_by
0.92 compiler.py(481):             for_update_part = None
0.92 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.92 compiler.py(484):             combinator = self.query.combinator
0.92 compiler.py(485):             features = self.connection.features
0.92 compiler.py(486):             if combinator:
0.92 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.92 compiler.py(683):         result = []
0.92 compiler.py(684):         params = []
0.92 compiler.py(685):         opts = self.query.get_meta()
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(687):         for name in self.query.distinct_fields:
0.92 compiler.py(698):         return result, params
0.92 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.92 compiler.py(755):         result = []
0.92 compiler.py(756):         params = []
0.92 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.92 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.92 compiler.py(760):             try:
0.92 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.92 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(767):             result.append(clause_sql)
0.92 compiler.py(768):             params.extend(clause_params)
0.92 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.92 compiler.py(769):         for t in self.query.extra_tables:
0.92 compiler.py(776):         return result, params
0.92 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.92 compiler.py(497):                 result = ['SELECT']
0.92 compiler.py(498):                 params = []
0.92 compiler.py(500):                 if self.query.distinct:
0.92 compiler.py(508):                 out_cols = []
0.92 compiler.py(509):                 col_idx = 1
0.92 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.92 compiler.py(511):                     if alias:
0.92 compiler.py(513):                     elif with_col_aliases:
0.92 compiler.py(516):                     params.extend(s_params)
0.92 compiler.py(517):                     out_cols.append(s_sql)
0.92 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.92 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.92 compiler.py(520):                 params.extend(f_params)
0.92 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.92 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.92 compiler.py(552):                 if where:
0.92 compiler.py(553):                     result.append('WHERE %s' % where)
0.92 compiler.py(554):                     params.extend(w_params)
0.92 compiler.py(556):                 grouping = []
0.92 compiler.py(557):                 for g_sql, g_params in group_by:
0.92 compiler.py(560):                 if grouping:
0.92 compiler.py(577):                 if having:
0.92 compiler.py(581):             if self.query.explain_query:
0.92 compiler.py(587):             if order_by:
0.92 compiler.py(594):             if with_limit_offset:
0.92 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.92 compiler.py(600):             if self.query.subquery and extra_select:
0.92 compiler.py(627):             return ' '.join(result), tuple(params)
0.92 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.92 query.py(820):             self.unref_alias(alias, unref_amount)
0.92 query.py(758):         self.alias_refcount[alias] -= amount
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 compiler.py(441):                 if compiler.query.combinator:
0.92 compiler.py(450):                 parts += ((part_sql, part_args),)
0.92 compiler.py(428):         for compiler in compilers:
0.92 compiler.py(429):             try:
0.92 compiler.py(433):                 if not compiler.query.values_select and self.query.values_select:
0.92 compiler.py(440):                 part_sql, part_args = compiler.as_sql()
0.92 compiler.py(478):         refcounts_before = self.query.alias_refcount.copy()
0.92 compiler.py(479):         try:
0.92 compiler.py(480):             extra_select, order_by, group_by = self.pre_sql_setup()
0.92 compiler.py(52):         self.setup_query()
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(41):         if all(self.query.alias_refcount[a] == 0 for a in self.query.alias_map):
0.92 compiler.py(43):         self.select, self.klass_info, self.annotation_col_map = self.get_select()
0.92 compiler.py(202):         select = []
0.92 compiler.py(203):         klass_info = None
0.92 compiler.py(204):         annotations = {}
0.92 compiler.py(205):         select_idx = 0
0.92 compiler.py(206):         for alias, (sql, params) in self.query.extra_select.items():
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(210):         assert not (self.query.select and self.query.default_cols)
0.92 compiler.py(211):         if self.query.default_cols:
0.92 compiler.py(216):             cols = self.query.select
0.92 compiler.py(217):         if cols:
0.92 compiler.py(218):             select_list = []
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(220):                 select_list.append(select_idx)
0.92 compiler.py(221):                 select.append((col, None))
0.92 compiler.py(222):                 select_idx += 1
0.92 compiler.py(219):             for col in cols:
0.92 compiler.py(224):                 'model': self.query.model,
0.92 compiler.py(225):                 'select_fields': select_list,
0.92 compiler.py(227):         for alias, annotation in self.query.annotation_select.items():
0.92 query.py(2075):         if self._annotation_select_cache is not None:
0.92 query.py(2077):         elif not self.annotations:
0.92 query.py(2078):             return {}
0.92 compiler.py(232):         if self.query.select_related:
0.92 compiler.py(244):         ret = []
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(246):             try:
0.92 compiler.py(247):                 sql, params = self.compile(col, select_format=True)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(396):         if ((name in self.query.alias_map and name not in self.query.table_map) or
0.92 compiler.py(397):                 name in self.query.extra_select or (
0.92 query.py(2090):         if self._extra_select_cache is not None:
0.92 query.py(2092):         if not self.extra:
0.92 query.py(2093):             return {}
0.92 compiler.py(398):                     name in self.query.external_aliases and name not in self.query.table_map)):
0.92 compiler.py(401):         r = self.connection.ops.quote_name(name)
0.92 compiler.py(402):         self.quote_cache[name] = r
0.92 compiler.py(403):         return r
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(412):             return node.output_field.select_format(self, sql, params)
0.92 compiler.py(251):             ret.append((col, (sql, params), alias))
0.92 compiler.py(245):         for col, alias in select:
0.92 compiler.py(252):         return ret, klass_info, annotations
0.92 compiler.py(44):         self.col_count = len(self.select)
0.92 compiler.py(53):         order_by = self.get_order_by()
0.92 compiler.py(263):         if self.query.extra_order_by:
0.92 compiler.py(265):         elif not self.query.default_ordering:
0.92 compiler.py(267):         elif self.query.order_by:
0.92 compiler.py(269):         elif self.query.get_meta().ordering:
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(273):             ordering = []
0.92 compiler.py(274):         if self.query.standard_ordering:
0.92 compiler.py(275):             asc, desc = ORDER_DIR['ASC']
0.92 compiler.py(279):         order_by = []
0.92 compiler.py(280):         for field in ordering:
0.92 compiler.py(340):         result = []
0.92 compiler.py(341):         seen = set()
0.92 compiler.py(343):         for expr, is_ref in order_by:
0.92 compiler.py(376):         return result
0.92 compiler.py(54):         self.where, self.having = self.query.where.split_having()
0.92 compiler.py(55):         extra_select = self.get_extra_select(order_by, self.select)
0.92 compiler.py(379):         extra_select = []
0.92 compiler.py(380):         if self.query.distinct and not self.query.distinct_fields:
0.92 compiler.py(386):         return extra_select
0.92 compiler.py(56):         self.has_extra_select = bool(extra_select)
0.92 compiler.py(57):         group_by = self.get_group_by(self.select + extra_select, order_by)
0.92 compiler.py(97):         if self.query.group_by is None:
0.92 compiler.py(98):             return []
0.92 compiler.py(58):         return extra_select, order_by, group_by
0.92 compiler.py(481):             for_update_part = None
0.92 compiler.py(483):             with_limit_offset = with_limits and (self.query.high_mark is not None or self.query.low_mark)
0.92 compiler.py(484):             combinator = self.query.combinator
0.92 compiler.py(485):             features = self.connection.features
0.92 compiler.py(486):             if combinator:
0.92 compiler.py(491):                 distinct_fields, distinct_params = self.get_distinct()
0.92 compiler.py(683):         result = []
0.92 compiler.py(684):         params = []
0.92 compiler.py(685):         opts = self.query.get_meta()
0.92 query.py(290):         return self.model._meta
0.92 compiler.py(687):         for name in self.query.distinct_fields:
0.92 compiler.py(698):         return result, params
0.92 compiler.py(494):                 from_, f_params = self.get_from_clause()
0.92 compiler.py(755):         result = []
0.92 compiler.py(756):         params = []
0.92 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.92 compiler.py(758):             if not self.query.alias_refcount[alias]:
0.92 compiler.py(760):             try:
0.92 compiler.py(761):                 from_clause = self.query.alias_map[alias]
0.92 compiler.py(766):             clause_sql, clause_params = self.compile(from_clause)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(767):             result.append(clause_sql)
0.92 compiler.py(768):             params.extend(clause_params)
0.92 compiler.py(757):         for alias in tuple(self.query.alias_map):
0.92 compiler.py(769):         for t in self.query.extra_tables:
0.92 compiler.py(776):         return result, params
0.92 compiler.py(495):                 where, w_params = self.compile(self.where) if self.where is not None else ("", [])
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(406):         vendor_impl = getattr(node, 'as_' + self.connection.vendor, None)
0.92 compiler.py(407):         if vendor_impl:
0.92 compiler.py(410):             sql, params = node.as_sql(self, self.connection)
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(394):         if name in self.quote_cache:
0.92 compiler.py(395):             return self.quote_cache[name]
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(411):         if select_format is FORCE or (select_format and not self.query.subquery):
0.92 compiler.py(413):         return sql, params
0.92 compiler.py(496):                 having, h_params = self.compile(self.having) if self.having is not None else ("", [])
0.92 compiler.py(497):                 result = ['SELECT']
0.92 compiler.py(498):                 params = []
0.92 compiler.py(500):                 if self.query.distinct:
0.92 compiler.py(508):                 out_cols = []
0.92 compiler.py(509):                 col_idx = 1
0.92 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.92 compiler.py(511):                     if alias:
0.92 compiler.py(513):                     elif with_col_aliases:
0.92 compiler.py(516):                     params.extend(s_params)
0.92 compiler.py(517):                     out_cols.append(s_sql)
0.92 compiler.py(510):                 for _, (s_sql, s_params), alias in self.select + extra_select:
0.92 compiler.py(519):                 result += [', '.join(out_cols), 'FROM', *from_]
0.92 compiler.py(520):                 params.extend(f_params)
0.92 compiler.py(522):                 if self.query.select_for_update and self.connection.features.has_select_for_update:
0.92 compiler.py(549):                 if for_update_part and self.connection.features.for_update_after_from:
0.92 compiler.py(552):                 if where:
0.92 compiler.py(553):                     result.append('WHERE %s' % where)
0.92 compiler.py(554):                     params.extend(w_params)
0.92 compiler.py(556):                 grouping = []
0.92 compiler.py(557):                 for g_sql, g_params in group_by:
0.92 compiler.py(560):                 if grouping:
0.92 compiler.py(577):                 if having:
0.92 compiler.py(581):             if self.query.explain_query:
0.92 compiler.py(587):             if order_by:
0.92 compiler.py(594):             if with_limit_offset:
0.92 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.92 compiler.py(600):             if self.query.subquery and extra_select:
0.92 compiler.py(627):             return ' '.join(result), tuple(params)
0.92 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.92 query.py(820):             self.unref_alias(alias, unref_amount)
0.92 query.py(758):         self.alias_refcount[alias] -= amount
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 compiler.py(441):                 if compiler.query.combinator:
0.92 compiler.py(450):                 parts += ((part_sql, part_args),)
FAIL

======================================================================
FAIL: test_union_queryset_ordering_bug (test_coverup_django__django-10554.UnionQuerysetOrderingTests)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/django/db/backends/utils.py", line 86, in _execute
    return self.cursor.execute(sql, params)
sqlite3.OperationalError: 1st ORDER BY term out of range - should be between 1 and 1

The above exception was the direct cause of the following exception:

Traceback (most recent call last):
  File "./tests/test_coverup_django__django-10554.py", line 39, in test_union_queryset_ordering_bug
    result = list(qs)
django.db.utils.OperationalError: 1st ORDER BY term out of range - should be between 1 and 1

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "./tests/test_coverup_django__django-10554.py", line 45, in test_union_queryset_ordering_bug
    self.fail(f"Unexpected exception raised: {e}")
AssertionError: Unexpected exception raised: 1st ORDER BY term out of range - should be between 1 and 1

----------------------------------------------------------------------
Ran 1 test in 0.009s

FAILED (failures=1)
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
0.92 compiler.py(428):         for compiler in compilers:
0.92 compiler.py(457):         if not parts:
0.92 compiler.py(459):         combinator_sql = self.connection.ops.set_operators[combinator]
0.92 compiler.py(460):         if all and combinator == 'union':
0.92 compiler.py(462):         braces = '({})' if features.supports_slicing_ordering_in_compound else '{}'
0.92 compiler.py(463):         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
0.92 compiler.py(463):         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
0.92 compiler.py(463):         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
0.92 compiler.py(463):         sql_parts, args_parts = zip(*((braces.format(sql), args) for sql, args in parts))
0.92 compiler.py(464):         result = [' {} '.format(combinator_sql).join(sql_parts)]
0.92 compiler.py(465):         params = []
0.92 compiler.py(466):         for part in args_parts:
0.92 compiler.py(467):             params.extend(part)
0.92 compiler.py(466):         for part in args_parts:
0.92 compiler.py(467):             params.extend(part)
0.92 compiler.py(466):         for part in args_parts:
0.92 compiler.py(468):         return result, params
0.92 compiler.py(581):             if self.query.explain_query:
0.92 compiler.py(587):             if order_by:
0.92 compiler.py(588):                 ordering = []
0.92 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.92 compiler.py(590):                     ordering.append(o_sql)
0.92 compiler.py(591):                     params.extend(o_params)
0.92 compiler.py(589):                 for _, (o_sql, o_params, _) in order_by:
0.92 compiler.py(592):                 result.append('ORDER BY %s' % ', '.join(ordering))
0.92 compiler.py(594):             if with_limit_offset:
0.92 compiler.py(597):             if for_update_part and not self.connection.features.for_update_after_from:
0.92 compiler.py(600):             if self.query.subquery and extra_select:
0.92 compiler.py(627):             return ' '.join(result), tuple(params)
0.92 compiler.py(630):             self.query.reset_refcounts(refcounts_before)
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 query.py(819):             unref_amount = cur_refcount - to_counts.get(alias, 0)
0.92 query.py(820):             self.unref_alias(alias, unref_amount)
0.92 query.py(758):         self.alias_refcount[alias] -= amount
0.92 query.py(818):         for alias, cur_refcount in self.alias_refcount.copy().items():
0.92 compiler.py(1083):             if not sql:
0.92 compiler.py(1090):         if chunked_fetch:
0.92 compiler.py(1093):             cursor = self.connection.cursor()
0.92 compiler.py(1094):         try:
0.92 compiler.py(1095):             cursor.execute(sql, params)
0.92 compiler.py(1096):         except Exception:
0.92 compiler.py(1098):             cursor.close()
0.92 compiler.py(1099):             raise
+ cat coverage.cover
{"/testbed/django/db/models/sql/query.py": {"9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "19": 1, "22": 1, "23": 1, "24": 1, "25": 1, "28": 1, "29": 1, "30": 1, "31": 1, "34": 1, "37": 1, "40": 1, "43": 1, "44": 1, "45": 1, "47": 1, "50": 1, "57": 1, "65": 1, "66": 1, "67": 1, "71": 1, "77": 2, "145": 2, "2196": 1, "2210": 1, "2221": 1, "2229": 2, "51": 0, "52": 0, "53": 0, "58": 0, "59": 0, "60": 0, "62": 0, "72": 32, "73": 0, "74": 32, "80": 1, "92": 1, "95": 1, "98": 1, "105": 1, "117": 1, "120": 1, "124": 1, "127": 1, "81": 0, "82": 0, "83": 0, "84": 0, "88": 0, "89": 0, "90": 0, "93": 0, "96": 0, "99": 0, "100": 0, "101": 0, "102": 0, "103": 0, "108": 0, "109": 0, "112": 0, "114": 0, "115": 0, "118": 0, "122": 0, "125": 0, "128": 0, "132": 0, "133": 0, "134": 0, "135": 0, "136": 0, "137": 0, "139": 0, "141": 0, "142": 0, "148": 1, "149": 1, "151": 1, "153": 1, "237": 1, "244": 1, "248": 1, "253": 1, "264": 1, "271": 1, "277": 1, "284": 1, "292": 1, "338": 1, "353": 1, "358": 1, "410": 1, "506": 1, "517": 1, "520": 1, "532": 1, "540": 1, "641": 1, "727": 1, "752": 1, "756": 1, "760": 1, "794": 1, "813": 1, "822": 1, "858": 1, "907": 1, "919": 1, "927": 1, "975": 1, "1008": 1, "1015": 1, "1043": 1, "1049": 1, "1069": 1, "1087": 1, "1098": 1, "1118": 1, "1163": 1, "1185": 1, "1304": 1, "1307": 1, "1324": 1, "1329": 1, "1355": 1, "1377": 1, "1390": 1, "1487": 1, "1588": 1, "1616": 1, "1645": 1, "1716": 1, "1719": 1, "1722": 1, "1745": 1, "1749": 1, "1752": 1, "1760": 1, "1768": 1, "1777": 1, "1781": 1, "1785": 1, "1792": 1, "1830": 1, "1855": 1, "1865": 1, "1892": 1, "1908": 1, "1940": 1, "1944": 1, "1964": 1, "1988": 1, "2007": 1, "2011": 1, "2019": 1, "2023": 1, "2034": 1, "2069": 1, "2088": 1, "2103": 1, "2177": 1, "154": 72, "155": 72, "161": 72, "165": 72, "166": 72, "167": 72, "168": 72, "169": 72, "170": 72, "171": 72, "172": 72, "180": 72, "181": 72, "182": 72, "189": 72, "190": 72, "191": 72, "192": 72, "193": 72, "194": 72, "195": 72, "196": 72, "197": 72, "199": 72, "201": 72, "205": 72, "208": 72, "209": 72, "210": 72, "213": 72, "214": 72, "215": 72, "219": 72, "220": 72, "221": 72, "223": 72, "224": 72, "229": 72, "231": 72, "233": 72, "234": 72, "235": 72, "239": 0, "240": 0, "241": 0, "242": 0, "246": 0, "250": 37, "251": 37, "261": 0, "262": 0, "269": 0, "273": 0, "274": 0, "275": 0, "278": 47, "279": 0, "280": 47, "281": 47, "282": 47, "290": 221, "297": 86, "298": 86, "300": 86, "302": 86, "303": 86, "304": 86, "305": 86, "306": 86, "307": 86, "308": 86, "309": 84, "311": 2, "317": 86, "318": 86, "319": 86, "320": 84, "322": 2, "323": 86, "324": 86, "326": 0, "327": 86, "328": 0, "329": 86, "330": 86, "332": 86, "333": 86, "334": 78, "335": 78, "336": 86, "343": 85, "344": 85, "345": 1, "346": 85, "347": 85, "348": 85, "349": 85, "350": 1, "351": 85, "354": 0, "355": 0, "356": 0, "370": 0, "371": 0, "372": 0, "376": 0, "379": 0, "380": 0, "384": 0, "385": 0, "388": 0, "389": 0, "390": 0, "391": 0, "394": 0, "397": 0, "398": 0, "399": 0, "400": 0, "401": 0, "405": 0, "406": 0, "407": 0, "408": 0, "414": 0, "415": 0, "416": 0, "418": 0, "419": 0, "433": 0, "434": 0, "435": 0, "436": 0, "437": 0, "438": 0, "439": 0, "440": 0, "441": 0, "445": 0, "446": 0, "452": 0, "453": 0, "456": 0, "457": 0, "458": 0, "460": 0, "461": 0, "464": 0, "465": 0, "466": 0, "467": 0, "468": 0, "469": 0, "470": 0, "471": 0, "473": 0, "474": 0, "478": 0, "479": 0, "480": 0, "481": 0, "482": 0, "484": 0, "487": 0, "488": 0, "489": 0, "490": 0, "492": 0, "493": 0, "494": 0, "495": 0, "496": 0, "497": 0, "498": 0, "499": 0, "501": 0, "502": 0, "504": 0, "420": 0, "454": 0, "510": 0, "511": 0, "512": 0, "513": 0, "514": 0, "515": 0, "518": 0, "521": 1, "522": 1, "523": 1, "524": 0, "525": 0, "526": 1, "527": 1, "528": 1, "529": 1, "530": 1, "533": 0, "534": 0, "535": 0, "536": 0, "537": 0, "538": 0, "549": 0, "550": 0, "551": 0, "552": 0, "553": 0, "554": 0, "555": 0, "556": 0, "559": 0, "560": 0, "574": 0, "577": 0, "578": 0, "579": 0, "580": 0, "581": 0, "584": 0, "585": 0, "586": 0, "589": 0, "590": 0, "591": 0, "592": 0, "596": 0, "597": 0, "598": 0, "599": 0, "604": 0, "605": 0, "606": 0, "610": 0, "611": 0, "612": 0, "615": 0, "616": 0, "618": 0, "620": 0, "624": 0, "625": 0, "626": 0, "627": 0, "628": 0, "629": 0, "630": 0, "631": 0, "632": 0, "633": 0, "634": 0, "638": 0, "639": 0, "655": 21, "656": 21, "657": 21, "658": 0, "659": 0, "660": 0, "661": 0, "662": 0, "663": 0, "664": 0, "665": 0, "666": 0, "667": 0, "668": 0, "669": 0, "670": 0, "671": 0, "673": 0, "674": 0, "678": 0, "679": 0, "680": 0, "681": 0, "682": 0, "683": 0, "684": 0, "685": 0, "686": 0, "687": 0, "688": 0, "690": 0, "695": 0, "696": 0, "697": 0, "698": 0, "699": 0, "700": 0, "701": 0, "706": 0, "707": 0, "708": 0, "709": 0, "711": 0, "712": 0, "713": 0, "718": 0, "722": 0, "723": 0, "724": 0, "725": 0, "735": 35, "736": 35, "737": 0, "738": 0, "739": 0, "742": 35, "743": 0, "744": 0, "747": 35, "748": 35, "749": 35, "750": 35, "754": 69, "758": 45, "771": 25, "772": 25, "773": 0, "774": 0, "778": 0, "780": 0, "781": 0, "782": 0, "783": 0, "784": 0, "785": 0, "786": 0, "789": 0, "790": 0, "791": 0, "804": 50, "805": 80, "806": 30, "807": 30, "808": 0, "809": 0, "810": 0, "811": 0, "818": 65, "819": 35, "820": 35, "828": 0, "832": 0, "833": 0, "834": 0, "835": 0, "836": 0, "837": 0, "841": 0, "842": 0, "843": 0, "844": 0, "845": 0, "846": 0, "847": 0, "848": 0, "850": 0, "851": 0, "852": 0, "853": 0, "854": 0, "855": 0, "856": 0, "865": 0, "883": 0, "885": 0, "891": 0, "892": 0, "893": 0, "894": 0, "895": 0, "896": 0, "897": 0, "898": 0, "900": 0, "901": 0, "902": 0, "904": 0, "874": 0, "875": 0, "876": 0, "877": 0, "878": 0, "879": 0, "880": 0, "881": 0, "912": 84, "913": 54, "914": 54, "916": 30, "917": 84, "925": 3, "943": 50, "945": 0, "950": 135, "953": 50, "954": 15, "955": 0, "959": 15, "960": 15, "961": 15, "964": 35, "965": 35, "966": 5, "967": 0, "969": 5, "970": 5, "971": 35, "972": 35, "973": 35, "946": 0, "951": 35, "984": 70, "985": 70, "986": 0, "987": 0, "988": 0, "989": 0, "990": 0, "991": 0, "992": 0, "993": 0, "994": 0, "999": 0, "1000": 0, "1001": 0, "1002": 0, "1003": 0, "1004": 0, "1005": 0, "1006": 0, "1010": 0, "1011": 0, "1012": 0, "1013": 0, "1016": 0, "1018": 0, "1019": 0, "1022": 0, "1023": 0, "1024": 0, "1025": 0, "1026": 0, "1027": 0, "1028": 0, "1029": 0, "1030": 0, "1031": 0, "1033": 0, "1034": 0, "1041": 0, "1036": 0, "1038": 0, "1044": 0, "1045": 0, "1046": 0, "1047": 0, "1050": 32, "1051": 0, "1052": 0, "1053": 0, "1054": 0, "1055": 32, "1058": 6, "1059": 4, "1060": 0, "1061": 0, "1062": 0, "1063": 0, "1066": 0, "1067": 32, "1073": 32, "1074": 32, "1075": 0, "1076": 0, "1077": 0, "1078": 32, "1079": 32, "1080": 32, "1081": 0, "1082": 0, "1083": 0, "1085": 32, "1092": 7, "1093": 7, "1094": 0, "1095": 0, "1096": 0, "1100": 32, "1106": 5, "1107": 0, "1108": 0, "1109": 0, "1110": 0, "1112": 5, "1113": 0, "1114": 5, "1115": 12, "1116": 7, "1128": 32, "1129": 32, "1130": 0, "1133": 32, "1134": 32, "1135": 0, "1136": 0, "1139": 0, "1140": 0, "1141": 0, "1142": 0, "1143": 0, "1145": 32, "1148": 32, "1149": 0, "1150": 0, "1151": 0, "1157": 32, "1158": 0, "1159": 0, "1161": 32, "1168": 0, "1169": 0, "1170": 0, "1172": 0, "1173": 0, "1174": 0, "1175": 0, "1177": 0, "1178": 0, "1179": 0, "1180": 0, "1214": 32, "1215": 0, "1216": 32, "1217": 32, "1218": 0, "1219": 32, "1221": 32, "1222": 0, "1223": 0, "1227": 32, "1228": 0, "1230": 32, "1231": 32, "1232": 71, "1234": 32, "1235": 32, "1236": 0, "1237": 0, "1238": 0, "1240": 32, "1241": 32, "1242": 32, "1244": 32, "1245": 32, "1246": 32, "1247": 32, "1251": 32, "1252": 0, "1253": 32, "1257": 32, "1258": 0, "1259": 0, "1263": 32, "1264": 32, "1265": 32, "1266": 32, "1268": 32, "1270": 5, "1271": 5, "1272": 0, "1273": 5, "1274": 5, "1276": 0, "1278": 27, "1280": 32, "1281": 32, "1282": 32, "1284": 32, "1285": 32, "1286": 0, "1287": 0, "1288": 0, "1289": 0, "1299": 0, "1300": 0, "1301": 0, "1302": 32, "1305": 0, "1318": 50, "1319": 25, "1320": 25, "1321": 25, "1322": 25, "1325": 0, "1331": 25, "1332": 25, "1333": 25, "1334": 25, "1335": 25, "1336": 25, "1337": 57, "1338": 32, "1339": 0, "1340": 0, "1341": 0, "1342": 0, "1344": 32, "1345": 32, "1346": 32, "1347": 32, "1349": 32, "1350": 32, "1351": 32, "1352": 25, "1353": 25, "1357": 0, "1358": 0, "1359": 0, "1360": 0, "1361": 0, "1362": 0, "1363": 0, "1364": 0, "1365": 0, "1368": 0, "1369": 0, "1370": 0, "1371": 0, "1372": 0, "1374": 0, "1375": 0, "1378": 0, "1379": 0, "1380": 0, "1381": 0, "1382": 0, "1383": 0, "1384": 0, "1385": 0, "1386": 0, "1388": 0, "1405": 94, "1406": 119, "1407": 109, "1408": 109, "1409": 6, "1411": 109, "1412": 109, "1413": 109, "1414": 109, "1415": 5, "1416": 5, "1417": 0, "1418": 5, "1419": 0, "1420": 0, "1421": 109, "1425": 104, "1426": 0, "1427": 0, "1430": 0, "1432": 104, "1433": 104, "1434": 0, "1437": 0, "1441": 5, "1442": 5, "1443": 0, "1444": 0, "1445": 0, "1446": 0, "1448": 0, "1449": 0, "1450": 5, "1454": 104, "1455": 0, "1456": 0, "1457": 0, "1458": 0, "1459": 0, "1460": 104, "1461": 25, "1462": 25, "1463": 0, "1464": 0, "1465": 0, "1466": 0, "1467": 0, "1468": 25, "1469": 25, "1470": 25, "1471": 25, "1472": 25, "1473": 25, "1474": 25, "1477": 79, "1478": 79, "1479": 79, "1480": 0, "1481": 0, "1482": 0, "1483": 79, "1484": 94, "1518": 62, "1524": 62, "1529": 62, "1530": 62, "1531": 62, "1532": 62, "1533": 62, "1535": 0, "1536": 0, "1539": 0, "1541": 0, "1545": 62, "1546": 62, "1547": 62, "1548": 0, "1558": 0, "1562": 82, "1563": 20, "1564": 0, "1565": 0, "1567": 20, "1568": 20, "1569": 20, "1570": 20, "1571": 20, "1573": 0, "1574": 20, "1575": 20, "1576": 20, "1578": 20, "1579": 20, "1580": 20, "1581": 20, "1583": 20, "1584": 20, "1585": 0, "1586": 62, "1525": 30, "1549": 0, "1550": 0, "1551": 0, "1552": 0, "1554": 0, "1555": 0, "1557": 0, "1601": 62, "1602": 72, "1603": 20, "1604": 0, "1605": 20, "1606": 0, "1607": 60, "1608": 60, "1609": 20, "1610": 10, "1611": 30, "1612": 30, "1613": 10, "1614": 62, "1617": 0, "1618": 0, "1619": 0, "1620": 0, "1625": 0, "1627": 0, "1629": 0, "1630": 0, "1631": 0, "1632": 0, "1633": 0, "1634": 0, "1635": 0, "1639": 0, "1640": 0, "1641": 0, "1642": 0, "1643": 0, "1664": 0, "1665": 0, "1666": 0, "1668": 0, "1669": 0, "1670": 0, "1671": 0, "1674": 0, "1680": 0, "1681": 0, "1682": 0, "1683": 0, "1684": 0, "1685": 0, "1686": 0, "1687": 0, "1688": 0, "1691": 0, "1692": 0, "1695": 0, "1696": 0, "1697": 0, "1698": 0, "1700": 0, "1701": 0, "1702": 0, "1703": 0, "1704": 0, "1705": 0, "1706": 0, "1707": 0, "1714": 0, "1717": 0, "1720": 9, "1731": 8, "1732": 8, "1733": 0, "1735": 8, "1736": 8, "1737": 0, "1738": 0, "1740": 0, "1742": 8, "1743": 0, "1747": 1, "1750": 0, "1758": 43, "1762": 1, "1763": 1, "1764": 1, "1765": 1, "1766": 1, "1774": 7, "1775": 7, "1778": 1, "1779": 1, "1782": 7, "1783": 7, "1789": 0, "1790": 0, "1797": 7, "1798": 7, "1800": 7, "1801": 7, "1802": 19, "1805": 12, "1806": 12, "1807": 12, "1808": 12, "1809": 12, "1811": 24, "1812": 12, "1813": 7, "1814": 7, "1815": 0, "1816": 0, "1817": 0, "1818": 0, "1821": 0, "1823": 0, "1824": 0, "1825": 0, "1827": 0, "1828": 0, "1839": 10, "1840": 13, "1841": 3, "1842": 0, "1843": 3, "1844": 0, "1845": 0, "1846": 0, "1848": 10, "1849": 0, "1850": 10, "1851": 3, "1853": 7, "1860": 12, "1861": 12, "1862": 12, "1863": 2, "1874": 0, "1875": 0, "1876": 0, "1877": 0, "1878": 0, "1879": 0, "1880": 0, "1882": 0, "1884": 0, "1885": 0, "1886": 0, "1888": 0, "1889": 0, "1890": 0, "1898": 0, "1899": 0, "1901": 0, "1902": 0, "1903": 0, "1904": 0, "1905": 0, "1906": 0, "1913": 1, "1918": 1, "1919": 1, "1920": 0, "1922": 1, "1923": 2, "1924": 1, "1925": 1, "1926": 1, "1927": 1, "1928": 0, "1929": 0, "1930": 0, "1931": 1, "1932": 1, "1933": 1, "1934": 0, "1935": 1, "1936": 0, "1937": 1, "1938": 0, "1942": 7, "1956": 0, "1957": 0, "1959": 0, "1962": 0, "1974": 0, "1975": 0, "1976": 0, "1977": 0, "1978": 0, "1980": 0, "1983": 0, "1986": 0, "1999": 0, "2000": 0, "2001": 0, "2002": 0, "2003": 0, "2004": 0, "2005": 0, "2009": 0, "2013": 8, "2014": 0, "2016": 8, "2017": 8, "2020": 0, "2021": 0, "2028": 9, "2029": 0, "2031": 9, "2032": 9, "2035": 7, "2036": 7, "2037": 7, "2039": 7, "2040": 0, "2041": 0, "2042": 0, "2044": 7, "2045": 7, "2046": 7, "2047": 7, "2048": 7, "2051": 7, "2053": 0, "2054": 0, "2055": 0, "2056": 0, "2057": 0, "2058": 0, "2060": 0, "2061": 7, "2062": 7, "2064": 0, "2066": 7, "2067": 7, "2075": 63, "2076": 0, "2077": 63, "2078": 63, "2079": 0, "2080": 0, "2081": 0, "2084": 0, "2086": 0, "2082": 0, "2090": 167, "2091": 1, "2092": 166, "2093": 165, "2094": 1, "2095": 3, "2096": 2, "2099": 1, "2101": 0, "2097": 1, "2116": 0, "2117": 0, "2118": 0, "2119": 0, "2124": 0, "2127": 0, "2128": 0, "2129": 0, "2130": 0, "2131": 0, "2132": 0, "2133": 0, "2135": 0, "2137": 0, "2138": 0, "2139": 0, "2140": 0, "2141": 0, "2142": 0, "2143": 0, "2144": 0, "2145": 0, "2146": 0, "2153": 0, "2154": 0, "2155": 0, "2156": 0, "2157": 0, "2158": 0, "2159": 0, "2160": 0, "2161": 0, "2166": 0, "2167": 0, "2170": 0, "2171": 0, "2172": 0, "2173": 0, "2174": 0, "2175": 0, "2125": 0, "2191": 20, "2192": 0, "2193": 20, "2204": 36, "2205": 36, "2206": 0, "2207": 36, "2215": 0, "2216": 0, "2218": 0, "2226": 0, "2235": 1, "2250": 1, "2257": 1, "2236": 25, "2237": 25, "2238": 25, "2239": 0, "2240": 0, "2242": 0, "2244": 25, "2245": 25, "2248": 25, "2255": 32, "2264": 25, "2265": 25, "2268": 55, "2279": 30, "2280": 0, "2291": 30, "2292": 0, "2293": 30, "2309": 25, "2310": 25, "2311": 25}}
{"/testbed/django/db/models/sql/compiler.py": {"1": 1, "2": 1, "3": 1, "4": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "14": 1, "15": 1, "16": 1, "17": 1, "18": 1, "20": 1, "23": 2, "1158": 2, "1349": 2, "1365": 2, "1493": 2, "1513": 1, "24": 1, "40": 1, "46": 1, "60": 1, "138": 1, "184": 1, "254": 1, "378": 1, "388": 1, "405": 1, "415": 1, "470": 1, "632": 1, "676": 1, "701": 1, "731": 1, "744": 1, "779": 1, "953": 1, "1012": 1, "1022": 1, "1032": 1, "1043": 1, "1044": 1, "1057": 1, "1067": 1, "1134": 1, "1147": 1, "25": 47, "26": 47, "27": 47, "28": 47, "33": 47, "34": 47, "35": 47, "37": 47, "38": 47, "41": 60, "42": 5, "43": 30, "44": 30, "52": 30, "53": 30, "54": 30, "55": 30, "56": 30, "57": 30, "58": 30, "97": 30, "98": 30, "99": 0, "100": 0, "106": 0, "107": 0, "108": 0, "110": 0, "114": 0, "115": 0, "116": 0, "117": 0, "118": 0, "121": 0, "122": 0, "123": 0, "124": 0, "125": 0, "126": 0, "127": 0, "128": 0, "130": 0, "131": 0, "132": 0, "133": 0, "134": 0, "135": 0, "136": 0, "143": 0, "145": 0, "146": 0, "149": 0, "150": 0, "151": 0, "152": 0, "156": 0, "157": 0, "158": 0, "161": 0, "162": 0, "167": 0, "174": 0, "175": 0, "178": 0, "180": 0, "182": 0, "159": 0, "163": 0, "164": 0, "176": 0, "202": 30, "203": 30, "204": 30, "205": 30, "206": 31, "207": 1, "208": 1, "209": 1, "210": 30, "211": 30, "212": 21, "216": 9, "217": 30, "218": 29, "219": 112, "220": 83, "221": 83, "222": 83, "224": 29, "225": 29, "227": 30, "228": 0, "229": 0, "230": 0, "232": 30, "233": 0, "234": 0, "236": 0, "242": 0, "244": 30, "245": 114, "246": 84, "247": 84, "248": 0, "250": 0, "251": 84, "252": 30, "237": 0, "238": 0, "239": 0, "240": 0, "241": 0, "263": 32, "264": 0, "265": 32, "266": 9, "267": 23, "268": 2, "269": 21, "270": 5, "271": 5, "273": 16, "274": 32, "275": 32, "277": 0, "279": 32, "280": 50, "281": 18, "282": 0, "284": 0, "285": 0, "286": 0, "287": 0, "288": 0, "289": 0, "290": 0, "291": 0, "292": 18, "293": 0, "294": 0, "296": 18, "297": 18, "299": 18, "301": 0, "302": 0, "303": 0, "304": 0, "305": 18, "308": 0, "309": 0, "311": 0, "312": 0, "313": 0, "315": 18, "318": 0, "319": 0, "320": 0, "321": 0, "322": 0, "323": 0, "324": 0, "326": 18, "329": 18, "330": 18, "332": 0, "333": 0, "334": 0, "335": 0, "337": 0, "338": 0, "339": 0, "340": 32, "341": 32, "343": 50, "344": 18, "345": 18, "346": 1, "350": 2, "351": 1, "352": 0, "353": 1, "354": 0, "355": 1, "356": 0, "357": 0, "359": 1, "360": 0, "363": 1, "364": 1, "365": 18, "370": 18, "371": 18, "372": 18, "373": 0, "374": 18, "375": 18, "376": 32, "379": 30, "380": 30, "381": 0, "382": 0, "383": 0, "384": 0, "385": 0, "386": 30, "394": 311, "395": 179, "396": 132, "397": 132, "398": 132, "399": 0, "400": 0, "401": 132, "402": 132, "403": 132, "406": 248, "407": 248, "408": 18, "410": 230, "411": 248, "412": 84, "413": 164, "416": 1, "418": 4, "419": 3, "421": 1, "422": 3, "423": 2, "424": 0, "425": 2, "426": 0, "427": 1, "428": 3, "429": 2, "433": 2, "434": 0, "435": 0, "436": 0, "437": 0, "438": 0, "440": 2, "441": 2, "444": 0, "445": 0, "448": 0, "449": 0, "450": 2, "451": 0, "454": 0, "455": 0, "456": 0, "457": 1, "458": 0, "459": 1, "460": 1, "461": 0, "462": 1, "463": 4, "464": 1, "465": 1, "466": 3, "467": 2, "468": 1, "478": 30, "479": 30, "480": 30, "481": 30, "483": 30, "484": 30, "485": 30, "486": 30, "487": 1, "488": 0, "489": 1, "491": 29, "494": 29, "495": 29, "496": 29, "497": 29, "498": 29, "500": 29, "501": 0, "502": 0, "503": 0, "505": 0, "506": 0, "508": 29, "509": 29, "510": 112, "511": 83, "512": 1, "513": 82, "514": 0, "515": 0, "516": 83, "517": 83, "519": 29, "520": 29, "522": 29, "523": 0, "524": 0, "526": 0, "527": 0, "528": 0, "531": 0, "532": 0, "533": 0, "537": 0, "538": 0, "539": 0, "540": 0, "541": 0, "542": 0, "543": 0, "544": 0, "545": 0, "546": 0, "549": 29, "550": 0, "552": 29, "553": 24, "554": 24, "556": 29, "557": 29, "558": 0, "559": 0, "560": 29, "561": 0, "562": 0, "563": 0, "564": 0, "565": 0, "568": 0, "569": 0, "571": 0, "572": 0, "574": 0, "575": 0, "577": 29, "578": 0, "579": 0, "581": 30, "582": 0, "583": 0, "584": 0, "587": 30, "588": 8, "589": 26, "590": 18, "591": 18, "592": 8, "594": 30, "595": 8, "597": 30, "598": 0, "600": 30, "607": 0, "608": 0, "609": 0, "610": 0, "611": 0, "612": 0, "613": 0, "614": 0, "615": 0, "618": 0, "619": 0, "620": 0, "621": 0, "622": 0, "623": 0, "624": 0, "625": 0, "627": 30, "630": 30, "644": 21, "645": 21, "646": 21, "647": 21, "648": 21, "652": 21, "654": 91, "655": 70, "658": 70, "659": 70, "660": 70, "661": 0, "667": 0, "668": 70, "669": 0, "670": 70, "671": 70, "672": 70, "673": 70, "674": 21, "683": 29, "684": 29, "685": 29, "687": 29, "688": 0, "689": 0, "690": 0, "691": 0, "692": 0, "693": 0, "695": 0, "696": 0, "697": 0, "698": 29, "707": 18, "708": 18, "709": 18, "710": 18, "715": 18, "717": 0, "718": 0, "719": 0, "720": 0, "721": 0, "723": 0, "724": 0, "725": 0, "726": 0, "727": 0, "728": 18, "729": 54, "739": 18, "740": 18, "741": 18, "742": 18, "755": 29, "756": 29, "757": 63, "758": 34, "759": 0, "760": 34, "761": 34, "762": 0, "765": 0, "766": 34, "767": 34, "768": 34, "769": 29, "770": 0, "774": 0, "775": 0, "776": 29, "786": 0, "794": 0, "795": 0, "797": 0, "799": 0, "800": 0, "801": 0, "802": 0, "806": 0, "807": 0, "808": 0, "809": 0, "810": 0, "812": 0, "815": 0, "816": 0, "817": 0, "819": 0, "820": 0, "821": 0, "824": 0, "825": 0, "826": 0, "828": 0, "829": 0, "833": 0, "835": 0, "836": 0, "837": 0, "839": 0, "840": 0, "841": 0, "842": 0, "843": 0, "844": 0, "846": 0, "847": 0, "848": 0, "849": 0, "850": 0, "851": 0, "852": 0, "853": 0, "854": 0, "855": 0, "856": 0, "857": 0, "858": 0, "860": 0, "862": 0, "863": 0, "866": 0, "867": 0, "868": 0, "869": 0, "871": 0, "872": 0, "874": 0, "875": 0, "876": 0, "878": 0, "879": 0, "880": 0, "881": 0, "882": 0, "883": 0, "885": 0, "886": 0, "887": 0, "888": 0, "889": 0, "890": 0, "891": 0, "892": 0, "893": 0, "894": 0, "895": 0, "896": 0, "897": 0, "898": 0, "900": 0, "901": 0, "902": 0, "903": 0, "904": 0, "905": 0, "906": 0, "907": 0, "909": 0, "914": 0, "917": 0, "918": 0, "919": 0, "920": 0, "921": 0, "922": 0, "924": 0, "925": 0, "926": 0, "927": 0, "928": 0, "930": 0, "931": 0, "932": 0, "933": 0, "934": 0, "935": 0, "936": 0, "937": 0, "938": 0, "940": 0, "941": 0, "942": 0, "943": 0, "944": 0, "945": 0, "947": 0, "948": 0, "951": 0, "787": 0, "789": 0, "790": 0, "792": 0, "813": 0, "864": 0, "911": 0, "912": 0, "915": 0, "958": 0, "976": 0, "977": 0, "978": 0, "979": 0, "980": 0, "981": 0, "982": 0, "983": 0, "984": 0, "985": 0, "986": 0, "987": 0, "988": 0, "990": 0, "991": 0, "992": 0, "993": 0, "994": 0, "995": 0, "996": 0, "997": 0, "998": 0, "1000": 0, "1001": 0, "1002": 0, "1003": 0, "1006": 0, "1007": 0, "1010": 0, "960": 0, "961": 0, "962": 0, "963": 0, "964": 0, "965": 0, "967": 0, "968": 0, "969": 0, "970": 0, "971": 0, "972": 0, "973": 0, "974": 0, "1018": 21, "1019": 21, "1020": 21, "1023": 26, "1024": 106, "1025": 80, "1026": 80, "1027": 80, "1028": 80, "1029": 3, "1030": 26, "1033": 3, "1034": 3, "1035": 13, "1036": 20, "1037": 10, "1038": 20, "1039": 10, "1040": 10, "1041": 10, "1046": 27, "1047": 6, "1048": 132, "1049": 26, "1050": 26, "1051": 26, "1052": 3, "1053": 3, "1054": 0, "1055": 26, "1063": 1, "1064": 1, "1065": 1, "1080": 29, "1081": 29, "1082": 29, "1083": 29, "1084": 0, "1085": 0, "1086": 0, "1087": 0, "1089": 0, "1090": 29, "1091": 2, "1093": 27, "1094": 29, "1095": 29, "1096": 1, "1098": 1, "1099": 1, "1101": 28, "1103": 1, "1104": 27, "1105": 1, "1106": 1, "1107": 1, "1108": 0, "1109": 1, "1112": 1, "1113": 26, "1114": 0, "1115": 0, "1117": 26, "1118": 26, "1119": 26, "1120": 26, "1122": 26, "1123": 24, "1128": 24, "1131": 24, "1132": 2, "1135": 0, "1136": 0, "1138": 0, "1139": 0, "1140": 0, "1141": 0, "1142": 0, "1144": 0, "1145": 0, "1148": 0, "1151": 0, "1152": 0, "1153": 0, "1155": 0, "1159": 1, "1161": 1, "1193": 1, "1222": 1, "1231": 1, "1266": 1, "1328": 1, "1170": 116, "1172": 0, "1173": 116, "1175": 0, "1176": 116, "1179": 0, "1182": 116, "1189": 116, "1191": 116, "1198": 116, "1199": 0, "1203": 0, "1204": 0, "1205": 0, "1206": 0, "1208": 0, "1209": 0, "1210": 0, "1211": 0, "1213": 0, "1214": 0, "1215": 0, "1216": 0, "1219": 116, "1220": 116, "1227": 116, "1228": 0, "1229": 116, "1243": 16, "1244": 0, "1249": 230, "1250": 57, "1255": 73, "1259": 16, "1262": 346, "1264": 16, "1269": 16, "1270": 16, "1271": 16, "1272": 16, "1273": 16, "1274": 75, "1276": 16, "1278": 230, "1279": 57, "1283": 0, "1284": 0, "1290": 16, "1292": 16, "1294": 16, "1295": 16, "1297": 16, "1298": 0, "1299": 0, "1300": 0, "1302": 0, "1303": 0, "1304": 0, "1305": 0, "1306": 0, "1307": 0, "1310": 0, "1311": 0, "1312": 0, "1313": 0, "1315": 16, "1316": 11, "1317": 11, "1318": 0, "1319": 159, "1321": 5, "1322": 0, "1324": 15, "1325": 10, "1330": 16, "1331": 0, "1333": 16, "1334": 16, "1335": 32, "1336": 16, "1337": 16, "1338": 11, "1339": 5, "1340": 0, "1341": 5, "1342": 0, "1343": 0, "1344": 5, "1345": 5, "1350": 1, "1355": 0, "1356": 0, "1357": 0, "1358": 0, "1359": 0, "1360": 0, "1361": 0, "1362": 0, "1366": 1, "1429": 1, "1450": 1, "1371": 1, "1372": 1, "1373": 0, "1374": 1, "1375": 1, "1376": 3, "1377": 2, "1378": 0, "1379": 0, "1380": 0, "1381": 0, "1382": 0, "1384": 0, "1385": 0, "1386": 0, "1387": 0, "1389": 2, "1390": 0, "1391": 0, "1392": 0, "1393": 0, "1396": 0, "1397": 0, "1399": 0, "1402": 2, "1405": 2, "1406": 0, "1408": 2, "1409": 2, "1410": 2, "1411": 0, "1412": 0, "1413": 0, "1414": 2, "1415": 2, "1416": 2, "1418": 0, "1419": 1, "1421": 1, "1422": 1, "1424": 1, "1425": 1, "1426": 1, "1427": 1, "1436": 1, "1437": 1, "1438": 1, "1439": 1, "1441": 1, "1442": 1, "1443": 1, "1444": 0, "1445": 0, "1446": 0, "1447": 0, "1448": 1, "1459": 1, "1461": 1, "1462": 1, "1463": 1, "1464": 1, "1465": 0, "1466": 0, "1467": 0, "1468": 0, "1469": 0, "1470": 0, "1471": 0, "1473": 0, "1477": 0, "1478": 0, "1482": 0, "1483": 0, "1484": 0, "1485": 0, "1486": 0, "1489": 0, "1490": 0, "1494": 1, "1499": 0, "1500": 0, "1501": 0, "1502": 0, "1503": 0, "1504": 0, "1505": 0, "1506": 0, "1508": 0, "1509": 0, "1510": 0, "1518": 26, "1519": 82, "1520": 15, "1522": 26}}
+ git checkout 14d026cccb144c6877294ba4cd4e03ebf0842498
Note: switching to '14d026cccb144c6877294ba4cd4e03ebf0842498'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 14d026cccb Fixed #30572 -- Prevented values()/values_list() on combined queryset from mutating the list of columns in querysets.
M	django/db/models/sql/compiler.py
M	django/db/models/sql/query.py
+ git apply /root/pre_state.patch
error: unrecognized input
