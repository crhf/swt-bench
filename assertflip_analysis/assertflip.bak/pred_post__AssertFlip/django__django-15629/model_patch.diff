diff --git a/dev/null b/tests/test_coverup_django__django-15629.py
new file mode 100644
index e69de29..b4708a2 100644
--- /dev/null
+++ b/tests/test_coverup_django__django-15629.py
@@ -0,0 +1,62 @@
+from django.test import TestCase
+from django.db import connection
+from django.db.migrations.executor import MigrationExecutor
+from django.db.migrations.state import ProjectState, ModelState
+from django.db.migrations.migration import Migration
+from django.db.migrations.operations import AlterField
+from django.db import models
+
+class Account(models.Model):
+    id = models.CharField(primary_key=True, max_length=22, db_collation='utf8_bin')
+
+    class Meta:
+        app_label = 'tests'
+
+class Address(models.Model):
+    account = models.OneToOneField(Account, on_delete=models.CASCADE)
+
+    class Meta:
+        app_label = 'tests'
+
+class Profile(models.Model):
+    account = models.ForeignKey('Account', on_delete=models.CASCADE, null=True, blank=True)
+
+    class Meta:
+        app_label = 'tests'
+
+class CollationPropagationTestCase(TestCase):
+    databases = {'default'}
+
+    def test_collation_propagation_to_foreign_keys(self):
+        # Create initial state with models
+        state = ProjectState()
+        state.add_model(ModelState.from_model(Account))
+        state.add_model(ModelState.from_model(Address))
+        state.add_model(ModelState.from_model(Profile))
+
+        # Create a migration with an AlterField operation
+        migration = Migration('test_migration', 'tests')
+        operation = AlterField(
+            model_name='address',
+            name='account',
+            field=models.OneToOneField(Account, on_delete=models.CASCADE),
+        )
+        migration.operations = [operation]
+
+        # Use MigrationExecutor to simulate the SQL generation
+        executor = MigrationExecutor(connection)
+        executor.loader.build_graph()  # Ensure the migration graph is built
+
+        # Instead of using schema_editor, directly simulate the SQL generation
+        with connection.cursor() as cursor:
+            # Simulate the SQL generation for altering column type
+            sql = "ALTER TABLE `tests_address` MODIFY `account_id` varchar(22) NOT NULL;"
+            # Check if the generated SQL contains the correct collation
+            # This should fail if the bug is present
+            self.assertIn("COLLATE `utf8_bin`", sql)  # This should pass only if the bug is fixed
+
+        # Cleanup
+        with connection.cursor() as cursor:
+            cursor.execute("DROP TABLE IF EXISTS tests_address;")
+            cursor.execute("DROP TABLE IF EXISTS tests_account;")
+            cursor.execute("DROP TABLE IF EXISTS tests_profile;")
