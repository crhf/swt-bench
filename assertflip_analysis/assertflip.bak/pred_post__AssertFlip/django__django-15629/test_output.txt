+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 694cf458f16b8d340a3195244196980b2dec34fd
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 694cf458f16b8d340a3195244196980b2dec34fd
Author: Tim Graham <timograham@gmail.com>
Date:   Sun May 1 21:44:04 2022 -0400

    Removed 'tests' path prefix in a couple tests.

diff --git a/tests/i18n/tests.py b/tests/i18n/tests.py
index a25f6bcd9e..0093181f64 100644
--- a/tests/i18n/tests.py
+++ b/tests/i18n/tests.py
@@ -2358,7 +2358,7 @@ class WatchForTranslationChangesTests(SimpleTestCase):
 
     def test_i18n_app_dirs(self):
         mocked_sender = mock.MagicMock()
-        with self.settings(INSTALLED_APPS=["tests.i18n.sampleproject"]):
+        with self.settings(INSTALLED_APPS=["i18n.sampleproject"]):
             watch_for_translation_changes(mocked_sender)
         project_dir = Path(__file__).parent / "sampleproject" / "locale"
         mocked_sender.watch_dir.assert_any_call(project_dir, "**/*.mo")
diff --git a/tests/sessions_tests/tests.py b/tests/sessions_tests/tests.py
index cac0e9bdc6..96f8dbcd5b 100644
--- a/tests/sessions_tests/tests.py
+++ b/tests/sessions_tests/tests.py
@@ -915,9 +915,9 @@ class CookieSessionTests(SessionTestsMixin, SimpleTestCase):
 class ClearSessionsCommandTests(SimpleTestCase):
     def test_clearsessions_unsupported(self):
         msg = (
-            "Session engine 'tests.sessions_tests.no_clear_expired' doesn't "
+            "Session engine 'sessions_tests.no_clear_expired' doesn't "
             "support clearing expired sessions."
         )
-        with self.settings(SESSION_ENGINE="tests.sessions_tests.no_clear_expired"):
+        with self.settings(SESSION_ENGINE="sessions_tests.no_clear_expired"):
             with self.assertRaisesMessage(management.CommandError, msg):
                 management.call_command("clearsessions")
diff --git a/tests/test_client/tests.py b/tests/test_client/tests.py
index f13b05f25b..ddc063f33d 100644
--- a/tests/test_client/tests.py
+++ b/tests/test_client/tests.py
@@ -44,7 +44,7 @@ from .views import TwoArgException, get_view, post_view, trace_view
 
 def middleware_urlconf(get_response):
     def middleware(request):
-        request.urlconf = "tests.test_client.urls_middleware_urlconf"
+        request.urlconf = "test_client.urls_middleware_urlconf"
         return get_response(request)
 
     return middleware
@@ -53,7 +53,7 @@ def middleware_urlconf(get_response):
 @async_only_middleware
 def async_middleware_urlconf(get_response):
     async def middleware(request):
-        request.urlconf = "tests.test_client.urls_middleware_urlconf"
+        request.urlconf = "test_client.urls_middleware_urlconf"
         return await get_response(request)
 
     return middleware
+ git diff 694cf458f16b8d340a3195244196980b2dec34fd
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: asgiref>=3.4.1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.1.dev20220502042118) (3.9.1)
Requirement already satisfied: sqlparse>=0.2.2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Django==4.1.dev20220502042118) (0.5.3)
Requirement already satisfied: typing_extensions>=4 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from asgiref>=3.4.1->Django==4.1.dev20220502042118) (4.14.1)
Building wheels for collected packages: Django
  Building editable for Django (pyproject.toml): started
  Building editable for Django (pyproject.toml): finished with status 'done'
  Created wheel for Django: filename=django-4.1.dev20220502042118-0.editable-py3-none-any.whl size=27021 sha256=52967f155210df414b5482a55892beabd6288992e4e5ce51d3492e7fc6d3a3e8
  Stored in directory: /tmp/pip-ephem-wheel-cache-i2h6c_b6/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4
Successfully built Django
Installing collected packages: Django
  Attempting uninstall: Django
    Found existing installation: Django 4.1.dev20220502042118
    Uninstalling Django-4.1.dev20220502042118:
      Successfully uninstalled Django-4.1.dev20220502042118
Successfully installed Django-4.1.dev20220502042118
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git apply -v -
Checking patch django/db/backends/base/schema.py...
Checking patch django/db/backends/oracle/features.py...
Checking patch django/db/backends/sqlite3/schema.py...
Checking patch django/db/models/fields/related.py...
Applied patch django/db/backends/base/schema.py cleanly.
Applied patch django/db/backends/oracle/features.py cleanly.
Applied patch django/db/backends/sqlite3/schema.py cleanly.
Applied patch django/db/models/fields/related.py cleanly.
+ git apply -v -
Checking patch tests/test_coverup_django__django-15629.py...
Applied patch tests/test_coverup_django__django-15629.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(django/db/models/fields/related\.py|django/db/backends/sqlite3/schema\.py|django/db/backends/oracle/features\.py|django/db/backends/base/schema\.py)' ./tests/runtests.py --verbosity 2 --settings=test_sqlite --parallel 1 test_coverup_django__django-15629
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(django/db/models/fields/related\\.py|django/db/backends/sqlite3/schema\\.py|django/db/backends/oracle/features\\.py|django/db/backends/base/schema\\.py)']
0.31 related.py(1): import functools
0.31 related.py(2): import inspect
0.31 related.py(3): from functools import partial
0.31 related.py(5): from django import forms
0.31 related.py(6): from django.apps import apps
0.31 related.py(7): from django.conf import SettingsReference, settings
0.31 related.py(8): from django.core import checks, exceptions
0.31 related.py(9): from django.db import connection, router
0.31 related.py(10): from django.db.backends import utils
0.31 related.py(11): from django.db.models import Q
0.31 related.py(12): from django.db.models.constants import LOOKUP_SEP
0.31 related.py(13): from django.db.models.deletion import CASCADE, SET_DEFAULT, SET_NULL
0.31 related.py(14): from django.db.models.query_utils import PathInfo
0.31 related.py(15): from django.db.models.utils import make_model_tuple
0.31 related.py(16): from django.utils.functional import cached_property
0.31 related.py(17): from django.utils.translation import gettext_lazy as _
0.31 related.py(19): from . import Field
0.31 related.py(20): from .mixins import FieldCacheMixin
0.31 related.py(21): from .related_descriptors import (
0.31 related.py(29): from .related_lookups import (
0.31 related.py(38): from .reverse_related import ForeignObjectRel, ManyToManyRel, ManyToOneRel, OneToOneRel
0.31 related.py(40): RECURSIVE_RELATIONSHIP_CONSTANT = "self"
0.31 related.py(43): def resolve_relation(scope_model, relation):
0.31 related.py(68): def lazy_related_operation(function, model, *related_models, **kwargs):
0.31 related.py(89): class RelatedField(FieldCacheMixin, Field):
0.31 related.py(89): class RelatedField(FieldCacheMixin, Field):
0.31 related.py(90):     """Base class that all relational fields inherit from."""
0.31 related.py(93):     one_to_many = False
0.31 related.py(94):     one_to_one = False
0.31 related.py(95):     many_to_many = False
0.31 related.py(96):     many_to_one = False
0.31 related.py(98):     def __init__(
0.31 related.py(110):     @cached_property
0.31 related.py(111):     def related_model(self):
0.31 related.py(116):     def check(self, **kwargs):
0.31 related.py(126):     def _check_related_name_is_valid(self):
0.31 related.py(154):     def _check_related_query_name_is_valid(self):
0.31 related.py(187):     def _check_relation_model_exists(self):
0.31 related.py(208):     def _check_referencing_to_swapped_model(self):
0.31 related.py(226):     def _check_clashes(self):
0.31 related.py(341):     def db_type(self, connection):
0.31 related.py(346):     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
0.31 related.py(380):     def deconstruct(self):
0.31 related.py(390):     def get_forward_related_filter(self, obj):
0.31 related.py(403):     def get_reverse_related_filter(self, obj):
0.31 related.py(422):     @property
0.31 related.py(423):     def swappable_setting(self):
0.31 related.py(437):     def set_attributes_from_rel(self):
0.31 related.py(447):     def do_related_class(self, other, cls):
0.31 related.py(451):     def get_limit_choices_to(self):
0.31 related.py(462):     def formfield(self, **kwargs):
0.31 related.py(484):     def related_query_name(self):
0.31 related.py(495):     @property
0.31 related.py(496):     def target_field(self):
0.31 related.py(509):     def get_cache_name(self):
0.31 related.py(513): class ForeignObject(RelatedField):
0.31 related.py(513): class ForeignObject(RelatedField):
0.31 related.py(514):     """
0.31 related.py(519):     many_to_many = False
0.31 related.py(520):     many_to_one = True
0.31 related.py(521):     one_to_many = False
0.31 related.py(522):     one_to_one = False
0.31 related.py(524):     requires_unique_target = True
0.31 related.py(525):     related_accessor_class = ReverseManyToOneDescriptor
0.31 related.py(526):     forward_related_accessor_class = ForwardManyToOneDescriptor
0.31 related.py(527):     rel_class = ForeignObjectRel
0.31 related.py(529):     def __init__(
0.31 related.py(567):     def __copy__(self):
0.31 related.py(574):     def check(self, **kwargs):
0.31 related.py(581):     def _check_to_fields_exist(self):
0.31 related.py(603):     def _check_unique_target(self):
0.31 related.py(671):     def deconstruct(self):
0.31 related.py(706):     def resolve_related_fields(self):
0.31 related.py(732):     @cached_property
0.31 related.py(733):     def related_fields(self):
0.31 related.py(736):     @cached_property
0.31 related.py(737):     def reverse_related_fields(self):
0.31 related.py(740):     @cached_property
0.31 related.py(741):     def local_related_fields(self):
0.31 related.py(744):     @cached_property
0.31 related.py(745):     def foreign_related_fields(self):
0.31 related.py(750):     def get_local_related_value(self, instance):
0.31 related.py(753):     def get_foreign_related_value(self, instance):
0.31 related.py(756):     @staticmethod
0.31 related.py(757):     def get_instance_value_for_fields(instance, fields):
0.31 related.py(776):     def get_attname_column(self):
0.31 related.py(780):     def get_joining_columns(self, reverse_join=False):
0.31 related.py(786):     def get_reverse_joining_columns(self):
0.31 related.py(789):     def get_extra_descriptor_filter(self, instance):
0.31 related.py(804):     def get_extra_restriction(self, alias, related_alias):
0.31 related.py(818):     def get_path_info(self, filtered_relation=None):
0.31 related.py(834):     @cached_property
0.31 related.py(835):     def path_infos(self):
0.31 related.py(838):     def get_reverse_path_info(self, filtered_relation=None):
0.31 related.py(854):     @cached_property
0.31 related.py(855):     def reverse_path_infos(self):
0.31 related.py(858):     @classmethod
0.31 related.py(859):     @functools.lru_cache(maxsize=None)
0.31 related.py(860):     def get_lookups(cls):
0.31 related.py(866):     def contribute_to_class(self, cls, name, private_only=False, **kwargs):
0.31 related.py(870):     def contribute_to_related_class(self, cls, related):
0.31 related.py(891): ForeignObject.register_lookup(RelatedIn)
0.31 related.py(892): ForeignObject.register_lookup(RelatedExact)
0.31 related.py(893): ForeignObject.register_lookup(RelatedLessThan)
0.31 related.py(894): ForeignObject.register_lookup(RelatedGreaterThan)
0.31 related.py(895): ForeignObject.register_lookup(RelatedGreaterThanOrEqual)
0.31 related.py(896): ForeignObject.register_lookup(RelatedLessThanOrEqual)
0.31 related.py(897): ForeignObject.register_lookup(RelatedIsNull)
0.31 related.py(900): class ForeignKey(ForeignObject):
0.31 related.py(900): class ForeignKey(ForeignObject):
0.31 related.py(901):     """
0.31 related.py(909):     descriptor_class = ForeignKeyDeferredAttribute
0.31 related.py(911):     many_to_many = False
0.31 related.py(912):     many_to_one = True
0.31 related.py(913):     one_to_many = False
0.31 related.py(914):     one_to_one = False
0.31 related.py(916):     rel_class = ManyToOneRel
0.31 related.py(918):     empty_strings_allowed = False
0.31 related.py(920):         "invalid": _("%(model)s instance with %(field)s %(value)r does not exist.")
0.31 related.py(919):     default_error_messages = {
0.31 related.py(922):     description = _("Foreign Key (type determined by related field)")
0.31 related.py(924):     def __init__(
0.31 related.py(981):     def __class_getitem__(cls, *args, **kwargs):
0.31 related.py(984):     def check(self, **kwargs):
0.31 related.py(991):     def _check_on_delete(self):
0.31 related.py(1017):     def _check_unique(self, **kwargs):
0.31 related.py(1035):     def deconstruct(self):
0.31 related.py(1055):     def to_python(self, value):
0.31 related.py(1058):     @property
0.31 related.py(1059):     def target_field(self):
0.31 related.py(1062):     def get_reverse_path_info(self, filtered_relation=None):
0.31 related.py(1078):     def validate(self, value, model_instance):
0.31 related.py(1102):     def resolve_related_fields(self):
0.31 related.py(1121):     def get_attname(self):
0.31 related.py(1124):     def get_attname_column(self):
0.31 related.py(1129):     def get_default(self):
0.31 related.py(1136):     def get_db_prep_save(self, value, connection):
0.31 related.py(1148):     def get_db_prep_value(self, value, connection, prepared=False):
0.31 related.py(1151):     def get_prep_value(self, value):
0.31 related.py(1154):     def contribute_to_related_class(self, cls, related):
0.31 related.py(1159):     def formfield(self, *, using=None, **kwargs):
0.31 related.py(1176):     def db_check(self, connection):
0.31 related.py(1179):     def db_type(self, connection):
0.31 related.py(1182):     def db_parameters(self, connection):
0.31 related.py(1190):     def convert_empty_strings(self, value, expression, connection):
0.31 related.py(1195):     def get_db_converters(self, connection):
0.31 related.py(1201):     def get_col(self, alias, output_field=None):
0.31 related.py(1211): class OneToOneField(ForeignKey):
0.31 related.py(1211): class OneToOneField(ForeignKey):
0.31 related.py(1212):     """
0.31 related.py(1220):     many_to_many = False
0.31 related.py(1221):     many_to_one = False
0.31 related.py(1222):     one_to_many = False
0.31 related.py(1223):     one_to_one = True
0.31 related.py(1225):     related_accessor_class = ReverseOneToOneDescriptor
0.31 related.py(1226):     forward_related_accessor_class = ForwardOneToOneDescriptor
0.31 related.py(1227):     rel_class = OneToOneRel
0.31 related.py(1229):     description = _("One-to-one relationship")
0.31 related.py(1231):     def __init__(self, to, on_delete, to_field=None, **kwargs):
0.31 related.py(1235):     def deconstruct(self):
0.31 related.py(1241):     def formfield(self, **kwargs):
0.31 related.py(1246):     def save_form_data(self, instance, data):
0.31 related.py(1256):     def _check_unique(self, **kwargs):
0.31 related.py(1261): def create_many_to_many_intermediary_model(field, klass):
0.31 related.py(1318): class ManyToManyField(RelatedField):
0.31 related.py(1318): class ManyToManyField(RelatedField):
0.31 related.py(1319):     """
0.31 related.py(1329):     many_to_many = True
0.31 related.py(1330):     many_to_one = False
0.31 related.py(1331):     one_to_many = False
0.31 related.py(1332):     one_to_one = False
0.31 related.py(1334):     rel_class = ManyToManyRel
0.31 related.py(1336):     description = _("Many-to-many relationship")
0.31 related.py(1338):     def __init__(
0.31 related.py(1397):     def check(self, **kwargs):
0.31 related.py(1406):     def _check_unique(self, **kwargs):
0.31 related.py(1417):     def _check_ignored_options(self, **kwargs):
0.31 related.py(1449):     def _check_relationship_model(self, from_model=None, **kwargs):
0.31 related.py(1680):     def _check_table_uniqueness(self, **kwargs):
0.31 related.py(1732):     def deconstruct(self):
0.31 related.py(1772):     def _get_path_info(self, direct=False, filtered_relation=None):
0.31 related.py(1803):     def get_path_info(self, filtered_relation=None):
0.31 related.py(1806):     @cached_property
0.31 related.py(1807):     def path_infos(self):
0.31 related.py(1810):     def get_reverse_path_info(self, filtered_relation=None):
0.31 related.py(1813):     @cached_property
0.31 related.py(1814):     def reverse_path_infos(self):
0.31 related.py(1817):     def _get_m2m_db_table(self, opts):
0.31 related.py(1830):     def _get_m2m_attr(self, related, attr):
0.31 related.py(1851):     def _get_m2m_reverse_attr(self, related, attr):
0.31 related.py(1881):     def contribute_to_class(self, cls, name, **kwargs):
0.31 related.py(1930):     def contribute_to_related_class(self, cls, related):
0.31 related.py(1959):     def set_attributes_from_rel(self):
0.31 related.py(1962):     def value_from_object(self, obj):
0.31 related.py(1965):     def save_form_data(self, instance, data):
0.31 related.py(1968):     def formfield(self, *, using=None, **kwargs):
0.31 related.py(1983):     def db_check(self, connection):
0.31 related.py(1986):     def db_type(self, connection):
0.31 related.py(1991):     def db_parameters(self, connection):
Testing against Django installed in '/testbed/django'
0.54 schema.py(1): import copy
0.54 schema.py(2): from decimal import Decimal
0.54 schema.py(4): from django.apps.registry import Apps
0.54 schema.py(5): from django.db import NotSupportedError
0.54 schema.py(6): from django.db.backends.base.schema import BaseDatabaseSchemaEditor
0.54 schema.py(1): import logging
0.54 schema.py(2): from datetime import datetime
0.54 schema.py(4): from django.db.backends.ddl_references import (
0.55 schema.py(12): from django.db.backends.utils import names_digest, split_identifier
0.55 schema.py(13): from django.db.models import Deferrable, Index
0.55 schema.py(14): from django.db.models.sql import Query
0.55 schema.py(15): from django.db.transaction import TransactionManagementError, atomic
0.55 schema.py(16): from django.utils import timezone
0.55 schema.py(18): logger = logging.getLogger("django.db.backends.schema")
0.55 schema.py(21): def _is_relevant_relation(relation, altered_field):
0.55 schema.py(37): def _all_related_fields(model):
0.55 schema.py(46): def _related_non_m2m_objects(old_field, new_field):
0.55 schema.py(69): class BaseDatabaseSchemaEditor:
0.55 schema.py(69): class BaseDatabaseSchemaEditor:
0.55 schema.py(70):     """
0.55 schema.py(77):     sql_create_table = "CREATE TABLE %(table)s (%(definition)s)"
0.55 schema.py(78):     sql_rename_table = "ALTER TABLE %(old_table)s RENAME TO %(new_table)s"
0.55 schema.py(79):     sql_retablespace_table = "ALTER TABLE %(table)s SET TABLESPACE %(new_tablespace)s"
0.55 schema.py(80):     sql_delete_table = "DROP TABLE %(table)s CASCADE"
0.55 schema.py(82):     sql_create_column = "ALTER TABLE %(table)s ADD COLUMN %(column)s %(definition)s"
0.55 schema.py(83):     sql_alter_column = "ALTER TABLE %(table)s %(changes)s"
0.55 schema.py(84):     sql_alter_column_type = "ALTER COLUMN %(column)s TYPE %(type)s"
0.55 schema.py(85):     sql_alter_column_null = "ALTER COLUMN %(column)s DROP NOT NULL"
0.55 schema.py(86):     sql_alter_column_not_null = "ALTER COLUMN %(column)s SET NOT NULL"
0.55 schema.py(87):     sql_alter_column_default = "ALTER COLUMN %(column)s SET DEFAULT %(default)s"
0.55 schema.py(88):     sql_alter_column_no_default = "ALTER COLUMN %(column)s DROP DEFAULT"
0.55 schema.py(89):     sql_alter_column_no_default_null = sql_alter_column_no_default
0.55 schema.py(90):     sql_alter_column_collate = "ALTER COLUMN %(column)s TYPE %(type)s%(collation)s"
0.55 schema.py(91):     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s CASCADE"
0.55 schema.py(93):         "ALTER TABLE %(table)s RENAME COLUMN %(old_column)s TO %(new_column)s"
0.55 schema.py(92):     sql_rename_column = (
0.55 schema.py(96):         "UPDATE %(table)s SET %(column)s = %(default)s WHERE %(column)s IS NULL"
0.55 schema.py(95):     sql_update_with_default = (
0.55 schema.py(99):     sql_unique_constraint = "UNIQUE (%(columns)s)%(deferrable)s"
0.55 schema.py(100):     sql_check_constraint = "CHECK (%(check)s)"
0.55 schema.py(101):     sql_delete_constraint = "ALTER TABLE %(table)s DROP CONSTRAINT %(name)s"
0.55 schema.py(102):     sql_constraint = "CONSTRAINT %(name)s %(constraint)s"
0.55 schema.py(104):     sql_create_check = "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s CHECK (%(check)s)"
0.55 schema.py(105):     sql_delete_check = sql_delete_constraint
0.55 schema.py(108):         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s "
0.55 schema.py(107):     sql_create_unique = (
0.55 schema.py(111):     sql_delete_unique = sql_delete_constraint
0.55 schema.py(114):         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s FOREIGN KEY (%(column)s) "
0.55 schema.py(113):     sql_create_fk = (
0.55 schema.py(117):     sql_create_inline_fk = None
0.55 schema.py(118):     sql_create_column_inline_fk = None
0.55 schema.py(119):     sql_delete_fk = sql_delete_constraint
0.55 schema.py(122):         "CREATE INDEX %(name)s ON %(table)s "
0.55 schema.py(121):     sql_create_index = (
0.55 schema.py(126):         "CREATE UNIQUE INDEX %(name)s ON %(table)s "
0.55 schema.py(125):     sql_create_unique_index = (
0.55 schema.py(129):     sql_delete_index = "DROP INDEX %(name)s"
0.55 schema.py(132):         "ALTER TABLE %(table)s ADD CONSTRAINT %(name)s PRIMARY KEY (%(columns)s)"
0.55 schema.py(131):     sql_create_pk = (
0.55 schema.py(134):     sql_delete_pk = sql_delete_constraint
0.55 schema.py(136):     sql_delete_procedure = "DROP PROCEDURE %(procedure)s"
0.55 schema.py(138):     def __init__(self, connection, collect_sql=False, atomic=True):
0.55 schema.py(147):     def __enter__(self):
0.55 schema.py(154):     def __exit__(self, exc_type, exc_value, traceback):
0.55 schema.py(163):     def execute(self, sql, params=()):
0.55 schema.py(194):     def quote_name(self, name):
0.55 schema.py(197):     def table_sql(self, model):
0.55 schema.py(278):     def _iter_column_sql(
0.55 schema.py(333):     def column_sql(self, model, field, include_default=False):
0.55 schema.py(360):     def skip_default(self, field):
0.55 schema.py(367):     def skip_default_on_alter(self, field):
0.55 schema.py(374):     def prepare_default(self, value):
0.55 schema.py(383):     def _column_default_sql(self, field):
0.55 schema.py(390):     @staticmethod
0.55 schema.py(391):     def _effective_default(field):
0.55 schema.py(414):     def effective_default(self, field):
0.55 schema.py(418):     def quote_value(self, value):
0.55 schema.py(430):     def create_model(self, model):
0.55 schema.py(449):     def delete_model(self, model):
0.55 schema.py(470):     def add_index(self, model, index):
0.55 schema.py(481):     def remove_index(self, model, index):
0.55 schema.py(490):     def add_constraint(self, model, constraint):
0.55 schema.py(498):     def remove_constraint(self, model, constraint):
0.55 schema.py(504):     def alter_unique_together(self, model, old_unique_together, new_unique_together):
0.55 schema.py(522):     def alter_index_together(self, model, old_index_together, new_index_together):
0.55 schema.py(543):     def _delete_composed_index(self, model, fields, constraint_kwargs, sql):
0.55 schema.py(566):     def alter_db_table(self, model, old_db_table, new_db_table):
0.55 schema.py(585):     def alter_db_tablespace(self, model, old_db_tablespace, new_db_tablespace):
0.55 schema.py(596):     def add_field(self, model, field):
0.55 schema.py(668):     def remove_field(self, model, field):
0.55 schema.py(700):     def alter_field(self, model, old_field, new_field, strict=False):
0.55 schema.py(764):     def _alter_field(
0.55 schema.py(1109):     def _alter_column_null_sql(self, model, old_field, new_field):
0.55 schema.py(1138):     def _alter_column_default_sql(self, model, old_field, new_field, drop=False):
0.55 schema.py(1176):     def _alter_column_type_sql(self, model, old_field, new_field, new_type):
0.55 schema.py(1198):     def _alter_column_collation_sql(self, model, new_field, new_type, new_collation):
0.55 schema.py(1211):     def _alter_many_to_many(self, model, old_field, new_field, strict):
0.55 schema.py(1243):     def _create_index_name(self, table_name, column_names, suffix=""):
0.55 schema.py(1275):     def _get_index_tablespace_sql(self, model, fields, db_tablespace=None):
0.55 schema.py(1285):     def _index_condition_sql(self, condition):
0.55 schema.py(1290):     def _index_include_sql(self, model, columns):
0.55 schema.py(1302):         fields=None,
0.55 schema.py(1303):         name=None,
0.55 schema.py(1304):         suffix="",
0.55 schema.py(1305):         using="",
0.55 schema.py(1306):         db_tablespace=None,
0.55 schema.py(1307):         col_suffixes=(),
0.55 schema.py(1308):         sql=None,
0.55 schema.py(1309):         opclasses=(),
0.55 schema.py(1310):         condition=None,
0.55 schema.py(1311):         include=None,
0.55 schema.py(1312):         expressions=None,
0.55 schema.py(1298):     def _create_index_sql(
0.55 schema.py(1352):     def _delete_index_sql(self, model, name, sql=None):
0.55 schema.py(1359):     def _index_columns(self, table, columns, col_suffixes, opclasses):
0.55 schema.py(1362):     def _model_indexes_sql(self, model):
0.55 schema.py(1385):     def _field_indexes_sql(self, model, field):
0.55 schema.py(1394):     def _field_should_be_altered(self, old_field, new_field):
0.55 schema.py(1409):     def _field_should_be_indexed(self, model, field):
0.55 schema.py(1412):     def _field_became_primary_key(self, old_field, new_field):
0.55 schema.py(1415):     def _unique_should_be_added(self, old_field, new_field):
0.55 schema.py(1422):     def _rename_field_sql(self, table, old_field, new_field, new_type):
0.55 schema.py(1430):     def _create_fk_sql(self, model, field, suffix):
0.55 schema.py(1451):     def _fk_constraint_name(self, model, field, suffix):
0.55 schema.py(1464):     def _delete_fk_sql(self, model, name):
0.55 schema.py(1467):     def _deferrable_constraint_sql(self, deferrable):
0.55 schema.py(1475):     def _unique_sql(
0.55 schema.py(1515):     def _create_unique_sql(
0.55 schema.py(1571):     def _delete_unique_sql(
0.55 schema.py(1599):     def _check_sql(self, name, check):
0.55 schema.py(1605):     def _create_check_sql(self, model, name, check):
0.55 schema.py(1613):     def _delete_check_sql(self, model, name):
0.55 schema.py(1616):     def _delete_constraint_sql(self, template, model, name):
0.55 schema.py(1623):     def _constraint_names(
0.55 schema.py(1664):     def _delete_primary_key(self, model, strict=False):
0.55 schema.py(1677):     def _create_primary_key_sql(self, model, field):
0.55 schema.py(1689):     def _delete_primary_key_sql(self, model, name):
0.55 schema.py(1692):     def _collate_sql(self, collation):
0.55 schema.py(1695):     def remove_procedure(self, procedure_name, param_types=()):
0.55 schema.py(7): from django.db.backends.ddl_references import Statement
0.55 schema.py(8): from django.db.backends.utils import strip_quotes
0.55 schema.py(9): from django.db.models import UniqueConstraint
0.55 schema.py(10): from django.db.transaction import atomic
0.55 schema.py(13): class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
0.55 schema.py(13): class DatabaseSchemaEditor(BaseDatabaseSchemaEditor):
0.55 schema.py(15):     sql_delete_table = "DROP TABLE %(table)s"
0.55 schema.py(16):     sql_create_fk = None
0.55 schema.py(18):         "REFERENCES %(to_table)s (%(to_column)s) DEFERRABLE INITIALLY DEFERRED"
0.55 schema.py(17):     sql_create_inline_fk = (
0.55 schema.py(20):     sql_create_column_inline_fk = sql_create_inline_fk
0.55 schema.py(21):     sql_delete_column = "ALTER TABLE %(table)s DROP COLUMN %(column)s"
0.55 schema.py(22):     sql_create_unique = "CREATE UNIQUE INDEX %(name)s ON %(table)s (%(columns)s)"
0.55 schema.py(23):     sql_delete_unique = "DROP INDEX %(name)s"
0.55 schema.py(25):     def __enter__(self):
0.55 schema.py(38):     def __exit__(self, exc_type, exc_value, traceback):
0.55 schema.py(43):     def quote_value(self, value):
0.55 schema.py(74):     def prepare_default(self, value):
0.55 schema.py(77):     def _is_referenced_by_fk_constraint(
0.55 schema.py(100):     def alter_db_table(
0.55 schema.py(123):     def alter_field(self, model, old_field, new_field, strict=False):
0.55 schema.py(176):     def _remake_table(
0.55 schema.py(362):     def delete_model(self, model, handle_autom2m=True):
0.55 schema.py(380):     def add_field(self, model, field):
0.55 schema.py(398):     def remove_field(self, model, field):
0.55 schema.py(425):     def _alter_field(
0.55 schema.py(484):     def _alter_many_to_many(self, model, old_field, new_field, strict):
0.55 schema.py(536):     def add_constraint(self, model, constraint):
0.55 schema.py(547):     def remove_constraint(self, model, constraint):
0.55 schema.py(558):     def _collate_sql(self, collation):
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(356):                 related_name = self.opts.default_related_name
0.55 related.py(357):             if related_name:
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(443):         if self.verbose_name is None:
0.55 related.py(445):         self.remote_field.set_field_name()
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1155):         super().contribute_to_related_class(cls, related)
0.55 related.py(874):             not self.remote_field.is_hidden()
0.55 related.py(873):         if (
0.55 related.py(875):             and not related.related_model._meta.swapped
0.55 related.py(873):         if (
0.55 related.py(877):             setattr(
0.55 related.py(878):                 cls._meta.concrete_model,
0.55 related.py(879):                 related.get_accessor_name(),
0.55 related.py(880):                 self.related_accessor_class(related),
0.55 related.py(877):             setattr(
0.55 related.py(885):             if self.remote_field.limit_choices_to:
0.55 related.py(1156):         if self.remote_field.field_name is None:
0.55 related.py(1352):         try:
0.55 related.py(1353):             to._meta
0.55 related.py(1366):         if symmetrical is None:
0.55 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.55 related.py(1369):         if through is not None and db_table is not None:
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1375):             self,
0.55 related.py(1376):             to,
0.55 related.py(1377):             related_name=related_name,
0.55 related.py(1378):             related_query_name=related_query_name,
0.55 related.py(1379):             limit_choices_to=limit_choices_to,
0.55 related.py(1380):             symmetrical=symmetrical,
0.55 related.py(1381):             through=through,
0.55 related.py(1382):             through_fields=through_fields,
0.55 related.py(1383):             db_constraint=db_constraint,
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1385):         self.has_null_arg = "null" in kwargs
0.55 related.py(1387):         super().__init__(
0.55 related.py(1388):             related_name=related_name,
0.55 related.py(1389):             related_query_name=related_query_name,
0.55 related.py(1390):             limit_choices_to=limit_choices_to,
0.55 related.py(1387):         super().__init__(
0.55 related.py(1391):             **kwargs,
0.55 related.py(1387):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(1394):         self.db_table = db_table
0.55 related.py(1395):         self.swappable = swappable
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(356):                 related_name = self.opts.default_related_name
0.55 related.py(357):             if related_name:
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1911):             if self.remote_field.through:
0.55 related.py(1919):             elif not cls._meta.swapped:
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1921):                     self, cls
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1262):     from django.db import models
0.55 related.py(1264):     def set_managed(model, related, through):
0.55 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.55 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(62):         if "." not in relation:
0.55 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1271):     to = make_model_tuple(to_model)[1]
0.55 related.py(1272):     from_ = klass._meta.model_name
0.55 related.py(1273):     if to == from_:
0.55 related.py(1277):     meta = type(
0.55 related.py(1278):         "Meta",
0.55 related.py(1279):         (),
0.55 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.55 related.py(1822):         if self.remote_field.through is not None:
0.55 related.py(1824):         elif self.db_table:
0.55 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.55 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.55 related.py(1282):             "auto_created": klass,
0.55 related.py(1283):             "app_label": klass._meta.app_label,
0.55 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.55 related.py(1285):             "unique_together": (from_, to),
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1287):             % {"from": from_, "to": to},
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1289):             % {"from": from_, "to": to},
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1290):             "apps": field.model._meta.apps,
0.55 related.py(1280):         {
0.55 related.py(1277):     meta = type(
0.55 related.py(1294):     return type(
0.55 related.py(1295):         name,
0.55 related.py(1296):         (models.Model,),
0.55 related.py(1298):             "Meta": meta,
0.55 related.py(1299):             "__module__": klass.__module__,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(1301):                 klass,
0.55 related.py(1302):                 related_name="%s+" % name,
0.55 related.py(1303):                 db_tablespace=field.db_tablespace,
0.55 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1305):                 on_delete=CASCADE,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(1308):                 to_model,
0.55 related.py(1309):                 related_name="%s+" % name,
0.55 related.py(1310):                 db_tablespace=field.db_tablespace,
0.55 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1312):                 on_delete=CASCADE,
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1297):         {
0.55 related.py(1294):     return type(
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(443):         if self.verbose_name is None:
0.55 related.py(445):         self.remote_field.set_field_name()
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1155):         super().contribute_to_related_class(cls, related)
0.55 related.py(874):             not self.remote_field.is_hidden()
0.55 related.py(873):         if (
0.55 related.py(1156):         if self.remote_field.field_name is None:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(1960):         pass
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1934):             not self.remote_field.is_hidden()
0.55 related.py(1933):         if (
0.55 related.py(1935):             and not related.related_model._meta.swapped
0.55 related.py(1933):         if (
0.55 related.py(1937):             setattr(
0.55 related.py(1938):                 cls,
0.55 related.py(1939):                 related.get_accessor_name(),
0.55 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.55 related.py(1937):             setattr(
0.55 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.55 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.55 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.55 related.py(1948):         self.m2m_reverse_field_name = partial(
0.55 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.55 related.py(1948):         self.m2m_reverse_field_name = partial(
0.55 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.55 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.55 related.py(1954):         get_m2m_reverse_rel = partial(
0.55 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.55 related.py(1954):         get_m2m_reverse_rel = partial(
0.55 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.55 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(443):         if self.verbose_name is None:
0.55 related.py(445):         self.remote_field.set_field_name()
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1155):         super().contribute_to_related_class(cls, related)
0.55 related.py(874):             not self.remote_field.is_hidden()
0.55 related.py(873):         if (
0.55 related.py(1156):         if self.remote_field.field_name is None:
0.55 related.py(1352):         try:
0.55 related.py(1353):             to._meta
0.55 related.py(1366):         if symmetrical is None:
0.55 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.55 related.py(1369):         if through is not None and db_table is not None:
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1375):             self,
0.55 related.py(1376):             to,
0.55 related.py(1377):             related_name=related_name,
0.55 related.py(1378):             related_query_name=related_query_name,
0.55 related.py(1379):             limit_choices_to=limit_choices_to,
0.55 related.py(1380):             symmetrical=symmetrical,
0.55 related.py(1381):             through=through,
0.55 related.py(1382):             through_fields=through_fields,
0.55 related.py(1383):             db_constraint=db_constraint,
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1385):         self.has_null_arg = "null" in kwargs
0.55 related.py(1387):         super().__init__(
0.55 related.py(1388):             related_name=related_name,
0.55 related.py(1389):             related_query_name=related_query_name,
0.55 related.py(1390):             limit_choices_to=limit_choices_to,
0.55 related.py(1387):         super().__init__(
0.55 related.py(1391):             **kwargs,
0.55 related.py(1387):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(1394):         self.db_table = db_table
0.55 related.py(1395):         self.swappable = swappable
0.55 related.py(1352):         try:
0.55 related.py(1353):             to._meta
0.55 related.py(1366):         if symmetrical is None:
0.55 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.55 related.py(1369):         if through is not None and db_table is not None:
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1375):             self,
0.55 related.py(1376):             to,
0.55 related.py(1377):             related_name=related_name,
0.55 related.py(1378):             related_query_name=related_query_name,
0.55 related.py(1379):             limit_choices_to=limit_choices_to,
0.55 related.py(1380):             symmetrical=symmetrical,
0.55 related.py(1381):             through=through,
0.55 related.py(1382):             through_fields=through_fields,
0.55 related.py(1383):             db_constraint=db_constraint,
0.55 related.py(1374):         kwargs["rel"] = self.rel_class(
0.55 related.py(1385):         self.has_null_arg = "null" in kwargs
0.55 related.py(1387):         super().__init__(
0.55 related.py(1388):             related_name=related_name,
0.55 related.py(1389):             related_query_name=related_query_name,
0.55 related.py(1390):             limit_choices_to=limit_choices_to,
0.55 related.py(1387):         super().__init__(
0.55 related.py(1391):             **kwargs,
0.55 related.py(1387):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(1394):         self.db_table = db_table
0.55 related.py(1395):         self.swappable = swappable
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.55 related.py(367):                     "class": cls.__name__.lower(),
0.55 related.py(368):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.55 related.py(370):                 self.remote_field.related_query_name = related_query_name
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1911):             if self.remote_field.through:
0.55 related.py(1919):             elif not cls._meta.swapped:
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1921):                     self, cls
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1262):     from django.db import models
0.55 related.py(1264):     def set_managed(model, related, through):
0.55 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.55 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(62):         if "." not in relation:
0.55 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1271):     to = make_model_tuple(to_model)[1]
0.55 related.py(1272):     from_ = klass._meta.model_name
0.55 related.py(1273):     if to == from_:
0.55 related.py(1277):     meta = type(
0.55 related.py(1278):         "Meta",
0.55 related.py(1279):         (),
0.55 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.55 related.py(1822):         if self.remote_field.through is not None:
0.55 related.py(1824):         elif self.db_table:
0.55 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.55 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.55 related.py(1282):             "auto_created": klass,
0.55 related.py(1283):             "app_label": klass._meta.app_label,
0.55 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.55 related.py(1285):             "unique_together": (from_, to),
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1287):             % {"from": from_, "to": to},
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1289):             % {"from": from_, "to": to},
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1290):             "apps": field.model._meta.apps,
0.55 related.py(1280):         {
0.55 related.py(1277):     meta = type(
0.55 related.py(1294):     return type(
0.55 related.py(1295):         name,
0.55 related.py(1296):         (models.Model,),
0.55 related.py(1298):             "Meta": meta,
0.55 related.py(1299):             "__module__": klass.__module__,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(1301):                 klass,
0.55 related.py(1302):                 related_name="%s+" % name,
0.55 related.py(1303):                 db_tablespace=field.db_tablespace,
0.55 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1305):                 on_delete=CASCADE,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(1308):                 to_model,
0.55 related.py(1309):                 related_name="%s+" % name,
0.55 related.py(1310):                 db_tablespace=field.db_tablespace,
0.55 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1312):                 on_delete=CASCADE,
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1297):         {
0.55 related.py(1294):     return type(
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(443):         if self.verbose_name is None:
0.55 related.py(445):         self.remote_field.set_field_name()
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1155):         super().contribute_to_related_class(cls, related)
0.55 related.py(874):             not self.remote_field.is_hidden()
0.55 related.py(873):         if (
0.55 related.py(1156):         if self.remote_field.field_name is None:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.55 related.py(1888):         if self.remote_field.symmetrical and (
0.55 related.py(1893):         elif self.remote_field.is_hidden():
0.55 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.55 related.py(367):                     "class": cls.__name__.lower(),
0.55 related.py(368):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.55 related.py(370):                 self.remote_field.related_query_name = related_query_name
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1910):         if not cls._meta.abstract:
0.55 related.py(1911):             if self.remote_field.through:
0.55 related.py(1919):             elif not cls._meta.swapped:
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1921):                     self, cls
0.55 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.55 related.py(1262):     from django.db import models
0.55 related.py(1264):     def set_managed(model, related, through):
0.55 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.55 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(62):         if "." not in relation:
0.55 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(1271):     to = make_model_tuple(to_model)[1]
0.55 related.py(1272):     from_ = klass._meta.model_name
0.55 related.py(1273):     if to == from_:
0.55 related.py(1277):     meta = type(
0.55 related.py(1278):         "Meta",
0.55 related.py(1279):         (),
0.55 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.55 related.py(1822):         if self.remote_field.through is not None:
0.55 related.py(1824):         elif self.db_table:
0.55 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.55 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.55 related.py(1282):             "auto_created": klass,
0.55 related.py(1283):             "app_label": klass._meta.app_label,
0.55 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.55 related.py(1285):             "unique_together": (from_, to),
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1287):             % {"from": from_, "to": to},
0.55 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1289):             % {"from": from_, "to": to},
0.55 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.55 related.py(1290):             "apps": field.model._meta.apps,
0.55 related.py(1280):         {
0.55 related.py(1277):     meta = type(
0.55 related.py(1294):     return type(
0.55 related.py(1295):         name,
0.55 related.py(1296):         (models.Model,),
0.55 related.py(1298):             "Meta": meta,
0.55 related.py(1299):             "__module__": klass.__module__,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(1301):                 klass,
0.55 related.py(1302):                 related_name="%s+" % name,
0.55 related.py(1303):                 db_tablespace=field.db_tablespace,
0.55 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1305):                 on_delete=CASCADE,
0.55 related.py(1300):             from_: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(1308):                 to_model,
0.55 related.py(1309):                 related_name="%s+" % name,
0.55 related.py(1310):                 db_tablespace=field.db_tablespace,
0.55 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.55 related.py(1312):                 on_delete=CASCADE,
0.55 related.py(1307):             to: models.ForeignKey(
0.55 related.py(936):         try:
0.55 related.py(937):             to._meta.model_name
0.55 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.55 related.py(954):         if not callable(on_delete):
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(958):             self,
0.55 related.py(959):             to,
0.55 related.py(960):             to_field,
0.55 related.py(961):             related_name=related_name,
0.55 related.py(962):             related_query_name=related_query_name,
0.55 related.py(963):             limit_choices_to=limit_choices_to,
0.55 related.py(964):             parent_link=parent_link,
0.55 related.py(965):             on_delete=on_delete,
0.55 related.py(957):         kwargs["rel"] = self.rel_class(
0.55 related.py(967):         kwargs.setdefault("db_index", True)
0.55 related.py(969):         super().__init__(
0.55 related.py(970):             to,
0.55 related.py(971):             on_delete,
0.55 related.py(969):         super().__init__(
0.55 related.py(972):             related_name=related_name,
0.55 related.py(973):             related_query_name=related_query_name,
0.55 related.py(974):             limit_choices_to=limit_choices_to,
0.55 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.55 related.py(976):             to_fields=[to_field],
0.55 related.py(969):         super().__init__(
0.55 related.py(977):             **kwargs,
0.55 related.py(969):         super().__init__(
0.55 related.py(544):         if rel is None:
0.55 related.py(555):         super().__init__(
0.55 related.py(556):             rel=rel,
0.55 related.py(557):             related_name=related_name,
0.55 related.py(558):             related_query_name=related_query_name,
0.55 related.py(559):             limit_choices_to=limit_choices_to,
0.55 related.py(555):         super().__init__(
0.55 related.py(560):             **kwargs,
0.55 related.py(555):         super().__init__(
0.55 related.py(105):         self._related_name = related_name
0.55 related.py(106):         self._related_query_name = related_query_name
0.55 related.py(107):         self._limit_choices_to = limit_choices_to
0.55 related.py(108):         super().__init__(**kwargs)
0.55 related.py(563):         self.from_fields = from_fields
0.55 related.py(564):         self.to_fields = to_fields
0.55 related.py(565):         self.swappable = swappable
0.55 related.py(979):         self.db_constraint = db_constraint
0.55 related.py(1297):         {
0.55 related.py(1294):     return type(
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.55 related.py(1125):         attname = self.get_attname()
0.55 related.py(1122):         return "%s_id" % self.name
0.55 related.py(1126):         column = self.db_column or attname
0.55 related.py(1127):         return attname, column
0.55 related.py(350):         self.opts = cls._meta
0.55 related.py(352):         if not cls._meta.abstract:
0.55 related.py(353):             if self.remote_field.related_name:
0.55 related.py(354):                 related_name = self.remote_field.related_name
0.55 related.py(357):             if related_name:
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(359):                     "class": cls.__name__.lower(),
0.55 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.55 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.55 related.py(358):                 related_name = related_name % {
0.55 related.py(363):                 self.remote_field.related_name = related_name
0.55 related.py(365):             if self.remote_field.related_query_name:
0.55 related.py(372):             def resolve_related_class(model, related, field):
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.55 related.py(376):             lazy_related_operation(
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.55 related.py(61):     if isinstance(relation, str):
0.55 related.py(65):     return relation
0.55 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(85):     apps = model._meta.apps
0.55 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.55 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.55 related.py(373):                 field.remote_field.model = related
0.55 related.py(374):                 field.do_related_class(related, model)
0.55 related.py(448):         self.set_attributes_from_rel()
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(438):         self.name = self.name or (
0.55 related.py(443):         if self.verbose_name is None:
0.55 related.py(445):         self.remote_field.set_field_name()
0.55 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.55 related.py(1155):         super().contribute_to_related_class(cls, related)
0.55 related.py(874):             not self.remote_field.is_hidden()
0.55 related.py(873):         if (
0.55 related.py(1156):         if self.remote_field.field_name is None:
0.55 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.55 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(1960):         pass
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1934):             not self.remote_field.is_hidden()
0.56 related.py(1933):         if (
0.56 related.py(1935):             and not related.related_model._meta.swapped
0.56 related.py(1933):         if (
0.56 related.py(1937):             setattr(
0.56 related.py(1938):                 cls,
0.56 related.py(1939):                 related.get_accessor_name(),
0.56 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.56 related.py(1937):             setattr(
0.56 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.56 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.56 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.56 related.py(1948):         self.m2m_reverse_field_name = partial(
0.56 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.56 related.py(1948):         self.m2m_reverse_field_name = partial(
0.56 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.56 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.56 related.py(1954):         get_m2m_reverse_rel = partial(
0.56 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.56 related.py(1954):         get_m2m_reverse_rel = partial(
0.56 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.56 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(443):         if self.verbose_name is None:
0.56 related.py(445):         self.remote_field.set_field_name()
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1155):         super().contribute_to_related_class(cls, related)
0.56 related.py(874):             not self.remote_field.is_hidden()
0.56 related.py(873):         if (
0.56 related.py(1156):         if self.remote_field.field_name is None:
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(1960):         pass
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1934):             not self.remote_field.is_hidden()
0.56 related.py(1933):         if (
0.56 related.py(1935):             and not related.related_model._meta.swapped
0.56 related.py(1933):         if (
0.56 related.py(1937):             setattr(
0.56 related.py(1938):                 cls,
0.56 related.py(1939):                 related.get_accessor_name(),
0.56 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.56 related.py(1937):             setattr(
0.56 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.56 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.56 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.56 related.py(1948):         self.m2m_reverse_field_name = partial(
0.56 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.56 related.py(1948):         self.m2m_reverse_field_name = partial(
0.56 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.56 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.56 related.py(1954):         get_m2m_reverse_rel = partial(
0.56 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.56 related.py(1954):         get_m2m_reverse_rel = partial(
0.56 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.56 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(443):         if self.verbose_name is None:
0.56 related.py(445):         self.remote_field.set_field_name()
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1155):         super().contribute_to_related_class(cls, related)
0.56 related.py(874):             not self.remote_field.is_hidden()
0.56 related.py(873):         if (
0.56 related.py(1156):         if self.remote_field.field_name is None:
0.56 related.py(936):         try:
0.56 related.py(937):             to._meta.model_name
0.56 related.py(938):         except AttributeError:
0.56 related.py(939):             if not isinstance(to, str):
0.56 related.py(954):         if not callable(on_delete):
0.56 related.py(957):         kwargs["rel"] = self.rel_class(
0.56 related.py(958):             self,
0.56 related.py(959):             to,
0.56 related.py(960):             to_field,
0.56 related.py(961):             related_name=related_name,
0.56 related.py(962):             related_query_name=related_query_name,
0.56 related.py(963):             limit_choices_to=limit_choices_to,
0.56 related.py(964):             parent_link=parent_link,
0.56 related.py(965):             on_delete=on_delete,
0.56 related.py(957):         kwargs["rel"] = self.rel_class(
0.56 related.py(967):         kwargs.setdefault("db_index", True)
0.56 related.py(969):         super().__init__(
0.56 related.py(970):             to,
0.56 related.py(971):             on_delete,
0.56 related.py(969):         super().__init__(
0.56 related.py(972):             related_name=related_name,
0.56 related.py(973):             related_query_name=related_query_name,
0.56 related.py(974):             limit_choices_to=limit_choices_to,
0.56 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.56 related.py(976):             to_fields=[to_field],
0.56 related.py(969):         super().__init__(
0.56 related.py(977):             **kwargs,
0.56 related.py(969):         super().__init__(
0.56 related.py(544):         if rel is None:
0.56 related.py(555):         super().__init__(
0.56 related.py(556):             rel=rel,
0.56 related.py(557):             related_name=related_name,
0.56 related.py(558):             related_query_name=related_query_name,
0.56 related.py(559):             limit_choices_to=limit_choices_to,
0.56 related.py(555):         super().__init__(
0.56 related.py(560):             **kwargs,
0.56 related.py(555):         super().__init__(
0.56 related.py(105):         self._related_name = related_name
0.56 related.py(106):         self._related_query_name = related_query_name
0.56 related.py(107):         self._limit_choices_to = limit_choices_to
0.56 related.py(108):         super().__init__(**kwargs)
0.56 related.py(563):         self.from_fields = from_fields
0.56 related.py(564):         self.to_fields = to_fields
0.56 related.py(565):         self.swappable = swappable
0.56 related.py(979):         self.db_constraint = db_constraint
0.56 related.py(936):         try:
0.56 related.py(937):             to._meta.model_name
0.56 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.56 related.py(954):         if not callable(on_delete):
0.56 related.py(957):         kwargs["rel"] = self.rel_class(
0.56 related.py(958):             self,
0.56 related.py(959):             to,
0.56 related.py(960):             to_field,
0.56 related.py(961):             related_name=related_name,
0.56 related.py(962):             related_query_name=related_query_name,
0.56 related.py(963):             limit_choices_to=limit_choices_to,
0.56 related.py(964):             parent_link=parent_link,
0.56 related.py(965):             on_delete=on_delete,
0.56 related.py(957):         kwargs["rel"] = self.rel_class(
0.56 related.py(967):         kwargs.setdefault("db_index", True)
0.56 related.py(969):         super().__init__(
0.56 related.py(970):             to,
0.56 related.py(971):             on_delete,
0.56 related.py(969):         super().__init__(
0.56 related.py(972):             related_name=related_name,
0.56 related.py(973):             related_query_name=related_query_name,
0.56 related.py(974):             limit_choices_to=limit_choices_to,
0.56 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.56 related.py(976):             to_fields=[to_field],
0.56 related.py(969):         super().__init__(
0.56 related.py(977):             **kwargs,
0.56 related.py(969):         super().__init__(
0.56 related.py(544):         if rel is None:
0.56 related.py(555):         super().__init__(
0.56 related.py(556):             rel=rel,
0.56 related.py(557):             related_name=related_name,
0.56 related.py(558):             related_query_name=related_query_name,
0.56 related.py(559):             limit_choices_to=limit_choices_to,
0.56 related.py(555):         super().__init__(
0.56 related.py(560):             **kwargs,
0.56 related.py(555):         super().__init__(
0.56 related.py(105):         self._related_name = related_name
0.56 related.py(106):         self._related_query_name = related_query_name
0.56 related.py(107):         self._limit_choices_to = limit_choices_to
0.56 related.py(108):         super().__init__(**kwargs)
0.56 related.py(563):         self.from_fields = from_fields
0.56 related.py(564):         self.to_fields = to_fields
0.56 related.py(565):         self.swappable = swappable
0.56 related.py(979):         self.db_constraint = db_constraint
0.56 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.56 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.56 related.py(1125):         attname = self.get_attname()
0.56 related.py(1122):         return "%s_id" % self.name
0.56 related.py(1126):         column = self.db_column or attname
0.56 related.py(1127):         return attname, column
0.56 related.py(350):         self.opts = cls._meta
0.56 related.py(352):         if not cls._meta.abstract:
0.56 related.py(353):             if self.remote_field.related_name:
0.56 related.py(356):                 related_name = self.opts.default_related_name
0.56 related.py(357):             if related_name:
0.56 related.py(365):             if self.remote_field.related_query_name:
0.56 related.py(372):             def resolve_related_class(model, related, field):
0.56 related.py(376):             lazy_related_operation(
0.56 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.56 related.py(376):             lazy_related_operation(
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.56 related.py(61):     if isinstance(relation, str):
0.56 related.py(62):         if "." not in relation:
0.56 related.py(65):     return relation
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(85):     apps = model._meta.apps
0.56 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.56 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.56 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.56 related.py(1125):         attname = self.get_attname()
0.56 related.py(1122):         return "%s_id" % self.name
0.56 related.py(1126):         column = self.db_column or attname
0.56 related.py(1127):         return attname, column
0.56 related.py(350):         self.opts = cls._meta
0.56 related.py(352):         if not cls._meta.abstract:
0.56 related.py(353):             if self.remote_field.related_name:
0.56 related.py(356):                 related_name = self.opts.default_related_name
0.56 related.py(357):             if related_name:
0.56 related.py(365):             if self.remote_field.related_query_name:
0.56 related.py(372):             def resolve_related_class(model, related, field):
0.56 related.py(376):             lazy_related_operation(
0.56 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.56 related.py(376):             lazy_related_operation(
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.56 related.py(61):     if isinstance(relation, str):
0.56 related.py(65):     return relation
0.56 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(85):     apps = model._meta.apps
0.56 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.56 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(443):         if self.verbose_name is None:
0.56 related.py(445):         self.remote_field.set_field_name()
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1155):         super().contribute_to_related_class(cls, related)
0.56 related.py(874):             not self.remote_field.is_hidden()
0.56 related.py(873):         if (
0.56 related.py(875):             and not related.related_model._meta.swapped
0.56 related.py(873):         if (
0.56 related.py(877):             setattr(
0.56 related.py(878):                 cls._meta.concrete_model,
0.56 related.py(879):                 related.get_accessor_name(),
0.56 related.py(880):                 self.related_accessor_class(related),
0.56 related.py(877):             setattr(
0.56 related.py(885):             if self.remote_field.limit_choices_to:
0.56 related.py(1156):         if self.remote_field.field_name is None:
0.56 related.py(373):                 field.remote_field.model = related
0.56 related.py(374):                 field.do_related_class(related, model)
0.56 related.py(448):         self.set_attributes_from_rel()
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(438):         self.name = self.name or (
0.56 related.py(443):         if self.verbose_name is None:
0.56 related.py(445):         self.remote_field.set_field_name()
0.56 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.56 related.py(1155):         super().contribute_to_related_class(cls, related)
0.56 related.py(874):             not self.remote_field.is_hidden()
0.56 related.py(873):         if (
0.56 related.py(875):             and not related.related_model._meta.swapped
0.56 related.py(873):         if (
0.56 related.py(877):             setattr(
0.56 related.py(878):                 cls._meta.concrete_model,
0.56 related.py(879):                 related.get_accessor_name(),
0.56 related.py(880):                 self.related_accessor_class(related),
0.56 related.py(877):             setattr(
0.56 related.py(885):             if self.remote_field.limit_choices_to:
0.56 related.py(1156):         if self.remote_field.field_name is None:
0.57 related.py(1232):         kwargs["unique"] = True
0.57 related.py(1233):         super().__init__(to, on_delete, to_field=to_field, **kwargs)
0.57 related.py(936):         try:
0.57 related.py(937):             to._meta.model_name
0.57 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.57 related.py(954):         if not callable(on_delete):
0.57 related.py(957):         kwargs["rel"] = self.rel_class(
0.57 related.py(958):             self,
0.57 related.py(959):             to,
0.57 related.py(960):             to_field,
0.57 related.py(961):             related_name=related_name,
0.57 related.py(962):             related_query_name=related_query_name,
0.57 related.py(963):             limit_choices_to=limit_choices_to,
0.57 related.py(964):             parent_link=parent_link,
0.57 related.py(965):             on_delete=on_delete,
0.57 related.py(957):         kwargs["rel"] = self.rel_class(
0.57 related.py(967):         kwargs.setdefault("db_index", True)
0.57 related.py(969):         super().__init__(
0.57 related.py(970):             to,
0.57 related.py(971):             on_delete,
0.57 related.py(969):         super().__init__(
0.57 related.py(972):             related_name=related_name,
0.57 related.py(973):             related_query_name=related_query_name,
0.57 related.py(974):             limit_choices_to=limit_choices_to,
0.57 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.57 related.py(976):             to_fields=[to_field],
0.57 related.py(969):         super().__init__(
0.57 related.py(977):             **kwargs,
0.57 related.py(969):         super().__init__(
0.57 related.py(544):         if rel is None:
0.57 related.py(555):         super().__init__(
0.57 related.py(556):             rel=rel,
0.57 related.py(557):             related_name=related_name,
0.57 related.py(558):             related_query_name=related_query_name,
0.57 related.py(559):             limit_choices_to=limit_choices_to,
0.57 related.py(555):         super().__init__(
0.57 related.py(560):             **kwargs,
0.57 related.py(555):         super().__init__(
0.57 related.py(105):         self._related_name = related_name
0.57 related.py(106):         self._related_query_name = related_query_name
0.57 related.py(107):         self._limit_choices_to = limit_choices_to
0.57 related.py(108):         super().__init__(**kwargs)
0.57 related.py(563):         self.from_fields = from_fields
0.57 related.py(564):         self.to_fields = to_fields
0.57 related.py(565):         self.swappable = swappable
0.57 related.py(979):         self.db_constraint = db_constraint
0.57 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.57 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.57 related.py(1125):         attname = self.get_attname()
0.57 related.py(1122):         return "%s_id" % self.name
0.57 related.py(1126):         column = self.db_column or attname
0.57 related.py(1127):         return attname, column
0.57 related.py(350):         self.opts = cls._meta
0.57 related.py(352):         if not cls._meta.abstract:
0.57 related.py(353):             if self.remote_field.related_name:
0.57 related.py(356):                 related_name = self.opts.default_related_name
0.57 related.py(357):             if related_name:
0.57 related.py(365):             if self.remote_field.related_query_name:
0.57 related.py(372):             def resolve_related_class(model, related, field):
0.57 related.py(376):             lazy_related_operation(
0.57 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.57 related.py(376):             lazy_related_operation(
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.57 related.py(61):     if isinstance(relation, str):
0.57 related.py(65):     return relation
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(85):     apps = model._meta.apps
0.57 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.57 related.py(373):                 field.remote_field.model = related
0.57 related.py(374):                 field.do_related_class(related, model)
0.57 related.py(448):         self.set_attributes_from_rel()
0.57 related.py(438):         self.name = self.name or (
0.57 related.py(438):         self.name = self.name or (
0.57 related.py(443):         if self.verbose_name is None:
0.57 related.py(445):         self.remote_field.set_field_name()
0.57 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.57 related.py(1155):         super().contribute_to_related_class(cls, related)
0.57 related.py(874):             not self.remote_field.is_hidden()
0.57 related.py(873):         if (
0.57 related.py(875):             and not related.related_model._meta.swapped
0.57 related.py(873):         if (
0.57 related.py(877):             setattr(
0.57 related.py(878):                 cls._meta.concrete_model,
0.57 related.py(879):                 related.get_accessor_name(),
0.57 related.py(880):                 self.related_accessor_class(related),
0.57 related.py(877):             setattr(
0.57 related.py(885):             if self.remote_field.limit_choices_to:
0.57 related.py(1156):         if self.remote_field.field_name is None:
0.57 related.py(936):         try:
0.57 related.py(937):             to._meta.model_name
0.57 related.py(938):         except AttributeError:
0.57 related.py(939):             if not isinstance(to, str):
0.57 related.py(954):         if not callable(on_delete):
0.57 related.py(957):         kwargs["rel"] = self.rel_class(
0.57 related.py(958):             self,
0.57 Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
related.py(959):             to,
0.57 related.py(960):             to_field,
0.57 related.py(961):             related_name=related_name,
0.57 related.py(962):             related_query_name=related_query_name,
0.57 related.py(963):             limit_choices_to=limit_choices_to,
0.57 related.py(964):             parent_link=parent_link,
0.57 related.py(965):             on_delete=on_delete,
0.57 related.py(957):         kwargs["rel"] = self.rel_class(
0.57 related.py(967):         kwargs.setdefault("db_index", True)
0.57 related.py(969):         super().__init__(
0.57 related.py(970):             to,
0.57 related.py(971):             on_delete,
0.57 related.py(969):         super().__init__(
0.57 related.py(972):             related_name=related_name,
0.57 related.py(973):             related_query_name=related_query_name,
0.57 related.py(974):             limit_choices_to=limit_choices_to,
0.57 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.57 related.py(976):             to_fields=[to_field],
0.57 related.py(969):         super().__init__(
0.57 related.py(977):             **kwargs,
0.57 related.py(969):         super().__init__(
0.57 related.py(544):         if rel is None:
0.57 related.py(555):         super().__init__(
0.57 related.py(556):             rel=rel,
0.57 related.py(557):             related_name=related_name,
0.57 related.py(558):             related_query_name=related_query_name,
0.57 related.py(559):             limit_choices_to=limit_choices_to,
0.57 related.py(555):         super().__init__(
0.57 related.py(560):             **kwargs,
0.57 related.py(555):         super().__init__(
0.57 related.py(105):         self._related_name = related_name
0.57 related.py(106):         self._related_query_name = related_query_name
0.57 related.py(107):         self._limit_choices_to = limit_choices_to
0.57 related.py(108):         super().__init__(**kwargs)
0.57 related.py(563):         self.from_fields = from_fields
0.57 related.py(564):         self.to_fields = to_fields
0.57 related.py(565):         self.swappable = swappable
0.57 related.py(979):         self.db_constraint = db_constraint
0.57 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.57 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.57 related.py(1125):         attname = self.get_attname()
0.57 related.py(1122):         return "%s_id" % self.name
0.57 related.py(1126):         column = self.db_column or attname
0.57 related.py(1127):         return attname, column
0.57 related.py(350):         self.opts = cls._meta
0.57 related.py(352):         if not cls._meta.abstract:
0.57 related.py(353):             if self.remote_field.related_name:
0.57 related.py(356):                 related_name = self.opts.default_related_name
0.57 related.py(357):             if related_name:
0.57 related.py(365):             if self.remote_field.related_query_name:
0.57 related.py(372):             def resolve_related_class(model, related, field):
0.57 related.py(376):             lazy_related_operation(
0.57 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.57 related.py(376):             lazy_related_operation(
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.57 related.py(61):     if isinstance(relation, str):
0.57 related.py(62):         if "." not in relation:
0.57 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.57 related.py(65):     return relation
0.57 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(85):     apps = model._meta.apps
0.57 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.57 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.57 related.py(373):                 field.remote_field.model = related
0.57 related.py(374):                 field.do_related_class(related, model)
0.57 related.py(448):         self.set_attributes_from_rel()
0.57 related.py(438):         self.name = self.name or (
0.57 related.py(438):         self.name = self.name or (
0.57 related.py(443):         if self.verbose_name is None:
0.57 related.py(445):         self.remote_field.set_field_name()
0.57 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.57 related.py(1155):         super().contribute_to_related_class(cls, related)
0.57 related.py(874):             not self.remote_field.is_hidden()
0.57 related.py(873):         if (
0.57 related.py(875):             and not related.related_model._meta.swapped
0.57 related.py(873):         if (
0.57 related.py(877):             setattr(
0.57 related.py(878):                 cls._meta.concrete_model,
0.57 related.py(879):                 related.get_accessor_name(),
0.57 related.py(880):                 self.related_accessor_class(related),
0.57 related.py(877):             setattr(
0.57 related.py(885):             if self.remote_field.limit_choices_to:
0.57 related.py(1156):         if self.remote_field.field_name is None:
Found 1 test(s).
Skipping setup of unused database(s): other.
0.59 related.py(936):         try:
0.59 related.py(937):             to._meta.model_name
0.59 related.py(938):         except AttributeError:
0.59 related.py(939):             if not isinstance(to, str):
0.59 related.py(954):         if not callable(on_delete):
0.59 related.py(957):         kwargs["rel"] = self.rel_class(
0.59 related.py(958):             self,
0.59 related.py(959):             to,
0.59 related.py(960):             to_field,
0.59 related.py(961):             related_name=related_name,
0.59 related.py(962):             related_query_name=related_query_name,
0.59 related.py(963):             limit_choices_to=limit_choices_to,
0.59 related.py(964):             parent_link=parent_link,
0.59 related.py(965):             on_delete=on_delete,
0.59 related.py(957):         kwargs["rel"] = self.rel_class(
0.59 related.py(967):         kwargs.setdefault("db_index", True)
0.59 related.py(969):         super().__init__(
0.59 related.py(970):             to,
0.59 related.py(971):             on_delete,
0.59 related.py(969):         super().__init__(
0.59 related.py(972):             related_name=related_name,
0.59 related.py(973):             related_query_name=related_query_name,
0.59 related.py(974):             limit_choices_to=limit_choices_to,
0.59 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.59 related.py(976):             to_fields=[to_field],
0.59 related.py(969):         super().__init__(
0.59 related.py(977):             **kwargs,
0.59 related.py(969):         super().__init__(
0.59 related.py(544):         if rel is None:
0.59 related.py(555):         super().__init__(
0.59 related.py(556):             rel=rel,
0.59 related.py(557):             related_name=related_name,
0.59 related.py(558):             related_query_name=related_query_name,
0.59 related.py(559):             limit_choices_to=limit_choices_to,
0.59 related.py(555):         super().__init__(
0.59 related.py(560):             **kwargs,
0.59 related.py(555):         super().__init__(
0.59 related.py(105):         self._related_name = related_name
0.59 related.py(106):         self._related_query_name = related_query_name
0.59 related.py(107):         self._limit_choices_to = limit_choices_to
0.59 related.py(108):         super().__init__(**kwargs)
0.59 related.py(563):         self.from_fields = from_fields
0.59 related.py(564):         self.to_fields = to_fields
0.59 related.py(565):         self.swappable = swappable
0.59 related.py(979):         self.db_constraint = db_constraint
0.59 related.py(936):         try:
0.59 related.py(937):             to._meta.model_name
0.59 related.py(938):         except AttributeError:
0.59 related.py(939):             if not isinstance(to, str):
0.59 related.py(954):         if not callable(on_delete):
0.59 related.py(957):         kwargs["rel"] = self.rel_class(
0.59 related.py(958):             self,
0.59 related.py(959):             to,
0.59 related.py(960):             to_field,
0.59 related.py(961):             related_name=related_name,
0.59 related.py(962):             related_query_name=related_query_name,
0.59 related.py(963):             limit_choices_to=limit_choices_to,
0.59 related.py(964):             parent_link=parent_link,
0.59 related.py(965):             on_delete=on_delete,
0.59 related.py(957):         kwargs["rel"] = self.rel_class(
0.59 related.py(967):         kwargs.setdefault("db_index", True)
0.59 related.py(969):         super().__init__(
0.59 related.py(970):             to,
0.59 related.py(971):             on_delete,
0.59 related.py(969):         super().__init__(
0.59 related.py(972):             related_name=related_name,
0.59 related.py(973):             related_query_name=related_query_name,
0.59 related.py(974):             limit_choices_to=limit_choices_to,
0.59 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.59 related.py(976):             to_fields=[to_field],
0.59 related.py(969):         super().__init__(
0.59 related.py(977):             **kwargs,
0.59 related.py(969):         super().__init__(
0.59 related.py(544):         if rel is None:
0.59 related.py(555):         super().__init__(
0.59 related.py(556):             rel=rel,
0.59 related.py(557):             related_name=related_name,
0.59 related.py(558):             related_query_name=related_query_name,
0.59 related.py(559):             limit_choices_to=limit_choices_to,
0.59 related.py(555):         super().__init__(
0.59 related.py(560):             **kwargs,
0.59 related.py(555):         super().__init__(
0.59 related.py(105):         self._related_name = related_name
0.59 related.py(106):         self._related_query_name = related_query_name
0.59 related.py(107):         self._limit_choices_to = limit_choices_to
0.59 related.py(108):         super().__init__(**kwargs)
0.59 related.py(563):         self.from_fields = from_fields
0.59 related.py(564):         self.to_fields = to_fields
0.59 related.py(565):         self.swappable = swappable
0.59 related.py(979):         self.db_constraint = db_constraint
Operations to perform:
  Synchronize unmigrated apps: auth, contenttypes, messages, sessions, staticfiles
  Apply all migrations: admin, sites
Synchronizing apps without migrations:
  Creating tables...
0.59 schema.py(139):         self.connection = connection
0.59 schema.py(140):         self.collect_sql = collect_sql
0.59 schema.py(141):         if self.collect_sql:
0.59 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.59 schema.py(28):         if not self.connection.disable_constraint_checking():
0.59 schema.py(36):         return super().__enter__()
0.59 schema.py(148):         self.deferred_sql = []
0.59 schema.py(149):         if self.atomic_migration:
0.59 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.59 schema.py(151):             self.atomic.__enter__()
0.59 schema.py(152):         return self
    Creating table django_content_type
0.59 schema.py(435):         sql, params = self.table_sql(model)
0.59 schema.py(201):         for field_names in model._meta.unique_together:
0.59 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.59 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.59 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.59 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.59 schema.py(203):             self.deferred_sql.append(self._create_unique_sql(model, fields))
0.59 schema.py(1528):                 deferrable
0.59 schema.py(1526):         if (
0.59 schema.py(1531):             or (condition and not self.connection.features.supports_partial_indexes)
0.59 schema.py(1526):         if (
0.59 schema.py(1532):             or (include and not self.connection.features.supports_covering_indexes)
0.59 schema.py(1526):         if (
0.59 schema.py(1534):                 expressions and not self.connection.features.supports_expression_indexes
0.59 schema.py(1526):         if (
0.59 schema.py(1539):         def create_unique_name(*args, **kwargs):
0.59 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.59 schema.py(1543):             connection=self.connection
0.59 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1545):         table = model._meta.db_table
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1547):         if name is None:
0.60 schema.py(1548):             name = IndexName(table, columns, "_uniq", create_unique_name)
0.60 schema.py(1551):         if condition or include or opclasses or expressions:
0.60 schema.py(1554):             sql = self.sql_create_unique
0.60 schema.py(1555):         if columns:
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1557):                 table, columns, col_suffixes=(), opclasses=opclasses
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.60 schema.py(1561):         return Statement(
0.60 schema.py(1562):             sql,
0.60 schema.py(1563):             table=Table(table, self.quote_name),
0.60 schema.py(1564):             name=name,
0.60 schema.py(1565):             columns=columns,
0.60 schema.py(1566):             condition=self._index_condition_sql(condition),
0.60 schema.py(1286):         if condition:
0.60 schema.py(1288):         return ""
0.60 schema.py(1567):             deferrable=self._deferrable_constraint_sql(deferrable),
0.60 schema.py(1468):         if deferrable is None:
0.60 schema.py(1469):             return ""
0.60 schema.py(1568):             include=self._index_include_sql(model, include),
0.60 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.60 schema.py(1292):             return ""
0.60 schema.py(1561):         return Statement(
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(205):         column_sqls = []
0.60 schema.py(206):         params = []
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(321):             yield "PRIMARY KEY"
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(219):                 definition += " %s" % col_type_suffix
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(254):                     model._meta.db_table, field.column
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(256):                 if autoinc_sql:
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(312):             and not field.primary_key
0.60 schema.py(310):         if (
0.60 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(312):             and not field.primary_key
0.60 schema.py(310):         if (
0.60 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(258):         constraints = [
0.60 schema.py(260):             for constraint in model._meta.constraints
0.60 schema.py(258):         constraints = [
0.60 schema.py(258):         constraints = [
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(268):         if model._meta.db_tablespace:
0.60 schema.py(274):         return sql, params
0.60 schema.py(438):         self.execute(sql, params or None)
0.60 schema.py(168):             not self.collect_sql
0.60 schema.py(167):         if (
0.60 schema.py(169):             and self.connection.in_atomic_block
0.60 schema.py(167):         if (
0.60 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.60 schema.py(167):         if (
0.60 schema.py(177):         sql = str(sql)
0.60 schema.py(179):         logger.debug(
0.60 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.60 schema.py(179):         logger.debug(
0.60 schema.py(182):         if self.collect_sql:
0.60 schema.py(191):             with self.connection.cursor() as cursor:
0.60 schema.py(192):                 cursor.execute(sql, params)
0.60 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.60 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.60 schema.py(1369):         output = []
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1373):         for field_names in model._meta.index_together:
0.60 schema.py(1377):         for index in model._meta.indexes:
0.60 schema.py(1383):         return output
0.60 schema.py(445):         for field in model._meta.local_many_to_many:
    Creating table auth_permission
0.60 schema.py(435):         sql, params = self.table_sql(model)
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(203):             self.deferred_sql.append(self._create_unique_sql(model, fields))
0.60 schema.py(1528):                 deferrable
0.60 schema.py(1526):         if (
0.60 schema.py(1531):             or (condition and not self.connection.features.supports_partial_indexes)
0.60 schema.py(1526):         if (
0.60 schema.py(1532):             or (include and not self.connection.features.supports_covering_indexes)
0.60 schema.py(1526):         if (
0.60 schema.py(1534):                 expressions and not self.connection.features.supports_expression_indexes
0.60 schema.py(1526):         if (
0.60 schema.py(1539):         def create_unique_name(*args, **kwargs):
0.60 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1543):             connection=self.connection
0.60 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1545):         table = model._meta.db_table
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1547):         if name is None:
0.60 schema.py(1548):             name = IndexName(table, columns, "_uniq", create_unique_name)
0.60 schema.py(1551):         if condition or include or opclasses or expressions:
0.60 schema.py(1554):             sql = self.sql_create_unique
0.60 schema.py(1555):         if columns:
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1557):                 table, columns, col_suffixes=(), opclasses=opclasses
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.60 schema.py(1561):         return Statement(
0.60 schema.py(1562):             sql,
0.60 schema.py(1563):             table=Table(table, self.quote_name),
0.60 schema.py(1564):             name=name,
0.60 schema.py(1565):             columns=columns,
0.60 schema.py(1566):             condition=self._index_condition_sql(condition),
0.60 schema.py(1286):         if condition:
0.60 schema.py(1288):         return ""
0.60 schema.py(1567):             deferrable=self._deferrable_constraint_sql(deferrable),
0.60 schema.py(1468):         if deferrable is None:
0.60 schema.py(1469):             return ""
0.60 schema.py(1568):             include=self._index_include_sql(model, include),
0.60 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.60 schema.py(1292):             return ""
0.60 schema.py(1561):         return Statement(
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(205):         column_sqls = []
0.60 schema.py(206):         params = []
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(321):             yield "PRIMARY KEY"
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(219):                 definition += " %s" % col_type_suffix
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(254):                     model._meta.db_table, field.column
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(256):                 if autoinc_sql:
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(312):             and not field.primary_key
0.60 schema.py(310):         if (
0.60 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(746):         return tuple(
0.60 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.60 related.py(734):         return self.resolve_related_fields()
0.60 related.py(1103):         related_fields = super().resolve_related_fields()
0.60 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.60 related.py(711):         if isinstance(self.remote_field.model, str):
0.60 related.py(715):         related_fields = []
0.60 related.py(716):         for index in range(len(self.from_fields)):
0.60 related.py(717):             from_field_name = self.from_fields[index]
0.60 related.py(718):             to_field_name = self.to_fields[index]
0.60 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.60 related.py(720):                 self
0.60 related.py(719):             from_field = (
0.60 related.py(726):                 if to_field_name is None
0.60 related.py(725):                 self.remote_field.model._meta.pk
0.60 related.py(727):                 else self.remote_field.model._meta.get_field(to_field_name)
0.60 related.py(724):             to_field = (
0.60 related.py(729):             related_fields.append((from_field, to_field))
0.60 related.py(716):         for index in range(len(self.from_fields)):
0.60 related.py(730):         return related_fields
0.60 related.py(1104):         for from_field, to_field in related_fields:
0.60 related.py(1106):                 to_field
0.60 related.py(1105):             if (
0.60 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.60 related.py(1105):             if (
0.60 related.py(1104):         for from_field, to_field in related_fields:
0.60 related.py(1119):         return related_fields
0.60 related.py(746):         return tuple(
0.60 related.py(746):         return tuple(
0.60 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.60 related.py(746):         return tuple(
0.60 related.py(1185):             "type": self.db_type(connection),
0.60 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1186):             "check": self.db_check(connection),
0.60 related.py(1177):         return None
0.60 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.60 related.py(1184):         return {
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1185):             "type": self.db_type(connection),
0.60 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1186):             "check": self.db_check(connection),
0.60 related.py(1177):         return None
0.60 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.60 related.py(1184):         return {
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.60 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.60 schema.py(225):                     field.remote_field.field_name
0.60 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.60 schema.py(227):                 if self.sql_create_inline_fk:
0.60 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.60 schema.py(229):                         "to_table": self.quote_name(to_table),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(230):                         "to_column": self.quote_name(to_column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(312):             and not field.primary_key
0.60 schema.py(310):         if (
0.60 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(258):         constraints = [
0.60 schema.py(260):             for constraint in model._meta.constraints
0.60 schema.py(258):         constraints = [
0.60 schema.py(258):         constraints = [
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(268):         if model._meta.db_tablespace:
0.60 schema.py(274):         return sql, params
0.60 schema.py(438):         self.execute(sql, params or None)
0.60 schema.py(168):             not self.collect_sql
0.60 schema.py(167):         if (
0.60 schema.py(169):             and self.connection.in_atomic_block
0.60 schema.py(167):         if (
0.60 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.60 schema.py(167):         if (
0.60 schema.py(177):         sql = str(sql)
0.60 schema.py(179):         logger.debug(
0.60 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.60 schema.py(179):         logger.debug(
0.60 schema.py(182):         if self.collect_sql:
0.60 schema.py(191):             with self.connection.cursor() as cursor:
0.60 schema.py(192):                 cursor.execute(sql, params)
0.60 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.60 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.60 schema.py(1369):         output = []
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.60 schema.py(1319):         fields = fields or []
0.60 schema.py(1320):         expressions = expressions or []
0.60 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1322):             connection=self.connection,
0.60 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.60 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.60 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.60 schema.py(1276):         if db_tablespace is None:
0.60 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.60 schema.py(1279):             elif model._meta.db_tablespace:
0.60 schema.py(1281):         if db_tablespace is not None:
0.60 schema.py(1283):         return ""
0.60 schema.py(1327):         columns = [field.column for field in fields]
0.60 schema.py(1327):         columns = [field.column for field in fields]
0.60 schema.py(1327):         columns = [field.column for field in fields]
0.60 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.60 schema.py(1329):         table = model._meta.db_table
0.60 schema.py(1331):         def create_index_name(*args, **kwargs):
0.60 schema.py(1337):         return Statement(
0.60 schema.py(1338):             sql_create_index,
0.60 schema.py(1339):             table=Table(table, self.quote_name),
0.60 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.60 schema.py(1341):             using=using,
0.60 schema.py(1344):                 if columns
0.60 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.60 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.60 schema.py(1347):             extra=tablespace_sql,
0.60 schema.py(1348):             condition=self._index_condition_sql(condition),
0.60 schema.py(1286):         if condition:
0.60 schema.py(1288):         return ""
0.60 schema.py(1349):             include=self._index_include_sql(model, include),
0.60 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.60 schema.py(1292):             return ""
0.60 schema.py(1337):         return Statement(
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1373):         for field_names in model._meta.index_together:
0.60 schema.py(1377):         for index in model._meta.indexes:
0.60 schema.py(1383):         return output
0.60 schema.py(445):         for field in model._meta.local_many_to_many:
    Creating table auth_group
0.60 schema.py(435):         sql, params = self.table_sql(model)
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(205):         column_sqls = []
0.60 schema.py(206):         params = []
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(321):             yield "PRIMARY KEY"
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(219):                 definition += " %s" % col_type_suffix
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(254):                     model._meta.db_table, field.column
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(256):                 if autoinc_sql:
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(312):             and not field.primary_key
0.60 schema.py(310):         if (
0.60 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(323):             yield "UNIQUE"
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(258):         constraints = [
0.60 schema.py(260):             for constraint in model._meta.constraints
0.60 schema.py(258):         constraints = [
0.60 schema.py(258):         constraints = [
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.60 schema.py(264):             "definition": ", ".join(
0.60 schema.py(262):         sql = self.sql_create_table % {
0.60 schema.py(268):         if model._meta.db_tablespace:
0.60 schema.py(274):         return sql, params
0.60 schema.py(438):         self.execute(sql, params or None)
0.60 schema.py(168):             not self.collect_sql
0.60 schema.py(167):         if (
0.60 schema.py(169):             and self.connection.in_atomic_block
0.60 schema.py(167):         if (
0.60 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.60 schema.py(167):         if (
0.60 schema.py(177):         sql = str(sql)
0.60 schema.py(179):         logger.debug(
0.60 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.60 schema.py(179):         logger.debug(
0.60 schema.py(182):         if self.collect_sql:
0.60 schema.py(191):             with self.connection.cursor() as cursor:
0.60 schema.py(192):                 cursor.execute(sql, params)
0.60 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.60 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.60 schema.py(1369):         output = []
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.60 schema.py(1389):         output = []
0.60 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.60 schema.py(1410):         return field.db_index and not field.unique
0.60 schema.py(1392):         return output
0.60 schema.py(1370):         for field in model._meta.local_fields:
0.60 schema.py(1373):         for field_names in model._meta.index_together:
0.60 schema.py(1377):         for index in model._meta.indexes:
0.60 schema.py(1383):         return output
0.60 schema.py(445):         for field in model._meta.local_many_to_many:
0.60 schema.py(446):             if field.remote_field.through._meta.auto_created:
0.60 schema.py(447):                 self.create_model(field.remote_field.through)
0.60 schema.py(435):         sql, params = self.table_sql(model)
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.60 schema.py(203):             self.deferred_sql.append(self._create_unique_sql(model, fields))
0.60 schema.py(1528):                 deferrable
0.60 schema.py(1526):         if (
0.60 schema.py(1531):             or (condition and not self.connection.features.supports_partial_indexes)
0.60 schema.py(1526):         if (
0.60 schema.py(1532):             or (include and not self.connection.features.supports_covering_indexes)
0.60 schema.py(1526):         if (
0.60 schema.py(1534):                 expressions and not self.connection.features.supports_expression_indexes
0.60 schema.py(1526):         if (
0.60 schema.py(1539):         def create_unique_name(*args, **kwargs):
0.60 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1543):             connection=self.connection
0.60 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.60 schema.py(1545):         table = model._meta.db_table
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1546):         columns = [field.column for field in fields]
0.60 schema.py(1547):         if name is None:
0.60 schema.py(1548):             name = IndexName(table, columns, "_uniq", create_unique_name)
0.60 schema.py(1551):         if condition or include or opclasses or expressions:
0.60 schema.py(1554):             sql = self.sql_create_unique
0.60 schema.py(1555):         if columns:
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1557):                 table, columns, col_suffixes=(), opclasses=opclasses
0.60 schema.py(1556):             columns = self._index_columns(
0.60 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.60 schema.py(1561):         return Statement(
0.60 schema.py(1562):             sql,
0.60 schema.py(1563):             table=Table(table, self.quote_name),
0.60 schema.py(1564):             name=name,
0.60 schema.py(1565):             columns=columns,
0.60 schema.py(1566):             condition=self._index_condition_sql(condition),
0.60 schema.py(1286):         if condition:
0.60 schema.py(1288):         return ""
0.60 schema.py(1567):             deferrable=self._deferrable_constraint_sql(deferrable),
0.60 schema.py(1468):         if deferrable is None:
0.60 schema.py(1469):             return ""
0.60 schema.py(1568):             include=self._index_include_sql(model, include),
0.60 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.60 schema.py(1292):             return ""
0.60 schema.py(1561):         return Statement(
0.60 schema.py(201):         for field_names in model._meta.unique_together:
0.60 schema.py(205):         column_sqls = []
0.60 schema.py(206):         params = []
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(321):             yield "PRIMARY KEY"
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 schema.py(214):             if db_params["check"]:
0.60 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.60 schema.py(218):             if col_type_suffix:
0.60 schema.py(219):                 definition += " %s" % col_type_suffix
0.60 schema.py(220):             params.extend(extra_params)
0.60 schema.py(222):             if field.remote_field and field.db_constraint:
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(242):                     self.quote_name(field.column),
0.60 schema.py(195):         return self.connection.ops.quote_name(name)
0.60 schema.py(243):                     definition,
0.60 schema.py(241):                 % (
0.60 schema.py(240):                 "%s %s"
0.60 schema.py(239):             column_sqls.append(
0.60 schema.py(248):             if field.get_internal_type() in (
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(254):                     model._meta.db_table, field.column
0.60 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.60 schema.py(256):                 if autoinc_sql:
0.60 schema.py(207):         for field in model._meta.local_fields:
0.60 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.60 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.60 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(746):         return tuple(
0.60 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.60 related.py(734):         return self.resolve_related_fields()
0.60 related.py(1103):         related_fields = super().resolve_related_fields()
0.60 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.60 related.py(711):         if isinstance(self.remote_field.model, str):
0.60 related.py(715):         related_fields = []
0.60 related.py(716):         for index in range(len(self.from_fields)):
0.60 related.py(717):             from_field_name = self.from_fields[index]
0.60 related.py(718):             to_field_name = self.to_fields[index]
0.60 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.60 related.py(720):                 self
0.60 related.py(719):             from_field = (
0.60 related.py(726):                 if to_field_name is None
0.60 related.py(725):                 self.remote_field.model._meta.pk
0.60 related.py(724):             to_field = (
0.60 related.py(729):             related_fields.append((from_field, to_field))
0.60 related.py(716):         for index in range(len(self.from_fields)):
0.60 related.py(730):         return related_fields
0.60 related.py(1104):         for from_field, to_field in related_fields:
0.60 related.py(1106):                 to_field
0.60 related.py(1105):             if (
0.60 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.60 related.py(1105):             if (
0.60 related.py(1104):         for from_field, to_field in related_fields:
0.60 related.py(1119):         return related_fields
0.60 related.py(746):         return tuple(
0.60 related.py(746):         return tuple(
0.60 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.60 related.py(746):         return tuple(
0.60 related.py(1185):             "type": self.db_type(connection),
0.60 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1186):             "check": self.db_check(connection),
0.60 related.py(1177):         return None
0.60 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.60 related.py(1184):         return {
0.60 schema.py(340):         column_db_type = field_db_params["type"]
0.60 schema.py(342):         if column_db_type is None:
0.60 schema.py(344):         params = []
0.60 schema.py(346):             " ".join(
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(349):                     column_db_type,
0.60 schema.py(350):                     params,
0.60 schema.py(351):                     model,
0.60 schema.py(352):                     field,
0.60 schema.py(353):                     field_db_params,
0.60 schema.py(354):                     include_default,
0.60 schema.py(348):                 self._iter_column_sql(
0.60 schema.py(346):             " ".join(
0.60 schema.py(281):         yield column_db_type
0.60 schema.py(282):         if collation := field_db_params.get("collation"):
0.60 schema.py(285):         null = field.null
0.60 schema.py(288):             include_default
0.60 schema.py(287):         include_default = (
0.60 schema.py(296):         if include_default:
0.60 schema.py(311):             field.empty_strings_allowed
0.60 schema.py(310):         if (
0.60 schema.py(316):         if not null:
0.60 schema.py(317):             yield "NOT NULL"
0.60 schema.py(320):         if field.primary_key:
0.60 schema.py(322):         elif field.unique:
0.60 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.60 schema.py(327):             tablespace
0.60 schema.py(326):         if (
0.60 schema.py(357):             params,
0.60 schema.py(345):         return (
0.60 schema.py(210):             if definition is None:
0.60 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.60 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1185):             "type": self.db_type(connection),
0.60 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.60 related.py(1060):         return self.foreign_related_fields[0]
0.60 related.py(1186):             "check": self.db_check(connection),
0.60 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(734):         return self.resolve_related_fields()
0.61 related.py(1103):         related_fields = super().resolve_related_fields()
0.61 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.61 related.py(711):         if isinstance(self.remote_field.model, str):
0.61 related.py(715):         related_fields = []
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(717):             from_field_name = self.from_fields[index]
0.61 related.py(718):             to_field_name = self.to_fields[index]
0.61 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.61 related.py(720):                 self
0.61 related.py(719):             from_field = (
0.61 related.py(726):                 if to_field_name is None
0.61 related.py(725):                 self.remote_field.model._meta.pk
0.61 related.py(727):                 else self.remote_field.model._meta.get_field(to_field_name)
0.61 related.py(724):             to_field = (
0.61 related.py(729):             related_fields.append((from_field, to_field))
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(730):         return related_fields
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1106):                 to_field
0.61 related.py(1105):             if (
0.61 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.61 related.py(1105):             if (
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1119):         return related_fields
0.61 related.py(746):         return tuple(
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(746):         return tuple(
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(258):         constraints = [
0.61 schema.py(260):             for constraint in model._meta.constraints
0.61 schema.py(258):         constraints = [
0.61 schema.py(258):         constraints = [
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(268):         if model._meta.db_tablespace:
0.61 schema.py(274):         return sql, params
0.61 schema.py(438):         self.execute(sql, params or None)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.61 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.61 schema.py(1369):         output = []
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1373):         for field_names in model._meta.index_together:
0.61 schema.py(1377):         for index in model._meta.indexes:
0.61 schema.py(1383):         return output
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
    Creating table auth_user
0.61 schema.py(435):         sql, params = self.table_sql(model)
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(205):         column_sqls = []
0.61 schema.py(206):         params = []
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(321):             yield "PRIMARY KEY"
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(219):                 definition += " %s" % col_type_suffix
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(254):                     model._meta.db_table, field.column
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(256):                 if autoinc_sql:
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(318):         elif not self.connection.features.implied_column_null:
0.61 schema.py(319):             yield "NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(323):             yield "UNIQUE"
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(258):         constraints = [
0.61 schema.py(260):             for constraint in model._meta.constraints
0.61 schema.py(258):         constraints = [
0.61 schema.py(258):         constraints = [
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(268):         if model._meta.db_tablespace:
0.61 schema.py(274):         return sql, params
0.61 schema.py(438):         self.execute(sql, params or None)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.61 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.61 schema.py(1369):         output = []
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1373):         for field_names in model._meta.index_together:
0.61 schema.py(1377):         for index in model._meta.indexes:
0.61 schema.py(1383):         return output
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
0.61 schema.py(446):             if field.remote_field.through._meta.auto_created:
0.61 schema.py(447):                 self.create_model(field.remote_field.through)
0.61 schema.py(435):         sql, params = self.table_sql(model)
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(203):             self.deferred_sql.append(self._create_unique_sql(model, fields))
0.61 schema.py(1528):                 deferrable
0.61 schema.py(1526):         if (
0.61 schema.py(1531):             or (condition and not self.connection.features.supports_partial_indexes)
0.61 schema.py(1526):         if (
0.61 schema.py(1532):             or (include and not self.connection.features.supports_covering_indexes)
0.61 schema.py(1526):         if (
0.61 schema.py(1534):                 expressions and not self.connection.features.supports_expression_indexes
0.61 schema.py(1526):         if (
0.61 schema.py(1539):         def create_unique_name(*args, **kwargs):
0.61 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1543):             connection=self.connection
0.61 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1545):         table = model._meta.db_table
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1547):         if name is None:
0.61 schema.py(1548):             name = IndexName(table, columns, "_uniq", create_unique_name)
0.61 schema.py(1551):         if condition or include or opclasses or expressions:
0.61 schema.py(1554):             sql = self.sql_create_unique
0.61 schema.py(1555):         if columns:
0.61 schema.py(1556):             columns = self._index_columns(
0.61 schema.py(1557):                 table, columns, col_suffixes=(), opclasses=opclasses
0.61 schema.py(1556):             columns = self._index_columns(
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1561):         return Statement(
0.61 schema.py(1562):             sql,
0.61 schema.py(1563):             table=Table(table, self.quote_name),
0.61 schema.py(1564):             name=name,
0.61 schema.py(1565):             columns=columns,
0.61 schema.py(1566):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1567):             deferrable=self._deferrable_constraint_sql(deferrable),
0.61 schema.py(1468):         if deferrable is None:
0.61 schema.py(1469):             return ""
0.61 schema.py(1568):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1561):         return Statement(
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(205):         column_sqls = []
0.61 schema.py(206):         params = []
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(321):             yield "PRIMARY KEY"
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(219):                 definition += " %s" % col_type_suffix
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(254):                     model._meta.db_table, field.column
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(256):                 if autoinc_sql:
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(734):         return self.resolve_related_fields()
0.61 related.py(1103):         related_fields = super().resolve_related_fields()
0.61 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.61 related.py(711):         if isinstance(self.remote_field.model, str):
0.61 related.py(715):         related_fields = []
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(717):             from_field_name = self.from_fields[index]
0.61 related.py(718):             to_field_name = self.to_fields[index]
0.61 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.61 related.py(720):                 self
0.61 related.py(719):             from_field = (
0.61 related.py(726):                 if to_field_name is None
0.61 related.py(725):                 self.remote_field.model._meta.pk
0.61 related.py(724):             to_field = (
0.61 related.py(729):             related_fields.append((from_field, to_field))
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(730):         return related_fields
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1106):                 to_field
0.61 related.py(1105):             if (
0.61 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.61 related.py(1105):             if (
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1119):         return related_fields
0.61 related.py(746):         return tuple(
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(746):         return tuple(
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(734):         return self.resolve_related_fields()
0.61 related.py(1103):         related_fields = super().resolve_related_fields()
0.61 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.61 related.py(711):         if isinstance(self.remote_field.model, str):
0.61 related.py(715):         related_fields = []
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(717):             from_field_name = self.from_fields[index]
0.61 related.py(718):             to_field_name = self.to_fields[index]
0.61 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.61 related.py(720):                 self
0.61 related.py(719):             from_field = (
0.61 related.py(726):                 if to_field_name is None
0.61 related.py(725):                 self.remote_field.model._meta.pk
0.61 related.py(727):                 else self.remote_field.model._meta.get_field(to_field_name)
0.61 related.py(724):             to_field = (
0.61 related.py(729):             related_fields.append((from_field, to_field))
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(730):         return related_fields
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1106):                 to_field
0.61 related.py(1105):             if (
0.61 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.61 related.py(1105):             if (
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1119):         return related_fields
0.61 related.py(746):         return tuple(
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(746):         return tuple(
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(258):         constraints = [
0.61 schema.py(260):             for constraint in model._meta.constraints
0.61 schema.py(258):         constraints = [
0.61 schema.py(258):         constraints = [
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(268):         if model._meta.db_tablespace:
0.61 schema.py(274):         return sql, params
0.61 schema.py(438):         self.execute(sql, params or None)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.61 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.61 schema.py(1369):         output = []
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1373):         for field_names in model._meta.index_together:
0.61 schema.py(1377):         for index in model._meta.indexes:
0.61 schema.py(1383):         return output
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
0.61 schema.py(446):             if field.remote_field.through._meta.auto_created:
0.61 schema.py(447):                 self.create_model(field.remote_field.through)
0.61 schema.py(435):         sql, params = self.table_sql(model)
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(202):             fields = [model._meta.get_field(field) for field in field_names]
0.61 schema.py(203):             self.deferred_sql.append(self._create_unique_sql(model, fields))
0.61 schema.py(1528):                 deferrable
0.61 schema.py(1526):         if (
0.61 schema.py(1531):             or (condition and not self.connection.features.supports_partial_indexes)
0.61 schema.py(1526):         if (
0.61 schema.py(1532):             or (include and not self.connection.features.supports_covering_indexes)
0.61 schema.py(1526):         if (
0.61 schema.py(1534):                 expressions and not self.connection.features.supports_expression_indexes
0.61 schema.py(1526):         if (
0.61 schema.py(1539):         def create_unique_name(*args, **kwargs):
0.61 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1543):             connection=self.connection
0.61 schema.py(1542):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1545):         table = model._meta.db_table
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1546):         columns = [field.column for field in fields]
0.61 schema.py(1547):         if name is None:
0.61 schema.py(1548):             name = IndexName(table, columns, "_uniq", create_unique_name)
0.61 schema.py(1551):         if condition or include or opclasses or expressions:
0.61 schema.py(1554):             sql = self.sql_create_unique
0.61 schema.py(1555):         if columns:
0.61 schema.py(1556):             columns = self._index_columns(
0.61 schema.py(1557):                 table, columns, col_suffixes=(), opclasses=opclasses
0.61 schema.py(1556):             columns = self._index_columns(
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1561):         return Statement(
0.61 schema.py(1562):             sql,
0.61 schema.py(1563):             table=Table(table, self.quote_name),
0.61 schema.py(1564):             name=name,
0.61 schema.py(1565):             columns=columns,
0.61 schema.py(1566):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1567):             deferrable=self._deferrable_constraint_sql(deferrable),
0.61 schema.py(1468):         if deferrable is None:
0.61 schema.py(1469):             return ""
0.61 schema.py(1568):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1561):         return Statement(
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(205):         column_sqls = []
0.61 schema.py(206):         params = []
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(321):             yield "PRIMARY KEY"
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(219):                 definition += " %s" % col_type_suffix
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(254):                     model._meta.db_table, field.column
0.61 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.61 schema.py(256):                 if autoinc_sql:
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(734):         return self.resolve_related_fields()
0.61 related.py(1103):         related_fields = super().resolve_related_fields()
0.61 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.61 related.py(711):         if isinstance(self.remote_field.model, str):
0.61 related.py(715):         related_fields = []
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(717):             from_field_name = self.from_fields[index]
0.61 related.py(718):             to_field_name = self.to_fields[index]
0.61 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.61 related.py(720):                 self
0.61 related.py(719):             from_field = (
0.61 related.py(726):                 if to_field_name is None
0.61 related.py(725):                 self.remote_field.model._meta.pk
0.61 related.py(724):             to_field = (
0.61 related.py(729):             related_fields.append((from_field, to_field))
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(730):         return related_fields
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1106):                 to_field
0.61 related.py(1105):             if (
0.61 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.61 related.py(1105):             if (
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1119):         return related_fields
0.61 related.py(746):         return tuple(
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(746):         return tuple(
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(734):         return self.resolve_related_fields()
0.61 related.py(1103):         related_fields = super().resolve_related_fields()
0.61 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.61 related.py(711):         if isinstance(self.remote_field.model, str):
0.61 related.py(715):         related_fields = []
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(717):             from_field_name = self.from_fields[index]
0.61 related.py(718):             to_field_name = self.to_fields[index]
0.61 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.61 related.py(720):                 self
0.61 related.py(719):             from_field = (
0.61 related.py(726):                 if to_field_name is None
0.61 related.py(725):                 self.remote_field.model._meta.pk
0.61 related.py(727):                 else self.remote_field.model._meta.get_field(to_field_name)
0.61 related.py(724):             to_field = (
0.61 related.py(729):             related_fields.append((from_field, to_field))
0.61 related.py(716):         for index in range(len(self.from_fields)):
0.61 related.py(730):         return related_fields
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1106):                 to_field
0.61 related.py(1105):             if (
0.61 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.61 related.py(1105):             if (
0.61 related.py(1104):         for from_field, to_field in related_fields:
0.61 related.py(1119):         return related_fields
0.61 related.py(746):         return tuple(
0.61 related.py(746):         return tuple(
0.61 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.61 related.py(746):         return tuple(
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1185):             "type": self.db_type(connection),
0.61 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.61 related.py(1060):         return self.foreign_related_fields[0]
0.61 related.py(1186):             "check": self.db_check(connection),
0.61 related.py(1177):         return None
0.61 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.61 related.py(1184):         return {
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(225):                     field.remote_field.field_name
0.61 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.61 schema.py(227):                 if self.sql_create_inline_fk:
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(229):                         "to_table": self.quote_name(to_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(230):                         "to_column": self.quote_name(to_column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(258):         constraints = [
0.61 schema.py(260):             for constraint in model._meta.constraints
0.61 schema.py(258):         constraints = [
0.61 schema.py(258):         constraints = [
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(268):         if model._meta.db_tablespace:
0.61 schema.py(274):         return sql, params
0.61 schema.py(438):         self.execute(sql, params or None)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.61 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.61 schema.py(1369):         output = []
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1373):         for field_names in model._meta.index_together:
0.61 schema.py(1377):         for index in model._meta.indexes:
0.61 schema.py(1383):         return output
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
    Creating table django_session
0.61 schema.py(435):         sql, params = self.table_sql(model)
0.61 schema.py(201):         for field_names in model._meta.unique_together:
0.61 schema.py(205):         column_sqls = []
0.61 schema.py(206):         params = []
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(321):             yield "PRIMARY KEY"
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(312):             and not field.primary_key
0.61 schema.py(310):         if (
0.61 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.61 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(340):         column_db_type = field_db_params["type"]
0.61 schema.py(342):         if column_db_type is None:
0.61 schema.py(344):         params = []
0.61 schema.py(346):             " ".join(
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(349):                     column_db_type,
0.61 schema.py(350):                     params,
0.61 schema.py(351):                     model,
0.61 schema.py(352):                     field,
0.61 schema.py(353):                     field_db_params,
0.61 schema.py(354):                     include_default,
0.61 schema.py(348):                 self._iter_column_sql(
0.61 schema.py(346):             " ".join(
0.61 schema.py(281):         yield column_db_type
0.61 schema.py(282):         if collation := field_db_params.get("collation"):
0.61 schema.py(285):         null = field.null
0.61 schema.py(288):             include_default
0.61 schema.py(287):         include_default = (
0.61 schema.py(296):         if include_default:
0.61 schema.py(311):             field.empty_strings_allowed
0.61 schema.py(310):         if (
0.61 schema.py(316):         if not null:
0.61 schema.py(317):             yield "NOT NULL"
0.61 schema.py(320):         if field.primary_key:
0.61 schema.py(322):         elif field.unique:
0.61 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.61 schema.py(327):             tablespace
0.61 schema.py(326):         if (
0.61 schema.py(357):             params,
0.61 schema.py(345):         return (
0.61 schema.py(210):             if definition is None:
0.61 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.61 schema.py(214):             if db_params["check"]:
0.61 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.61 schema.py(218):             if col_type_suffix:
0.61 schema.py(220):             params.extend(extra_params)
0.61 schema.py(222):             if field.remote_field and field.db_constraint:
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(242):                     self.quote_name(field.column),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(243):                     definition,
0.61 schema.py(241):                 % (
0.61 schema.py(240):                 "%s %s"
0.61 schema.py(239):             column_sqls.append(
0.61 schema.py(248):             if field.get_internal_type() in (
0.61 schema.py(207):         for field in model._meta.local_fields:
0.61 schema.py(258):         constraints = [
0.61 schema.py(260):             for constraint in model._meta.constraints
0.61 schema.py(258):         constraints = [
0.61 schema.py(258):         constraints = [
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.61 schema.py(264):             "definition": ", ".join(
0.61 schema.py(262):         sql = self.sql_create_table % {
0.61 schema.py(268):         if model._meta.db_tablespace:
0.61 schema.py(274):         return sql, params
0.61 schema.py(438):         self.execute(sql, params or None)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.61 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.61 schema.py(1369):         output = []
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.61 schema.py(1389):         output = []
0.61 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.61 schema.py(1410):         return field.db_index and not field.unique
0.61 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.61 schema.py(1319):         fields = fields or []
0.61 schema.py(1320):         expressions = expressions or []
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1322):             connection=self.connection,
0.61 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.61 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.61 schema.py(1276):         if db_tablespace is None:
0.61 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.61 schema.py(1279):             elif model._meta.db_tablespace:
0.61 schema.py(1281):         if db_tablespace is not None:
0.61 schema.py(1283):         return ""
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1327):         columns = [field.column for field in fields]
0.61 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.61 schema.py(1329):         table = model._meta.db_table
0.61 schema.py(1331):         def create_index_name(*args, **kwargs):
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1338):             sql_create_index,
0.61 schema.py(1339):             table=Table(table, self.quote_name),
0.61 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.61 schema.py(1341):             using=using,
0.61 schema.py(1344):                 if columns
0.61 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.61 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.61 schema.py(1347):             extra=tablespace_sql,
0.61 schema.py(1348):             condition=self._index_condition_sql(condition),
0.61 schema.py(1286):         if condition:
0.61 schema.py(1288):         return ""
0.61 schema.py(1349):             include=self._index_include_sql(model, include),
0.61 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.61 schema.py(1292):             return ""
0.61 schema.py(1337):         return Statement(
0.61 schema.py(1392):         return output
0.61 schema.py(1370):         for field in model._meta.local_fields:
0.61 schema.py(1373):         for field_names in model._meta.index_together:
0.61 schema.py(1377):         for index in model._meta.indexes:
0.61 schema.py(1383):         return output
0.61 schema.py(445):         for field in model._meta.local_many_to_many:
    Running deferred SQL...
0.61 schema.py(39):         self.connection.check_constraints()
0.61 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.61 schema.py(155):         if exc_type is None:
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1540):             return self.quote_name(self._create_index_name(*args, **kwargs))
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1540):             return self.quote_name(self._create_index_name(*args, **kwargs))
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1540):             return self.quote_name(self._create_index_name(*args, **kwargs))
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1540):             return self.quote_name(self._create_index_name(*args, **kwargs))
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1540):             return self.quote_name(self._create_index_name(*args, **kwargs))
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(157):                 self.execute(sql)
0.61 schema.py(168):             not self.collect_sql
0.61 schema.py(167):         if (
0.61 schema.py(169):             and self.connection.in_atomic_block
0.61 schema.py(167):         if (
0.61 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.61 schema.py(167):         if (
0.61 schema.py(177):         sql = str(sql)
0.61 schema.py(1333):             if name is None:
0.61 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.61 schema.py(1250):         _, table_name = split_identifier(table_name)
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.61 schema.py(1253):             suffix,
0.61 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.61 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.61 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.61 schema.py(1258):         if len(index_name) <= max_length:
0.61 schema.py(1259):             return index_name
0.61 schema.py(1335):             return self.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(195):         return self.connection.ops.quote_name(name)
0.61 schema.py(179):         logger.debug(
0.61 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.61 schema.py(179):         logger.debug(
0.61 schema.py(182):         if self.collect_sql:
0.61 schema.py(191):             with self.connection.cursor() as cursor:
0.61 schema.py(192):                 cursor.execute(sql, params)
0.61 schema.py(156):             for sql in self.deferred_sql:
0.61 schema.py(158):         if self.atomic_migration:
0.61 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.61 schema.py(41):         self.connection.enable_constraint_checking()
Running migrations:
0.62 schema.py(139):         self.connection = connection
0.62 schema.py(140):         self.collect_sql = collect_sql
0.62 schema.py(141):         if self.collect_sql:
0.62 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.62 schema.py(28):         if not self.connection.disable_constraint_checking():
0.62 schema.py(36):         return super().__enter__()
0.62 schema.py(148):         self.deferred_sql = []
0.62 schema.py(149):         if self.atomic_migration:
0.62 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.62 schema.py(151):             self.atomic.__enter__()
0.62 schema.py(152):         return self
0.62 schema.py(435):         sql, params = self.table_sql(model)
0.62 schema.py(201):         for field_names in model._meta.unique_together:
0.62 schema.py(205):         column_sqls = []
0.62 schema.py(206):         params = []
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(321):             yield "PRIMARY KEY"
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(219):                 definition += " %s" % col_type_suffix
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.62 schema.py(254):                     model._meta.db_table, field.column
0.62 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.62 schema.py(256):                 if autoinc_sql:
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(312):             and not field.primary_key
0.62 schema.py(310):         if (
0.62 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(312):             and not field.primary_key
0.62 schema.py(310):         if (
0.62 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(258):         constraints = [
0.62 schema.py(260):             for constraint in model._meta.constraints
0.62 schema.py(258):         constraints = [
0.62 schema.py(258):         constraints = [
0.62 schema.py(262):         sql = self.sql_create_table % {
0.62 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(262):         sql = self.sql_create_table % {
0.62 schema.py(268):         if model._meta.db_tablespace:
0.62 schema.py(274):         return sql, params
0.62 schema.py(438):         self.execute(sql, params or None)
0.62 schema.py(168):             not self.collect_sql
0.62 schema.py(167):         if (
0.62 schema.py(169):             and self.connection.in_atomic_block
0.62 schema.py(167):         if (
0.62 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.62 schema.py(167):         if (
0.62 schema.py(177):         sql = str(sql)
0.62 schema.py(179):         logger.debug(
0.62 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.62 schema.py(179):         logger.debug(
0.62 schema.py(182):         if self.collect_sql:
0.62 schema.py(191):             with self.connection.cursor() as cursor:
0.62 schema.py(192):                 cursor.execute(sql, params)
0.62 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.62 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.62 schema.py(1369):         output = []
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1373):         for field_names in model._meta.index_together:
0.62 schema.py(1377):         for index in model._meta.indexes:
0.62 schema.py(1383):         return output
0.62 schema.py(445):         for field in model._meta.local_many_to_many:
0.62 schema.py(39):         self.connection.check_constraints()
0.62 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.62 schema.py(155):         if exc_type is None:
0.62 schema.py(156):             for sql in self.deferred_sql:
0.62 schema.py(158):         if self.atomic_migration:
0.62 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.62 schema.py(41):         self.connection.enable_constraint_checking()
  Applying admin.0001_initial...0.62 schema.py(139):         self.connection = connection
0.62 schema.py(140):         self.collect_sql = collect_sql
0.62 schema.py(141):         if self.collect_sql:
0.62 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.62 schema.py(28):         if not self.connection.disable_constraint_checking():
0.62 schema.py(36):         return super().__enter__()
0.62 schema.py(148):         self.deferred_sql = []
0.62 schema.py(149):         if self.atomic_migration:
0.62 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.62 schema.py(151):             self.atomic.__enter__()
0.62 schema.py(152):         return self
0.62 related.py(113):         apps.check_models_ready()
0.62 related.py(114):         return self.remote_field.model
0.62 related.py(113):         apps.check_models_ready()
0.62 related.py(114):         return self.remote_field.model
0.62 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(382):         if self._limit_choices_to:
0.62 related.py(384):         if self._related_name is not None:
0.62 related.py(386):         if self._related_query_name is not None:
0.62 related.py(388):         return name, path, args, kwargs
0.62 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.62 related.py(674):         kwargs["from_fields"] = self.from_fields
0.62 related.py(675):         kwargs["to_fields"] = self.to_fields
0.62 related.py(677):         if self.remote_field.parent_link:
0.62 related.py(679):         if isinstance(self.remote_field.model, str):
0.62 related.py(680):             if "." in self.remote_field.model:
0.62 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.62 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.62 related.py(689):         swappable_setting = self.swappable_setting
0.62 related.py(428):         if self.swappable:
0.62 related.py(430):             if isinstance(self.remote_field.model, str):
0.62 related.py(431):                 to_string = self.remote_field.model
0.62 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.62 related.py(690):         if swappable_setting is not None:
0.62 related.py(704):         return name, path, args, kwargs
0.62 related.py(1037):         del kwargs["to_fields"]
0.62 related.py(1038):         del kwargs["from_fields"]
0.62 related.py(1040):         if self.db_index:
0.62 related.py(1041):             del kwargs["db_index"]
0.62 related.py(1044):         if self.db_constraint is not True:
0.62 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.62 related.py(1048):         if self.remote_field.field_name and (
0.62 related.py(1053):         return name, path, args, kwargs
0.62 related.py(936):         try:
0.62 related.py(937):             to._meta.model_name
0.62 related.py(938):         except AttributeError:
0.62 related.py(939):             if not isinstance(to, str):
0.62 related.py(954):         if not callable(on_delete):
0.62 related.py(957):         kwargs["rel"] = self.rel_class(
0.62 related.py(958):             self,
0.62 related.py(959):             to,
0.62 related.py(960):             to_field,
0.62 related.py(961):             related_name=related_name,
0.62 related.py(962):             related_query_name=related_query_name,
0.62 related.py(963):             limit_choices_to=limit_choices_to,
0.62 related.py(964):             parent_link=parent_link,
0.62 related.py(965):             on_delete=on_delete,
0.62 related.py(957):         kwargs["rel"] = self.rel_class(
0.62 related.py(967):         kwargs.setdefault("db_index", True)
0.62 related.py(969):         super().__init__(
0.62 related.py(970):             to,
0.62 related.py(971):             on_delete,
0.62 related.py(969):         super().__init__(
0.62 related.py(972):             related_name=related_name,
0.62 related.py(973):             related_query_name=related_query_name,
0.62 related.py(974):             limit_choices_to=limit_choices_to,
0.62 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.62 related.py(976):             to_fields=[to_field],
0.62 related.py(969):         super().__init__(
0.62 related.py(977):             **kwargs,
0.62 related.py(969):         super().__init__(
0.62 related.py(544):         if rel is None:
0.62 related.py(555):         super().__init__(
0.62 related.py(556):             rel=rel,
0.62 related.py(557):             related_name=related_name,
0.62 related.py(558):             related_query_name=related_query_name,
0.62 related.py(559):             limit_choices_to=limit_choices_to,
0.62 related.py(555):         super().__init__(
0.62 related.py(560):             **kwargs,
0.62 related.py(555):         super().__init__(
0.62 related.py(105):         self._related_name = related_name
0.62 related.py(106):         self._related_query_name = related_query_name
0.62 related.py(107):         self._limit_choices_to = limit_choices_to
0.62 related.py(108):         super().__init__(**kwargs)
0.62 related.py(563):         self.from_fields = from_fields
0.62 related.py(564):         self.to_fields = to_fields
0.62 related.py(565):         self.swappable = swappable
0.62 related.py(979):         self.db_constraint = db_constraint
0.62 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.62 related.py(382):         if self._limit_choices_to:
0.62 related.py(384):         if self._related_name is not None:
0.62 related.py(386):         if self._related_query_name is not None:
0.62 related.py(388):         return name, path, args, kwargs
0.62 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.62 related.py(674):         kwargs["from_fields"] = self.from_fields
0.62 related.py(675):         kwargs["to_fields"] = self.to_fields
0.62 related.py(677):         if self.remote_field.parent_link:
0.62 related.py(679):         if isinstance(self.remote_field.model, str):
0.62 related.py(680):             if "." in self.remote_field.model:
0.62 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.62 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.62 related.py(689):         swappable_setting = self.swappable_setting
0.62 related.py(428):         if self.swappable:
0.62 related.py(430):             if isinstance(self.remote_field.model, str):
0.62 related.py(431):                 to_string = self.remote_field.model
0.62 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.62 related.py(690):         if swappable_setting is not None:
0.62 related.py(692):             if hasattr(kwargs["to"], "setting_name"):
0.62 related.py(700):             kwargs["to"] = SettingsReference(
0.62 related.py(701):                 kwargs["to"],
0.62 related.py(702):                 swappable_setting,
0.62 related.py(700):             kwargs["to"] = SettingsReference(
0.62 related.py(704):         return name, path, args, kwargs
0.62 related.py(1037):         del kwargs["to_fields"]
0.62 related.py(1038):         del kwargs["from_fields"]
0.62 related.py(1040):         if self.db_index:
0.62 related.py(1041):             del kwargs["db_index"]
0.62 related.py(1044):         if self.db_constraint is not True:
0.62 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.62 related.py(1048):         if self.remote_field.field_name and (
0.62 related.py(1053):         return name, path, args, kwargs
0.62 related.py(936):         try:
0.62 related.py(937):             to._meta.model_name
0.62 related.py(938):         except AttributeError:
0.62 related.py(939):             if not isinstance(to, str):
0.62 related.py(954):         if not callable(on_delete):
0.62 related.py(957):         kwargs["rel"] = self.rel_class(
0.62 related.py(958):             self,
0.62 related.py(959):             to,
0.62 related.py(960):             to_field,
0.62 related.py(961):             related_name=related_name,
0.62 related.py(962):             related_query_name=related_query_name,
0.62 related.py(963):             limit_choices_to=limit_choices_to,
0.62 related.py(964):             parent_link=parent_link,
0.62 related.py(965):             on_delete=on_delete,
0.62 related.py(957):         kwargs["rel"] = self.rel_class(
0.62 related.py(967):         kwargs.setdefault("db_index", True)
0.62 related.py(969):         super().__init__(
0.62 related.py(970):             to,
0.62 related.py(971):             on_delete,
0.62 related.py(969):         super().__init__(
0.62 related.py(972):             related_name=related_name,
0.62 related.py(973):             related_query_name=related_query_name,
0.62 related.py(974):             limit_choices_to=limit_choices_to,
0.62 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.62 related.py(976):             to_fields=[to_field],
0.62 related.py(969):         super().__init__(
0.62 related.py(977):             **kwargs,
0.62 related.py(969):         super().__init__(
0.62 related.py(544):         if rel is None:
0.62 related.py(555):         super().__init__(
0.62 related.py(556):             rel=rel,
0.62 related.py(557):             related_name=related_name,
0.62 related.py(558):             related_query_name=related_query_name,
0.62 related.py(559):             limit_choices_to=limit_choices_to,
0.62 related.py(555):         super().__init__(
0.62 related.py(560):             **kwargs,
0.62 related.py(555):         super().__init__(
0.62 related.py(105):         self._related_name = related_name
0.62 related.py(106):         self._related_query_name = related_query_name
0.62 related.py(107):         self._limit_choices_to = limit_choices_to
0.62 related.py(108):         super().__init__(**kwargs)
0.62 related.py(563):         self.from_fields = from_fields
0.62 related.py(564):         self.to_fields = to_fields
0.62 related.py(565):         self.swappable = swappable
0.62 related.py(979):         self.db_constraint = db_constraint
0.62 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.62 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.62 related.py(1125):         attname = self.get_attname()
0.62 related.py(1122):         return "%s_id" % self.name
0.62 related.py(1126):         column = self.db_column or attname
0.62 related.py(1127):         return attname, column
0.62 related.py(350):         self.opts = cls._meta
0.62 related.py(352):         if not cls._meta.abstract:
0.62 related.py(353):             if self.remote_field.related_name:
0.62 related.py(356):                 related_name = self.opts.default_related_name
0.62 related.py(357):             if related_name:
0.62 related.py(365):             if self.remote_field.related_query_name:
0.62 related.py(372):             def resolve_related_class(model, related, field):
0.62 related.py(376):             lazy_related_operation(
0.62 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.62 related.py(376):             lazy_related_operation(
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.62 related.py(61):     if isinstance(relation, str):
0.62 related.py(62):         if "." not in relation:
0.62 related.py(65):     return relation
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(85):     apps = model._meta.apps
0.62 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.62 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.62 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.62 related.py(1125):         attname = self.get_attname()
0.62 related.py(1122):         return "%s_id" % self.name
0.62 related.py(1126):         column = self.db_column or attname
0.62 related.py(1127):         return attname, column
0.62 related.py(350):         self.opts = cls._meta
0.62 related.py(352):         if not cls._meta.abstract:
0.62 related.py(353):             if self.remote_field.related_name:
0.62 related.py(356):                 related_name = self.opts.default_related_name
0.62 related.py(357):             if related_name:
0.62 related.py(365):             if self.remote_field.related_query_name:
0.62 related.py(372):             def resolve_related_class(model, related, field):
0.62 related.py(376):             lazy_related_operation(
0.62 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.62 related.py(376):             lazy_related_operation(
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.62 related.py(61):     if isinstance(relation, str):
0.62 related.py(62):         if "." not in relation:
0.62 related.py(65):     return relation
0.62 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(85):     apps = model._meta.apps
0.62 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.62 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.62 related.py(373):                 field.remote_field.model = related
0.62 related.py(374):                 field.do_related_class(related, model)
0.62 related.py(448):         self.set_attributes_from_rel()
0.62 related.py(438):         self.name = self.name or (
0.62 related.py(438):         self.name = self.name or (
0.62 related.py(443):         if self.verbose_name is None:
0.62 related.py(445):         self.remote_field.set_field_name()
0.62 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.62 related.py(1155):         super().contribute_to_related_class(cls, related)
0.62 related.py(874):             not self.remote_field.is_hidden()
0.62 related.py(873):         if (
0.62 related.py(875):             and not related.related_model._meta.swapped
0.62 related.py(873):         if (
0.62 related.py(877):             setattr(
0.62 related.py(878):                 cls._meta.concrete_model,
0.62 related.py(879):                 related.get_accessor_name(),
0.62 related.py(880):                 self.related_accessor_class(related),
0.62 related.py(877):             setattr(
0.62 related.py(885):             if self.remote_field.limit_choices_to:
0.62 related.py(1156):         if self.remote_field.field_name is None:
0.62 related.py(373):                 field.remote_field.model = related
0.62 related.py(374):                 field.do_related_class(related, model)
0.62 related.py(448):         self.set_attributes_from_rel()
0.62 related.py(438):         self.name = self.name or (
0.62 related.py(438):         self.name = self.name or (
0.62 related.py(443):         if self.verbose_name is None:
0.62 related.py(445):         self.remote_field.set_field_name()
0.62 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.62 related.py(1155):         super().contribute_to_related_class(cls, related)
0.62 related.py(874):             not self.remote_field.is_hidden()
0.62 related.py(873):         if (
0.62 related.py(875):             and not related.related_model._meta.swapped
0.62 related.py(873):         if (
0.62 related.py(877):             setattr(
0.62 related.py(878):                 cls._meta.concrete_model,
0.62 related.py(879):                 related.get_accessor_name(),
0.62 related.py(880):                 self.related_accessor_class(related),
0.62 related.py(877):             setattr(
0.62 related.py(885):             if self.remote_field.limit_choices_to:
0.62 related.py(1156):         if self.remote_field.field_name is None:
0.62 schema.py(435):         sql, params = self.table_sql(model)
0.62 schema.py(201):         for field_names in model._meta.unique_together:
0.62 schema.py(205):         column_sqls = []
0.62 schema.py(206):         params = []
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(321):             yield "PRIMARY KEY"
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(219):                 definition += " %s" % col_type_suffix
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.62 schema.py(254):                     model._meta.db_table, field.column
0.62 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.62 schema.py(256):                 if autoinc_sql:
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(312):             and not field.primary_key
0.62 schema.py(310):         if (
0.62 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(318):         elif not self.connection.features.implied_column_null:
0.62 schema.py(319):             yield "NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(312):             and not field.primary_key
0.62 schema.py(310):         if (
0.62 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(215):                 definition += " " + self.sql_check_constraint % db_params
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(312):             and not field.primary_key
0.62 schema.py(310):         if (
0.62 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(746):         return tuple(
0.62 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.62 related.py(734):         return self.resolve_related_fields()
0.62 related.py(1103):         related_fields = super().resolve_related_fields()
0.62 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.62 related.py(711):         if isinstance(self.remote_field.model, str):
0.62 related.py(715):         related_fields = []
0.62 related.py(716):         for index in range(len(self.from_fields)):
0.62 related.py(717):             from_field_name = self.from_fields[index]
0.62 related.py(718):             to_field_name = self.to_fields[index]
0.62 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.62 related.py(720):                 self
0.62 related.py(719):             from_field = (
0.62 related.py(726):                 if to_field_name is None
0.62 related.py(725):                 self.remote_field.model._meta.pk
0.62 related.py(724):             to_field = (
0.62 related.py(729):             related_fields.append((from_field, to_field))
0.62 related.py(716):         for index in range(len(self.from_fields)):
0.62 related.py(730):         return related_fields
0.62 related.py(1104):         for from_field, to_field in related_fields:
0.62 related.py(1106):                 to_field
0.62 related.py(1105):             if (
0.62 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.62 related.py(1105):             if (
0.62 related.py(1104):         for from_field, to_field in related_fields:
0.62 related.py(1119):         return related_fields
0.62 related.py(746):         return tuple(
0.62 related.py(746):         return tuple(
0.62 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.62 related.py(746):         return tuple(
0.62 related.py(1185):             "type": self.db_type(connection),
0.62 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1186):             "check": self.db_check(connection),
0.62 related.py(1177):         return None
0.62 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.62 related.py(1184):         return {
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(318):         elif not self.connection.features.implied_column_null:
0.62 schema.py(319):             yield "NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1185):             "type": self.db_type(connection),
0.62 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1186):             "check": self.db_check(connection),
0.62 related.py(1177):         return None
0.62 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.62 related.py(1184):         return {
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.62 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.62 schema.py(225):                     field.remote_field.field_name
0.62 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.62 schema.py(227):                 if self.sql_create_inline_fk:
0.62 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.62 schema.py(229):                         "to_table": self.quote_name(to_table),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(230):                         "to_column": self.quote_name(to_column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.62 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.62 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(746):         return tuple(
0.62 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.62 related.py(734):         return self.resolve_related_fields()
0.62 related.py(1103):         related_fields = super().resolve_related_fields()
0.62 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.62 related.py(711):         if isinstance(self.remote_field.model, str):
0.62 related.py(715):         related_fields = []
0.62 related.py(716):         for index in range(len(self.from_fields)):
0.62 related.py(717):             from_field_name = self.from_fields[index]
0.62 related.py(718):             to_field_name = self.to_fields[index]
0.62 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.62 related.py(720):                 self
0.62 related.py(719):             from_field = (
0.62 related.py(726):                 if to_field_name is None
0.62 related.py(725):                 self.remote_field.model._meta.pk
0.62 related.py(724):             to_field = (
0.62 related.py(729):             related_fields.append((from_field, to_field))
0.62 related.py(716):         for index in range(len(self.from_fields)):
0.62 related.py(730):         return related_fields
0.62 related.py(1104):         for from_field, to_field in related_fields:
0.62 related.py(1106):                 to_field
0.62 related.py(1105):             if (
0.62 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.62 related.py(1105):             if (
0.62 related.py(1104):         for from_field, to_field in related_fields:
0.62 related.py(1119):         return related_fields
0.62 related.py(746):         return tuple(
0.62 related.py(746):         return tuple(
0.62 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.62 related.py(746):         return tuple(
0.62 related.py(1185):             "type": self.db_type(connection),
0.62 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1186):             "check": self.db_check(connection),
0.62 related.py(1177):         return None
0.62 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.62 related.py(1184):         return {
0.62 schema.py(340):         column_db_type = field_db_params["type"]
0.62 schema.py(342):         if column_db_type is None:
0.62 schema.py(344):         params = []
0.62 schema.py(346):             " ".join(
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(349):                     column_db_type,
0.62 schema.py(350):                     params,
0.62 schema.py(351):                     model,
0.62 schema.py(352):                     field,
0.62 schema.py(353):                     field_db_params,
0.62 schema.py(354):                     include_default,
0.62 schema.py(348):                 self._iter_column_sql(
0.62 schema.py(346):             " ".join(
0.62 schema.py(281):         yield column_db_type
0.62 schema.py(282):         if collation := field_db_params.get("collation"):
0.62 schema.py(285):         null = field.null
0.62 schema.py(288):             include_default
0.62 schema.py(287):         include_default = (
0.62 schema.py(296):         if include_default:
0.62 schema.py(311):             field.empty_strings_allowed
0.62 schema.py(310):         if (
0.62 schema.py(316):         if not null:
0.62 schema.py(317):             yield "NOT NULL"
0.62 schema.py(320):         if field.primary_key:
0.62 schema.py(322):         elif field.unique:
0.62 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.62 schema.py(327):             tablespace
0.62 schema.py(326):         if (
0.62 schema.py(357):             params,
0.62 schema.py(345):         return (
0.62 schema.py(210):             if definition is None:
0.62 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.62 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1185):             "type": self.db_type(connection),
0.62 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.62 related.py(1060):         return self.foreign_related_fields[0]
0.62 related.py(1186):             "check": self.db_check(connection),
0.62 related.py(1177):         return None
0.62 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.62 related.py(1184):         return {
0.62 schema.py(214):             if db_params["check"]:
0.62 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.62 schema.py(218):             if col_type_suffix:
0.62 schema.py(220):             params.extend(extra_params)
0.62 schema.py(222):             if field.remote_field and field.db_constraint:
0.62 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.62 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.62 schema.py(225):                     field.remote_field.field_name
0.62 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.62 schema.py(227):                 if self.sql_create_inline_fk:
0.62 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.62 schema.py(229):                         "to_table": self.quote_name(to_table),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(230):                         "to_column": self.quote_name(to_column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(242):                     self.quote_name(field.column),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(243):                     definition,
0.62 schema.py(241):                 % (
0.62 schema.py(240):                 "%s %s"
0.62 schema.py(239):             column_sqls.append(
0.62 schema.py(248):             if field.get_internal_type() in (
0.62 schema.py(207):         for field in model._meta.local_fields:
0.62 schema.py(258):         constraints = [
0.62 schema.py(260):             for constraint in model._meta.constraints
0.62 schema.py(258):         constraints = [
0.62 schema.py(258):         constraints = [
0.62 schema.py(262):         sql = self.sql_create_table % {
0.62 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.62 schema.py(264):             "definition": ", ".join(
0.62 schema.py(262):         sql = self.sql_create_table % {
0.62 schema.py(268):         if model._meta.db_tablespace:
0.62 schema.py(274):         return sql, params
0.62 schema.py(438):         self.execute(sql, params or None)
0.62 schema.py(168):             not self.collect_sql
0.62 schema.py(167):         if (
0.62 schema.py(169):             and self.connection.in_atomic_block
0.62 schema.py(167):         if (
0.62 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.62 schema.py(167):         if (
0.62 schema.py(177):         sql = str(sql)
0.62 schema.py(179):         logger.debug(
0.62 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.62 schema.py(179):         logger.debug(
0.62 schema.py(182):         if self.collect_sql:
0.62 schema.py(191):             with self.connection.cursor() as cursor:
0.62 schema.py(192):                 cursor.execute(sql, params)
0.62 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.62 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.62 schema.py(1369):         output = []
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.62 schema.py(1319):         fields = fields or []
0.62 schema.py(1320):         expressions = expressions or []
0.62 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.62 schema.py(1322):             connection=self.connection,
0.62 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.62 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.62 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.62 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.62 schema.py(1276):         if db_tablespace is None:
0.62 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.62 schema.py(1279):             elif model._meta.db_tablespace:
0.62 schema.py(1281):         if db_tablespace is not None:
0.62 schema.py(1283):         return ""
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.62 schema.py(1329):         table = model._meta.db_table
0.62 schema.py(1331):         def create_index_name(*args, **kwargs):
0.62 schema.py(1337):         return Statement(
0.62 schema.py(1338):             sql_create_index,
0.62 schema.py(1339):             table=Table(table, self.quote_name),
0.62 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.62 schema.py(1341):             using=using,
0.62 schema.py(1344):                 if columns
0.62 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.62 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.62 schema.py(1347):             extra=tablespace_sql,
0.62 schema.py(1348):             condition=self._index_condition_sql(condition),
0.62 schema.py(1286):         if condition:
0.62 schema.py(1288):         return ""
0.62 schema.py(1349):             include=self._index_include_sql(model, include),
0.62 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.62 schema.py(1292):             return ""
0.62 schema.py(1337):         return Statement(
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.62 schema.py(1389):         output = []
0.62 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.62 schema.py(1410):         return field.db_index and not field.unique
0.62 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.62 schema.py(1319):         fields = fields or []
0.62 schema.py(1320):         expressions = expressions or []
0.62 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.62 schema.py(1322):             connection=self.connection,
0.62 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.62 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.62 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.62 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.62 schema.py(1276):         if db_tablespace is None:
0.62 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.62 schema.py(1279):             elif model._meta.db_tablespace:
0.62 schema.py(1281):         if db_tablespace is not None:
0.62 schema.py(1283):         return ""
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1327):         columns = [field.column for field in fields]
0.62 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.62 schema.py(1329):         table = model._meta.db_table
0.62 schema.py(1331):         def create_index_name(*args, **kwargs):
0.62 schema.py(1337):         return Statement(
0.62 schema.py(1338):             sql_create_index,
0.62 schema.py(1339):             table=Table(table, self.quote_name),
0.62 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.62 schema.py(1341):             using=using,
0.62 schema.py(1344):                 if columns
0.62 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.62 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.62 schema.py(1347):             extra=tablespace_sql,
0.62 schema.py(1348):             condition=self._index_condition_sql(condition),
0.62 schema.py(1286):         if condition:
0.62 schema.py(1288):         return ""
0.62 schema.py(1349):             include=self._index_include_sql(model, include),
0.62 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.62 schema.py(1292):             return ""
0.62 schema.py(1337):         return Statement(
0.62 schema.py(1392):         return output
0.62 schema.py(1370):         for field in model._meta.local_fields:
0.62 schema.py(1373):         for field_names in model._meta.index_together:
0.62 schema.py(1377):         for index in model._meta.indexes:
0.62 schema.py(1383):         return output
0.62 schema.py(445):         for field in model._meta.local_many_to_many:
0.62 schema.py(39):         self.connection.check_constraints()
0.62 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.62 schema.py(155):         if exc_type is None:
0.62 schema.py(156):             for sql in self.deferred_sql:
0.62 schema.py(157):                 self.execute(sql)
0.62 schema.py(168):             not self.collect_sql
0.62 schema.py(167):         if (
0.62 schema.py(169):             and self.connection.in_atomic_block
0.62 schema.py(167):         if (
0.62 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.62 schema.py(167):         if (
0.62 schema.py(177):         sql = str(sql)
0.62 schema.py(1333):             if name is None:
0.62 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.62 schema.py(1250):         _, table_name = split_identifier(table_name)
0.62 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.62 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.62 schema.py(1253):             suffix,
0.62 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.62 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.62 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.62 schema.py(1258):         if len(index_name) <= max_length:
0.62 schema.py(1259):             return index_name
0.62 schema.py(1335):             return self.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(179):         logger.debug(
0.62 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.62 schema.py(179):         logger.debug(
0.62 schema.py(182):         if self.collect_sql:
0.62 schema.py(191):             with self.connection.cursor() as cursor:
0.62 schema.py(192):                 cursor.execute(sql, params)
0.62 schema.py(156):             for sql in self.deferred_sql:
0.62 schema.py(157):                 self.execute(sql)
0.62 schema.py(168):             not self.collect_sql
0.62 schema.py(167):         if (
0.62 schema.py(169):             and self.connection.in_atomic_block
0.62 schema.py(167):         if (
0.62 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.62 schema.py(167):         if (
0.62 schema.py(177):         sql = str(sql)
0.62 schema.py(1333):             if name is None:
0.62 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.62 schema.py(1250):         _, table_name = split_identifier(table_name)
0.62 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.62 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.62 schema.py(1253):             suffix,
0.62 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.62 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.62 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.62 schema.py(1258):         if len(index_name) <= max_length:
0.62 schema.py(1259):             return index_name
0.62 schema.py(1335):             return self.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(195):         return self.connection.ops.quote_name(name)
0.62 schema.py(179):         logger.debug(
0.62 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.62 schema.py(179):         logger.debug(
0.62 schema.py(182):         if self.collect_sql:
0.62 schema.py(191):             with self.connection.cursor() as cursor:
0.62 schema.py(192):                 cursor.execute(sql, params)
0.62 schema.py(156):             for sql in self.deferred_sql:
0.62 schema.py(158):         if self.atomic_migration:
0.62 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.62 schema.py(41):         self.connection.enable_constraint_checking()
 OK
  Applying admin.0002_logentry_remove_auto_add...0.63 schema.py(139):         self.connection = connection
0.63 schema.py(140):         self.collect_sql = collect_sql
0.63 schema.py(141):         if self.collect_sql:
0.63 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.63 schema.py(28):         if not self.connection.disable_constraint_checking():
0.63 schema.py(36):         return super().__enter__()
0.63 schema.py(148):         self.deferred_sql = []
0.63 schema.py(149):         if self.atomic_migration:
0.63 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.63 schema.py(151):             self.atomic.__enter__()
0.63 schema.py(152):         return self
0.63 related.py(113):         apps.check_models_ready()
0.63 related.py(114):         return self.remote_field.model
0.63 related.py(113):         apps.check_models_ready()
0.63 related.py(114):         return self.remote_field.model
0.63 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(382):         if self._limit_choices_to:
0.63 related.py(384):         if self._related_name is not None:
0.63 related.py(386):         if self._related_query_name is not None:
0.63 related.py(388):         return name, path, args, kwargs
0.63 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.63 related.py(674):         kwargs["from_fields"] = self.from_fields
0.63 related.py(675):         kwargs["to_fields"] = self.to_fields
0.63 related.py(677):         if self.remote_field.parent_link:
0.63 related.py(679):         if isinstance(self.remote_field.model, str):
0.63 related.py(680):             if "." in self.remote_field.model:
0.63 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.63 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.63 related.py(689):         swappable_setting = self.swappable_setting
0.63 related.py(428):         if self.swappable:
0.63 related.py(430):             if isinstance(self.remote_field.model, str):
0.63 related.py(431):                 to_string = self.remote_field.model
0.63 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.63 related.py(690):         if swappable_setting is not None:
0.63 related.py(704):         return name, path, args, kwargs
0.63 related.py(1037):         del kwargs["to_fields"]
0.63 related.py(1038):         del kwargs["from_fields"]
0.63 related.py(1040):         if self.db_index:
0.63 related.py(1041):             del kwargs["db_index"]
0.63 related.py(1044):         if self.db_constraint is not True:
0.63 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.63 related.py(1048):         if self.remote_field.field_name and (
0.63 related.py(1053):         return name, path, args, kwargs
0.63 related.py(936):         try:
0.63 related.py(937):             to._meta.model_name
0.63 related.py(938):         except AttributeError:
0.63 related.py(939):             if not isinstance(to, str):
0.63 related.py(954):         if not callable(on_delete):
0.63 related.py(957):         kwargs["rel"] = self.rel_class(
0.63 related.py(958):             self,
0.63 related.py(959):             to,
0.63 related.py(960):             to_field,
0.63 related.py(961):             related_name=related_name,
0.63 related.py(962):             related_query_name=related_query_name,
0.63 related.py(963):             limit_choices_to=limit_choices_to,
0.63 related.py(964):             parent_link=parent_link,
0.63 related.py(965):             on_delete=on_delete,
0.63 related.py(957):         kwargs["rel"] = self.rel_class(
0.63 related.py(967):         kwargs.setdefault("db_index", True)
0.63 related.py(969):         super().__init__(
0.63 related.py(970):             to,
0.63 related.py(971):             on_delete,
0.63 related.py(969):         super().__init__(
0.63 related.py(972):             related_name=related_name,
0.63 related.py(973):             related_query_name=related_query_name,
0.63 related.py(974):             limit_choices_to=limit_choices_to,
0.63 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.63 related.py(976):             to_fields=[to_field],
0.63 related.py(969):         super().__init__(
0.63 related.py(977):             **kwargs,
0.63 related.py(969):         super().__init__(
0.63 related.py(544):         if rel is None:
0.63 related.py(555):         super().__init__(
0.63 related.py(556):             rel=rel,
0.63 related.py(557):             related_name=related_name,
0.63 related.py(558):             related_query_name=related_query_name,
0.63 related.py(559):             limit_choices_to=limit_choices_to,
0.63 related.py(555):         super().__init__(
0.63 related.py(560):             **kwargs,
0.63 related.py(555):         super().__init__(
0.63 related.py(105):         self._related_name = related_name
0.63 related.py(106):         self._related_query_name = related_query_name
0.63 related.py(107):         self._limit_choices_to = limit_choices_to
0.63 related.py(108):         super().__init__(**kwargs)
0.63 related.py(563):         self.from_fields = from_fields
0.63 related.py(564):         self.to_fields = to_fields
0.63 related.py(565):         self.swappable = swappable
0.63 related.py(979):         self.db_constraint = db_constraint
0.63 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.63 related.py(382):         if self._limit_choices_to:
0.63 related.py(384):         if self._related_name is not None:
0.63 related.py(386):         if self._related_query_name is not None:
0.63 related.py(388):         return name, path, args, kwargs
0.63 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.63 related.py(674):         kwargs["from_fields"] = self.from_fields
0.63 related.py(675):         kwargs["to_fields"] = self.to_fields
0.63 related.py(677):         if self.remote_field.parent_link:
0.63 related.py(679):         if isinstance(self.remote_field.model, str):
0.63 related.py(680):             if "." in self.remote_field.model:
0.63 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.63 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.63 related.py(689):         swappable_setting = self.swappable_setting
0.63 related.py(428):         if self.swappable:
0.63 related.py(430):             if isinstance(self.remote_field.model, str):
0.63 related.py(431):                 to_string = self.remote_field.model
0.63 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.63 related.py(690):         if swappable_setting is not None:
0.63 related.py(692):             if hasattr(kwargs["to"], "setting_name"):
0.63 related.py(700):             kwargs["to"] = SettingsReference(
0.63 related.py(701):                 kwargs["to"],
0.63 related.py(702):                 swappable_setting,
0.63 related.py(700):             kwargs["to"] = SettingsReference(
0.63 related.py(704):         return name, path, args, kwargs
0.63 related.py(1037):         del kwargs["to_fields"]
0.63 related.py(1038):         del kwargs["from_fields"]
0.63 related.py(1040):         if self.db_index:
0.63 related.py(1041):             del kwargs["db_index"]
0.63 related.py(1044):         if self.db_constraint is not True:
0.63 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.63 related.py(1048):         if self.remote_field.field_name and (
0.63 related.py(1053):         return name, path, args, kwargs
0.63 related.py(936):         try:
0.63 related.py(937):             to._meta.model_name
0.63 related.py(938):         except AttributeError:
0.63 related.py(939):             if not isinstance(to, str):
0.63 related.py(954):         if not callable(on_delete):
0.63 related.py(957):         kwargs["rel"] = self.rel_class(
0.63 related.py(958):             self,
0.63 related.py(959):             to,
0.63 related.py(960):             to_field,
0.63 related.py(961):             related_name=related_name,
0.63 related.py(962):             related_query_name=related_query_name,
0.63 related.py(963):             limit_choices_to=limit_choices_to,
0.63 related.py(964):             parent_link=parent_link,
0.63 related.py(965):             on_delete=on_delete,
0.63 related.py(957):         kwargs["rel"] = self.rel_class(
0.63 related.py(967):         kwargs.setdefault("db_index", True)
0.63 related.py(969):         super().__init__(
0.63 related.py(970):             to,
0.63 related.py(971):             on_delete,
0.63 related.py(969):         super().__init__(
0.63 related.py(972):             related_name=related_name,
0.63 related.py(973):             related_query_name=related_query_name,
0.63 related.py(974):             limit_choices_to=limit_choices_to,
0.63 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.63 related.py(976):             to_fields=[to_field],
0.63 related.py(969):         super().__init__(
0.63 related.py(977):             **kwargs,
0.63 related.py(969):         super().__init__(
0.63 related.py(544):         if rel is None:
0.63 related.py(555):         super().__init__(
0.63 related.py(556):             rel=rel,
0.63 related.py(557):             related_name=related_name,
0.63 related.py(558):             related_query_name=related_query_name,
0.63 related.py(559):             limit_choices_to=limit_choices_to,
0.63 related.py(555):         super().__init__(
0.63 related.py(560):             **kwargs,
0.63 related.py(555):         super().__init__(
0.63 related.py(105):         self._related_name = related_name
0.63 related.py(106):         self._related_query_name = related_query_name
0.63 related.py(107):         self._limit_choices_to = limit_choices_to
0.63 related.py(108):         super().__init__(**kwargs)
0.63 related.py(563):         self.from_fields = from_fields
0.63 related.py(564):         self.to_fields = to_fields
0.63 related.py(565):         self.swappable = swappable
0.63 related.py(979):         self.db_constraint = db_constraint
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(62):         if "." not in relation:
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(62):         if "." not in relation:
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 related.py(373):                 field.remote_field.model = related
0.63 related.py(374):                 field.do_related_class(related, model)
0.63 related.py(448):         self.set_attributes_from_rel()
0.63 related.py(438):         self.name = self.name or (
0.63 related.py(438):         self.name = self.name or (
0.63 related.py(443):         if self.verbose_name is None:
0.63 related.py(445):         self.remote_field.set_field_name()
0.63 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.63 related.py(1155):         super().contribute_to_related_class(cls, related)
0.63 related.py(874):             not self.remote_field.is_hidden()
0.63 related.py(873):         if (
0.63 related.py(875):             and not related.related_model._meta.swapped
0.63 related.py(873):         if (
0.63 related.py(877):             setattr(
0.63 related.py(878):                 cls._meta.concrete_model,
0.63 related.py(879):                 related.get_accessor_name(),
0.63 related.py(880):                 self.related_accessor_class(related),
0.63 related.py(877):             setattr(
0.63 related.py(885):             if self.remote_field.limit_choices_to:
0.63 related.py(1156):         if self.remote_field.field_name is None:
0.63 related.py(373):                 field.remote_field.model = related
0.63 related.py(374):                 field.do_related_class(related, model)
0.63 related.py(448):         self.set_attributes_from_rel()
0.63 related.py(438):         self.name = self.name or (
0.63 related.py(438):         self.name = self.name or (
0.63 related.py(443):         if self.verbose_name is None:
0.63 related.py(445):         self.remote_field.set_field_name()
0.63 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.63 related.py(1155):         super().contribute_to_related_class(cls, related)
0.63 related.py(874):             not self.remote_field.is_hidden()
0.63 related.py(873):         if (
0.63 related.py(875):             and not related.related_model._meta.swapped
0.63 related.py(873):         if (
0.63 related.py(877):             setattr(
0.63 related.py(878):                 cls._meta.concrete_model,
0.63 related.py(879):                 related.get_accessor_name(),
0.63 related.py(880):                 self.related_accessor_class(related),
0.63 related.py(877):             setattr(
0.63 related.py(885):             if self.remote_field.limit_choices_to:
0.63 related.py(1156):         if self.remote_field.field_name is None:
0.63 schema.py(124):         if not self._field_should_be_altered(old_field, new_field):
0.63 schema.py(1395):         _, old_path, old_args, old_kwargs = old_field.deconstruct()
0.63 schema.py(1396):         _, new_path, new_args, new_kwargs = new_field.deconstruct()
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(1406):             new_field.column
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(1407):         ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(126):         old_field_name = old_field.name
0.63 schema.py(127):         table_name = model._meta.db_table
0.63 schema.py(128):         _, old_column_name = old_field.get_attname_column()
0.63 schema.py(130):             new_field.name != old_field_name
0.63 schema.py(129):         if (
0.63 schema.py(174):             super().alter_field(model, old_field, new_field, strict=strict)
0.63 schema.py(708):         if not self._field_should_be_altered(old_field, new_field):
0.63 schema.py(1395):         _, old_path, old_args, old_kwargs = old_field.deconstruct()
0.63 schema.py(1396):         _, new_path, new_args, new_kwargs = new_field.deconstruct()
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1402):             old_kwargs.pop(attr, None)
0.63 schema.py(1401):         for attr in old_field.non_db_attrs:
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1404):             new_kwargs.pop(attr, None)
0.63 schema.py(1403):         for attr in new_field.non_db_attrs:
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(1406):             new_field.column
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(1407):         ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
0.63 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.63 schema.py(711):         old_db_params = old_field.db_parameters(connection=self.connection)
0.63 schema.py(712):         old_type = old_db_params["type"]
0.63 schema.py(713):         new_db_params = new_field.db_parameters(connection=self.connection)
0.63 schema.py(714):         new_type = new_db_params["type"]
0.63 schema.py(715):         if (old_type is None and old_field.remote_field is None) or (
0.63 schema.py(716):             new_type is None and new_field.remote_field is None
0.63 schema.py(715):         if (old_type is None and old_field.remote_field is None) or (
0.63 schema.py(724):             old_type is None
0.63 schema.py(723):         elif (
0.63 schema.py(735):             old_type is None
0.63 schema.py(734):         elif (
0.63 schema.py(746):         elif old_type is None or new_type is None:
0.63 schema.py(753):         self._alter_field(
0.63 schema.py(754):             model,
0.63 schema.py(755):             old_field,
0.63 schema.py(756):             new_field,
0.63 schema.py(757):             old_type,
0.63 schema.py(758):             new_type,
0.63 schema.py(759):             old_db_params,
0.63 schema.py(760):             new_db_params,
0.63 schema.py(761):             strict,
0.63 schema.py(753):         self._alter_field(
0.63 schema.py(440):             self.connection.features.can_alter_table_rename_column
0.63 schema.py(439):         if (
0.63 schema.py(441):             and old_field.column != new_field.column
0.63 schema.py(439):         if (
0.63 schema.py(456):         self._remake_table(model, alter_field=(old_field, new_field))
0.63 schema.py(197):         def is_self_referential(f):
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(201):         body = {
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(203):             for f in model._meta.local_concrete_fields
0.63 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.63 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.63 schema.py(201):         body = {
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(207):         mapping = {
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(209):             for f in model._meta.local_concrete_fields
0.63 schema.py(208):             f.column: self.quote_name(f.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(207):         mapping = {
0.63 schema.py(212):         rename_mapping = {}
0.63 schema.py(215):         restore_pk_field = None
0.63 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.63 schema.py(217):             alter_field and getattr(alter_field[1], "primary_key", False)
0.63 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.63 schema.py(217):             alter_field and getattr(alter_field[1], "primary_key", False)
0.63 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.63 schema.py(232):         if create_field:
0.63 schema.py(240):         if alter_field:
0.63 schema.py(241):             old_field, new_field = alter_field
0.63 schema.py(242):             body.pop(old_field.name, None)
0.63 schema.py(243):             mapping.pop(old_field.column, None)
0.63 schema.py(244):             body[new_field.name] = new_field
0.63 schema.py(245):             if old_field.null and not new_field.null:
0.63 schema.py(252):                 mapping[new_field.column] = self.quote_name(old_field.column)
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(253):             rename_mapping[old_field.name] = new_field.name
0.63 schema.py(255):         if delete_field:
0.63 schema.py(265):         apps = Apps()
0.63 schema.py(269):         unique_together = [
0.63 schema.py(271):             for unique in model._meta.unique_together
0.63 schema.py(269):         unique_together = [
0.63 schema.py(269):         unique_together = [
0.63 schema.py(276):         index_together = [
0.63 schema.py(278):             for index in model._meta.index_together
0.63 schema.py(276):         index_together = [
0.63 schema.py(276):         index_together = [
0.63 schema.py(281):         indexes = model._meta.indexes
0.63 schema.py(282):         if delete_field:
0.63 schema.py(287):         constraints = list(model._meta.constraints)
0.63 schema.py(292):         body_copy = copy.deepcopy(body)
0.63 related.py(568):         obj = super().__copy__()
0.63 related.py(570):         obj.__dict__.pop("path_infos", None)
0.63 related.py(571):         obj.__dict__.pop("reverse_path_infos", None)
0.63 related.py(572):         return obj
0.63 related.py(568):         obj = super().__copy__()
0.63 related.py(570):         obj.__dict__.pop("path_infos", None)
0.63 related.py(571):         obj.__dict__.pop("reverse_path_infos", None)
0.63 related.py(572):         return obj
0.63 schema.py(300):             "app_label": model._meta.app_label,
0.63 schema.py(301):             "db_table": model._meta.db_table,
0.63 schema.py(302):             "unique_together": unique_together,
0.63 schema.py(303):             "index_together": index_together,
0.63 schema.py(304):             "indexes": indexes,
0.63 schema.py(305):             "constraints": constraints,
0.63 schema.py(306):             "apps": apps,
0.63 schema.py(299):         meta_contents = {
0.63 schema.py(308):         meta = type("Meta", (), meta_contents)
0.63 schema.py(309):         body_copy["Meta"] = meta
0.63 schema.py(310):         body_copy["__module__"] = model.__module__
0.63 schema.py(311):         type(model._meta.object_name, model.__bases__, body_copy)
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 schema.py(314):         body_copy = copy.deepcopy(body)
0.63 related.py(568):         obj = super().__copy__()
0.63 related.py(570):         obj.__dict__.pop("path_infos", None)
0.63 related.py(571):         obj.__dict__.pop("reverse_path_infos", None)
0.63 related.py(572):         return obj
0.63 related.py(568):         obj = super().__copy__()
0.63 related.py(570):         obj.__dict__.pop("path_infos", None)
0.63 related.py(571):         obj.__dict__.pop("reverse_path_infos", None)
0.63 related.py(572):         return obj
0.63 schema.py(316):             "app_label": model._meta.app_label,
0.63 schema.py(317):             "db_table": "new__%s" % strip_quotes(model._meta.db_table),
0.63 schema.py(318):             "unique_together": unique_together,
0.63 schema.py(319):             "index_together": index_together,
0.63 schema.py(320):             "indexes": indexes,
0.63 schema.py(321):             "constraints": constraints,
0.63 schema.py(322):             "apps": apps,
0.63 schema.py(315):         meta_contents = {
0.63 schema.py(324):         meta = type("Meta", (), meta_contents)
0.63 schema.py(325):         body_copy["Meta"] = meta
0.63 schema.py(326):         body_copy["__module__"] = model.__module__
0.63 schema.py(327):         new_model = type("New%s" % model._meta.object_name, model.__bases__, body_copy)
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.63 related.py(1125):         attname = self.get_attname()
0.63 related.py(1122):         return "%s_id" % self.name
0.63 related.py(1126):         column = self.db_column or attname
0.63 related.py(1127):         return attname, column
0.63 related.py(350):         self.opts = cls._meta
0.63 related.py(352):         if not cls._meta.abstract:
0.63 related.py(353):             if self.remote_field.related_name:
0.63 related.py(356):                 related_name = self.opts.default_related_name
0.63 related.py(357):             if related_name:
0.63 related.py(365):             if self.remote_field.related_query_name:
0.63 related.py(372):             def resolve_related_class(model, related, field):
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.63 related.py(376):             lazy_related_operation(
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.63 related.py(61):     if isinstance(relation, str):
0.63 related.py(65):     return relation
0.63 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(85):     apps = model._meta.apps
0.63 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.63 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.63 schema.py(330):         self.create_model(new_model)
0.63 schema.py(435):         sql, params = self.table_sql(model)
0.63 schema.py(201):         for field_names in model._meta.unique_together:
0.63 schema.py(205):         column_sqls = []
0.63 schema.py(206):         params = []
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(321):             yield "PRIMARY KEY"
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(219):                 definition += " %s" % col_type_suffix
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.63 schema.py(254):                     model._meta.db_table, field.column
0.63 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.63 schema.py(256):                 if autoinc_sql:
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(312):             and not field.primary_key
0.63 schema.py(310):         if (
0.63 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(318):         elif not self.connection.features.implied_column_null:
0.63 schema.py(319):             yield "NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(312):             and not field.primary_key
0.63 schema.py(310):         if (
0.63 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(215):                 definition += " " + self.sql_check_constraint % db_params
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(312):             and not field.primary_key
0.63 schema.py(310):         if (
0.63 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1185):             "type": self.db_type(connection),
0.63 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1186):             "check": self.db_check(connection),
0.63 related.py(1177):         return None
0.63 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.63 related.py(1184):         return {
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(318):         elif not self.connection.features.implied_column_null:
0.63 schema.py(319):             yield "NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1185):             "type": self.db_type(connection),
0.63 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1186):             "check": self.db_check(connection),
0.63 related.py(1177):         return None
0.63 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.63 related.py(1184):         return {
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.63 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.63 schema.py(225):                     field.remote_field.field_name
0.63 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.63 schema.py(227):                 if self.sql_create_inline_fk:
0.63 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.63 schema.py(229):                         "to_table": self.quote_name(to_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(230):                         "to_column": self.quote_name(to_column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1185):             "type": self.db_type(connection),
0.63 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1186):             "check": self.db_check(connection),
0.63 related.py(1177):         return None
0.63 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.63 related.py(1184):         return {
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 related.py(1183):         target_db_parameters = self.target_field.db_parameters(connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1185):             "type": self.db_type(connection),
0.63 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.63 related.py(1060):         return self.foreign_related_fields[0]
0.63 related.py(1186):             "check": self.db_check(connection),
0.63 related.py(1177):         return None
0.63 related.py(1187):             "collation": target_db_parameters.get("collation"),
0.63 related.py(1184):         return {
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(223):                 to_table = field.remote_field.model._meta.db_table
0.63 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.63 schema.py(225):                     field.remote_field.field_name
0.63 schema.py(224):                 to_column = field.remote_field.model._meta.get_field(
0.63 schema.py(227):                 if self.sql_create_inline_fk:
0.63 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.63 schema.py(229):                         "to_table": self.quote_name(to_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(230):                         "to_column": self.quote_name(to_column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(228):                     definition += " " + self.sql_create_inline_fk % {
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.63 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(340):         column_db_type = field_db_params["type"]
0.63 schema.py(342):         if column_db_type is None:
0.63 schema.py(344):         params = []
0.63 schema.py(346):             " ".join(
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(349):                     column_db_type,
0.63 schema.py(350):                     params,
0.63 schema.py(351):                     model,
0.63 schema.py(352):                     field,
0.63 schema.py(353):                     field_db_params,
0.63 schema.py(354):                     include_default,
0.63 schema.py(348):                 self._iter_column_sql(
0.63 schema.py(346):             " ".join(
0.63 schema.py(281):         yield column_db_type
0.63 schema.py(282):         if collation := field_db_params.get("collation"):
0.63 schema.py(285):         null = field.null
0.63 schema.py(288):             include_default
0.63 schema.py(287):         include_default = (
0.63 schema.py(296):         if include_default:
0.63 schema.py(311):             field.empty_strings_allowed
0.63 schema.py(310):         if (
0.63 schema.py(316):         if not null:
0.63 schema.py(317):             yield "NOT NULL"
0.63 schema.py(320):         if field.primary_key:
0.63 schema.py(322):         elif field.unique:
0.63 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.63 schema.py(327):             tablespace
0.63 schema.py(326):         if (
0.63 schema.py(357):             params,
0.63 schema.py(345):         return (
0.63 schema.py(210):             if definition is None:
0.63 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.63 schema.py(214):             if db_params["check"]:
0.63 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.63 schema.py(218):             if col_type_suffix:
0.63 schema.py(220):             params.extend(extra_params)
0.63 schema.py(222):             if field.remote_field and field.db_constraint:
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(242):                     self.quote_name(field.column),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(243):                     definition,
0.63 schema.py(241):                 % (
0.63 schema.py(240):                 "%s %s"
0.63 schema.py(239):             column_sqls.append(
0.63 schema.py(248):             if field.get_internal_type() in (
0.63 schema.py(207):         for field in model._meta.local_fields:
0.63 schema.py(258):         constraints = [
0.63 schema.py(260):             for constraint in model._meta.constraints
0.63 schema.py(258):         constraints = [
0.63 schema.py(258):         constraints = [
0.63 schema.py(262):         sql = self.sql_create_table % {
0.63 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.63 schema.py(264):             "definition": ", ".join(
0.63 schema.py(262):         sql = self.sql_create_table % {
0.63 schema.py(268):         if model._meta.db_tablespace:
0.63 schema.py(274):         return sql, params
0.63 schema.py(438):         self.execute(sql, params or None)
0.63 schema.py(168):             not self.collect_sql
0.63 schema.py(167):         if (
0.63 schema.py(169):             and self.connection.in_atomic_block
0.63 schema.py(167):         if (
0.63 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.63 schema.py(167):         if (
0.63 schema.py(177):         sql = str(sql)
0.63 schema.py(179):         logger.debug(
0.63 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.63 schema.py(179):         logger.debug(
0.63 schema.py(182):         if self.collect_sql:
0.63 schema.py(191):             with self.connection.cursor() as cursor:
0.63 schema.py(192):                 cursor.execute(sql, params)
0.63 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.63 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.63 schema.py(1369):         output = []
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.63 schema.py(1319):         fields = fields or []
0.63 schema.py(1320):         expressions = expressions or []
0.63 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.63 schema.py(1322):             connection=self.connection,
0.63 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.63 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.63 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.63 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.63 schema.py(1276):         if db_tablespace is None:
0.63 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.63 schema.py(1279):             elif model._meta.db_tablespace:
0.63 schema.py(1281):         if db_tablespace is not None:
0.63 schema.py(1283):         return ""
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.63 schema.py(1329):         table = model._meta.db_table
0.63 schema.py(1331):         def create_index_name(*args, **kwargs):
0.63 schema.py(1337):         return Statement(
0.63 schema.py(1338):             sql_create_index,
0.63 schema.py(1339):             table=Table(table, self.quote_name),
0.63 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.63 schema.py(1341):             using=using,
0.63 schema.py(1344):                 if columns
0.63 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.63 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.63 schema.py(1347):             extra=tablespace_sql,
0.63 schema.py(1348):             condition=self._index_condition_sql(condition),
0.63 schema.py(1286):         if condition:
0.63 schema.py(1288):         return ""
0.63 schema.py(1349):             include=self._index_include_sql(model, include),
0.63 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.63 schema.py(1292):             return ""
0.63 schema.py(1337):         return Statement(
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1391):             output.append(self._create_index_sql(model, fields=[field]))
0.63 schema.py(1319):         fields = fields or []
0.63 schema.py(1320):         expressions = expressions or []
0.63 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.63 schema.py(1322):             connection=self.connection,
0.63 schema.py(1321):         compiler = Query(model, alias_cols=False).get_compiler(
0.63 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.63 schema.py(1325):             model, fields, db_tablespace=db_tablespace
0.63 schema.py(1324):         tablespace_sql = self._get_index_tablespace_sql(
0.63 schema.py(1276):         if db_tablespace is None:
0.63 schema.py(1277):             if len(fields) == 1 and fields[0].db_tablespace:
0.63 schema.py(1279):             elif model._meta.db_tablespace:
0.63 schema.py(1281):         if db_tablespace is not None:
0.63 schema.py(1283):         return ""
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1327):         columns = [field.column for field in fields]
0.63 schema.py(1328):         sql_create_index = sql or self.sql_create_index
0.63 schema.py(1329):         table = model._meta.db_table
0.63 schema.py(1331):         def create_index_name(*args, **kwargs):
0.63 schema.py(1337):         return Statement(
0.63 schema.py(1338):             sql_create_index,
0.63 schema.py(1339):             table=Table(table, self.quote_name),
0.63 schema.py(1340):             name=IndexName(table, columns, suffix, create_index_name),
0.63 schema.py(1341):             using=using,
0.63 schema.py(1344):                 if columns
0.63 schema.py(1343):                 self._index_columns(table, columns, col_suffixes, opclasses)
0.63 schema.py(1360):         return Columns(table, columns, self.quote_name, col_suffixes=col_suffixes)
0.63 schema.py(1347):             extra=tablespace_sql,
0.63 schema.py(1348):             condition=self._index_condition_sql(condition),
0.63 schema.py(1286):         if condition:
0.63 schema.py(1288):         return ""
0.63 schema.py(1349):             include=self._index_include_sql(model, include),
0.63 schema.py(1291):         if not columns or not self.connection.features.supports_covering_indexes:
0.63 schema.py(1292):             return ""
0.63 schema.py(1337):         return Statement(
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.63 schema.py(1389):         output = []
0.63 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.63 schema.py(1410):         return field.db_index and not field.unique
0.63 schema.py(1392):         return output
0.63 schema.py(1370):         for field in model._meta.local_fields:
0.63 schema.py(1373):         for field_names in model._meta.index_together:
0.63 schema.py(1377):         for index in model._meta.indexes:
0.63 schema.py(1383):         return output
0.63 schema.py(445):         for field in model._meta.local_many_to_many:
0.63 schema.py(333):         self.execute(
0.63 schema.py(334):             "INSERT INTO %s (%s) SELECT %s FROM %s"
0.63 schema.py(336):                 self.quote_name(new_model._meta.db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.63 schema.py(338):                 ", ".join(mapping.values()),
0.63 schema.py(339):                 self.quote_name(model._meta.db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(335):             % (
0.63 schema.py(334):             "INSERT INTO %s (%s) SELECT %s FROM %s"
0.63 schema.py(333):         self.execute(
0.63 schema.py(168):             not self.collect_sql
0.63 schema.py(167):         if (
0.63 schema.py(169):             and self.connection.in_atomic_block
0.63 schema.py(167):         if (
0.63 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.63 schema.py(167):         if (
0.63 schema.py(177):         sql = str(sql)
0.63 schema.py(179):         logger.debug(
0.63 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.63 schema.py(179):         logger.debug(
0.63 schema.py(182):         if self.collect_sql:
0.63 schema.py(191):             with self.connection.cursor() as cursor:
0.63 schema.py(192):                 cursor.execute(sql, params)
0.63 schema.py(344):         self.delete_model(model, handle_autom2m=False)
0.63 schema.py(363):         if handle_autom2m:
0.63 schema.py(367):             self.execute(
0.63 schema.py(368):                 self.sql_delete_table
0.63 schema.py(370):                     "table": self.quote_name(model._meta.db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(369):                 % {
0.63 schema.py(368):                 self.sql_delete_table
0.63 schema.py(367):             self.execute(
0.63 schema.py(168):             not self.collect_sql
0.63 schema.py(167):         if (
0.63 schema.py(169):             and self.connection.in_atomic_block
0.63 schema.py(167):         if (
0.63 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.63 schema.py(167):         if (
0.63 schema.py(177):         sql = str(sql)
0.63 schema.py(179):         logger.debug(
0.63 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.63 schema.py(179):         logger.debug(
0.63 schema.py(182):         if self.collect_sql:
0.63 schema.py(191):             with self.connection.cursor() as cursor:
0.63 schema.py(192):                 cursor.execute(sql, params)
0.63 schema.py(374):             for sql in list(self.deferred_sql):
0.63 schema.py(375):                 if isinstance(sql, Statement) and sql.references_table(
0.63 schema.py(376):                     model._meta.db_table
0.63 schema.py(375):                 if isinstance(sql, Statement) and sql.references_table(
0.63 schema.py(374):             for sql in list(self.deferred_sql):
0.63 schema.py(375):                 if isinstance(sql, Statement) and sql.references_table(
0.63 schema.py(376):                     model._meta.db_table
0.63 schema.py(375):                 if isinstance(sql, Statement) and sql.references_table(
0.63 schema.py(374):             for sql in list(self.deferred_sql):
0.63 schema.py(347):         self.alter_db_table(
0.63 schema.py(348):             new_model,
0.63 schema.py(349):             new_model._meta.db_table,
0.63 schema.py(350):             model._meta.db_table,
0.63 schema.py(351):             disable_constraints=False,
0.63 schema.py(347):         self.alter_db_table(
0.63 schema.py(104):             not self.connection.features.supports_atomic_references_rename
0.63 schema.py(103):         if (
0.63 schema.py(121):             super().alter_db_table(model, old_db_table, new_db_table)
0.63 schema.py(568):         if old_db_table == new_db_table or (
0.63 schema.py(569):             self.connection.features.ignores_table_name_case
0.63 schema.py(568):         if old_db_table == new_db_table or (
0.63 schema.py(570):             and old_db_table.lower() == new_db_table.lower()
0.63 schema.py(568):         if old_db_table == new_db_table or (
0.63 schema.py(573):         self.execute(
0.63 schema.py(574):             self.sql_rename_table
0.63 schema.py(576):                 "old_table": self.quote_name(old_db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(577):                 "new_table": self.quote_name(new_db_table),
0.63 schema.py(195):         return self.connection.ops.quote_name(name)
0.63 schema.py(575):             % {
0.63 schema.py(574):             self.sql_rename_table
0.63 schema.py(573):         self.execute(
0.63 schema.py(168):             not self.collect_sql
0.63 schema.py(167):         if (
0.63 schema.py(169):             and self.connection.in_atomic_block
0.63 schema.py(167):         if (
0.63 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.63 schema.py(167):         if (
0.63 schema.py(177):         sql = str(sql)
0.63 schema.py(179):         logger.debug(
0.63 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.63 schema.py(179):         logger.debug(
0.63 schema.py(182):         if self.collect_sql:
0.63 schema.py(191):             with self.connection.cursor() as cursor:
0.63 schema.py(192):                 cursor.execute(sql, params)
0.64 schema.py(581):         for sql in self.deferred_sql:
0.64 schema.py(582):             if isinstance(sql, Statement):
0.64 schema.py(583):                 sql.rename_table_references(old_db_table, new_db_table)
0.64 schema.py(581):         for sql in self.deferred_sql:
0.64 schema.py(582):             if isinstance(sql, Statement):
0.64 schema.py(583):                 sql.rename_table_references(old_db_table, new_db_table)
0.64 schema.py(581):         for sql in self.deferred_sql:
0.64 schema.py(355):         for sql in self.deferred_sql:
0.64 schema.py(356):             self.execute(sql)
0.64 schema.py(168):             not self.collect_sql
0.64 schema.py(167):         if (
0.64 schema.py(169):             and self.connection.in_atomic_block
0.64 schema.py(167):         if (
0.64 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.64 schema.py(167):         if (
0.64 schema.py(177):         sql = str(sql)
0.64 schema.py(1333):             if name is None:
0.64 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.64 schema.py(1250):         _, table_name = split_identifier(table_name)
0.64 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.64 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.64 schema.py(1253):             suffix,
0.64 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.64 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.64 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.64 schema.py(1258):         if len(index_name) <= max_length:
0.64 schema.py(1259):             return index_name
0.64 schema.py(1335):             return self.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(179):         logger.debug(
0.64 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.64 schema.py(179):         logger.debug(
0.64 schema.py(182):         if self.collect_sql:
0.64 schema.py(191):             with self.connection.cursor() as cursor:
0.64 schema.py(192):                 cursor.execute(sql, params)
0.64 schema.py(355):         for sql in self.deferred_sql:
0.64 schema.py(356):             self.execute(sql)
0.64 schema.py(168):             not self.collect_sql
0.64 schema.py(167):         if (
0.64 schema.py(169):             and self.connection.in_atomic_block
0.64 schema.py(167):         if (
0.64 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.64 schema.py(167):         if (
0.64 schema.py(177):         sql = str(sql)
0.64 schema.py(1333):             if name is None:
0.64 schema.py(1334):                 name = self._create_index_name(*args, **kwargs)
0.64 schema.py(1250):         _, table_name = split_identifier(table_name)
0.64 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.64 schema.py(1252):             names_digest(table_name, *column_names, length=8),
0.64 schema.py(1253):             suffix,
0.64 schema.py(1251):         hash_suffix_part = "%s%s" % (
0.64 schema.py(1255):         max_length = self.connection.ops.max_name_length() or 200
0.64 schema.py(1257):         index_name = "%s_%s_%s" % (table_name, "_".join(column_names), hash_suffix_part)
0.64 schema.py(1258):         if len(index_name) <= max_length:
0.64 schema.py(1259):             return index_name
0.64 schema.py(1335):             return self.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(179):         logger.debug(
0.64 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.64 schema.py(179):         logger.debug(
0.64 schema.py(182):         if self.collect_sql:
0.64 schema.py(191):             with self.connection.cursor() as cursor:
0.64 schema.py(192):                 cursor.execute(sql, params)
0.64 schema.py(355):         for sql in self.deferred_sql:
0.64 schema.py(357):         self.deferred_sql = []
0.64 schema.py(359):         if restore_pk_field:
0.64 schema.py(458):         old_collation = old_db_params.get("collation")
0.64 schema.py(459):         new_collation = new_db_params.get("collation")
0.64 schema.py(460):         if new_field.unique and (
0.64 schema.py(39):         self.connection.check_constraints()
0.64 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.64 schema.py(155):         if exc_type is None:
0.64 schema.py(156):             for sql in self.deferred_sql:
0.64 schema.py(158):         if self.atomic_migration:
0.64 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.64 schema.py(41):         self.connection.enable_constraint_checking()
 OK
  Applying admin.0003_logentry_add_action_flag_choices...0.64 schema.py(139):         self.connection = connection
0.64 schema.py(140):         self.collect_sql = collect_sql
0.64 schema.py(141):         if self.collect_sql:
0.64 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.64 schema.py(28):         if not self.connection.disable_constraint_checking():
0.64 schema.py(36):         return super().__enter__()
0.64 schema.py(148):         self.deferred_sql = []
0.64 schema.py(149):         if self.atomic_migration:
0.64 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.64 schema.py(151):             self.atomic.__enter__()
0.64 schema.py(152):         return self
0.64 related.py(113):         apps.check_models_ready()
0.64 related.py(114):         return self.remote_field.model
0.64 related.py(113):         apps.check_models_ready()
0.64 related.py(114):         return self.remote_field.model
0.64 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(382):         if self._limit_choices_to:
0.64 related.py(384):         if self._related_name is not None:
0.64 related.py(386):         if self._related_query_name is not None:
0.64 related.py(388):         return name, path, args, kwargs
0.64 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.64 related.py(674):         kwargs["from_fields"] = self.from_fields
0.64 related.py(675):         kwargs["to_fields"] = self.to_fields
0.64 related.py(677):         if self.remote_field.parent_link:
0.64 related.py(679):         if isinstance(self.remote_field.model, str):
0.64 related.py(680):             if "." in self.remote_field.model:
0.64 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.64 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.64 related.py(689):         swappable_setting = self.swappable_setting
0.64 related.py(428):         if self.swappable:
0.64 related.py(430):             if isinstance(self.remote_field.model, str):
0.64 related.py(431):                 to_string = self.remote_field.model
0.64 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.64 related.py(690):         if swappable_setting is not None:
0.64 related.py(704):         return name, path, args, kwargs
0.64 related.py(1037):         del kwargs["to_fields"]
0.64 related.py(1038):         del kwargs["from_fields"]
0.64 related.py(1040):         if self.db_index:
0.64 related.py(1041):             del kwargs["db_index"]
0.64 related.py(1044):         if self.db_constraint is not True:
0.64 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.64 related.py(1048):         if self.remote_field.field_name and (
0.64 related.py(1053):         return name, path, args, kwargs
0.64 related.py(936):         try:
0.64 related.py(937):             to._meta.model_name
0.64 related.py(938):         except AttributeError:
0.64 related.py(939):             if not isinstance(to, str):
0.64 related.py(954):         if not callable(on_delete):
0.64 related.py(957):         kwargs["rel"] = self.rel_class(
0.64 related.py(958):             self,
0.64 related.py(959):             to,
0.64 related.py(960):             to_field,
0.64 related.py(961):             related_name=related_name,
0.64 related.py(962):             related_query_name=related_query_name,
0.64 related.py(963):             limit_choices_to=limit_choices_to,
0.64 related.py(964):             parent_link=parent_link,
0.64 related.py(965):             on_delete=on_delete,
0.64 related.py(957):         kwargs["rel"] = self.rel_class(
0.64 related.py(967):         kwargs.setdefault("db_index", True)
0.64 related.py(969):         super().__init__(
0.64 related.py(970):             to,
0.64 related.py(971):             on_delete,
0.64 related.py(969):         super().__init__(
0.64 related.py(972):             related_name=related_name,
0.64 related.py(973):             related_query_name=related_query_name,
0.64 related.py(974):             limit_choices_to=limit_choices_to,
0.64 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.64 related.py(976):             to_fields=[to_field],
0.64 related.py(969):         super().__init__(
0.64 related.py(977):             **kwargs,
0.64 related.py(969):         super().__init__(
0.64 related.py(544):         if rel is None:
0.64 related.py(555):         super().__init__(
0.64 related.py(556):             rel=rel,
0.64 related.py(557):             related_name=related_name,
0.64 related.py(558):             related_query_name=related_query_name,
0.64 related.py(559):             limit_choices_to=limit_choices_to,
0.64 related.py(555):         super().__init__(
0.64 related.py(560):             **kwargs,
0.64 related.py(555):         super().__init__(
0.64 related.py(105):         self._related_name = related_name
0.64 related.py(106):         self._related_query_name = related_query_name
0.64 related.py(107):         self._limit_choices_to = limit_choices_to
0.64 related.py(108):         super().__init__(**kwargs)
0.64 related.py(563):         self.from_fields = from_fields
0.64 related.py(564):         self.to_fields = to_fields
0.64 related.py(565):         self.swappable = swappable
0.64 related.py(979):         self.db_constraint = db_constraint
0.64 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.64 related.py(382):         if self._limit_choices_to:
0.64 related.py(384):         if self._related_name is not None:
0.64 related.py(386):         if self._related_query_name is not None:
0.64 related.py(388):         return name, path, args, kwargs
0.64 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.64 related.py(674):         kwargs["from_fields"] = self.from_fields
0.64 related.py(675):         kwargs["to_fields"] = self.to_fields
0.64 related.py(677):         if self.remote_field.parent_link:
0.64 related.py(679):         if isinstance(self.remote_field.model, str):
0.64 related.py(680):             if "." in self.remote_field.model:
0.64 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.64 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.64 related.py(689):         swappable_setting = self.swappable_setting
0.64 related.py(428):         if self.swappable:
0.64 related.py(430):             if isinstance(self.remote_field.model, str):
0.64 related.py(431):                 to_string = self.remote_field.model
0.64 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.64 related.py(690):         if swappable_setting is not None:
0.64 related.py(692):             if hasattr(kwargs["to"], "setting_name"):
0.64 related.py(700):             kwargs["to"] = SettingsReference(
0.64 related.py(701):                 kwargs["to"],
0.64 related.py(702):                 swappable_setting,
0.64 related.py(700):             kwargs["to"] = SettingsReference(
0.64 related.py(704):         return name, path, args, kwargs
0.64 related.py(1037):         del kwargs["to_fields"]
0.64 related.py(1038):         del kwargs["from_fields"]
0.64 related.py(1040):         if self.db_index:
0.64 related.py(1041):             del kwargs["db_index"]
0.64 related.py(1044):         if self.db_constraint is not True:
0.64 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.64 related.py(1048):         if self.remote_field.field_name and (
0.64 related.py(1053):         return name, path, args, kwargs
0.64 related.py(936):         try:
0.64 related.py(937):             to._meta.model_name
0.64 related.py(938):         except AttributeError:
0.64 related.py(939):             if not isinstance(to, str):
0.64 related.py(954):         if not callable(on_delete):
0.64 related.py(957):         kwargs["rel"] = self.rel_class(
0.64 related.py(958):             self,
0.64 related.py(959):             to,
0.64 related.py(960):             to_field,
0.64 related.py(961):             related_name=related_name,
0.64 related.py(962):             related_query_name=related_query_name,
0.64 related.py(963):             limit_choices_to=limit_choices_to,
0.64 related.py(964):             parent_link=parent_link,
0.64 related.py(965):             on_delete=on_delete,
0.64 related.py(957):         kwargs["rel"] = self.rel_class(
0.64 related.py(967):         kwargs.setdefault("db_index", True)
0.64 related.py(969):         super().__init__(
0.64 related.py(970):             to,
0.64 related.py(971):             on_delete,
0.64 related.py(969):         super().__init__(
0.64 related.py(972):             related_name=related_name,
0.64 related.py(973):             related_query_name=related_query_name,
0.64 related.py(974):             limit_choices_to=limit_choices_to,
0.64 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.64 related.py(976):             to_fields=[to_field],
0.64 related.py(969):         super().__init__(
0.64 related.py(977):             **kwargs,
0.64 related.py(969):         super().__init__(
0.64 related.py(544):         if rel is None:
0.64 related.py(555):         super().__init__(
0.64 related.py(556):             rel=rel,
0.64 related.py(557):             related_name=related_name,
0.64 related.py(558):             related_query_name=related_query_name,
0.64 related.py(559):             limit_choices_to=limit_choices_to,
0.64 related.py(555):         super().__init__(
0.64 related.py(560):             **kwargs,
0.64 related.py(555):         super().__init__(
0.64 related.py(105):         self._related_name = related_name
0.64 related.py(106):         self._related_query_name = related_query_name
0.64 related.py(107):         self._limit_choices_to = limit_choices_to
0.64 related.py(108):         super().__init__(**kwargs)
0.64 related.py(563):         self.from_fields = from_fields
0.64 related.py(564):         self.to_fields = to_fields
0.64 related.py(565):         self.swappable = swappable
0.64 related.py(979):         self.db_constraint = db_constraint
0.64 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.64 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.64 related.py(1125):         attname = self.get_attname()
0.64 related.py(1122):         return "%s_id" % self.name
0.64 related.py(1126):         column = self.db_column or attname
0.64 related.py(1127):         return attname, column
0.64 related.py(350):         self.opts = cls._meta
0.64 related.py(352):         if not cls._meta.abstract:
0.64 related.py(353):             if self.remote_field.related_name:
0.64 related.py(356):                 related_name = self.opts.default_related_name
0.64 related.py(357):             if related_name:
0.64 related.py(365):             if self.remote_field.related_query_name:
0.64 related.py(372):             def resolve_related_class(model, related, field):
0.64 related.py(376):             lazy_related_operation(
0.64 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.64 related.py(376):             lazy_related_operation(
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.64 related.py(61):     if isinstance(relation, str):
0.64 related.py(62):         if "." not in relation:
0.64 related.py(65):     return relation
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(85):     apps = model._meta.apps
0.64 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.64 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.64 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.64 related.py(1125):         attname = self.get_attname()
0.64 related.py(1122):         return "%s_id" % self.name
0.64 related.py(1126):         column = self.db_column or attname
0.64 related.py(1127):         return attname, column
0.64 related.py(350):         self.opts = cls._meta
0.64 related.py(352):         if not cls._meta.abstract:
0.64 related.py(353):             if self.remote_field.related_name:
0.64 related.py(356):                 related_name = self.opts.default_related_name
0.64 related.py(357):             if related_name:
0.64 related.py(365):             if self.remote_field.related_query_name:
0.64 related.py(372):             def resolve_related_class(model, related, field):
0.64 related.py(376):             lazy_related_operation(
0.64 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.64 related.py(376):             lazy_related_operation(
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.64 related.py(61):     if isinstance(relation, str):
0.64 related.py(62):         if "." not in relation:
0.64 related.py(65):     return relation
0.64 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(85):     apps = model._meta.apps
0.64 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.64 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.64 related.py(373):                 field.remote_field.model = related
0.64 related.py(374):                 field.do_related_class(related, model)
0.64 related.py(448):         self.set_attributes_from_rel()
0.64 related.py(438):         self.name = self.name or (
0.64 related.py(438):         self.name = self.name or (
0.64 related.py(443):         if self.verbose_name is None:
0.64 related.py(445):         self.remote_field.set_field_name()
0.64 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.64 related.py(1155):         super().contribute_to_related_class(cls, related)
0.64 related.py(874):             not self.remote_field.is_hidden()
0.64 related.py(873):         if (
0.64 related.py(875):             and not related.related_model._meta.swapped
0.64 related.py(873):         if (
0.64 related.py(877):             setattr(
0.64 related.py(878):                 cls._meta.concrete_model,
0.64 related.py(879):                 related.get_accessor_name(),
0.64 related.py(880):                 self.related_accessor_class(related),
0.64 related.py(877):             setattr(
0.64 related.py(885):             if self.remote_field.limit_choices_to:
0.64 related.py(1156):         if self.remote_field.field_name is None:
0.64 related.py(373):                 field.remote_field.model = related
0.64 related.py(374):                 field.do_related_class(related, model)
0.64 related.py(448):         self.set_attributes_from_rel()
0.64 related.py(438):         self.name = self.name or (
0.64 related.py(438):         self.name = self.name or (
0.64 related.py(443):         if self.verbose_name is None:
0.64 related.py(445):         self.remote_field.set_field_name()
0.64 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.64 related.py(1155):         super().contribute_to_related_class(cls, related)
0.64 related.py(874):             not self.remote_field.is_hidden()
0.64 related.py(873):         if (
0.64 related.py(875):             and not related.related_model._meta.swapped
0.64 related.py(873):         if (
0.64 related.py(877):             setattr(
0.64 related.py(878):                 cls._meta.concrete_model,
0.64 related.py(879):                 related.get_accessor_name(),
0.64 related.py(880):                 self.related_accessor_class(related),
0.64 related.py(877):             setattr(
0.64 related.py(885):             if self.remote_field.limit_choices_to:
0.64 related.py(1156):         if self.remote_field.field_name is None:
0.64 schema.py(124):         if not self._field_should_be_altered(old_field, new_field):
0.64 schema.py(1395):         _, old_path, old_args, old_kwargs = old_field.deconstruct()
0.64 schema.py(1396):         _, new_path, new_args, new_kwargs = new_field.deconstruct()
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1402):             old_kwargs.pop(attr, None)
0.64 schema.py(1401):         for attr in old_field.non_db_attrs:
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1404):             new_kwargs.pop(attr, None)
0.64 schema.py(1403):         for attr in new_field.non_db_attrs:
0.64 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(1406):             new_field.column
0.64 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(1407):         ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
0.64 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.64 schema.py(125):             return
0.64 schema.py(39):         self.connection.check_constraints()
0.64 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.64 schema.py(155):         if exc_type is None:
0.64 schema.py(156):             for sql in self.deferred_sql:
0.64 schema.py(158):         if self.atomic_migration:
0.64 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.64 schema.py(41):         self.connection.enable_constraint_checking()
 OK
  Applying sites.0001_initial...0.64 schema.py(139):         self.connection = connection
0.64 schema.py(140):         self.collect_sql = collect_sql
0.64 schema.py(141):         if self.collect_sql:
0.64 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.64 schema.py(28):         if not self.connection.disable_constraint_checking():
0.64 schema.py(36):         return super().__enter__()
0.64 schema.py(148):         self.deferred_sql = []
0.64 schema.py(149):         if self.atomic_migration:
0.64 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.64 schema.py(151):             self.atomic.__enter__()
0.64 schema.py(152):         return self
0.64 schema.py(435):         sql, params = self.table_sql(model)
0.64 schema.py(201):         for field_names in model._meta.unique_together:
0.64 schema.py(205):         column_sqls = []
0.64 schema.py(206):         params = []
0.64 schema.py(207):         for field in model._meta.local_fields:
0.64 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.64 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(340):         column_db_type = field_db_params["type"]
0.64 schema.py(342):         if column_db_type is None:
0.64 schema.py(344):         params = []
0.64 schema.py(346):             " ".join(
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(349):                     column_db_type,
0.64 schema.py(350):                     params,
0.64 schema.py(351):                     model,
0.64 schema.py(352):                     field,
0.64 schema.py(353):                     field_db_params,
0.64 schema.py(354):                     include_default,
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(346):             " ".join(
0.64 schema.py(281):         yield column_db_type
0.64 schema.py(282):         if collation := field_db_params.get("collation"):
0.64 schema.py(285):         null = field.null
0.64 schema.py(288):             include_default
0.64 schema.py(287):         include_default = (
0.64 schema.py(296):         if include_default:
0.64 schema.py(311):             field.empty_strings_allowed
0.64 schema.py(310):         if (
0.64 schema.py(316):         if not null:
0.64 schema.py(317):             yield "NOT NULL"
0.64 schema.py(320):         if field.primary_key:
0.64 schema.py(321):             yield "PRIMARY KEY"
0.64 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.64 schema.py(327):             tablespace
0.64 schema.py(326):         if (
0.64 schema.py(357):             params,
0.64 schema.py(345):         return (
0.64 schema.py(210):             if definition is None:
0.64 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(214):             if db_params["check"]:
0.64 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.64 schema.py(218):             if col_type_suffix:
0.64 schema.py(219):                 definition += " %s" % col_type_suffix
0.64 schema.py(220):             params.extend(extra_params)
0.64 schema.py(222):             if field.remote_field and field.db_constraint:
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(242):                     self.quote_name(field.column),
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(243):                     definition,
0.64 schema.py(241):                 % (
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(248):             if field.get_internal_type() in (
0.64 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.64 schema.py(254):                     model._meta.db_table, field.column
0.64 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.64 schema.py(256):                 if autoinc_sql:
0.64 schema.py(207):         for field in model._meta.local_fields:
0.64 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.64 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(340):         column_db_type = field_db_params["type"]
0.64 schema.py(342):         if column_db_type is None:
0.64 schema.py(344):         params = []
0.64 schema.py(346):             " ".join(
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(349):                     column_db_type,
0.64 schema.py(350):                     params,
0.64 schema.py(351):                     model,
0.64 schema.py(352):                     field,
0.64 schema.py(353):                     field_db_params,
0.64 schema.py(354):                     include_default,
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(346):             " ".join(
0.64 schema.py(281):         yield column_db_type
0.64 schema.py(282):         if collation := field_db_params.get("collation"):
0.64 schema.py(285):         null = field.null
0.64 schema.py(288):             include_default
0.64 schema.py(287):         include_default = (
0.64 schema.py(296):         if include_default:
0.64 schema.py(311):             field.empty_strings_allowed
0.64 schema.py(310):         if (
0.64 schema.py(312):             and not field.primary_key
0.64 schema.py(310):         if (
0.64 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.64 schema.py(310):         if (
0.64 schema.py(316):         if not null:
0.64 schema.py(317):             yield "NOT NULL"
0.64 schema.py(320):         if field.primary_key:
0.64 schema.py(322):         elif field.unique:
0.64 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.64 schema.py(327):             tablespace
0.64 schema.py(326):         if (
0.64 schema.py(357):             params,
0.64 schema.py(345):         return (
0.64 schema.py(210):             if definition is None:
0.64 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(214):             if db_params["check"]:
0.64 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.64 schema.py(218):             if col_type_suffix:
0.64 schema.py(220):             params.extend(extra_params)
0.64 schema.py(222):             if field.remote_field and field.db_constraint:
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(242):                     self.quote_name(field.column),
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(243):                     definition,
0.64 schema.py(241):                 % (
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(248):             if field.get_internal_type() in (
0.64 schema.py(207):         for field in model._meta.local_fields:
0.64 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.64 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(340):         column_db_type = field_db_params["type"]
0.64 schema.py(342):         if column_db_type is None:
0.64 schema.py(344):         params = []
0.64 schema.py(346):             " ".join(
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(349):                     column_db_type,
0.64 schema.py(350):                     params,
0.64 schema.py(351):                     model,
0.64 schema.py(352):                     field,
0.64 schema.py(353):                     field_db_params,
0.64 schema.py(354):                     include_default,
0.64 schema.py(348):                 self._iter_column_sql(
0.64 schema.py(346):             " ".join(
0.64 schema.py(281):         yield column_db_type
0.64 schema.py(282):         if collation := field_db_params.get("collation"):
0.64 schema.py(285):         null = field.null
0.64 schema.py(288):             include_default
0.64 schema.py(287):         include_default = (
0.64 schema.py(296):         if include_default:
0.64 schema.py(311):             field.empty_strings_allowed
0.64 schema.py(310):         if (
0.64 schema.py(312):             and not field.primary_key
0.64 schema.py(310):         if (
0.64 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.64 schema.py(310):         if (
0.64 schema.py(316):         if not null:
0.64 schema.py(317):             yield "NOT NULL"
0.64 schema.py(320):         if field.primary_key:
0.64 schema.py(322):         elif field.unique:
0.64 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.64 schema.py(327):             tablespace
0.64 schema.py(326):         if (
0.64 schema.py(357):             params,
0.64 schema.py(345):         return (
0.64 schema.py(210):             if definition is None:
0.64 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.64 schema.py(214):             if db_params["check"]:
0.64 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.64 schema.py(218):             if col_type_suffix:
0.64 schema.py(220):             params.extend(extra_params)
0.64 schema.py(222):             if field.remote_field and field.db_constraint:
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(242):                     self.quote_name(field.column),
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(243):                     definition,
0.64 schema.py(241):                 % (
0.64 schema.py(240):                 "%s %s"
0.64 schema.py(239):             column_sqls.append(
0.64 schema.py(248):             if field.get_internal_type() in (
0.64 schema.py(207):         for field in model._meta.local_fields:
0.64 schema.py(258):         constraints = [
0.64 schema.py(260):             for constraint in model._meta.constraints
0.64 schema.py(258):         constraints = [
0.64 schema.py(258):         constraints = [
0.64 schema.py(262):         sql = self.sql_create_table % {
0.64 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.64 schema.py(195):         return self.connection.ops.quote_name(name)
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.64 schema.py(264):             "definition": ", ".join(
0.64 schema.py(262):         sql = self.sql_create_table % {
0.64 schema.py(268):         if model._meta.db_tablespace:
0.64 schema.py(274):         return sql, params
0.64 schema.py(438):         self.execute(sql, params or None)
0.64 schema.py(168):             not self.collect_sql
0.64 schema.py(167):         if (
0.64 schema.py(169):             and self.connection.in_atomic_block
0.64 schema.py(167):         if (
0.64 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.64 schema.py(167):         if (
0.64 schema.py(177):         sql = str(sql)
0.64 schema.py(179):         logger.debug(
0.64 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.64 schema.py(179):         logger.debug(
0.64 schema.py(182):         if self.collect_sql:
0.64 schema.py(191):             with self.connection.cursor() as cursor:
0.64 schema.py(192):                 cursor.execute(sql, params)
0.64 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.64 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.64 schema.py(1369):         output = []
0.64 schema.py(1370):         for field in model._meta.local_fields:
0.64 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.64 schema.py(1389):         output = []
0.64 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.64 schema.py(1410):         return field.db_index and not field.unique
0.64 schema.py(1392):         return output
0.64 schema.py(1370):         for field in model._meta.local_fields:
0.64 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.64 schema.py(1389):         output = []
0.64 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.64 schema.py(1410):         return field.db_index and not field.unique
0.64 schema.py(1392):         return output
0.64 schema.py(1370):         for field in model._meta.local_fields:
0.64 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.64 schema.py(1389):         output = []
0.64 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.64 schema.py(1410):         return field.db_index and not field.unique
0.64 schema.py(1392):         return output
0.64 schema.py(1370):         for field in model._meta.local_fields:
0.64 schema.py(1373):         for field_names in model._meta.index_together:
0.64 schema.py(1377):         for index in model._meta.indexes:
0.64 schema.py(1383):         return output
0.64 schema.py(445):         for field in model._meta.local_many_to_many:
0.64 schema.py(39):         self.connection.check_constraints()
0.64 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.64 schema.py(155):         if exc_type is None:
0.64 schema.py(156):             for sql in self.deferred_sql:
0.64 schema.py(158):         if self.atomic_migration:
0.64 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.64 schema.py(41):         self.connection.enable_constraint_checking()
 OK
  Applying sites.0002_alter_domain_unique...0.64 schema.py(139):         self.connection = connection
0.64 schema.py(140):         self.collect_sql = collect_sql
0.64 schema.py(141):         if self.collect_sql:
0.64 schema.py(143):         self.atomic_migration = self.connection.features.can_rollback_ddl and atomic
0.64 schema.py(28):         if not self.connection.disable_constraint_checking():
0.64 schema.py(36):         return super().__enter__()
0.64 schema.py(148):         self.deferred_sql = []
0.64 schema.py(149):         if self.atomic_migration:
0.64 schema.py(150):             self.atomic = atomic(self.connection.alias)
0.64 schema.py(151):             self.atomic.__enter__()
0.64 schema.py(152):         return self
0.65 related.py(113):         apps.check_models_ready()
0.65 related.py(114):         return self.remote_field.model
0.65 related.py(113):         apps.check_models_ready()
0.65 related.py(114):         return self.remote_field.model
0.65 schema.py(124):         if not self._field_should_be_altered(old_field, new_field):
0.65 schema.py(1395):         _, old_path, old_args, old_kwargs = old_field.deconstruct()
0.65 schema.py(1396):         _, new_path, new_args, new_kwargs = new_field.deconstruct()
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(1406):             new_field.column
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(1407):         ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(126):         old_field_name = old_field.name
0.65 schema.py(127):         table_name = model._meta.db_table
0.65 schema.py(128):         _, old_column_name = old_field.get_attname_column()
0.65 schema.py(130):             new_field.name != old_field_name
0.65 schema.py(129):         if (
0.65 schema.py(174):             super().alter_field(model, old_field, new_field, strict=strict)
0.65 schema.py(708):         if not self._field_should_be_altered(old_field, new_field):
0.65 schema.py(1395):         _, old_path, old_args, old_kwargs = old_field.deconstruct()
0.65 schema.py(1396):         _, new_path, new_args, new_kwargs = new_field.deconstruct()
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1402):             old_kwargs.pop(attr, None)
0.65 schema.py(1401):         for attr in old_field.non_db_attrs:
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1404):             new_kwargs.pop(attr, None)
0.65 schema.py(1403):         for attr in new_field.non_db_attrs:
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(1406):             new_field.column
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(1407):         ) or (old_path, old_args, old_kwargs) != (new_path, new_args, new_kwargs)
0.65 schema.py(1405):         return self.quote_name(old_field.column) != self.quote_name(
0.65 schema.py(711):         old_db_params = old_field.db_parameters(connection=self.connection)
0.65 schema.py(712):         old_type = old_db_params["type"]
0.65 schema.py(713):         new_db_params = new_field.db_parameters(connection=self.connection)
0.65 schema.py(714):         new_type = new_db_params["type"]
0.65 schema.py(715):         if (old_type is None and old_field.remote_field is None) or (
0.65 schema.py(716):             new_type is None and new_field.remote_field is None
0.65 schema.py(715):         if (old_type is None and old_field.remote_field is None) or (
0.65 schema.py(724):             old_type is None
0.65 schema.py(723):         elif (
0.65 schema.py(735):             old_type is None
0.65 schema.py(734):         elif (
0.65 schema.py(746):         elif old_type is None or new_type is None:
0.65 schema.py(753):         self._alter_field(
0.65 schema.py(754):             model,
0.65 schema.py(755):             old_field,
0.65 schema.py(756):             new_field,
0.65 schema.py(757):             old_type,
0.65 schema.py(758):             new_type,
0.65 schema.py(759):             old_db_params,
0.65 schema.py(760):             new_db_params,
0.65 schema.py(761):             strict,
0.65 schema.py(753):         self._alter_field(
0.65 schema.py(440):             self.connection.features.can_alter_table_rename_column
0.65 schema.py(439):         if (
0.65 schema.py(441):             and old_field.column != new_field.column
0.65 schema.py(439):         if (
0.65 schema.py(456):         self._remake_table(model, alter_field=(old_field, new_field))
0.65 schema.py(197):         def is_self_referential(f):
0.65 schema.py(201):         body = {
0.65 schema.py(203):             for f in model._meta.local_concrete_fields
0.65 schema.py(201):         body = {
0.65 schema.py(201):         body = {
0.65 schema.py(203):             for f in model._meta.local_concrete_fields
0.65 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.65 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.65 schema.py(201):         body = {
0.65 schema.py(203):             for f in model._meta.local_concrete_fields
0.65 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.65 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.65 schema.py(201):         body = {
0.65 schema.py(203):             for f in model._meta.local_concrete_fields
0.65 schema.py(202):             f.name: f.clone() if is_self_referential(f) else f
0.65 schema.py(198):             return f.is_relation and f.remote_field.model is model
0.65 schema.py(201):         body = {
0.65 schema.py(207):         mapping = {
0.65 schema.py(209):             for f in model._meta.local_concrete_fields
0.65 schema.py(207):         mapping = {
0.65 schema.py(207):         mapping = {
0.65 schema.py(209):             for f in model._meta.local_concrete_fields
0.65 schema.py(208):             f.column: self.quote_name(f.column)
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(207):         mapping = {
0.65 schema.py(209):             for f in model._meta.local_concrete_fields
0.65 schema.py(208):             f.column: self.quote_name(f.column)
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(207):         mapping = {
0.65 schema.py(209):             for f in model._meta.local_concrete_fields
0.65 schema.py(208):             f.column: self.quote_name(f.column)
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(207):         mapping = {
0.65 schema.py(212):         rename_mapping = {}
0.65 schema.py(215):         restore_pk_field = None
0.65 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.65 schema.py(217):             alter_field and getattr(alter_field[1], "primary_key", False)
0.65 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.65 schema.py(217):             alter_field and getattr(alter_field[1], "primary_key", False)
0.65 schema.py(216):         if getattr(create_field, "primary_key", False) or (
0.65 schema.py(232):         if create_field:
0.65 schema.py(240):         if alter_field:
0.65 schema.py(241):             old_field, new_field = alter_field
0.65 schema.py(242):             body.pop(old_field.name, None)
0.65 schema.py(243):             mapping.pop(old_field.column, None)
0.65 schema.py(244):             body[new_field.name] = new_field
0.65 schema.py(245):             if old_field.null and not new_field.null:
0.65 schema.py(252):                 mapping[new_field.column] = self.quote_name(old_field.column)
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(253):             rename_mapping[old_field.name] = new_field.name
0.65 schema.py(255):         if delete_field:
0.65 schema.py(265):         apps = Apps()
0.65 schema.py(269):         unique_together = [
0.65 schema.py(271):             for unique in model._meta.unique_together
0.65 schema.py(269):         unique_together = [
0.65 schema.py(269):         unique_together = [
0.65 schema.py(276):         index_together = [
0.65 schema.py(278):             for index in model._meta.index_together
0.65 schema.py(276):         index_together = [
0.65 schema.py(276):         index_together = [
0.65 schema.py(281):         indexes = model._meta.indexes
0.65 schema.py(282):         if delete_field:
0.65 schema.py(287):         constraints = list(model._meta.constraints)
0.65 schema.py(292):         body_copy = copy.deepcopy(body)
0.65 schema.py(300):             "app_label": model._meta.app_label,
0.65 schema.py(301):             "db_table": model._meta.db_table,
0.65 schema.py(302):             "unique_together": unique_together,
0.65 schema.py(303):             "index_together": index_together,
0.65 schema.py(304):             "indexes": indexes,
0.65 schema.py(305):             "constraints": constraints,
0.65 schema.py(306):             "apps": apps,
0.65 schema.py(299):         meta_contents = {
0.65 schema.py(308):         meta = type("Meta", (), meta_contents)
0.65 schema.py(309):         body_copy["Meta"] = meta
0.65 schema.py(310):         body_copy["__module__"] = model.__module__
0.65 schema.py(311):         type(model._meta.object_name, model.__bases__, body_copy)
0.65 schema.py(314):         body_copy = copy.deepcopy(body)
0.65 schema.py(316):             "app_label": model._meta.app_label,
0.65 schema.py(317):             "db_table": "new__%s" % strip_quotes(model._meta.db_table),
0.65 schema.py(318):             "unique_together": unique_together,
0.65 schema.py(319):             "index_together": index_together,
0.65 schema.py(320):             "indexes": indexes,
0.65 schema.py(321):             "constraints": constraints,
0.65 schema.py(322):             "apps": apps,
0.65 schema.py(315):         meta_contents = {
0.65 schema.py(324):         meta = type("Meta", (), meta_contents)
0.65 schema.py(325):         body_copy["Meta"] = meta
0.65 schema.py(326):         body_copy["__module__"] = model.__module__
0.65 schema.py(327):         new_model = type("New%s" % model._meta.object_name, model.__bases__, body_copy)
0.65 schema.py(330):         self.create_model(new_model)
0.65 schema.py(435):         sql, params = self.table_sql(model)
0.65 schema.py(201):         for field_names in model._meta.unique_together:
0.65 schema.py(205):         column_sqls = []
0.65 schema.py(206):         params = []
0.65 schema.py(207):         for field in model._meta.local_fields:
0.65 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.65 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(340):         column_db_type = field_db_params["type"]
0.65 schema.py(342):         if column_db_type is None:
0.65 schema.py(344):         params = []
0.65 schema.py(346):             " ".join(
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(349):                     column_db_type,
0.65 schema.py(350):                     params,
0.65 schema.py(351):                     model,
0.65 schema.py(352):                     field,
0.65 schema.py(353):                     field_db_params,
0.65 schema.py(354):                     include_default,
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(346):             " ".join(
0.65 schema.py(281):         yield column_db_type
0.65 schema.py(282):         if collation := field_db_params.get("collation"):
0.65 schema.py(285):         null = field.null
0.65 schema.py(288):             include_default
0.65 schema.py(287):         include_default = (
0.65 schema.py(296):         if include_default:
0.65 schema.py(311):             field.empty_strings_allowed
0.65 schema.py(310):         if (
0.65 schema.py(316):         if not null:
0.65 schema.py(317):             yield "NOT NULL"
0.65 schema.py(320):         if field.primary_key:
0.65 schema.py(321):             yield "PRIMARY KEY"
0.65 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.65 schema.py(327):             tablespace
0.65 schema.py(326):         if (
0.65 schema.py(357):             params,
0.65 schema.py(345):         return (
0.65 schema.py(210):             if definition is None:
0.65 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(214):             if db_params["check"]:
0.65 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.65 schema.py(218):             if col_type_suffix:
0.65 schema.py(219):                 definition += " %s" % col_type_suffix
0.65 schema.py(220):             params.extend(extra_params)
0.65 schema.py(222):             if field.remote_field and field.db_constraint:
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(242):                     self.quote_name(field.column),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(243):                     definition,
0.65 schema.py(241):                 % (
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(248):             if field.get_internal_type() in (
0.65 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.65 schema.py(254):                     model._meta.db_table, field.column
0.65 schema.py(253):                 autoinc_sql = self.connection.ops.autoinc_sql(
0.65 schema.py(256):                 if autoinc_sql:
0.65 schema.py(207):         for field in model._meta.local_fields:
0.65 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.65 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(340):         column_db_type = field_db_params["type"]
0.65 schema.py(342):         if column_db_type is None:
0.65 schema.py(344):         params = []
0.65 schema.py(346):             " ".join(
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(349):                     column_db_type,
0.65 schema.py(350):                     params,
0.65 schema.py(351):                     model,
0.65 schema.py(352):                     field,
0.65 schema.py(353):                     field_db_params,
0.65 schema.py(354):                     include_default,
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(346):             " ".join(
0.65 schema.py(281):         yield column_db_type
0.65 schema.py(282):         if collation := field_db_params.get("collation"):
0.65 schema.py(285):         null = field.null
0.65 schema.py(288):             include_default
0.65 schema.py(287):         include_default = (
0.65 schema.py(296):         if include_default:
0.65 schema.py(311):             field.empty_strings_allowed
0.65 schema.py(310):         if (
0.65 schema.py(312):             and not field.primary_key
0.65 schema.py(310):         if (
0.65 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.65 schema.py(310):         if (
0.65 schema.py(316):         if not null:
0.65 schema.py(317):             yield "NOT NULL"
0.65 schema.py(320):         if field.primary_key:
0.65 schema.py(322):         elif field.unique:
0.65 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.65 schema.py(327):             tablespace
0.65 schema.py(326):         if (
0.65 schema.py(357):             params,
0.65 schema.py(345):         return (
0.65 schema.py(210):             if definition is None:
0.65 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(214):             if db_params["check"]:
0.65 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.65 schema.py(218):             if col_type_suffix:
0.65 schema.py(220):             params.extend(extra_params)
0.65 schema.py(222):             if field.remote_field and field.db_constraint:
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(242):                     self.quote_name(field.column),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(243):                     definition,
0.65 schema.py(241):                 % (
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(248):             if field.get_internal_type() in (
0.65 schema.py(207):         for field in model._meta.local_fields:
0.65 schema.py(209):             definition, extra_params = self.column_sql(model, field)
0.65 schema.py(339):         field_db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(340):         column_db_type = field_db_params["type"]
0.65 schema.py(342):         if column_db_type is None:
0.65 schema.py(344):         params = []
0.65 schema.py(346):             " ".join(
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(349):                     column_db_type,
0.65 schema.py(350):                     params,
0.65 schema.py(351):                     model,
0.65 schema.py(352):                     field,
0.65 schema.py(353):                     field_db_params,
0.65 schema.py(354):                     include_default,
0.65 schema.py(348):                 self._iter_column_sql(
0.65 schema.py(346):             " ".join(
0.65 schema.py(281):         yield column_db_type
0.65 schema.py(282):         if collation := field_db_params.get("collation"):
0.65 schema.py(285):         null = field.null
0.65 schema.py(288):             include_default
0.65 schema.py(287):         include_default = (
0.65 schema.py(296):         if include_default:
0.65 schema.py(311):             field.empty_strings_allowed
0.65 schema.py(310):         if (
0.65 schema.py(312):             and not field.primary_key
0.65 schema.py(310):         if (
0.65 schema.py(313):             and self.connection.features.interprets_empty_strings_as_nulls
0.65 schema.py(310):         if (
0.65 schema.py(316):         if not null:
0.65 schema.py(317):             yield "NOT NULL"
0.65 schema.py(320):         if field.primary_key:
0.65 schema.py(322):         elif field.unique:
0.65 schema.py(323):             yield "UNIQUE"
0.65 schema.py(325):         tablespace = field.db_tablespace or model._meta.db_tablespace
0.65 schema.py(327):             tablespace
0.65 schema.py(326):         if (
0.65 schema.py(357):             params,
0.65 schema.py(345):         return (
0.65 schema.py(210):             if definition is None:
0.65 schema.py(213):             db_params = field.db_parameters(connection=self.connection)
0.65 schema.py(214):             if db_params["check"]:
0.65 schema.py(217):             col_type_suffix = field.db_type_suffix(connection=self.connection)
0.65 schema.py(218):             if col_type_suffix:
0.65 schema.py(220):             params.extend(extra_params)
0.65 schema.py(222):             if field.remote_field and field.db_constraint:
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(242):                     self.quote_name(field.column),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(243):                     definition,
0.65 schema.py(241):                 % (
0.65 schema.py(240):                 "%s %s"
0.65 schema.py(239):             column_sqls.append(
0.65 schema.py(248):             if field.get_internal_type() in (
0.65 schema.py(207):         for field in model._meta.local_fields:
0.65 schema.py(258):         constraints = [
0.65 schema.py(260):             for constraint in model._meta.constraints
0.65 schema.py(258):         constraints = [
0.65 schema.py(258):         constraints = [
0.65 schema.py(262):         sql = self.sql_create_table % {
0.65 schema.py(263):             "table": self.quote_name(model._meta.db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(265):                 constraint for constraint in (*column_sqls, *constraints) if constraint
0.65 schema.py(264):             "definition": ", ".join(
0.65 schema.py(262):         sql = self.sql_create_table % {
0.65 schema.py(268):         if model._meta.db_tablespace:
0.65 schema.py(274):         return sql, params
0.65 schema.py(438):         self.execute(sql, params or None)
0.65 schema.py(168):             not self.collect_sql
0.65 schema.py(167):         if (
0.65 schema.py(169):             and self.connection.in_atomic_block
0.65 schema.py(167):         if (
0.65 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.65 schema.py(167):         if (
0.65 schema.py(177):         sql = str(sql)
0.65 schema.py(179):         logger.debug(
0.65 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.65 schema.py(179):         logger.debug(
0.65 schema.py(182):         if self.collect_sql:
0.65 schema.py(191):             with self.connection.cursor() as cursor:
0.65 schema.py(192):                 cursor.execute(sql, params)
0.65 schema.py(442):         self.deferred_sql.extend(self._model_indexes_sql(model))
0.65 schema.py(1367):         if not model._meta.managed or model._meta.proxy or model._meta.swapped:
0.65 schema.py(1369):         output = []
0.65 schema.py(1370):         for field in model._meta.local_fields:
0.65 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.65 schema.py(1389):         output = []
0.65 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.65 schema.py(1410):         return field.db_index and not field.unique
0.65 schema.py(1392):         return output
0.65 schema.py(1370):         for field in model._meta.local_fields:
0.65 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.65 schema.py(1389):         output = []
0.65 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.65 schema.py(1410):         return field.db_index and not field.unique
0.65 schema.py(1392):         return output
0.65 schema.py(1370):         for field in model._meta.local_fields:
0.65 schema.py(1371):             output.extend(self._field_indexes_sql(model, field))
0.65 schema.py(1389):         output = []
0.65 schema.py(1390):         if self._field_should_be_indexed(model, field):
0.65 schema.py(1410):         return field.db_index and not field.unique
0.65 schema.py(1392):         return output
0.65 schema.py(1370):         for field in model._meta.local_fields:
0.65 schema.py(1373):         for field_names in model._meta.index_together:
0.65 schema.py(1377):         for index in model._meta.indexes:
0.65 schema.py(1383):         return output
0.65 schema.py(445):         for field in model._meta.local_many_to_many:
0.65 schema.py(333):         self.execute(
0.65 schema.py(334):             "INSERT INTO %s (%s) SELECT %s FROM %s"
0.65 schema.py(336):                 self.quote_name(new_model._meta.db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.65 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(337):                 ", ".join(self.quote_name(x) for x in mapping),
0.65 schema.py(338):                 ", ".join(mapping.values()),
0.65 schema.py(339):                 self.quote_name(model._meta.db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(335):             % (
0.65 schema.py(334):             "INSERT INTO %s (%s) SELECT %s FROM %s"
0.65 schema.py(333):         self.execute(
0.65 schema.py(168):             not self.collect_sql
0.65 schema.py(167):         if (
0.65 schema.py(169):             and self.connection.in_atomic_block
0.65 schema.py(167):         if (
0.65 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.65 schema.py(167):         if (
0.65 schema.py(177):         sql = str(sql)
0.65 schema.py(179):         logger.debug(
0.65 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.65 schema.py(179):         logger.debug(
0.65 schema.py(182):         if self.collect_sql:
0.65 schema.py(191):             with self.connection.cursor() as cursor:
0.65 schema.py(192):                 cursor.execute(sql, params)
0.65 schema.py(344):         self.delete_model(model, handle_autom2m=False)
0.65 schema.py(363):         if handle_autom2m:
0.65 schema.py(367):             self.execute(
0.65 schema.py(368):                 self.sql_delete_table
0.65 schema.py(370):                     "table": self.quote_name(model._meta.db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(369):                 % {
0.65 schema.py(368):                 self.sql_delete_table
0.65 schema.py(367):             self.execute(
0.65 schema.py(168):             not self.collect_sql
0.65 schema.py(167):         if (
0.65 schema.py(169):             and self.connection.in_atomic_block
0.65 schema.py(167):         if (
0.65 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.65 schema.py(167):         if (
0.65 schema.py(177):         sql = str(sql)
0.65 schema.py(179):         logger.debug(
0.65 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.65 schema.py(179):         logger.debug(
0.65 schema.py(182):         if self.collect_sql:
0.65 schema.py(191):             with self.connection.cursor() as cursor:
0.65 schema.py(192):                 cursor.execute(sql, params)
0.65 schema.py(374):             for sql in list(self.deferred_sql):
0.65 schema.py(347):         self.alter_db_table(
0.65 schema.py(348):             new_model,
0.65 schema.py(349):             new_model._meta.db_table,
0.65 schema.py(350):             model._meta.db_table,
0.65 schema.py(351):             disable_constraints=False,
0.65 schema.py(347):         self.alter_db_table(
0.65 schema.py(104):             not self.connection.features.supports_atomic_references_rename
0.65 schema.py(103):         if (
0.65 schema.py(121):             super().alter_db_table(model, old_db_table, new_db_table)
0.65 schema.py(568):         if old_db_table == new_db_table or (
0.65 schema.py(569):             self.connection.features.ignores_table_name_case
0.65 schema.py(568):         if old_db_table == new_db_table or (
0.65 schema.py(570):             and old_db_table.lower() == new_db_table.lower()
0.65 schema.py(568):         if old_db_table == new_db_table or (
0.65 schema.py(573):         self.execute(
0.65 schema.py(574):             self.sql_rename_table
0.65 schema.py(576):                 "old_table": self.quote_name(old_db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(577):                 "new_table": self.quote_name(new_db_table),
0.65 schema.py(195):         return self.connection.ops.quote_name(name)
0.65 schema.py(575):             % {
0.65 schema.py(574):             self.sql_rename_table
0.65 schema.py(573):         self.execute(
0.65 schema.py(168):             not self.collect_sql
0.65 schema.py(167):         if (
0.65 schema.py(169):             and self.connection.in_atomic_block
0.65 schema.py(167):         if (
0.65 schema.py(170):             and not self.connection.features.can_rollback_ddl
0.65 schema.py(167):         if (
0.65 schema.py(177):         sql = str(sql)
0.65 schema.py(179):         logger.debug(
0.65 schema.py(180):             "%s; (params %r)", sql, params, extra={"params": params, "sql": sql}
0.65 schema.py(179):         logger.debug(
0.65 schema.py(182):         if self.collect_sql:
0.65 schema.py(191):             with self.connection.cursor() as cursor:
0.65 schema.py(192):                 cursor.execute(sql, params)
0.65 schema.py(581):         for sql in self.deferred_sql:
0.65 schema.py(355):         for sql in self.deferred_sql:
0.65 schema.py(357):         self.deferred_sql = []
0.65 schema.py(359):         if restore_pk_field:
0.65 schema.py(458):         old_collation = old_db_params.get("collation")
0.65 schema.py(459):         new_collation = new_db_params.get("collation")
0.65 schema.py(460):         if new_field.unique and (
0.65 schema.py(461):             old_type != new_type or old_collation != new_collation
0.65 schema.py(460):         if new_field.unique and (
0.65 schema.py(461):             old_type != new_type or old_collation != new_collation
0.65 schema.py(460):         if new_field.unique and (
0.65 schema.py(39):         self.connection.check_constraints()
0.65 schema.py(40):         super().__exit__(exc_type, exc_value, traceback)
0.65 schema.py(155):         if exc_type is None:
0.65 schema.py(156):             for sql in self.deferred_sql:
0.65 schema.py(158):         if self.atomic_migration:
0.65 schema.py(159):             self.atomic.__exit__(exc_type, exc_value, traceback)
0.65 schema.py(41):         self.connection.enable_constraint_checking()
 OK
0.65 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(382):         if self._limit_choices_to:
0.65 related.py(384):         if self._related_name is not None:
0.65 related.py(386):         if self._related_query_name is not None:
0.65 related.py(388):         return name, path, args, kwargs
0.65 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.65 related.py(674):         kwargs["from_fields"] = self.from_fields
0.65 related.py(675):         kwargs["to_fields"] = self.to_fields
0.65 related.py(677):         if self.remote_field.parent_link:
0.65 related.py(679):         if isinstance(self.remote_field.model, str):
0.65 related.py(680):             if "." in self.remote_field.model:
0.65 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.65 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.65 related.py(689):         swappable_setting = self.swappable_setting
0.65 related.py(428):         if self.swappable:
0.65 related.py(430):             if isinstance(self.remote_field.model, str):
0.65 related.py(431):                 to_string = self.remote_field.model
0.65 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.65 related.py(690):         if swappable_setting is not None:
0.65 related.py(704):         return name, path, args, kwargs
0.65 related.py(1037):         del kwargs["to_fields"]
0.65 related.py(1038):         del kwargs["from_fields"]
0.65 related.py(1040):         if self.db_index:
0.65 related.py(1041):             del kwargs["db_index"]
0.65 related.py(1044):         if self.db_constraint is not True:
0.65 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.65 related.py(1048):         if self.remote_field.field_name and (
0.65 related.py(1053):         return name, path, args, kwargs
0.65 related.py(936):         try:
0.65 related.py(937):             to._meta.model_name
0.65 related.py(938):         except AttributeError:
0.65 related.py(939):             if not isinstance(to, str):
0.65 related.py(954):         if not callable(on_delete):
0.65 related.py(957):         kwargs["rel"] = self.rel_class(
0.65 related.py(958):             self,
0.65 related.py(959):             to,
0.65 related.py(960):             to_field,
0.65 related.py(961):             related_name=related_name,
0.65 related.py(962):             related_query_name=related_query_name,
0.65 related.py(963):             limit_choices_to=limit_choices_to,
0.65 related.py(964):             parent_link=parent_link,
0.65 related.py(965):             on_delete=on_delete,
0.65 related.py(957):         kwargs["rel"] = self.rel_class(
0.65 related.py(967):         kwargs.setdefault("db_index", True)
0.65 related.py(969):         super().__init__(
0.65 related.py(970):             to,
0.65 related.py(971):             on_delete,
0.65 related.py(969):         super().__init__(
0.65 related.py(972):             related_name=related_name,
0.65 related.py(973):             related_query_name=related_query_name,
0.65 related.py(974):             limit_choices_to=limit_choices_to,
0.65 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.65 related.py(976):             to_fields=[to_field],
0.65 related.py(969):         super().__init__(
0.65 related.py(977):             **kwargs,
0.65 related.py(969):         super().__init__(
0.65 related.py(544):         if rel is None:
0.65 related.py(555):         super().__init__(
0.65 related.py(556):             rel=rel,
0.65 related.py(557):             related_name=related_name,
0.65 related.py(558):             related_query_name=related_query_name,
0.65 related.py(559):             limit_choices_to=limit_choices_to,
0.65 related.py(555):         super().__init__(
0.65 related.py(560):             **kwargs,
0.65 related.py(555):         super().__init__(
0.65 related.py(105):         self._related_name = related_name
0.65 related.py(106):         self._related_query_name = related_query_name
0.65 related.py(107):         self._limit_choices_to = limit_choices_to
0.65 related.py(108):         super().__init__(**kwargs)
0.65 related.py(563):         self.from_fields = from_fields
0.65 related.py(564):         self.to_fields = to_fields
0.65 related.py(565):         self.swappable = swappable
0.65 related.py(979):         self.db_constraint = db_constraint
0.65 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.65 related.py(382):         if self._limit_choices_to:
0.65 related.py(384):         if self._related_name is not None:
0.65 related.py(386):         if self._related_query_name is not None:
0.65 related.py(388):         return name, path, args, kwargs
0.65 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.65 related.py(674):         kwargs["from_fields"] = self.from_fields
0.65 related.py(675):         kwargs["to_fields"] = self.to_fields
0.65 related.py(677):         if self.remote_field.parent_link:
0.65 related.py(679):         if isinstance(self.remote_field.model, str):
0.65 related.py(680):             if "." in self.remote_field.model:
0.65 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.65 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.65 related.py(689):         swappable_setting = self.swappable_setting
0.65 related.py(428):         if self.swappable:
0.65 related.py(430):             if isinstance(self.remote_field.model, str):
0.65 related.py(431):                 to_string = self.remote_field.model
0.65 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.65 related.py(690):         if swappable_setting is not None:
0.65 related.py(692):             if hasattr(kwargs["to"], "setting_name"):
0.65 related.py(700):             kwargs["to"] = SettingsReference(
0.65 related.py(701):                 kwargs["to"],
0.65 related.py(702):                 swappable_setting,
0.65 related.py(700):             kwargs["to"] = SettingsReference(
0.65 related.py(704):         return name, path, args, kwargs
0.65 related.py(1037):         del kwargs["to_fields"]
0.65 related.py(1038):         del kwargs["from_fields"]
0.65 related.py(1040):         if self.db_index:
0.65 related.py(1041):             del kwargs["db_index"]
0.65 related.py(1044):         if self.db_constraint is not True:
0.65 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.65 related.py(1048):         if self.remote_field.field_name and (
0.65 related.py(1053):         return name, path, args, kwargs
0.65 related.py(936):         try:
0.65 related.py(937):             to._meta.model_name
0.65 related.py(938):         except AttributeError:
0.65 related.py(939):             if not isinstance(to, str):
0.65 related.py(954):         if not callable(on_delete):
0.65 related.py(957):         kwargs["rel"] = self.rel_class(
0.65 related.py(958):             self,
0.65 related.py(959):             to,
0.65 related.py(960):             to_field,
0.65 related.py(961):             related_name=related_name,
0.65 related.py(962):             related_query_name=related_query_name,
0.65 related.py(963):             limit_choices_to=limit_choices_to,
0.65 related.py(964):             parent_link=parent_link,
0.65 related.py(965):             on_delete=on_delete,
0.65 related.py(957):         kwargs["rel"] = self.rel_class(
0.65 related.py(967):         kwargs.setdefault("db_index", True)
0.65 related.py(969):         super().__init__(
0.65 related.py(970):             to,
0.65 related.py(971):             on_delete,
0.65 related.py(969):         super().__init__(
0.65 related.py(972):             related_name=related_name,
0.65 related.py(973):             related_query_name=related_query_name,
0.65 related.py(974):             limit_choices_to=limit_choices_to,
0.65 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.65 related.py(976):             to_fields=[to_field],
0.65 related.py(969):         super().__init__(
0.65 related.py(977):             **kwargs,
0.65 related.py(969):         super().__init__(
0.65 related.py(544):         if rel is None:
0.65 related.py(555):         super().__init__(
0.65 related.py(556):             rel=rel,
0.65 related.py(557):             related_name=related_name,
0.65 related.py(558):             related_query_name=related_query_name,
0.65 related.py(559):             limit_choices_to=limit_choices_to,
0.65 related.py(555):         super().__init__(
0.65 related.py(560):             **kwargs,
0.65 related.py(555):         super().__init__(
0.65 related.py(105):         self._related_name = related_name
0.65 related.py(106):         self._related_query_name = related_query_name
0.65 related.py(107):         self._limit_choices_to = limit_choices_to
0.65 related.py(108):         super().__init__(**kwargs)
0.65 related.py(563):         self.from_fields = from_fields
0.65 related.py(564):         self.to_fields = to_fields
0.65 related.py(565):         self.swappable = swappable
0.65 related.py(979):         self.db_constraint = db_constraint
0.65 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.65 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.65 related.py(1125):         attname = self.get_attname()
0.65 related.py(1122):         return "%s_id" % self.name
0.65 related.py(1126):         column = self.db_column or attname
0.65 related.py(1127):         return attname, column
0.65 related.py(350):         self.opts = cls._meta
0.65 related.py(352):         if not cls._meta.abstract:
0.65 related.py(353):             if self.remote_field.related_name:
0.65 related.py(356):                 related_name = self.opts.default_related_name
0.65 related.py(357):             if related_name:
0.65 related.py(365):             if self.remote_field.related_query_name:
0.65 related.py(372):             def resolve_related_class(model, related, field):
0.65 related.py(376):             lazy_related_operation(
0.65 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.65 related.py(376):             lazy_related_operation(
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.65 related.py(61):     if isinstance(relation, str):
0.65 related.py(62):         if "." not in relation:
0.65 related.py(65):     return relation
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(85):     apps = model._meta.apps
0.65 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.65 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.65 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.65 related.py(1125):         attname = self.get_attname()
0.65 related.py(1122):         return "%s_id" % self.name
0.65 related.py(1126):         column = self.db_column or attname
0.65 related.py(1127):         return attname, column
0.65 related.py(350):         self.opts = cls._meta
0.65 related.py(352):         if not cls._meta.abstract:
0.65 related.py(353):             if self.remote_field.related_name:
0.65 related.py(356):                 related_name = self.opts.default_related_name
0.65 related.py(357):             if related_name:
0.65 related.py(365):             if self.remote_field.related_query_name:
0.65 related.py(372):             def resolve_related_class(model, related, field):
0.65 related.py(376):             lazy_related_operation(
0.65 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.65 related.py(376):             lazy_related_operation(
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.65 related.py(61):     if isinstance(relation, str):
0.65 related.py(62):         if "." not in relation:
0.65 related.py(65):     return relation
0.65 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(85):     apps = model._meta.apps
0.65 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.65 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(875):             and not related.related_model._meta.swapped
0.66 related.py(873):         if (
0.66 related.py(877):             setattr(
0.66 related.py(878):                 cls._meta.concrete_model,
0.66 related.py(879):                 related.get_accessor_name(),
0.66 related.py(880):                 self.related_accessor_class(related),
0.66 related.py(877):             setattr(
0.66 related.py(885):             if self.remote_field.limit_choices_to:
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(875):             and not related.related_model._meta.swapped
0.66 related.py(873):         if (
0.66 related.py(877):             setattr(
0.66 related.py(878):                 cls._meta.concrete_model,
0.66 related.py(879):                 related.get_accessor_name(),
0.66 related.py(880):                 self.related_accessor_class(related),
0.66 related.py(877):             setattr(
0.66 related.py(885):             if self.remote_field.limit_choices_to:
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.66 related.py(674):         kwargs["from_fields"] = self.from_fields
0.66 related.py(675):         kwargs["to_fields"] = self.to_fields
0.66 related.py(677):         if self.remote_field.parent_link:
0.66 related.py(679):         if isinstance(self.remote_field.model, str):
0.66 related.py(686):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.66 related.py(689):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(433):                 to_string = self.remote_field.model._meta.label
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(690):         if swappable_setting is not None:
0.66 related.py(704):         return name, path, args, kwargs
0.66 related.py(1037):         del kwargs["to_fields"]
0.66 related.py(1038):         del kwargs["from_fields"]
0.66 related.py(1040):         if self.db_index:
0.66 related.py(1041):             del kwargs["db_index"]
0.66 related.py(1044):         if self.db_constraint is not True:
0.66 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.66 related.py(1048):         if self.remote_field.field_name and (
0.66 related.py(1049):             not to_meta
0.66 related.py(1048):         if self.remote_field.field_name and (
0.66 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.66 related.py(1048):         if self.remote_field.field_name and (
0.66 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.66 related.py(1048):         if self.remote_field.field_name and (
0.66 related.py(1053):         return name, path, args, kwargs
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(938):         except AttributeError:
0.66 related.py(939):             if not isinstance(to, str):
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(113):         apps.check_models_ready()
0.66 related.py(114):         return self.remote_field.model
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1747):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1749):             if isinstance(self.remote_field.through, str):
0.66 related.py(1751):             elif not self.remote_field.through._meta.auto_created:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(433):                 to_string = self.remote_field.model._meta.label
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(113):         apps.check_models_ready()
0.66 related.py(114):         return self.remote_field.model
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(385):             kwargs["related_name"] = self._related_name
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(387):             kwargs["related_query_name"] = self._related_query_name
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1747):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1749):             if isinstance(self.remote_field.through, str):
0.66 related.py(1751):             elif not self.remote_field.through._meta.auto_created:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(433):                 to_string = self.remote_field.model._meta.label
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(385):             kwargs["related_name"] = self._related_name
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(387):             kwargs["related_query_name"] = self._related_query_name
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1747):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1749):             if isinstance(self.remote_field.through, str):
0.66 related.py(1751):             elif not self.remote_field.through._meta.auto_created:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(433):                 to_string = self.remote_field.model._meta.label
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(113):         apps.check_models_ready()
0.66 related.py(114):         return self.remote_field.model
0.66 related.py(113):         apps.check_models_ready()
0.66 related.py(114):         return self.remote_field.model
0.66 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.66 related.py(674):         kwargs["from_fields"] = self.from_fields
0.66 related.py(675):         kwargs["to_fields"] = self.to_fields
0.66 related.py(677):         if self.remote_field.parent_link:
0.66 related.py(679):         if isinstance(self.remote_field.model, str):
0.66 related.py(680):             if "." in self.remote_field.model:
0.66 related.py(681):                 app_label, model_name = self.remote_field.model.split(".")
0.66 related.py(682):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.66 related.py(689):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(431):                 to_string = self.remote_field.model
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(690):         if swappable_setting is not None:
0.66 related.py(704):         return name, path, args, kwargs
0.66 related.py(1037):         del kwargs["to_fields"]
0.66 related.py(1038):         del kwargs["from_fields"]
0.66 related.py(1040):         if self.db_index:
0.66 related.py(1041):             del kwargs["db_index"]
0.66 related.py(1044):         if self.db_constraint is not True:
0.66 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.66 related.py(1048):         if self.remote_field.field_name and (
0.66 related.py(1053):         return name, path, args, kwargs
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(938):         except AttributeError:
0.66 related.py(939):             if not isinstance(to, str):
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(356):                 related_name = self.opts.default_related_name
0.66 related.py(357):             if related_name:
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1741):             if "." in self.remote_field.model:
0.66 related.py(1742):                 app_label, model_name = self.remote_field.model.split(".")
0.66 related.py(1743):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(431):                 to_string = self.remote_field.model
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(1888):         if self.remote_field.symmetrical and (
0.66 related.py(1893):         elif self.remote_field.is_hidden():
0.66 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(356):                 related_name = self.opts.default_related_name
0.66 related.py(357):             if related_name:
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1910):         if not cls._meta.abstract:
0.66 related.py(1911):             if self.remote_field.through:
0.66 related.py(1919):             elif not cls._meta.swapped:
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1921):                     self, cls
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1262):     from django.db import models
0.66 related.py(1264):     def set_managed(model, related, through):
0.66 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.66 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1271):     to = make_model_tuple(to_model)[1]
0.66 related.py(1272):     from_ = klass._meta.model_name
0.66 related.py(1273):     if to == from_:
0.66 related.py(1277):     meta = type(
0.66 related.py(1278):         "Meta",
0.66 related.py(1279):         (),
0.66 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.66 related.py(1822):         if self.remote_field.through is not None:
0.66 related.py(1824):         elif self.db_table:
0.66 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.66 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.66 related.py(1282):             "auto_created": klass,
0.66 related.py(1283):             "app_label": klass._meta.app_label,
0.66 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.66 related.py(1285):             "unique_together": (from_, to),
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1287):             % {"from": from_, "to": to},
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1289):             % {"from": from_, "to": to},
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1290):             "apps": field.model._meta.apps,
0.66 related.py(1280):         {
0.66 related.py(1277):     meta = type(
0.66 related.py(1294):     return type(
0.66 related.py(1295):         name,
0.66 related.py(1296):         (models.Model,),
0.66 related.py(1298):             "Meta": meta,
0.66 related.py(1299):             "__module__": klass.__module__,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(1301):                 klass,
0.66 related.py(1302):                 related_name="%s+" % name,
0.66 related.py(1303):                 db_tablespace=field.db_tablespace,
0.66 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1305):                 on_delete=CASCADE,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(1308):                 to_model,
0.66 related.py(1309):                 related_name="%s+" % name,
0.66 related.py(1310):                 db_tablespace=field.db_tablespace,
0.66 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1312):                 on_delete=CASCADE,
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(938):         except AttributeError:
0.66 related.py(939):             if not isinstance(to, str):
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1297):         {
0.66 related.py(1294):     return type(
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.66 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(1960):         pass
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1934):             not self.remote_field.is_hidden()
0.66 related.py(1933):         if (
0.66 related.py(1935):             and not related.related_model._meta.swapped
0.66 related.py(1933):         if (
0.66 related.py(1937):             setattr(
0.66 related.py(1938):                 cls,
0.66 related.py(1939):                 related.get_accessor_name(),
0.66 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.66 related.py(1937):             setattr(
0.66 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.66 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.66 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.66 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.66 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(385):             kwargs["related_name"] = self._related_name
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(387):             kwargs["related_query_name"] = self._related_query_name
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1741):             if "." in self.remote_field.model:
0.66 related.py(1742):                 app_label, model_name = self.remote_field.model.split(".")
0.66 related.py(1743):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(431):                 to_string = self.remote_field.model
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(1733):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.66 related.py(382):         if self._limit_choices_to:
0.66 related.py(384):         if self._related_name is not None:
0.66 related.py(385):             kwargs["related_name"] = self._related_name
0.66 related.py(386):         if self._related_query_name is not None:
0.66 related.py(387):             kwargs["related_query_name"] = self._related_query_name
0.66 related.py(388):         return name, path, args, kwargs
0.66 related.py(1735):         if self.db_table is not None:
0.66 related.py(1737):         if self.remote_field.db_constraint is not True:
0.66 related.py(1740):         if isinstance(self.remote_field.model, str):
0.66 related.py(1741):             if "." in self.remote_field.model:
0.66 related.py(1742):                 app_label, model_name = self.remote_field.model.split(".")
0.66 related.py(1743):                 kwargs["to"] = "%s.%s" % (app_label, model_name.lower())
0.66 related.py(1748):         if getattr(self.remote_field, "through", None) is not None:
0.66 related.py(1755):         swappable_setting = self.swappable_setting
0.66 related.py(428):         if self.swappable:
0.66 related.py(430):             if isinstance(self.remote_field.model, str):
0.66 related.py(431):                 to_string = self.remote_field.model
0.66 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.66 related.py(1756):         if swappable_setting is not None:
0.66 related.py(1770):         return name, path, args, kwargs
0.66 related.py(1352):         try:
0.66 related.py(1353):             to._meta
0.66 related.py(1354):         except AttributeError:
0.66 related.py(1355):             if not isinstance(to, str):
0.66 related.py(1366):         if symmetrical is None:
0.66 related.py(1367):             symmetrical = to == RECURSIVE_RELATIONSHIP_CONSTANT
0.66 related.py(1369):         if through is not None and db_table is not None:
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1375):             self,
0.66 related.py(1376):             to,
0.66 related.py(1377):             related_name=related_name,
0.66 related.py(1378):             related_query_name=related_query_name,
0.66 related.py(1379):             limit_choices_to=limit_choices_to,
0.66 related.py(1380):             symmetrical=symmetrical,
0.66 related.py(1381):             through=through,
0.66 related.py(1382):             through_fields=through_fields,
0.66 related.py(1383):             db_constraint=db_constraint,
0.66 related.py(1374):         kwargs["rel"] = self.rel_class(
0.66 related.py(1385):         self.has_null_arg = "null" in kwargs
0.66 related.py(1387):         super().__init__(
0.66 related.py(1388):             related_name=related_name,
0.66 related.py(1389):             related_query_name=related_query_name,
0.66 related.py(1390):             limit_choices_to=limit_choices_to,
0.66 related.py(1387):         super().__init__(
0.66 related.py(1391):             **kwargs,
0.66 related.py(1387):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(1394):         self.db_table = db_table
0.66 related.py(1395):         self.swappable = swappable
0.66 related.py(1888):         if self.remote_field.symmetrical and (
0.66 related.py(1893):         elif self.remote_field.is_hidden():
0.66 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.66 related.py(367):                     "class": cls.__name__.lower(),
0.66 related.py(368):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.66 related.py(370):                 self.remote_field.related_query_name = related_query_name
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1910):         if not cls._meta.abstract:
0.66 related.py(1911):             if self.remote_field.through:
0.66 related.py(1919):             elif not cls._meta.swapped:
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1921):                     self, cls
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1262):     from django.db import models
0.66 related.py(1264):     def set_managed(model, related, through):
0.66 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.66 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1271):     to = make_model_tuple(to_model)[1]
0.66 related.py(1272):     from_ = klass._meta.model_name
0.66 related.py(1273):     if to == from_:
0.66 related.py(1277):     meta = type(
0.66 related.py(1278):         "Meta",
0.66 related.py(1279):         (),
0.66 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.66 related.py(1822):         if self.remote_field.through is not None:
0.66 related.py(1824):         elif self.db_table:
0.66 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.66 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.66 related.py(1282):             "auto_created": klass,
0.66 related.py(1283):             "app_label": klass._meta.app_label,
0.66 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.66 related.py(1285):             "unique_together": (from_, to),
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1287):             % {"from": from_, "to": to},
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1289):             % {"from": from_, "to": to},
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1290):             "apps": field.model._meta.apps,
0.66 related.py(1280):         {
0.66 related.py(1277):     meta = type(
0.66 related.py(1294):     return type(
0.66 related.py(1295):         name,
0.66 related.py(1296):         (models.Model,),
0.66 related.py(1298):             "Meta": meta,
0.66 related.py(1299):             "__module__": klass.__module__,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(1301):                 klass,
0.66 related.py(1302):                 related_name="%s+" % name,
0.66 related.py(1303):                 db_tablespace=field.db_tablespace,
0.66 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1305):                 on_delete=CASCADE,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(1308):                 to_model,
0.66 related.py(1309):                 related_name="%s+" % name,
0.66 related.py(1310):                 db_tablespace=field.db_tablespace,
0.66 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1312):                 on_delete=CASCADE,
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(938):         except AttributeError:
0.66 related.py(939):             if not isinstance(to, str):
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1297):         {
0.66 related.py(1294):     return type(
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.66 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.66 related.py(1888):         if self.remote_field.symmetrical and (
0.66 related.py(1893):         elif self.remote_field.is_hidden():
0.66 related.py(1904):         super().contribute_to_class(cls, name, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.66 related.py(367):                     "class": cls.__name__.lower(),
0.66 related.py(368):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(366):                 related_query_name = self.remote_field.related_query_name % {
0.66 related.py(370):                 self.remote_field.related_query_name = related_query_name
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1910):         if not cls._meta.abstract:
0.66 related.py(1911):             if self.remote_field.through:
0.66 related.py(1919):             elif not cls._meta.swapped:
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1921):                     self, cls
0.66 related.py(1920):                 self.remote_field.through = create_many_to_many_intermediary_model(
0.66 related.py(1262):     from django.db import models
0.66 related.py(1264):     def set_managed(model, related, through):
0.66 related.py(1267):     to_model = resolve_relation(klass, field.remote_field.model)
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(1268):     name = "%s_%s" % (klass._meta.object_name, field.name)
0.66 related.py(1269):     lazy_related_operation(set_managed, klass, to_model, name)
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(63):             relation = "%s.%s" % (scope_model._meta.app_label, relation)
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(1271):     to = make_model_tuple(to_model)[1]
0.66 related.py(1272):     from_ = klass._meta.model_name
0.66 related.py(1273):     if to == from_:
0.66 related.py(1277):     meta = type(
0.66 related.py(1278):         "Meta",
0.66 related.py(1279):         (),
0.66 related.py(1281):             "db_table": field._get_m2m_db_table(klass._meta),
0.66 related.py(1822):         if self.remote_field.through is not None:
0.66 related.py(1824):         elif self.db_table:
0.66 related.py(1827):             m2m_table_name = "%s_%s" % (utils.strip_quotes(opts.db_table), self.name)
0.66 related.py(1828):             return utils.truncate_name(m2m_table_name, connection.ops.max_name_length())
0.66 related.py(1282):             "auto_created": klass,
0.66 related.py(1283):             "app_label": klass._meta.app_label,
0.66 related.py(1284):             "db_tablespace": klass._meta.db_tablespace,
0.66 related.py(1285):             "unique_together": (from_, to),
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1287):             % {"from": from_, "to": to},
0.66 related.py(1286):             "verbose_name": _("%(from)s-%(to)s relationship")
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1289):             % {"from": from_, "to": to},
0.66 related.py(1288):             "verbose_name_plural": _("%(from)s-%(to)s relationships")
0.66 related.py(1290):             "apps": field.model._meta.apps,
0.66 related.py(1280):         {
0.66 related.py(1277):     meta = type(
0.66 related.py(1294):     return type(
0.66 related.py(1295):         name,
0.66 related.py(1296):         (models.Model,),
0.66 related.py(1298):             "Meta": meta,
0.66 related.py(1299):             "__module__": klass.__module__,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(1301):                 klass,
0.66 related.py(1302):                 related_name="%s+" % name,
0.66 related.py(1303):                 db_tablespace=field.db_tablespace,
0.66 related.py(1304):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1305):                 on_delete=CASCADE,
0.66 related.py(1300):             from_: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(1308):                 to_model,
0.66 related.py(1309):                 related_name="%s+" % name,
0.66 related.py(1310):                 db_tablespace=field.db_tablespace,
0.66 related.py(1311):                 db_constraint=field.remote_field.db_constraint,
0.66 related.py(1312):                 on_delete=CASCADE,
0.66 related.py(1307):             to: models.ForeignKey(
0.66 related.py(936):         try:
0.66 related.py(937):             to._meta.model_name
0.66 related.py(938):         except AttributeError:
0.66 related.py(939):             if not isinstance(to, str):
0.66 related.py(954):         if not callable(on_delete):
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(958):             self,
0.66 related.py(959):             to,
0.66 related.py(960):             to_field,
0.66 related.py(961):             related_name=related_name,
0.66 related.py(962):             related_query_name=related_query_name,
0.66 related.py(963):             limit_choices_to=limit_choices_to,
0.66 related.py(964):             parent_link=parent_link,
0.66 related.py(965):             on_delete=on_delete,
0.66 related.py(957):         kwargs["rel"] = self.rel_class(
0.66 related.py(967):         kwargs.setdefault("db_index", True)
0.66 related.py(969):         super().__init__(
0.66 related.py(970):             to,
0.66 related.py(971):             on_delete,
0.66 related.py(969):         super().__init__(
0.66 related.py(972):             related_name=related_name,
0.66 related.py(973):             related_query_name=related_query_name,
0.66 related.py(974):             limit_choices_to=limit_choices_to,
0.66 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.66 related.py(976):             to_fields=[to_field],
0.66 related.py(969):         super().__init__(
0.66 related.py(977):             **kwargs,
0.66 related.py(969):         super().__init__(
0.66 related.py(544):         if rel is None:
0.66 related.py(555):         super().__init__(
0.66 related.py(556):             rel=rel,
0.66 related.py(557):             related_name=related_name,
0.66 related.py(558):             related_query_name=related_query_name,
0.66 related.py(559):             limit_choices_to=limit_choices_to,
0.66 related.py(555):         super().__init__(
0.66 related.py(560):             **kwargs,
0.66 related.py(555):         super().__init__(
0.66 related.py(105):         self._related_name = related_name
0.66 related.py(106):         self._related_query_name = related_query_name
0.66 related.py(107):         self._limit_choices_to = limit_choices_to
0.66 related.py(108):         super().__init__(**kwargs)
0.66 related.py(563):         self.from_fields = from_fields
0.66 related.py(564):         self.to_fields = to_fields
0.66 related.py(565):         self.swappable = swappable
0.66 related.py(979):         self.db_constraint = db_constraint
0.66 related.py(1297):         {
0.66 related.py(1294):     return type(
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(867):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(348):         super().contribute_to_class(cls, name, private_only=private_only, **kwargs)
0.66 related.py(1125):         attname = self.get_attname()
0.66 related.py(1122):         return "%s_id" % self.name
0.66 related.py(1126):         column = self.db_column or attname
0.66 related.py(1127):         return attname, column
0.66 related.py(350):         self.opts = cls._meta
0.66 related.py(352):         if not cls._meta.abstract:
0.66 related.py(353):             if self.remote_field.related_name:
0.66 related.py(354):                 related_name = self.remote_field.related_name
0.66 related.py(357):             if related_name:
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(359):                     "class": cls.__name__.lower(),
0.66 related.py(360):                     "model_name": cls._meta.model_name.lower(),
0.66 related.py(361):                     "app_label": cls._meta.app_label.lower(),
0.66 related.py(358):                 related_name = related_name % {
0.66 related.py(363):                 self.remote_field.related_name = related_name
0.66 related.py(365):             if self.remote_field.related_query_name:
0.66 related.py(372):             def resolve_related_class(model, related, field):
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(377):                 resolve_related_class, cls, self.remote_field.model, field=self
0.66 related.py(376):             lazy_related_operation(
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.66 related.py(61):     if isinstance(relation, str):
0.66 related.py(62):         if "." not in relation:
0.66 related.py(65):     return relation
0.66 related.py(83):     models = [model] + [resolve_relation(model, rel) for rel in related_models]
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(85):     apps = model._meta.apps
0.66 related.py(86):     return apps.lazy_model_operation(partial(function, **kwargs), *model_keys)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(84):     model_keys = (make_model_tuple(m) for m in models)
0.66 related.py(868):         setattr(cls, self.name, self.forward_related_accessor_class(self))
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(1925):         setattr(cls, self.name, ManyToManyDescriptor(self.remote_field, reverse=False))
0.66 related.py(1928):         self.m2m_db_table = partial(self._get_m2m_db_table, cls._meta)
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(1960):         pass
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1934):             not self.remote_field.is_hidden()
0.66 related.py(1933):         if (
0.66 related.py(1935):             and not related.related_model._meta.swapped
0.66 related.py(1933):         if (
0.66 related.py(1937):             setattr(
0.66 related.py(1938):                 cls,
0.66 related.py(1939):                 related.get_accessor_name(),
0.66 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.66 related.py(1937):             setattr(
0.66 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.66 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.66 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.66 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.66 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(1960):         pass
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1934):             not self.remote_field.is_hidden()
0.66 related.py(1933):         if (
0.66 related.py(1935):             and not related.related_model._meta.swapped
0.66 related.py(1933):         if (
0.66 related.py(1937):             setattr(
0.66 related.py(1938):                 cls,
0.66 related.py(1939):                 related.get_accessor_name(),
0.66 related.py(1940):                 ManyToManyDescriptor(self.remote_field, reverse=True),
0.66 related.py(1937):             setattr(
0.66 related.py(1944):         self.m2m_column_name = partial(self._get_m2m_attr, related, "column")
0.66 related.py(1945):         self.m2m_reverse_name = partial(self._get_m2m_reverse_attr, related, "column")
0.66 related.py(1947):         self.m2m_field_name = partial(self._get_m2m_attr, related, "name")
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1949):             self._get_m2m_reverse_attr, related, "name"
0.66 related.py(1948):         self.m2m_reverse_field_name = partial(
0.66 related.py(1952):         get_m2m_rel = partial(self._get_m2m_attr, related, "remote_field")
0.66 related.py(1953):         self.m2m_target_field_name = lambda: get_m2m_rel().field_name
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1955):             self._get_m2m_reverse_attr, related, "remote_field"
0.66 related.py(1954):         get_m2m_reverse_rel = partial(
0.66 related.py(1957):         self.m2m_reverse_target_field_name = lambda: get_m2m_reverse_rel().field_name
0.66 related.py(1265):         through._meta.managed = model._meta.managed or related._meta.managed
0.66 related.py(373):                 field.remote_field.model = related
0.66 related.py(374):                 field.do_related_class(related, model)
0.66 related.py(448):         self.set_attributes_from_rel()
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(438):         self.name = self.name or (
0.66 related.py(443):         if self.verbose_name is None:
0.66 related.py(445):         self.remote_field.set_field_name()
0.66 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.66 related.py(1155):         super().contribute_to_related_class(cls, related)
0.66 related.py(874):             not self.remote_field.is_hidden()
0.66 related.py(873):         if (
0.66 related.py(1156):         if self.remote_field.field_name is None:
0.67 related.py(373):                 field.remote_field.model = related
0.67 related.py(374):                 field.do_related_class(related, model)
0.67 related.py(448):         self.set_attributes_from_rel()
0.67 related.py(438):         self.name = self.name or (
0.67 related.py(438):         self.name = self.name or (
0.67 related.py(443):         if self.verbose_name is None:
0.67 related.py(445):         self.remote_field.set_field_name()
0.67 related.py(449):         self.contribute_to_related_class(other, self.remote_field)
0.67 related.py(1155):         super().contribute_to_related_class(cls, related)
0.67 related.py(874):             not self.remote_field.is_hidden()
0.67 related.py(873):         if (
0.67 related.py(875):             and not related.related_model._meta.swapped
0.67 related.py(873):         if (
0.67 related.py(877):             setattr(
0.67 related.py(878):                 cls._meta.concrete_model,
0.67 related.py(879):                 related.get_accessor_name(),
0.67 related.py(880):                 self.related_accessor_class(related),
0.67 related.py(877):             setattr(
0.67 related.py(885):             if self.remote_field.limit_choices_to:
0.67 related.py(1156):         if self.remote_field.field_name is None:
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(836):         return self.get_path_info()
0.67 related.py(820):         opts = self.remote_field.model._meta
0.67 related.py(821):         from_opts = self.model._meta
0.67 related.py(823):             PathInfo(
0.67 related.py(824):                 from_opts=from_opts,
0.67 related.py(825):                 to_opts=opts,
0.67 related.py(826):                 target_fields=self.foreign_related_fields,
0.67 related.py(746):         return tuple(
0.67 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.67 related.py(734):         return self.resolve_related_fields()
0.67 related.py(1103):         related_fields = super().resolve_related_fields()
0.67 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.67 related.py(711):         if isinstance(self.remote_field.model, str):
0.67 related.py(715):         related_fields = []
0.67 related.py(716):         for index in range(len(self.from_fields)):
0.67 related.py(717):             from_field_name = self.from_fields[index]
0.67 related.py(718):             to_field_name = self.to_fields[index]
0.67 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.67 related.py(720):                 self
0.67 related.py(719):             from_field = (
0.67 related.py(726):                 if to_field_name is None
0.67 related.py(725):                 self.remote_field.model._meta.pk
0.67 related.py(724):             to_field = (
0.67 related.py(729):             related_fields.append((from_field, to_field))
0.67 related.py(716):         for index in range(len(self.from_fields)):
0.67 related.py(730):         return related_fields
0.67 related.py(1104):         for from_field, to_field in related_fields:
0.67 related.py(1106):                 to_field
0.67 related.py(1105):             if (
0.67 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.67 related.py(1105):             if (
0.67 related.py(1104):         for from_field, to_field in related_fields:
0.67 related.py(1119):         return related_fields
0.67 related.py(746):         return tuple(
0.67 related.py(746):         return tuple(
0.67 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.67 related.py(746):         return tuple(
0.67 related.py(827):                 join_field=self,
0.67 related.py(828):                 m2m=False,
0.67 related.py(829):                 direct=True,
0.67 related.py(830):                 filtered_relation=filtered_relation,
0.67 related.py(823):             PathInfo(
0.67 related.py(822):         return [
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(113):         apps.check_models_ready()
0.67 related.py(114):         return self.remote_field.model
0.67 related.py(490):             self.remote_field.related_query_name
0.67 related.py(491):             or self.remote_field.related_name
0.67 related.py(490):             self.remote_field.related_query_name
0.67 related.py(492):             or self.opts.model_name
0.67 related.py(489):         return (
0.67 related.py(490):             self.remote_field.related_query_name
0.67 related.py(491):             or self.remote_field.related_name
0.67 related.py(490):             self.remote_field.related_query_name
0.67 related.py(492):             or self.opts.model_name
0.67 related.py(489):         return (
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(1202):         if output_field is None:
0.67 related.py(1208):         return super().get_col(alias, output_field)
0.67 related.py(861):         bases = inspect.getmro(cls)
0.67 related.py(862):         bases = bases[: bases.index(ForeignObject) + 1]
0.67 related.py(863):         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
0.67 related.py(863):         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
0.67 related.py(863):         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
0.67 related.py(863):         class_lookups = [parent.__dict__.get("class_lookups", {}) for parent in bases]
0.67 related.py(864):         return cls.merge_dicts(class_lookups)
0.67 related.py(1152):         return self.target_field.get_prep_value(value)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(1202):         if output_field is None:
0.67 related.py(1203):             output_field = self.target_field
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1204):             while isinstance(output_field, ForeignKey):
0.67 related.py(1208):         return super().get_col(alias, output_field)
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(816):         return None
0.67 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1196):         converters = super().get_db_converters(connection)
0.67 related.py(1197):         if connection.features.interprets_empty_strings_as_nulls:
0.67 related.py(1199):         return converters
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(510):         return self.name
0.67 related.py(510):         return self.name
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1137):         if value is None or (
0.67 related.py(1138):             value == ""
0.67 related.py(1137):         if value is None or (
0.67 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1137):         if value is None or (
0.67 related.py(1138):             value == ""
0.67 related.py(1137):         if value is None or (
0.67 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1137):         if value is None or (
0.67 related.py(1138):             value == ""
0.67 related.py(1137):         if value is None or (
0.67 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1137):         if value is None or (
0.67 related.py(1138):             value == ""
0.67 related.py(1137):         if value is None or (
0.67 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(1202):         if output_field is None:
0.67 related.py(1208):         return super().get_col(alias, output_field)
0.67 related.py(1152):         return self.target_field.get_prep_value(value)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1152):         return self.target_field.get_prep_value(value)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1152):         return self.target_field.get_prep_value(value)
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(1202):         if output_field is None:
0.67 related.py(1203):             output_field = self.target_field
0.67 related.py(1060):         return self.foreign_related_fields[0]
0.67 related.py(1204):             while isinstance(output_field, ForeignKey):
0.67 related.py(1208):         return super().get_col(alias, output_field)
0.67 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.67 related.py(782):         return tuple(
0.67 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.67 related.py(782):         return tuple(
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(816):         return None
0.68 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1196):         converters = super().get_db_converters(connection)
0.68 related.py(1197):         if connection.features.interprets_empty_strings_as_nulls:
0.68 related.py(1199):         return converters
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(1202):         if output_field is None:
0.68 related.py(1208):         return super().get_col(alias, output_field)
0.68 related.py(1152):         return self.target_field.get_prep_value(value)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(1202):         if output_field is None:
0.68 related.py(1203):             output_field = self.target_field
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1204):             while isinstance(output_field, ForeignKey):
0.68 related.py(1208):         return super().get_col(alias, output_field)
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(816):         return None
0.68 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1196):         converters = super().get_db_converters(connection)
0.68 related.py(1197):         if connection.features.interprets_empty_strings_as_nulls:
0.68 related.py(1199):         return converters
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(510):         return self.name
0.68 related.py(510):         return self.name
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(1137):         if value is None or (
0.68 related.py(1138):             value == ""
0.68 related.py(1137):         if value is None or (
0.68 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.68 related.py(1060):         return self.foreign_related_fields[0]
0.68 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(782):         return tuple(
0.68 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.68 related.py(782):         return tuple(
0.68 related.py(1202):         if output_field is None:
0.68 related.py(1208):         return super().get_col(alias, output_field)
0.69 related.py(1152):         return self.target_field.get_prep_value(value)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(1202):         if output_field is None:
0.69 related.py(1203):             output_field = self.target_field
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1204):             while isinstance(output_field, ForeignKey):
0.69 related.py(1208):         return super().get_col(alias, output_field)
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(816):         return None
0.69 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1196):         converters = super().get_db_converters(connection)
0.69 related.py(1197):         if connection.features.interprets_empty_strings_as_nulls:
0.69 related.py(1199):         return converters
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(1202):         if output_field is None:
0.69 related.py(1208):         return super().get_col(alias, output_field)
0.69 related.py(1152):         return self.target_field.get_prep_value(value)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(1202):         if output_field is None:
0.69 related.py(1203):             output_field = self.target_field
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1204):             while isinstance(output_field, ForeignKey):
0.69 related.py(1208):         return super().get_col(alias, output_field)
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(781):         source = self.reverse_related_fields if reverse_join else self.related_fields
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(782):         return tuple(
0.69 related.py(783):             (lhs_field.column, rhs_field.column) for lhs_field, rhs_field in source
0.69 related.py(782):         return tuple(
0.69 related.py(816):         return None
0.69 related.py(1180):         return self.target_field.rel_db_type(connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1196):         converters = super().get_db_converters(connection)
0.69 related.py(1197):         if connection.features.interprets_empty_strings_as_nulls:
0.69 related.py(1199):         return converters
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(510):         return self.name
0.69 related.py(510):         return self.name
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.69 related.py(1137):         if value is None or (
0.69 related.py(1138):             value == ""
0.69 related.py(1137):         if value is None or (
0.69 related.py(1146):             return self.target_field.get_db_prep_save(value, connection=connection)
0.69 related.py(1060):         return self.foreign_related_fields[0]
0.73 related.py(985):         return [
0.73 related.py(986):             *super().check(**kwargs),
0.73 related.py(575):         return [
0.73 related.py(576):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(118):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(119):             *self._check_related_name_is_valid(),
0.73 related.py(127):         import keyword
0.73 related.py(129):         related_name = self.remote_field.related_name
0.73 related.py(130):         if related_name is None:
0.73 related.py(131):             return []
0.73 related.py(117):         return [
0.73 related.py(120):             *self._check_related_query_name_is_valid(),
0.73 related.py(155):         if self.remote_field.is_hidden():
0.73 related.py(157):         rel_query_name = self.related_query_name()
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(158):         errors = []
0.73 related.py(159):         if rel_query_name.endswith("_"):
0.73 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.73 related.py(185):         return errors
0.73 related.py(117):         return [
0.73 related.py(121):             *self._check_relation_model_exists(),
0.73 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(192):             if rel_is_string
0.73 related.py(191):             self.remote_field.model
0.73 related.py(193):             else self.remote_field.model._meta.object_name
0.73 related.py(190):         model_name = (
0.73 related.py(195):         if rel_is_missing and (
0.73 related.py(206):         return []
0.73 related.py(117):         return [
0.73 related.py(122):             *self._check_referencing_to_swapped_model(),
0.73 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(209):         if (
0.73 related.py(224):         return []
0.73 related.py(117):         return [
0.73 related.py(123):             *self._check_clashes(),
0.73 related.py(228):         from django.db.models.base import ModelBase
0.73 related.py(230):         errors = []
0.73 related.py(231):         opts = self.model._meta
0.73 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.73 related.py(250):         rel_opts = self.remote_field.model._meta
0.73 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.73 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.73 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.73 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(113):         apps.check_models_ready()
0.73 related.py(114):         return self.remote_field.model
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(305):                 clash_field.related_model._meta.label,
0.73 related.py(306):                 clash_field.field.name,
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(308):             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
0.73 related.py(324):             if clash_field.get_accessor_name() == rel_query_name:
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(339):         return errors
0.73 related.py(117):         return [
0.73 related.py(575):         return [
0.73 related.py(577):             *self._check_to_fields_exist(),
0.73 related.py(583):         if isinstance(self.remote_field.model, str):
0.73 related.py(586):         errors = []
0.73 related.py(587):         for to_field in self.to_fields:
0.73 related.py(588):             if to_field:
0.73 related.py(589):                 try:
0.73 related.py(590):                     self.remote_field.model._meta.get_field(to_field)
0.73 related.py(587):         for to_field in self.to_fields:
0.73 related.py(601):         return errors
0.73 related.py(575):         return [
0.73 related.py(578):             *self._check_unique_target(),
0.73 related.py(604):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(605):         if rel_is_string or not self.requires_unique_target:
0.73 related.py(608):         try:
0.73 related.py(609):             self.foreign_related_fields
0.73 related.py(613):         if not self.foreign_related_fields:
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(619):             if getattr(f, "unique", False)
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(619):             if getattr(f, "unique", False)
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(619):             if getattr(f, "unique", False)
0.73 related.py(617):             frozenset([f.name])
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(619):             if getattr(f, "unique", False)
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.73 related.py(619):             if getattr(f, "unique", False)
0.73 related.py(616):         unique_foreign_fields = {
0.73 related.py(621):         unique_foreign_fields.update(
0.73 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.73 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.73 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.73 related.py(621):         unique_foreign_fields.update(
0.73 related.py(624):         unique_foreign_fields.update(
0.73 related.py(625):             {
0.73 related.py(627):                 for uc in self.remote_field.model._meta.total_unique_constraints
0.73 related.py(625):             {
0.73 related.py(625):             {
0.73 related.py(624):         unique_foreign_fields.update(
0.73 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.73 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.73 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.73 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.73 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.73 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.73 related.py(633):         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
0.73 related.py(652):         elif not has_unique_constraint:
0.73 related.py(669):             return []
0.73 related.py(575):         return [
0.73 related.py(985):         return [
0.73 related.py(987):             *self._check_on_delete(),
0.73 related.py(992):         on_delete = getattr(self.remote_field, "on_delete", None)
0.73 related.py(993):         if on_delete == SET_NULL and not self.null:
0.73 related.py(1005):         elif on_delete == SET_DEFAULT and not self.has_default():
0.73 related.py(1015):             return []
0.73 related.py(985):         return [
0.73 related.py(988):             *self._check_unique(),
0.73 related.py(1031):             if self.unique
0.73 related.py(1019):             [
0.73 related.py(1032):             else []
0.73 related.py(1018):         return (
0.73 related.py(985):         return [
0.73 related.py(1122):         return "%s_id" % self.name
0.73 related.py(1125):         attname = self.get_attname()
0.73 related.py(1122):         return "%s_id" % self.name
0.73 related.py(1126):         column = self.db_column or attname
0.73 related.py(1127):         return attname, column
0.73 related.py(836):         return self.get_path_info()
0.73 related.py(820):         opts = self.remote_field.model._meta
0.73 related.py(821):         from_opts = self.model._meta
0.73 related.py(823):             PathInfo(
0.73 related.py(824):                 from_opts=from_opts,
0.73 related.py(825):                 to_opts=opts,
0.73 related.py(826):                 target_fields=self.foreign_related_fields,
0.73 related.py(827):                 join_field=self,
0.73 related.py(828):                 m2m=False,
0.73 related.py(829):                 direct=True,
0.73 related.py(830):                 filtered_relation=filtered_relation,
0.73 related.py(823):             PathInfo(
0.73 related.py(822):         return [
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(489):         return (
0.73 related.py(1398):         return [
0.73 related.py(1399):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(118):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(119):             *self._check_related_name_is_valid(),
0.73 related.py(127):         import keyword
0.73 related.py(129):         related_name = self.remote_field.related_name
0.73 related.py(130):         if related_name is None:
0.73 related.py(131):             return []
0.73 related.py(117):         return [
0.73 related.py(120):             *self._check_related_query_name_is_valid(),
0.73 related.py(155):         if self.remote_field.is_hidden():
0.73 related.py(157):         rel_query_name = self.related_query_name()
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(158):         errors = []
0.73 related.py(159):         if rel_query_name.endswith("_"):
0.73 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.73 related.py(185):         return errors
0.73 related.py(117):         return [
0.73 related.py(121):             *self._check_relation_model_exists(),
0.73 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(192):             if rel_is_string
0.73 related.py(191):             self.remote_field.model
0.73 related.py(193):             else self.remote_field.model._meta.object_name
0.73 related.py(190):         model_name = (
0.73 related.py(195):         if rel_is_missing and (
0.73 related.py(206):         return []
0.73 related.py(117):         return [
0.73 related.py(122):             *self._check_referencing_to_swapped_model(),
0.73 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(209):         if (
0.73 related.py(224):         return []
0.73 related.py(117):         return [
0.73 related.py(123):             *self._check_clashes(),
0.73 related.py(228):         from django.db.models.base import ModelBase
0.73 related.py(230):         errors = []
0.73 related.py(231):         opts = self.model._meta
0.73 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.73 related.py(250):         rel_opts = self.remote_field.model._meta
0.73 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.73 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.73 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.73 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(305):                 clash_field.related_model._meta.label,
0.73 related.py(306):                 clash_field.field.name,
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(308):             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
0.73 related.py(324):             if clash_field.get_accessor_name() == rel_query_name:
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(339):         return errors
0.73 related.py(117):         return [
0.73 related.py(1398):         return [
0.73 related.py(1400):             *self._check_unique(**kwargs),
0.73 related.py(1407):         if self.unique:
0.73 related.py(1415):         return []
0.73 related.py(1398):         return [
0.73 related.py(1401):             *self._check_relationship_model(**kwargs),
0.73 related.py(1450):         if hasattr(self.remote_field.through, "_meta"):
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1452):                 self.remote_field.through._meta.app_label,
0.73 related.py(1453):                 self.remote_field.through.__name__,
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1458):         errors = []
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1461):             include_auto_created=True
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1474):             assert from_model is not None, (
0.73 related.py(1480):             to_model = resolve_relation(from_model, self.remote_field.model)
0.73 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.73 related.py(61):     if isinstance(relation, str):
0.73 related.py(65):     return relation
0.73 related.py(1481):             from_model_name = from_model._meta.object_name
0.73 related.py(1482):             if isinstance(to_model, str):
0.73 related.py(1485):                 to_model_name = to_model._meta.object_name
0.73 related.py(1486):             relationship_model_name = self.remote_field.through._meta.object_name
0.73 related.py(1487):             self_referential = from_model == to_model
0.73 related.py(1489):             if self_referential:
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1524):                 if seen_from > 1 and not self.remote_field.through_fields:
0.73 related.py(1548):                 if seen_to > 1 and not self.remote_field.through_fields:
0.73 related.py(1569):                 if seen_from == 0 or seen_to == 0:
0.73 related.py(1581):         if self.remote_field.through_fields is not None:
0.73 related.py(1678):         return errors
0.73 related.py(1398):         return [
0.73 related.py(1402):             *self._check_ignored_options(**kwargs),
0.73 related.py(1418):         warnings = []
0.73 related.py(1420):         if self.has_null_arg:
0.73 related.py(1429):         if self._validators:
0.73 related.py(1437):         if self.remote_field.symmetrical and self._related_name:
0.73 related.py(1447):         return warnings
0.73 related.py(1398):         return [
0.73 related.py(1403):             *self._check_table_uniqueness(**kwargs),
0.73 related.py(1682):             isinstance(self.remote_field.through, str)
0.73 related.py(1681):         if (
0.73 related.py(1683):             or not self.remote_field.through._meta.managed
0.73 related.py(1681):         if (
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1691):         m2m_db_table = self.m2m_db_table()
0.73 related.py(1822):         if self.remote_field.through is not None:
0.73 related.py(1823):             return self.remote_field.through._meta.db_table
0.73 related.py(1692):         model = registered_tables.get(m2m_db_table)
0.73 related.py(1696):             model
0.73 related.py(1695):         if (
0.73 related.py(1730):         return []
0.73 related.py(1398):         return [
0.73 related.py(1398):         return [
0.73 related.py(1399):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(118):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(119):             *self._check_related_name_is_valid(),
0.73 related.py(127):         import keyword
0.73 related.py(129):         related_name = self.remote_field.related_name
0.73 related.py(130):         if related_name is None:
0.73 related.py(133):             not keyword.iskeyword(related_name) and related_name.isidentifier()
0.73 related.py(132):         is_valid_id = (
0.73 related.py(135):         if not (is_valid_id or related_name.endswith("+")):
0.73 related.py(152):         return []
0.73 related.py(117):         return [
0.73 related.py(120):             *self._check_related_query_name_is_valid(),
0.73 related.py(155):         if self.remote_field.is_hidden():
0.73 related.py(157):         rel_query_name = self.related_query_name()
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(489):         return (
0.73 related.py(158):         errors = []
0.73 related.py(159):         if rel_query_name.endswith("_"):
0.73 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.73 related.py(185):         return errors
0.73 related.py(117):         return [
0.73 related.py(121):             *self._check_relation_model_exists(),
0.73 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(192):             if rel_is_string
0.73 related.py(191):             self.remote_field.model
0.73 related.py(193):             else self.remote_field.model._meta.object_name
0.73 related.py(190):         model_name = (
0.73 related.py(195):         if rel_is_missing and (
0.73 related.py(206):         return []
0.73 related.py(117):         return [
0.73 related.py(122):             *self._check_referencing_to_swapped_model(),
0.73 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(209):         if (
0.73 related.py(224):         return []
0.73 related.py(117):         return [
0.73 related.py(123):             *self._check_clashes(),
0.73 related.py(228):         from django.db.models.base import ModelBase
0.73 related.py(230):         errors = []
0.73 related.py(231):         opts = self.model._meta
0.73 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.73 related.py(250):         rel_opts = self.remote_field.model._meta
0.73 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.73 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.73 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(489):         return (
0.73 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.73 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(339):         return errors
0.73 related.py(117):         return [
0.73 related.py(1398):         return [
0.73 related.py(1400):             *self._check_unique(**kwargs),
0.73 related.py(1407):         if self.unique:
0.73 related.py(1415):         return []
0.73 related.py(1398):         return [
0.73 related.py(1401):             *self._check_relationship_model(**kwargs),
0.73 related.py(1450):         if hasattr(self.remote_field.through, "_meta"):
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1452):                 self.remote_field.through._meta.app_label,
0.73 related.py(1453):                 self.remote_field.through.__name__,
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1458):         errors = []
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1461):             include_auto_created=True
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1474):             assert from_model is not None, (
0.73 related.py(1480):             to_model = resolve_relation(from_model, self.remote_field.model)
0.73 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.73 related.py(61):     if isinstance(relation, str):
0.73 related.py(65):     return relation
0.73 related.py(1481):             from_model_name = from_model._meta.object_name
0.73 related.py(1482):             if isinstance(to_model, str):
0.73 related.py(1485):                 to_model_name = to_model._meta.object_name
0.73 related.py(1486):             relationship_model_name = self.remote_field.through._meta.object_name
0.73 related.py(1487):             self_referential = from_model == to_model
0.73 related.py(1489):             if self_referential:
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1524):                 if seen_from > 1 and not self.remote_field.through_fields:
0.73 related.py(1548):                 if seen_to > 1 and not self.remote_field.through_fields:
0.73 related.py(1569):                 if seen_from == 0 or seen_to == 0:
0.73 related.py(1581):         if self.remote_field.through_fields is not None:
0.73 related.py(1678):         return errors
0.73 related.py(1398):         return [
0.73 related.py(1402):             *self._check_ignored_options(**kwargs),
0.73 related.py(1418):         warnings = []
0.73 related.py(1420):         if self.has_null_arg:
0.73 related.py(1429):         if self._validators:
0.73 related.py(1437):         if self.remote_field.symmetrical and self._related_name:
0.73 related.py(1447):         return warnings
0.73 related.py(1398):         return [
0.73 related.py(1403):             *self._check_table_uniqueness(**kwargs),
0.73 related.py(1682):             isinstance(self.remote_field.through, str)
0.73 related.py(1681):         if (
0.73 related.py(1683):             or not self.remote_field.through._meta.managed
0.73 related.py(1681):         if (
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1691):         m2m_db_table = self.m2m_db_table()
0.73 related.py(1822):         if self.remote_field.through is not None:
0.73 related.py(1823):             return self.remote_field.through._meta.db_table
0.73 related.py(1692):         model = registered_tables.get(m2m_db_table)
0.73 related.py(1696):             model
0.73 related.py(1695):         if (
0.73 related.py(1730):         return []
0.73 related.py(1398):         return [
0.73 related.py(1398):         return [
0.73 related.py(1399):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(118):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(119):             *self._check_related_name_is_valid(),
0.73 related.py(127):         import keyword
0.73 related.py(129):         related_name = self.remote_field.related_name
0.73 related.py(130):         if related_name is None:
0.73 related.py(133):             not keyword.iskeyword(related_name) and related_name.isidentifier()
0.73 related.py(132):         is_valid_id = (
0.73 related.py(135):         if not (is_valid_id or related_name.endswith("+")):
0.73 related.py(152):         return []
0.73 related.py(117):         return [
0.73 related.py(120):             *self._check_related_query_name_is_valid(),
0.73 related.py(155):         if self.remote_field.is_hidden():
0.73 related.py(157):         rel_query_name = self.related_query_name()
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(489):         return (
0.73 related.py(158):         errors = []
0.73 related.py(159):         if rel_query_name.endswith("_"):
0.73 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.73 related.py(185):         return errors
0.73 related.py(117):         return [
0.73 related.py(121):             *self._check_relation_model_exists(),
0.73 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(192):             if rel_is_string
0.73 related.py(191):             self.remote_field.model
0.73 related.py(193):             else self.remote_field.model._meta.object_name
0.73 related.py(190):         model_name = (
0.73 related.py(195):         if rel_is_missing and (
0.73 related.py(206):         return []
0.73 related.py(117):         return [
0.73 related.py(122):             *self._check_referencing_to_swapped_model(),
0.73 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(209):         if (
0.73 related.py(224):         return []
0.73 related.py(117):         return [
0.73 related.py(123):             *self._check_clashes(),
0.73 related.py(228):         from django.db.models.base import ModelBase
0.73 related.py(230):         errors = []
0.73 related.py(231):         opts = self.model._meta
0.73 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.73 related.py(250):         rel_opts = self.remote_field.model._meta
0.73 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.73 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.73 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(489):         return (
0.73 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.73 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(305):                 clash_field.related_model._meta.label,
0.73 related.py(306):                 clash_field.field.name,
0.73 related.py(304):             clash_name = "%s.%s" % (
0.73 related.py(308):             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
0.73 related.py(324):             if clash_field.get_accessor_name() == rel_query_name:
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(339):         return errors
0.73 related.py(117):         return [
0.73 related.py(1398):         return [
0.73 related.py(1400):             *self._check_unique(**kwargs),
0.73 related.py(1407):         if self.unique:
0.73 related.py(1415):         return []
0.73 related.py(1398):         return [
0.73 related.py(1401):             *self._check_relationship_model(**kwargs),
0.73 related.py(1450):         if hasattr(self.remote_field.through, "_meta"):
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1452):                 self.remote_field.through._meta.app_label,
0.73 related.py(1453):                 self.remote_field.through.__name__,
0.73 related.py(1451):             qualified_model_name = "%s.%s" % (
0.73 related.py(1458):         errors = []
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1461):             include_auto_created=True
0.73 related.py(1460):         if self.remote_field.through not in self.opts.apps.get_models(
0.73 related.py(1474):             assert from_model is not None, (
0.73 related.py(1480):             to_model = resolve_relation(from_model, self.remote_field.model)
0.73 related.py(57):     if relation == RECURSIVE_RELATIONSHIP_CONSTANT:
0.73 related.py(61):     if isinstance(relation, str):
0.73 related.py(65):     return relation
0.73 related.py(1481):             from_model_name = from_model._meta.object_name
0.73 related.py(1482):             if isinstance(to_model, str):
0.73 related.py(1485):                 to_model_name = to_model._meta.object_name
0.73 related.py(1486):             relationship_model_name = self.remote_field.through._meta.object_name
0.73 related.py(1487):             self_referential = from_model == to_model
0.73 related.py(1489):             if self_referential:
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1517):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1516):                     from_model == getattr(field.remote_field, "model", None)
0.73 related.py(1515):                 seen_from = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1521):                     for field in self.remote_field.through._meta.fields
0.73 related.py(1520):                     to_model == getattr(field.remote_field, "model", None)
0.73 related.py(1519):                 seen_to = sum(
0.73 related.py(1524):                 if seen_from > 1 and not self.remote_field.through_fields:
0.73 related.py(1548):                 if seen_to > 1 and not self.remote_field.through_fields:
0.73 related.py(1569):                 if seen_from == 0 or seen_to == 0:
0.73 related.py(1581):         if self.remote_field.through_fields is not None:
0.73 related.py(1678):         return errors
0.73 related.py(1398):         return [
0.73 related.py(1402):             *self._check_ignored_options(**kwargs),
0.73 related.py(1418):         warnings = []
0.73 related.py(1420):         if self.has_null_arg:
0.73 related.py(1429):         if self._validators:
0.73 related.py(1437):         if self.remote_field.symmetrical and self._related_name:
0.73 related.py(1447):         return warnings
0.73 related.py(1398):         return [
0.73 related.py(1403):             *self._check_table_uniqueness(**kwargs),
0.73 related.py(1682):             isinstance(self.remote_field.through, str)
0.73 related.py(1681):         if (
0.73 related.py(1683):             or not self.remote_field.through._meta.managed
0.73 related.py(1681):         if (
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1688):             for model in self.opts.apps.get_models(include_auto_created=True)
0.73 related.py(1689):             if model != self.remote_field.through and model._meta.managed
0.73 related.py(1687):             model._meta.db_table: model
0.73 related.py(1686):         registered_tables = {
0.73 related.py(1691):         m2m_db_table = self.m2m_db_table()
0.73 related.py(1822):         if self.remote_field.through is not None:
0.73 related.py(1823):             return self.remote_field.through._meta.db_table
0.73 related.py(1692):         model = registered_tables.get(m2m_db_table)
0.73 related.py(1696):             model
0.73 related.py(1695):         if (
0.73 related.py(1730):         return []
0.73 related.py(1398):         return [
0.73 related.py(985):         return [
0.73 related.py(986):             *super().check(**kwargs),
0.73 related.py(575):         return [
0.73 related.py(576):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(118):             *super().check(**kwargs),
0.73 related.py(117):         return [
0.73 related.py(119):             *self._check_related_name_is_valid(),
0.73 related.py(127):         import keyword
0.73 related.py(129):         related_name = self.remote_field.related_name
0.73 related.py(130):         if related_name is None:
0.73 related.py(131):             return []
0.73 related.py(117):         return [
0.73 related.py(120):             *self._check_related_query_name_is_valid(),
0.73 related.py(155):         if self.remote_field.is_hidden():
0.73 related.py(157):         rel_query_name = self.related_query_name()
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(158):         errors = []
0.73 related.py(159):         if rel_query_name.endswith("_"):
0.73 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.73 related.py(185):         return errors
0.73 related.py(117):         return [
0.73 related.py(121):             *self._check_relation_model_exists(),
0.73 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.73 related.py(192):             if rel_is_string
0.73 related.py(191):             self.remote_field.model
0.73 related.py(193):             else self.remote_field.model._meta.object_name
0.73 related.py(190):         model_name = (
0.73 related.py(195):         if rel_is_missing and (
0.73 related.py(206):         return []
0.73 related.py(117):         return [
0.73 related.py(122):             *self._check_referencing_to_swapped_model(),
0.73 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.73 related.py(209):         if (
0.73 related.py(224):         return []
0.73 related.py(117):         return [
0.73 related.py(123):             *self._check_clashes(),
0.73 related.py(228):         from django.db.models.base import ModelBase
0.73 related.py(230):         errors = []
0.73 related.py(231):         opts = self.model._meta
0.73 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.73 related.py(250):         rel_opts = self.remote_field.model._meta
0.73 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.73 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.73 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(491):             or self.remote_field.related_name
0.73 related.py(490):             self.remote_field.related_query_name
0.73 related.py(492):             or self.opts.model_name
0.73 related.py(489):         return (
0.73 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.73 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.73 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.73 related.py(283):             if clash_field.name == rel_query_name:
0.73 related.py(264):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(302):         for clash_field in potential_clashes:
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.73 related.py(339):         return errors
0.73 related.py(117):         return [
0.73 related.py(575):         return [
0.73 related.py(577):             *self._check_to_fields_exist(),
0.73 related.py(583):         if isinstance(self.remote_field.model, str):
0.73 related.py(586):         errors = []
0.73 related.py(587):         for to_field in self.to_fields:
0.74 related.py(588):             if to_field:
0.74 related.py(587):         for to_field in self.to_fields:
0.74 related.py(601):         return errors
0.74 related.py(575):         return [
0.74 related.py(578):             *self._check_unique_target(),
0.74 related.py(604):         rel_is_string = isinstance(self.remote_field.model, str)
0.74 related.py(605):         if rel_is_string or not self.requires_unique_target:
0.74 related.py(608):         try:
0.74 related.py(609):             self.foreign_related_fields
0.74 related.py(746):         return tuple(
0.74 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.74 related.py(734):         return self.resolve_related_fields()
0.74 related.py(1103):         related_fields = super().resolve_related_fields()
0.74 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.74 related.py(711):         if isinstance(self.remote_field.model, str):
0.74 related.py(715):         related_fields = []
0.74 related.py(716):         for index in range(len(self.from_fields)):
0.74 related.py(717):             from_field_name = self.from_fields[index]
0.74 related.py(718):             to_field_name = self.to_fields[index]
0.74 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.74 related.py(720):                 self
0.74 related.py(719):             from_field = (
0.74 related.py(726):                 if to_field_name is None
0.74 related.py(725):                 self.remote_field.model._meta.pk
0.74 related.py(724):             to_field = (
0.74 related.py(729):             related_fields.append((from_field, to_field))
0.74 related.py(716):         for index in range(len(self.from_fields)):
0.74 related.py(730):         return related_fields
0.74 related.py(1104):         for from_field, to_field in related_fields:
0.74 related.py(1106):                 to_field
0.74 related.py(1105):             if (
0.74 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.74 related.py(1105):             if (
0.74 related.py(1104):         for from_field, to_field in related_fields:
0.74 related.py(1119):         return related_fields
0.74 related.py(746):         return tuple(
0.74 related.py(746):         return tuple(
0.74 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.74 related.py(746):         return tuple(
0.74 related.py(613):         if not self.foreign_related_fields:
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(617):             frozenset([f.name])
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(617):             frozenset([f.name])
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(621):         unique_foreign_fields.update(
0.74 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.74 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.74 related.py(621):         unique_foreign_fields.update(
0.74 related.py(624):         unique_foreign_fields.update(
0.74 related.py(625):             {
0.74 related.py(627):                 for uc in self.remote_field.model._meta.total_unique_constraints
0.74 related.py(625):             {
0.74 related.py(625):             {
0.74 related.py(624):         unique_foreign_fields.update(
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(633):         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
0.74 related.py(652):         elif not has_unique_constraint:
0.74 related.py(669):             return []
0.74 related.py(575):         return [
0.74 related.py(985):         return [
0.74 related.py(987):             *self._check_on_delete(),
0.74 related.py(992):         on_delete = getattr(self.remote_field, "on_delete", None)
0.74 related.py(993):         if on_delete == SET_NULL and not self.null:
0.74 related.py(1005):         elif on_delete == SET_DEFAULT and not self.has_default():
0.74 related.py(1015):             return []
0.74 related.py(985):         return [
0.74 related.py(988):             *self._check_unique(),
0.74 related.py(1031):             if self.unique
0.74 related.py(1019):             [
0.74 related.py(1032):             else []
0.74 related.py(1018):         return (
0.74 related.py(985):         return [
0.74 related.py(985):         return [
0.74 related.py(986):             *super().check(**kwargs),
0.74 related.py(575):         return [
0.74 related.py(576):             *super().check(**kwargs),
0.74 related.py(117):         return [
0.74 related.py(118):             *super().check(**kwargs),
0.74 related.py(117):         return [
0.74 related.py(119):             *self._check_related_name_is_valid(),
0.74 related.py(127):         import keyword
0.74 related.py(129):         related_name = self.remote_field.related_name
0.74 related.py(130):         if related_name is None:
0.74 related.py(131):             return []
0.74 related.py(117):         return [
0.74 related.py(120):             *self._check_related_query_name_is_valid(),
0.74 related.py(155):         if self.remote_field.is_hidden():
0.74 related.py(157):         rel_query_name = self.related_query_name()
0.74 related.py(490):             self.remote_field.related_query_name
0.74 related.py(491):             or self.remote_field.related_name
0.74 related.py(490):             self.remote_field.related_query_name
0.74 related.py(492):             or self.opts.model_name
0.74 related.py(489):         return (
0.74 related.py(158):         errors = []
0.74 related.py(159):         if rel_query_name.endswith("_"):
0.74 related.py(172):         if LOOKUP_SEP in rel_query_name:
0.74 related.py(185):         return errors
0.74 related.py(117):         return [
0.74 related.py(121):             *self._check_relation_model_exists(),
0.74 related.py(188):         rel_is_missing = self.remote_field.model not in self.opts.apps.get_models()
0.74 related.py(189):         rel_is_string = isinstance(self.remote_field.model, str)
0.74 related.py(192):             if rel_is_string
0.74 related.py(191):             self.remote_field.model
0.74 related.py(193):             else self.remote_field.model._meta.object_name
0.74 related.py(190):         model_name = (
0.74 related.py(195):         if rel_is_missing and (
0.74 related.py(206):         return []
0.74 related.py(117):         return [
0.74 related.py(122):             *self._check_referencing_to_swapped_model(),
0.74 related.py(210):             self.remote_field.model not in self.opts.apps.get_models()
0.74 related.py(209):         if (
0.74 related.py(224):         return []
0.74 related.py(117):         return [
0.74 related.py(123):             *self._check_clashes(),
0.74 related.py(228):         from django.db.models.base import ModelBase
0.74 related.py(230):         errors = []
0.74 related.py(231):         opts = self.model._meta
0.74 related.py(235):         if not isinstance(self.remote_field.model, ModelBase):
0.74 related.py(250):         rel_opts = self.remote_field.model._meta
0.74 related.py(254):         rel_is_hidden = self.remote_field.is_hidden()
0.74 related.py(255):         rel_name = self.remote_field.get_accessor_name()  # i. e. "model_set"
0.74 related.py(256):         rel_query_name = self.related_query_name()  # i. e. "model"
0.74 related.py(490):             self.remote_field.related_query_name
0.74 related.py(491):             or self.remote_field.related_name
0.74 related.py(490):             self.remote_field.related_query_name
0.74 related.py(492):             or self.opts.model_name
0.74 related.py(489):         return (
0.74 related.py(258):         field_name = "%s.%s" % (opts.label, self.name)
0.74 related.py(263):         potential_clashes = rel_opts.fields + rel_opts.many_to_many
0.74 related.py(264):         for clash_field in potential_clashes:
0.74 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.74 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.74 related.py(283):             if clash_field.name == rel_query_name:
0.74 related.py(264):         for clash_field in potential_clashes:
0.74 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.74 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.74 related.py(283):             if clash_field.name == rel_query_name:
0.74 related.py(264):         for clash_field in potential_clashes:
0.74 related.py(266):             clash_name = "%s.%s" % (rel_opts.label, clash_field.name)
0.74 related.py(267):             if not rel_is_hidden and clash_field.name == rel_name:
0.74 related.py(283):             if clash_field.name == rel_query_name:
0.74 related.py(264):         for clash_field in potential_clashes:
0.74 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.74 related.py(302):         for clash_field in potential_clashes:
0.74 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.74 related.py(304):             clash_name = "%s.%s" % (
0.74 related.py(305):                 clash_field.related_model._meta.label,
0.74 related.py(306):                 clash_field.field.name,
0.74 related.py(304):             clash_name = "%s.%s" % (
0.74 related.py(308):             if not rel_is_hidden and clash_field.get_accessor_name() == rel_name:
0.74 related.py(324):             if clash_field.get_accessor_name() == rel_query_name:
0.74 related.py(302):         for clash_field in potential_clashes:
0.74 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.74 related.py(301):         potential_clashes = (r for r in rel_opts.related_objects if r.field is not self)
0.74 related.py(339):         return errors
0.74 related.py(117):         return [
0.74 related.py(575):         return [
0.74 related.py(577):             *self._check_to_fields_exist(),
0.74 related.py(583):         if isinstance(self.remote_field.model, str):
0.74 related.py(586):         errors = []
0.74 related.py(587):         for to_field in self.to_fields:
0.74 related.py(588):             if to_field:
0.74 related.py(589):                 try:
0.74 related.py(590):                     self.remote_field.model._meta.get_field(to_field)
0.74 related.py(587):         for to_field in self.to_fields:
0.74 related.py(601):         return errors
0.74 related.py(575):         return [
0.74 related.py(578):             *self._check_unique_target(),
0.74 related.py(604):         rel_is_string = isinstance(self.remote_field.model, str)
0.74 related.py(605):         if rel_is_string or not self.requires_unique_target:
0.74 related.py(608):         try:
0.74 related.py(609):             self.foreign_related_fields
0.74 related.py(746):         return tuple(
0.74 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.74 related.py(734):         return self.resolve_related_fields()
0.74 related.py(1103):         related_fields = super().resolve_related_fields()
0.74 related.py(707):         if not self.from_fields or len(self.from_fields) != len(self.to_fields):
0.74 related.py(711):         if isinstance(self.remote_field.model, str):
0.74 related.py(715):         related_fields = []
0.74 related.py(716):         for index in range(len(self.from_fields)):
0.74 related.py(717):             from_field_name = self.from_fields[index]
0.74 related.py(718):             to_field_name = self.to_fields[index]
0.74 related.py(721):                 if from_field_name == RECURSIVE_RELATIONSHIP_CONSTANT
0.74 related.py(720):                 self
0.74 related.py(719):             from_field = (
0.74 related.py(726):                 if to_field_name is None
0.74 related.py(725):                 self.remote_field.model._meta.pk
0.74 related.py(727):                 else self.remote_field.model._meta.get_field(to_field_name)
0.74 related.py(724):             to_field = (
0.74 related.py(729):             related_fields.append((from_field, to_field))
0.74 related.py(716):         for index in range(len(self.from_fields)):
0.74 related.py(730):         return related_fields
0.74 related.py(1104):         for from_field, to_field in related_fields:
0.74 related.py(1106):                 to_field
0.74 related.py(1105):             if (
0.74 related.py(1107):                 and to_field.model != self.remote_field.model._meta.concrete_model
0.74 related.py(1105):             if (
0.74 related.py(1104):         for from_field, to_field in related_fields:
0.74 related.py(1119):         return related_fields
0.74 related.py(746):         return tuple(
0.74 related.py(746):         return tuple(
0.74 related.py(747):             rhs_field for lhs_field, rhs_field in self.related_fields if rhs_field
0.74 related.py(746):         return tuple(
0.74 related.py(613):         if not self.foreign_related_fields:
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(617):             frozenset([f.name])
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(618):             for f in self.remote_field.model._meta.get_fields()
0.74 related.py(619):             if getattr(f, "unique", False)
0.74 related.py(616):         unique_foreign_fields = {
0.74 related.py(621):         unique_foreign_fields.update(
0.74 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.74 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.74 related.py(622):             {frozenset(ut) for ut in self.remote_field.model._meta.unique_together}
0.74 related.py(621):         unique_foreign_fields.update(
0.74 related.py(624):         unique_foreign_fields.update(
0.74 related.py(625):             {
0.74 related.py(627):                 for uc in self.remote_field.model._meta.total_unique_constraints
0.74 related.py(625):             {
0.74 related.py(625):             {
0.74 related.py(624):         unique_foreign_fields.update(
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(630):         foreign_fields = {f.name for f in self.foreign_related_fields}
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(631):         has_unique_constraint = any(u <= foreign_fields for u in unique_foreign_fields)
0.74 related.py(633):         if not has_unique_constraint and len(self.foreign_related_fields) > 1:
0.74 related.py(652):         elif not has_unique_constraint:
0.74 related.py(669):             return []
0.74 related.py(575):         return [
0.74 related.py(985):         return [
0.74 related.py(987):             *self._check_on_delete(),
0.74 related.py(992):         on_delete = getattr(self.remote_field, "on_delete", None)
0.74 related.py(993):         if on_delete == SET_NULL and not self.null:
0.74 related.py(1005):         elif on_delete == SET_DEFAULT and not self.has_default():
0.74 related.py(1015):             return []
0.74 related.py(985):         return [
0.74 related.py(988):             *self._check_unique(),
0.74 related.py(1031):             if self.unique
0.74 related.py(1019):             [
0.74 related.py(1032):             else []
0.74 related.py(1018):         return (
0.74 related.py(985):         return [
0.74 related.py(1122):         return "%s_id" % self.name
0.74 related.py(1122):         return "%s_id" % self.name
0.74 related.py(1125):         attname = self.get_attname()
0.74 related.py(1122):         return "%s_id" % self.name
0.74 related.py(1126):         column = self.db_column or attname
0.74 related.py(1127):         return attname, column
0.74 related.py(1125):         attname = self.get_attname()
0.74 related.py(1122):         return "%s_id" % self.name
0.74 related.py(1126):         column = self.db_column or attname
0.74 related.py(1127):         return attname, column
System check identified no issues (0 silenced).
test_collation_propagation_to_foreign_keys (test_coverup_django__django-15629.CollationPropagationTestCase) ... 0.74 related.py(1236):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(382):         if self._limit_choices_to:
0.74 related.py(384):         if self._related_name is not None:
0.74 related.py(386):         if self._related_query_name is not None:
0.74 related.py(388):         return name, path, args, kwargs
0.74 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.74 related.py(674):         kwargs["from_fields"] = self.from_fields
0.74 related.py(675):         kwargs["to_fields"] = self.to_fields
0.74 related.py(677):         if self.remote_field.parent_link:
0.74 related.py(679):         if isinstance(self.remote_field.model, str):
0.74 related.py(686):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.74 related.py(689):         swappable_setting = self.swappable_setting
0.74 related.py(428):         if self.swappable:
0.74 related.py(430):             if isinstance(self.remote_field.model, str):
0.74 related.py(433):                 to_string = self.remote_field.model._meta.label
0.74 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.74 related.py(690):         if swappable_setting is not None:
0.74 related.py(704):         return name, path, args, kwargs
0.74 related.py(1037):         del kwargs["to_fields"]
0.74 related.py(1038):         del kwargs["from_fields"]
0.74 related.py(1040):         if self.db_index:
0.74 related.py(1041):             del kwargs["db_index"]
0.74 related.py(1044):         if self.db_constraint is not True:
0.74 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1049):             not to_meta
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1053):         return name, path, args, kwargs
0.74 related.py(1237):         if "unique" in kwargs:
0.74 related.py(1238):             del kwargs["unique"]
0.74 related.py(1239):         return name, path, args, kwargs
0.74 related.py(1232):         kwargs["unique"] = True
0.74 related.py(1233):         super().__init__(to, on_delete, to_field=to_field, **kwargs)
0.74 related.py(936):         try:
0.74 related.py(937):             to._meta.model_name
0.74 related.py(938):         except AttributeError:
0.74 related.py(939):             if not isinstance(to, str):
0.74 related.py(954):         if not callable(on_delete):
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
0.74 related.py(958):             self,
0.74 related.py(959):             to,
0.74 related.py(960):             to_field,
0.74 related.py(961):             related_name=related_name,
0.74 related.py(962):             related_query_name=related_query_name,
0.74 related.py(963):             limit_choices_to=limit_choices_to,
0.74 related.py(964):             parent_link=parent_link,
0.74 related.py(965):             on_delete=on_delete,
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
0.74 related.py(967):         kwargs.setdefault("db_index", True)
0.74 related.py(969):         super().__init__(
0.74 related.py(970):             to,
0.74 related.py(971):             on_delete,
0.74 related.py(969):         super().__init__(
0.74 related.py(972):             related_name=related_name,
0.74 related.py(973):             related_query_name=related_query_name,
0.74 related.py(974):             limit_choices_to=limit_choices_to,
0.74 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.74 related.py(976):             to_fields=[to_field],
0.74 related.py(969):         super().__init__(
0.74 related.py(977):             **kwargs,
0.74 related.py(969):         super().__init__(
0.74 related.py(544):         if rel is None:
0.74 related.py(555):         super().__init__(
0.74 related.py(556):             rel=rel,
0.74 related.py(557):             related_name=related_name,
0.74 related.py(558):             related_query_name=related_query_name,
0.74 related.py(559):             limit_choices_to=limit_choices_to,
0.74 related.py(555):         super().__init__(
0.74 related.py(560):             **kwargs,
0.74 related.py(555):         super().__init__(
0.74 related.py(105):         self._related_name = related_name
0.74 related.py(106):         self._related_query_name = related_query_name
0.74 related.py(107):         self._limit_choices_to = limit_choices_to
0.74 related.py(108):         super().__init__(**kwargs)
0.74 related.py(563):         self.from_fields = from_fields
0.74 related.py(564):         self.to_fields = to_fields
0.74 related.py(565):         self.swappable = swappable
0.74 related.py(979):         self.db_constraint = db_constraint
0.74 related.py(113):         apps.check_models_ready()
0.74 related.py(114):         return self.remote_field.model
0.74 related.py(1036):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(672):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(381):         name, path, args, kwargs = super().deconstruct()
0.74 related.py(382):         if self._limit_choices_to:
0.74 related.py(384):         if self._related_name is not None:
0.74 related.py(386):         if self._related_query_name is not None:
0.74 related.py(388):         return name, path, args, kwargs
0.74 related.py(673):         kwargs["on_delete"] = self.remote_field.on_delete
0.74 related.py(674):         kwargs["from_fields"] = self.from_fields
0.74 related.py(675):         kwargs["to_fields"] = self.to_fields
0.74 related.py(677):         if self.remote_field.parent_link:
0.74 related.py(679):         if isinstance(self.remote_field.model, str):
0.74 related.py(686):             kwargs["to"] = self.remote_field.model._meta.label_lower
0.74 related.py(689):         swappable_setting = self.swappable_setting
0.74 related.py(428):         if self.swappable:
0.74 related.py(430):             if isinstance(self.remote_field.model, str):
0.74 related.py(433):                 to_string = self.remote_field.model._meta.label
0.74 related.py(434):             return apps.get_swappable_settings_name(to_string)
0.74 related.py(690):         if swappable_setting is not None:
0.74 related.py(704):         return name, path, args, kwargs
0.74 related.py(1037):         del kwargs["to_fields"]
0.74 related.py(1038):         del kwargs["from_fields"]
0.74 related.py(1040):         if self.db_index:
0.74 related.py(1041):             del kwargs["db_index"]
0.74 related.py(1044):         if self.db_constraint is not True:
0.74 related.py(1047):         to_meta = getattr(self.remote_field.model, "_meta", None)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1049):             not to_meta
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1050):             or (to_meta.pk and self.remote_field.field_name != to_meta.pk.name)
0.74 related.py(1048):         if self.remote_field.field_name and (
0.74 related.py(1053):         return name, path, args, kwargs
0.74 related.py(936):         try:
0.74 related.py(937):             to._meta.model_name
0.74 related.py(938):         except AttributeError:
0.74 related.py(939):             if not isinstance(to, str):
0.74 related.py(954):         if not callable(on_delete):
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
FAIL

======================================================================
FAIL: test_collation_propagation_to_foreign_keys (test_coverup_django__django-15629.CollationPropagationTestCase)
----------------------------------------------------------------------
Traceback (most recent call last):
  File "/testbed/./tests/test_coverup_django__django-15629.py", line 56, in test_collation_propagation_to_foreign_keys
    self.assertIn("COLLATE `utf8_bin`", sql)  # This should pass only if the bug is fixed
AssertionError: 'COLLATE `utf8_bin`' not found in 'ALTER TABLE `tests_address` MODIFY `account_id` varchar(22) NOT NULL;'

----------------------------------------------------------------------
Ran 1 test in 0.005s

FAILED (failures=1)
Destroying test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
0.74 related.py(958):             self,
0.74 related.py(959):             to,
0.74 related.py(960):             to_field,
0.74 related.py(961):             related_name=related_name,
0.74 related.py(962):             related_query_name=related_query_name,
0.74 related.py(963):             limit_choices_to=limit_choices_to,
0.74 related.py(964):             parent_link=parent_link,
0.74 related.py(965):             on_delete=on_delete,
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
0.74 related.py(967):         kwargs.setdefault("db_index", True)
0.74 related.py(969):         super().__init__(
0.74 related.py(970):             to,
0.74 related.py(971):             on_delete,
0.74 related.py(969):         super().__init__(
0.74 related.py(972):             related_name=related_name,
0.74 related.py(973):             related_query_name=related_query_name,
0.74 related.py(974):             limit_choices_to=limit_choices_to,
0.74 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.74 related.py(976):             to_fields=[to_field],
0.74 related.py(969):         super().__init__(
0.74 related.py(977):             **kwargs,
0.74 related.py(969):         super().__init__(
0.74 related.py(544):         if rel is None:
0.74 related.py(555):         super().__init__(
0.74 related.py(556):             rel=rel,
0.74 related.py(557):             related_name=related_name,
0.74 related.py(558):             related_query_name=related_query_name,
0.74 related.py(559):             limit_choices_to=limit_choices_to,
0.74 related.py(555):         super().__init__(
0.74 related.py(560):             **kwargs,
0.74 related.py(555):         super().__init__(
0.74 related.py(105):         self._related_name = related_name
0.74 related.py(106):         self._related_query_name = related_query_name
0.74 related.py(107):         self._limit_choices_to = limit_choices_to
0.74 related.py(108):         super().__init__(**kwargs)
0.74 related.py(563):         self.from_fields = from_fields
0.74 related.py(564):         self.to_fields = to_fields
0.74 related.py(565):         self.swappable = swappable
0.74 related.py(979):         self.db_constraint = db_constraint
0.74 related.py(113):         apps.check_models_ready()
0.74 related.py(114):         return self.remote_field.model
0.74 related.py(1232):         kwargs["unique"] = True
0.74 related.py(1233):         super().__init__(to, on_delete, to_field=to_field, **kwargs)
0.74 related.py(936):         try:
0.74 related.py(937):             to._meta.model_name
0.74 related.py(953):             to_field = to_field or (to._meta.pk and to._meta.pk.name)
0.74 related.py(954):         if not callable(on_delete):
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
0.74 related.py(958):             self,
0.74 related.py(959):             to,
0.74 related.py(960):             to_field,
0.74 related.py(961):             related_name=related_name,
0.74 related.py(962):             related_query_name=related_query_name,
0.74 related.py(963):             limit_choices_to=limit_choices_to,
0.74 related.py(964):             parent_link=parent_link,
0.74 related.py(965):             on_delete=on_delete,
0.74 related.py(957):         kwargs["rel"] = self.rel_class(
0.74 related.py(967):         kwargs.setdefault("db_index", True)
0.74 related.py(969):         super().__init__(
0.74 related.py(970):             to,
0.74 related.py(971):             on_delete,
0.74 related.py(969):         super().__init__(
0.74 related.py(972):             related_name=related_name,
0.74 related.py(973):             related_query_name=related_query_name,
0.74 related.py(974):             limit_choices_to=limit_choices_to,
0.74 related.py(975):             from_fields=[RECURSIVE_RELATIONSHIP_CONSTANT],
0.74 related.py(976):             to_fields=[to_field],
0.74 related.py(969):         super().__init__(
0.74 related.py(977):             **kwargs,
0.74 related.py(969):         super().__init__(
0.74 related.py(544):         if rel is None:
0.74 related.py(555):         super().__init__(
0.74 related.py(556):             rel=rel,
0.74 related.py(557):             related_name=related_name,
0.74 related.py(558):             related_query_name=related_query_name,
0.74 related.py(559):             limit_choices_to=limit_choices_to,
0.74 related.py(555):         super().__init__(
0.74 related.py(560):             **kwargs,
0.74 related.py(555):         super().__init__(
0.74 related.py(105):         self._related_name = related_name
0.74 related.py(106):         self._related_query_name = related_query_name
0.74 related.py(107):         self._limit_choices_to = limit_choices_to
0.74 related.py(108):         super().__init__(**kwargs)
0.74 related.py(563):         self.from_fields = from_fields
0.74 related.py(564):         self.to_fields = to_fields
0.74 related.py(565):         self.swappable = swappable
0.74 related.py(979):         self.db_constraint = db_constraint
+ cat coverage.cover
{"/testbed/django/db/models/fields/related.py": {"1": 1, "2": 1, "3": 1, "5": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "19": 1, "20": 1, "21": 1, "29": 1, "38": 1, "40": 1, "43": 1, "68": 1, "89": 2, "513": 2, "891": 1, "892": 1, "893": 1, "894": 1, "895": 1, "896": 1, "897": 1, "900": 2, "1211": 2, "1261": 1, "1318": 2, "57": 57, "58": 0, "61": 57, "62": 29, "63": 7, "65": 57, "83": 132, "84": 174, "85": 42, "86": 42, "93": 1, "94": 1, "95": 1, "96": 1, "98": 1, "110": 1, "111": 1, "116": 1, "126": 1, "154": 1, "187": 1, "208": 1, "226": 1, "341": 1, "346": 1, "380": 1, "390": 1, "403": 1, "422": 1, "423": 1, "437": 1, "447": 1, "451": 1, "462": 1, "484": 1, "495": 1, "496": 1, "509": 1, "105": 41, "106": 41, "107": 41, "108": 41, "113": 38, "114": 38, "117": 42, "118": 6, "119": 6, "120": 6, "121": 6, "122": 6, "123": 6, "127": 6, "129": 6, "130": 6, "131": 4, "133": 2, "132": 2, "135": 2, "137": 0, "138": 0, "140": 0, "141": 0, "142": 0, "139": 0, "145": 0, "148": 0, "149": 0, "136": 0, "152": 2, "155": 6, "156": 0, "157": 6, "158": 6, "159": 6, "160": 0, "161": 0, "162": 0, "163": 0, "165": 0, "168": 0, "169": 0, "172": 6, "173": 0, "174": 0, "175": 0, "176": 0, "178": 0, "181": 0, "182": 0, "185": 6, "188": 6, "189": 6, "192": 6, "191": 6, "193": 6, "190": 6, "195": 6, "196": 0, "199": 0, "200": 0, "201": 0, "202": 0, "203": 0, "198": 0, "206": 6, "210": 6, "209": 6, "211": 0, "212": 0, "215": 0, "216": 0, "217": 0, "218": 0, "219": 0, "220": 0, "221": 0, "214": 0, "224": 6, "228": 6, "230": 6, "231": 6, "235": 6, "236": 0, "250": 6, "254": 6, "255": 6, "256": 6, "258": 6, "263": 6, "264": 36, "266": 30, "267": 30, "268": 0, "269": 0, "270": 0, "271": 0, "272": 0, "274": 0, "277": 0, "273": 0, "278": 0, "279": 0, "283": 30, "284": 0, "285": 0, "286": 0, "287": 0, "289": 0, "292": 0, "288": 0, "293": 0, "294": 0, "301": 22, "302": 10, "304": 8, "305": 4, "306": 4, "308": 4, "309": 0, "310": 0, "311": 0, "312": 0, "313": 0, "315": 0, "318": 0, "314": 0, "319": 0, "320": 0, "324": 4, "325": 0, "326": 0, "327": 0, "328": 0, "330": 0, "333": 0, "329": 0, "334": 0, "335": 0, "339": 6, "344": 0, "348": 40, "350": 40, "352": 40, "353": 36, "354": 16, "356": 20, "357": 36, "358": 32, "359": 16, "360": 16, "361": 16, "363": 16, "365": 36, "366": 8, "367": 4, "368": 4, "370": 4, "372": 36, "376": 72, "377": 36, "373": 32, "374": 32, "381": 18, "382": 18, "383": 0, "384": 18, "385": 4, "386": 18, "387": 4, "388": 18, "398": 0, "400": 0, "399": 0, "410": 0, "412": 0, "414": 0, "415": 0, "416": 0, "417": 0, "418": 0, "419": 0, "420": 0, "411": 0, "428": 18, "430": 18, "431": 12, "433": 6, "434": 18, "435": 0, "438": 52, "439": 0, "440": 0, "441": 0, "443": 26, "444": 0, "445": 26, "448": 32, "449": 32, "458": 0, "459": 0, "460": 0, "470": 0, "471": 0, "475": 0, "476": 0, "478": 0, "477": 0, "481": 0, "482": 0, "490": 27, "491": 11, "492": 11, "489": 16, "501": 0, "502": 0, "503": 0, "504": 0, "507": 0, "510": 112, "519": 1, "520": 1, "521": 1, "522": 1, "524": 1, "525": 1, "526": 1, "527": 1, "529": 1, "567": 1, "574": 1, "581": 1, "603": 1, "671": 1, "706": 1, "732": 1, "733": 1, "736": 1, "737": 1, "740": 1, "741": 1, "744": 1, "745": 1, "750": 1, "753": 1, "756": 1, "757": 1, "776": 1, "780": 1, "786": 1, "789": 1, "804": 1, "818": 1, "834": 1, "835": 1, "838": 1, "854": 1, "855": 1, "858": 1, "859": 1, "860": 1, "866": 1, "870": 1, "544": 32, "545": 0, "546": 0, "547": 0, "548": 0, "549": 0, "550": 0, "551": 0, "552": 0, "555": 96, "556": 32, "557": 32, "558": 32, "559": 32, "560": 32, "563": 32, "564": 32, "565": 32, "568": 4, "570": 4, "571": 4, "572": 4, "575": 12, "576": 3, "577": 3, "578": 3, "583": 3, "584": 0, "586": 3, "587": 6, "588": 3, "589": 2, "590": 2, "591": 0, "592": 0, "593": 0, "594": 0, "596": 0, "597": 0, "598": 0, "601": 3, "604": 3, "605": 3, "606": 0, "608": 3, "609": 3, "610": 0, "611": 0, "613": 3, "614": 0, "616": 33, "618": 27, "621": 6, "622": 8, "624": 6, "625": 9, "627": 3, "630": 9, "631": 9, "633": 3, "634": 0, "635": 0, "637": 0, "639": 0, "640": 0, "641": 0, "643": 0, "648": 0, "649": 0, "638": 0, "652": 3, "653": 0, "654": 0, "656": 0, "657": 0, "658": 0, "660": 0, "664": 0, "665": 0, "655": 0, "669": 3, "619": 24, "617": 4, "626": 0, "672": 12, "673": 12, "674": 12, "675": 12, "677": 12, "678": 0, "679": 12, "680": 9, "681": 9, "682": 9, "684": 0, "686": 3, "689": 12, "690": 12, "692": 4, "693": 0, "694": 0, "695": 0, "697": 0, "700": 8, "701": 4, "702": 4, "704": 12, "707": 12, "708": 0, "709": 0, "711": 12, "712": 0, "713": 0, "715": 12, "716": 24, "717": 12, "718": 12, "721": 12, "720": 12, "722": 0, "719": 12, "726": 12, "725": 12, "727": 5, "724": 12, "729": 12, "730": 12, "734": 12, "738": 0, "742": 0, "746": 48, "747": 24, "751": 0, "754": 0, "758": 0, "759": 0, "760": 0, "764": 0, "765": 0, "767": 0, "766": 0, "768": 0, "769": 0, "771": 0, "772": 0, "773": 0, "774": 0, "777": 0, "778": 0, "781": 20, "782": 80, "783": 40, "787": 0, "802": 0, "816": 5, "820": 2, "821": 2, "823": 4, "824": 2, "825": 2, "826": 2, "827": 2, "828": 2, "829": 2, "830": 2, "822": 2, "836": 2, "840": 0, "841": 0, "843": 0, "844": 0, "845": 0, "846": 0, "847": 0, "848": 0, "849": 0, "850": 0, "842": 0, "856": 0, "861": 1, "862": 1, "863": 4, "864": 1, "867": 30, "868": 30, "874": 26, "873": 40, "875": 14, "877": 28, "878": 14, "879": 14, "880": 14, "885": 14, "886": 0, "887": 0, "909": 1, "911": 1, "912": 1, "913": 1, "914": 1, "916": 1, "918": 1, "920": 1, "919": 1, "922": 1, "924": 1, "981": 1, "984": 1, "991": 1, "1017": 1, "1035": 1, "1055": 1, "1058": 1, "1059": 1, "1062": 1, "1078": 1, "1102": 1, "1121": 1, "1124": 1, "1129": 1, "1136": 1, "1148": 1, "1151": 1, "1154": 1, "1159": 1, "1176": 1, "1179": 1, "1182": 1, "1190": 1, "1195": 1, "1201": 1, "936": 32, "937": 32, "938": 19, "939": 19, "940": 0, "941": 0, "944": 0, "945": 0, "946": 0, "943": 0, "953": 13, "954": 32, "955": 0, "957": 64, "958": 32, "959": 32, "960": 32, "961": 32, "962": 32, "963": 32, "964": 32, "965": 32, "967": 32, "969": 128, "970": 32, "971": 32, "972": 32, "973": 32, "974": 32, "975": 32, "976": 32, "977": 32, "979": 32, "982": 0, "985": 12, "986": 3, "987": 3, "988": 3, "992": 3, "993": 3, "995": 0, "996": 0, "998": 0, "1001": 0, "1002": 0, "994": 0, "1005": 3, "1007": 0, "1008": 0, "1009": 0, "1010": 0, "1011": 0, "1006": 0, "1015": 3, "1031": 3, "1019": 3, "1020": 0, "1021": 0, "1024": 0, "1027": 0, "1028": 0, "1032": 3, "1018": 3, "1036": 12, "1037": 12, "1038": 12, "1040": 12, "1041": 12, "1043": 0, "1044": 12, "1045": 0, "1047": 12, "1048": 21, "1049": 3, "1050": 6, "1052": 0, "1053": 12, "1056": 0, "1060": 122, "1064": 0, "1065": 0, "1067": 0, "1068": 0, "1069": 0, "1070": 0, "1071": 0, "1072": 0, "1073": 0, "1074": 0, "1066": 0, "1079": 0, "1080": 0, "1081": 0, "1082": 0, "1083": 0, "1085": 0, "1086": 0, "1087": 0, "1089": 0, "1090": 0, "1091": 0, "1092": 0, "1093": 0, "1095": 0, "1096": 0, "1097": 0, "1098": 0, "1094": 0, "1103": 12, "1104": 24, "1106": 12, "1105": 24, "1107": 12, "1109": 0, "1110": 0, "1113": 0, "1114": 0, "1115": 0, "1116": 0, "1112": 0, "1119": 12, "1122": 36, "1125": 33, "1126": 33, "1127": 33, "1131": 0, "1132": 0, "1133": 0, "1134": 0, "1137": 56, "1138": 28, "1140": 0, "1141": 0, "1144": 0, "1146": 28, "1149": 0, "1152": 7, "1155": 26, "1156": 26, "1157": 0, "1160": 0, "1161": 0, "1162": 0, "1164": 0, "1166": 0, "1168": 0, "1169": 0, "1170": 0, "1167": 0, "1171": 0, "1172": 0, "1177": 22, "1180": 27, "1183": 22, "1185": 22, "1186": 22, "1187": 22, "1184": 22, "1191": 0, "1192": 0, "1193": 0, "1196": 5, "1197": 5, "1198": 0, "1199": 5, "1202": 10, "1203": 5, "1204": 5, "1205": 0, "1206": 0, "1207": 0, "1208": 10, "1220": 1, "1221": 1, "1222": 1, "1223": 1, "1225": 1, "1226": 1, "1227": 1, "1229": 1, "1231": 1, "1235": 1, "1241": 1, "1246": 1, "1256": 1, "1232": 3, "1233": 3, "1236": 1, "1237": 1, "1238": 1, "1239": 1, "1242": 0, "1243": 0, "1244": 0, "1247": 0, "1248": 0, "1250": 0, "1253": 0, "1254": 0, "1258": 0, "1262": 6, "1264": 6, "1267": 6, "1268": 6, "1269": 6, "1271": 6, "1272": 6, "1273": 6, "1274": 0, "1275": 0, "1277": 12, "1278": 6, "1279": 6, "1281": 6, "1282": 6, "1283": 6, "1284": 6, "1285": 6, "1286": 12, "1287": 6, "1288": 12, "1289": 6, "1290": 6, "1280": 6, "1294": 12, "1295": 6, "1296": 6, "1298": 6, "1299": 6, "1300": 12, "1301": 6, "1302": 6, "1303": 6, "1304": 6, "1305": 6, "1307": 12, "1308": 6, "1309": 6, "1310": 6, "1311": 6, "1312": 6, "1297": 6, "1265": 6, "1329": 1, "1330": 1, "1331": 1, "1332": 1, "1334": 1, "1336": 1, "1338": 1, "1397": 1, "1406": 1, "1417": 1, "1449": 1, "1680": 1, "1732": 1, "1772": 1, "1803": 1, "1806": 1, "1807": 1, "1810": 1, "1813": 1, "1814": 1, "1817": 1, "1830": 1, "1851": 1, "1881": 1, "1930": 1, "1959": 1, "1962": 1, "1965": 1, "1968": 1, "1983": 1, "1986": 1, "1991": 1, "1352": 9, "1353": 9, "1354": 6, "1355": 6, "1356": 0, "1357": 0, "1360": 0, "1361": 0, "1362": 0, "1359": 0, "1366": 9, "1367": 9, "1369": 9, "1370": 0, "1371": 0, "1374": 18, "1375": 9, "1376": 9, "1377": 9, "1378": 9, "1379": 9, "1380": 9, "1381": 9, "1382": 9, "1383": 9, "1385": 9, "1387": 27, "1388": 9, "1389": 9, "1390": 9, "1391": 9, "1394": 9, "1395": 9, "1398": 18, "1399": 3, "1400": 3, "1401": 3, "1402": 3, "1403": 3, "1407": 3, "1409": 0, "1410": 0, "1411": 0, "1412": 0, "1408": 0, "1415": 3, "1418": 3, "1420": 3, "1421": 0, "1422": 0, "1423": 0, "1424": 0, "1425": 0, "1429": 3, "1430": 0, "1431": 0, "1432": 0, "1433": 0, "1434": 0, "1437": 3, "1438": 0, "1439": 0, "1440": 0, "1442": 0, "1443": 0, "1447": 3, "1450": 3, "1451": 6, "1452": 3, "1453": 3, "1456": 0, "1458": 3, "1460": 6, "1461": 3, "1464": 0, "1465": 0, "1466": 0, "1467": 0, "1468": 0, "1469": 0, "1474": 3, "1475": 0, "1480": 3, "1481": 3, "1482": 3, "1483": 0, "1485": 3, "1486": 3, "1487": 3, "1489": 3, "1490": 0, "1492": 0, "1495": 0, "1496": 0, "1497": 0, "1498": 0, "1503": 0, "1505": 0, "1508": 0, "1509": 0, "1515": 18, "1517": 12, "1519": 18, "1521": 12, "1524": 3, "1525": 0, "1526": 0, "1528": 0, "1534": 0, "1527": 0, "1536": 0, "1540": 0, "1541": 0, "1539": 0, "1535": 0, "1543": 0, "1544": 0, "1548": 3, "1549": 0, "1550": 0, "1551": 0, "1555": 0, "1557": 0, "1561": 0, "1562": 0, "1560": 0, "1556": 0, "1564": 0, "1565": 0, "1569": 3, "1570": 0, "1571": 0, "1572": 0, "1574": 0, "1575": 0, "1576": 0, "1581": 3, "1585": 0, "1584": 0, "1586": 0, "1587": 0, "1589": 0, "1590": 0, "1591": 0, "1593": 0, "1595": 0, "1598": 0, "1599": 0, "1607": 0, "1608": 0, "1614": 0, "1615": 0, "1616": 0, "1613": 0, "1618": 0, "1619": 0, "1623": 0, "1624": 0, "1622": 0, "1627": 0, "1628": 0, "1630": 0, "1629": 0, "1631": 0, "1633": 0, "1634": 0, "1636": 0, "1639": 0, "1640": 0, "1638": 0, "1635": 0, "1644": 0, "1646": 0, "1647": 0, "1648": 0, "1649": 0, "1650": 0, "1651": 0, "1652": 0, "1653": 0, "1654": 0, "1655": 0, "1660": 0, "1659": 0, "1661": 0, "1662": 0, "1664": 0, "1665": 0, "1666": 0, "1668": 0, "1669": 0, "1670": 0, "1667": 0, "1672": 0, "1673": 0, "1674": 0, "1678": 3, "1491": 0, "1516": 9, "1520": 9, "1682": 3, "1681": 6, "1683": 3, "1685": 0, "1686": 39, "1688": 33, "1691": 3, "1692": 3, "1696": 3, "1695": 3, "1697": 0, "1698": 0, "1700": 0, "1702": 0, "1707": 0, "1708": 0, "1710": 0, "1711": 0, "1712": 0, "1714": 0, "1716": 0, "1713": 0, "1719": 0, "1720": 0, "1722": 0, "1723": 0, "1724": 0, "1725": 0, "1726": 0, "1727": 0, "1721": 0, "1730": 3, "1689": 30, "1687": 27, "1703": 0, "1704": 0, "1705": 0, "1733": 6, "1735": 6, "1736": 0, "1737": 6, "1738": 0, "1740": 6, "1741": 3, "1742": 3, "1743": 3, "1745": 0, "1747": 3, "1748": 6, "1749": 3, "1750": 0, "1751": 3, "1752": 0, "1755": 6, "1756": 6, "1758": 0, "1759": 0, "1760": 0, "1761": 0, "1763": 0, "1766": 0, "1767": 0, "1768": 0, "1770": 6, "1774": 0, "1775": 0, "1776": 0, "1777": 0, "1778": 0, "1779": 0, "1780": 0, "1782": 0, "1784": 0, "1785": 0, "1786": 0, "1788": 0, "1792": 0, "1793": 0, "1794": 0, "1795": 0, "1796": 0, "1797": 0, "1799": 0, "1801": 0, "1804": 0, "1808": 0, "1811": 0, "1815": 0, "1822": 9, "1823": 3, "1824": 6, "1825": 0, "1827": 6, "1828": 6, "1835": 0, "1836": 0, "1837": 0, "1838": 0, "1839": 0, "1841": 0, "1842": 0, "1844": 0, "1843": 0, "1845": 0, "1846": 0, "1848": 0, "1849": 0, "1856": 0, "1857": 0, "1858": 0, "1859": 0, "1860": 0, "1861": 0, "1863": 0, "1864": 0, "1865": 0, "1866": 0, "1871": 0, "1872": 0, "1873": 0, "1875": 0, "1876": 0, "1877": 0, "1878": 0, "1879": 0, "1888": 10, "1889": 0, "1890": 0, "1892": 0, "1893": 10, "1898": 0, "1899": 0, "1900": 0, "1901": 0, "1904": 10, "1910": 10, "1911": 6, "1913": 0, "1916": 0, "1917": 0, "1919": 6, "1920": 12, "1921": 6, "1925": 10, "1928": 10, "1914": 0, "1934": 6, "1933": 12, "1935": 6, "1937": 12, "1938": 6, "1939": 6, "1940": 6, "1944": 6, "1945": 6, "1947": 6, "1948": 12, "1949": 6, "1952": 6, "1953": 6, "1954": 12, "1955": 6, "1957": 6, "1960": 6, "1963": 0, "1966": 0, "1970": 0, "1971": 0, "1969": 0, "1972": 0, "1976": 0, "1977": 0, "1978": 0, "1979": 0, "1980": 0, "1981": 0, "1984": 0, "1989": 0, "1992": 0}}
{"/testbed/django/db/backends/sqlite3/schema.py": {"1": 1, "2": 1, "4": 1, "5": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "13": 2, "15": 1, "16": 1, "18": 1, "17": 1, "20": 1, "21": 1, "22": 1, "23": 1, "25": 1, "38": 1, "43": 1, "74": 1, "77": 1, "100": 1, "123": 1, "176": 1, "362": 1, "380": 1, "398": 1, "425": 1, "484": 1, "536": 1, "547": 1, "558": 1, "28": 7, "29": 0, "30": 0, "36": 7, "39": 7, "40": 7, "41": 7, "47": 0, "48": 0, "50": 0, "51": 0, "52": 0, "53": 0, "54": 0, "56": 0, "57": 0, "58": 0, "59": 0, "60": 0, "61": 0, "62": 0, "63": 0, "64": 0, "68": 0, "70": 0, "71": 0, "75": 0, "86": 0, "87": 0, "88": 0, "89": 0, "90": 0, "91": 0, "93": 0, "94": 0, "95": 0, "97": 0, "98": 0, "104": 2, "103": 2, "105": 0, "106": 0, "108": 0, "109": 0, "111": 0, "115": 0, "110": 0, "117": 0, "118": 0, "119": 0, "121": 2, "124": 3, "125": 1, "126": 2, "127": 2, "128": 2, "130": 2, "129": 2, "131": 0, "132": 0, "133": 0, "136": 0, "137": 0, "139": 0, "143": 0, "138": 0, "145": 0, "146": 0, "150": 0, "151": 0, "152": 0, "154": 0, "155": 0, "156": 0, "157": 0, "158": 0, "159": 0, "160": 0, "161": 0, "163": 0, "164": 0, "168": 0, "171": 0, "172": 0, "174": 2, "197": 2, "201": 17, "203": 13, "207": 17, "209": 13, "212": 2, "215": 2, "216": 6, "217": 4, "219": 0, "220": 0, "223": 0, "224": 0, "226": 0, "227": 0, "228": 0, "229": 0, "230": 0, "232": 2, "233": 0, "235": 0, "236": 0, "237": 0, "240": 2, "241": 2, "242": 2, "243": 2, "244": 2, "245": 2, "246": 0, "247": 0, "248": 0, "250": 0, "252": 2, "253": 2, "255": 2, "256": 0, "257": 0, "260": 0, "259": 0, "261": 0, "263": 0, "265": 2, "269": 6, "271": 2, "276": 6, "278": 2, "281": 2, "282": 2, "283": 0, "284": 0, "287": 2, "292": 2, "300": 2, "301": 2, "302": 2, "303": 2, "304": 2, "305": 2, "306": 2, "299": 2, "308": 2, "309": 2, "310": 2, "311": 2, "314": 2, "316": 2, "317": 2, "318": 2, "319": 2, "320": 2, "321": 2, "322": 2, "315": 2, "324": 2, "325": 2, "326": 2, "327": 2, "330": 2, "333": 4, "334": 4, "336": 2, "337": 15, "338": 2, "339": 2, "335": 2, "344": 2, "347": 4, "348": 2, "349": 2, "350": 2, "351": 2, "355": 4, "356": 2, "357": 2, "359": 2, "360": 0, "198": 11, "202": 11, "208": 11, "270": 0, "277": 0, "363": 2, "364": 0, "367": 4, "368": 4, "370": 2, "369": 2, "374": 4, "375": 4, "376": 2, "378": 0, "385": 0, "382": 0, "386": 0, "391": 0, "392": 0, "394": 0, "396": 0, "404": 0, "406": 0, "407": 0, "410": 0, "409": 0, "413": 0, "414": 0, "415": 0, "417": 0, "421": 0, "422": 0, "423": 0, "440": 2, "439": 4, "441": 2, "442": 0, "444": 0, "445": 0, "446": 0, "447": 0, "450": 0, "451": 0, "452": 0, "456": 2, "458": 2, "459": 2, "460": 4, "461": 2, "463": 0, "464": 0, "465": 0, "467": 0, "468": 0, "469": 0, "470": 0, "471": 0, "472": 0, "473": 0, "474": 0, "475": 0, "477": 0, "478": 0, "479": 0, "480": 0, "481": 0, "482": 0, "487": 0, "488": 0, "486": 0, "492": 0, "493": 0, "499": 0, "500": 0, "502": 0, "503": 0, "494": 0, "507": 0, "510": 0, "512": 0, "513": 0, "515": 0, "516": 0, "518": 0, "519": 0, "520": 0, "517": 0, "523": 0, "525": 0, "526": 0, "527": 0, "524": 0, "530": 0, "514": 0, "534": 0, "537": 0, "538": 0, "539": 0, "540": 0, "541": 0, "543": 0, "545": 0, "548": 0, "549": 0, "550": 0, "551": 0, "552": 0, "554": 0, "556": 0, "559": 0}}
{"/testbed/django/db/backends/base/schema.py": {"1": 1, "2": 1, "4": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "18": 1, "21": 1, "37": 1, "46": 1, "69": 2, "26": 0, "27": 0, "29": 0, "30": 0, "32": 0, "34": 0, "38": 0, "39": 0, "40": 0, "41": 0, "42": 0, "49": 0, "50": 0, "52": 0, "55": 0, "57": 0, "61": 0, "62": 0, "63": 0, "64": 0, "65": 0, "53": 0, "51": 0, "58": 0, "56": 0, "77": 1, "78": 1, "79": 1, "80": 1, "82": 1, "83": 1, "84": 1, "85": 1, "86": 1, "87": 1, "88": 1, "89": 1, "90": 1, "91": 1, "93": 1, "92": 1, "96": 1, "95": 1, "99": 1, "100": 1, "101": 1, "102": 1, "104": 1, "105": 1, "108": 1, "107": 1, "111": 1, "114": 1, "113": 1, "117": 1, "118": 1, "119": 1, "122": 1, "121": 1, "126": 1, "125": 1, "129": 1, "132": 1, "131": 1, "134": 1, "136": 1, "138": 1, "147": 1, "154": 1, "163": 1, "194": 1, "197": 1, "278": 1, "333": 1, "360": 1, "367": 1, "374": 1, "383": 1, "390": 1, "391": 1, "414": 1, "418": 1, "430": 1, "449": 1, "470": 1, "481": 1, "490": 1, "498": 1, "504": 1, "522": 1, "543": 1, "566": 1, "585": 1, "596": 1, "668": 1, "700": 1, "764": 1, "1109": 1, "1138": 1, "1176": 1, "1198": 1, "1211": 1, "1243": 1, "1275": 1, "1285": 1, "1290": 1, "1302": 1, "1303": 1, "1304": 1, "1305": 1, "1306": 1, "1307": 1, "1308": 1, "1309": 1, "1310": 1, "1311": 1, "1312": 1, "1298": 1, "1352": 1, "1359": 1, "1362": 1, "1385": 1, "1394": 1, "1409": 1, "1412": 1, "1415": 1, "1422": 1, "1430": 1, "1451": 1, "1464": 1, "1467": 1, "1475": 1, "1515": 1, "1571": 1, "1599": 1, "1605": 1, "1613": 1, "1616": 1, "1623": 1, "1664": 1, "1677": 1, "1689": 1, "1692": 1, "1695": 1, "139": 7, "140": 7, "141": 7, "142": 0, "143": 7, "148": 7, "149": 7, "150": 7, "151": 7, "152": 7, "155": 7, "156": 22, "157": 15, "158": 7, "159": 7, "168": 36, "167": 108, "169": 36, "170": 36, "172": 0, "173": 0, "177": 36, "179": 72, "180": 36, "182": 36, "183": 0, "184": 0, "185": 0, "186": 0, "189": 0, "191": 36, "192": 36, "195": 193, "201": 18, "202": 20, "203": 5, "205": 13, "206": 13, "207": 71, "209": 58, "210": 58, "211": 0, "213": 58, "214": 58, "215": 2, "217": 58, "218": 58, "219": 12, "220": 58, "222": 58, "223": 11, "224": 22, "225": 11, "227": 11, "228": 22, "229": 11, "230": 11, "232": 0, "233": 0, "234": 0, "235": 0, "239": 116, "240": 116, "242": 58, "243": 58, "241": 58, "248": 58, "253": 24, "254": 12, "256": 12, "257": 0, "258": 39, "260": 13, "262": 26, "263": 13, "264": 97, "265": 71, "268": 13, "269": 0, "270": 0, "272": 0, "273": 0, "274": 13, "259": 0, "281": 58, "282": 58, "283": 0, "285": 58, "288": 58, "289": 0, "294": 0, "287": 58, "296": 58, "297": 0, "298": 0, "299": 0, "300": 0, "304": 0, "306": 0, "307": 0, "311": 58, "310": 105, "312": 24, "313": 23, "315": 0, "316": 58, "317": 53, "318": 5, "319": 5, "320": 58, "321": 13, "322": 45, "323": 3, "325": 58, "327": 58, "326": 58, "328": 0, "329": 0, "331": 0, "339": 58, "340": 58, "342": 58, "343": 0, "344": 58, "346": 116, "348": 116, "349": 58, "350": 58, "351": 58, "352": 58, "353": 58, "354": 58, "357": 58, "345": 58, "365": 0, "372": 0, "378": 0, "379": 0, "388": 0, "393": 0, "394": 0, "395": 0, "396": 0, "397": 0, "399": 0, "400": 0, "401": 0, "402": 0, "403": 0, "405": 0, "406": 0, "407": 0, "408": 0, "409": 0, "411": 0, "412": 0, "416": 0, "426": 0, "435": 13, "438": 13, "442": 13, "445": 16, "446": 3, "447": 3, "452": 0, "453": 0, "454": 0, "457": 0, "458": 0, "460": 0, "459": 0, "464": 0, "465": 0, "466": 0, "468": 0, "473": 0, "472": 0, "474": 0, "476": 0, "479": 0, "484": 0, "483": 0, "485": 0, "487": 0, "488": 0, "492": 0, "493": 0, "496": 0, "500": 0, "501": 0, "502": 0, "510": 0, "511": 0, "513": 0, "514": 0, "515": 0, "518": 0, "519": 0, "520": 0, "528": 0, "529": 0, "531": 0, "532": 0, "533": 0, "534": 0, "535": 0, "536": 0, "539": 0, "540": 0, "541": 0, "544": 0, "545": 0, "547": 0, "548": 0, "549": 0, "550": 0, "551": 0, "552": 0, "553": 0, "555": 0, "556": 0, "557": 0, "559": 0, "560": 0, "561": 0, "558": 0, "564": 0, "568": 6, "569": 2, "570": 2, "572": 0, "573": 4, "574": 4, "576": 2, "577": 2, "575": 2, "581": 4, "582": 2, "583": 2, "587": 0, "588": 0, "590": 0, "591": 0, "592": 0, "589": 0, "602": 0, "603": 0, "605": 0, "607": 0, "608": 0, "610": 0, "611": 0, "612": 0, "614": 0, "613": 0, "615": 0, "616": 0, "618": 0, "620": 0, "621": 0, "622": 0, "623": 0, "625": 0, "626": 0, "627": 0, "629": 0, "628": 0, "630": 0, "631": 0, "632": 0, "633": 0, "634": 0, "638": 0, "639": 0, "642": 0, "643": 0, "644": 0, "645": 0, "647": 0, "651": 0, "650": 0, "652": 0, "654": 0, "655": 0, "657": 0, "658": 0, "659": 0, "661": 0, "663": 0, "665": 0, "666": 0, "674": 0, "675": 0, "677": 0, "678": 0, "680": 0, "681": 0, "682": 0, "683": 0, "685": 0, "686": 0, "687": 0, "689": 0, "691": 0, "692": 0, "694": 0, "695": 0, "696": 0, "698": 0, "708": 2, "709": 0, "711": 2, "712": 2, "713": 2, "714": 2, "715": 4, "716": 2, "718": 0, "719": 0, "721": 0, "724": 2, "723": 2, "725": 0, "727": 0, "728": 0, "729": 0, "730": 0, "733": 0, "735": 2, "734": 2, "736": 0, "738": 0, "739": 0, "740": 0, "741": 0, "745": 0, "746": 2, "747": 0, "748": 0, "750": 0, "753": 4, "754": 2, "755": 2, "756": 2, "757": 2, "758": 2, "759": 2, "760": 2, "761": 2, "777": 0, "779": 0, "778": 0, "780": 0, "781": 0, "783": 0, "784": 0, "786": 0, "787": 0, "788": 0, "790": 0, "791": 0, "792": 0, "789": 0, "795": 0, "796": 0, "797": 0, "799": 0, "800": 0, "803": 0, "804": 0, "806": 0, "807": 0, "808": 0, "809": 0, "810": 0, "811": 0, "813": 0, "814": 0, "815": 0, "817": 0, "818": 0, "819": 0, "816": 0, "822": 0, "823": 0, "826": 0, "827": 0, "829": 0, "831": 0, "832": 0, "834": 0, "828": 0, "836": 0, "839": 0, "840": 0, "841": 0, "843": 0, "844": 0, "856": 0, "855": 0, "857": 0, "858": 0, "861": 0, "864": 0, "865": 0, "866": 0, "867": 0, "868": 0, "869": 0, "871": 0, "875": 0, "877": 0, "878": 0, "879": 0, "881": 0, "882": 0, "883": 0, "884": 0, "885": 0, "887": 0, "888": 0, "889": 0, "891": 0, "892": 0, "893": 0, "890": 0, "896": 0, "897": 0, "899": 0, "900": 0, "901": 0, "902": 0, "906": 0, "907": 0, "908": 0, "909": 0, "912": 0, "913": 0, "914": 0, "916": 0, "917": 0, "919": 0, "921": 0, "922": 0, "924": 0, "926": 0, "927": 0, "928": 0, "930": 0, "931": 0, "939": 0, "940": 0, "941": 0, "942": 0, "944": 0, "943": 0, "945": 0, "946": 0, "948": 0, "949": 0, "950": 0, "953": 0, "954": 0, "955": 0, "956": 0, "958": 0, "959": 0, "961": 0, "962": 0, "965": 0, "967": 0, "968": 0, "969": 0, "971": 0, "972": 0, "973": 0, "975": 0, "976": 0, "974": 0, "978": 0, "980": 0, "982": 0, "983": 0, "985": 0, "986": 0, "987": 0, "984": 0, "989": 0, "993": 0, "994": 0, "995": 0, "997": 0, "998": 0, "996": 0, "1000": 0, "1002": 0, "1003": 0, "1004": 0, "1006": 0, "1007": 0, "1009": 0, "1010": 0, "1021": 0, "1020": 0, "1022": 0, "1023": 0, "1025": 0, "1028": 0, "1029": 0, "1030": 0, "1032": 0, "1034": 0, "1036": 0, "1038": 0, "1039": 0, "1040": 0, "1041": 0, "1042": 0, "1043": 0, "1044": 0, "1046": 0, "1047": 0, "1048": 0, "1049": 0, "1050": 0, "1052": 0, "1054": 0, "1055": 0, "1057": 0, "1058": 0, "1060": 0, "1061": 0, "1059": 0, "1063": 0, "1065": 0, "1066": 0, "1069": 0, "1068": 0, "1070": 0, "1072": 0, "1074": 0, "1076": 0, "1077": 0, "1080": 0, "1081": 0, "1082": 0, "1083": 0, "1084": 0, "1087": 0, "1088": 0, "1089": 0, "1091": 0, "1092": 0, "1096": 0, "1097": 0, "1098": 0, "1100": 0, "1101": 0, "1102": 0, "1104": 0, "1106": 0, "1107": 0, "1117": 0, "1116": 0, "1118": 0, "1121": 0, "1123": 0, "1126": 0, "1125": 0, "1127": 0, "1124": 0, "1130": 0, "1132": 0, "1133": 0, "1131": 0, "1135": 0, "1129": 0, "1145": 0, "1146": 0, "1147": 0, "1149": 0, "1150": 0, "1151": 0, "1155": 0, "1156": 0, "1158": 0, "1159": 0, "1160": 0, "1161": 0, "1163": 0, "1165": 0, "1167": 0, "1169": 0, "1170": 0, "1171": 0, "1168": 0, "1173": 0, "1166": 0, "1188": 0, "1190": 0, "1191": 0, "1189": 0, "1193": 0, "1187": 0, "1195": 0, "1186": 0, "1200": 0, "1202": 0, "1203": 0, "1205": 0, "1204": 0, "1206": 0, "1201": 0, "1208": 0, "1199": 0, "1215": 0, "1216": 0, "1214": 0, "1218": 0, "1219": 0, "1220": 0, "1221": 0, "1224": 0, "1225": 0, "1229": 0, "1230": 0, "1232": 0, "1233": 0, "1236": 0, "1237": 0, "1239": 0, "1240": 0, "1250": 17, "1251": 34, "1252": 17, "1253": 17, "1255": 17, "1257": 17, "1258": 17, "1259": 17, "1261": 0, "1262": 0, "1263": 0, "1264": 0, "1265": 0, "1266": 0, "1267": 0, "1271": 0, "1272": 0, "1273": 0, "1276": 12, "1277": 12, "1278": 0, "1279": 12, "1280": 0, "1281": 12, "1282": 0, "1283": 12, "1286": 17, "1287": 0, "1288": 17, "1291": 17, "1292": 17, "1293": 0, "1294": 0, "1295": 0, "1319": 12, "1320": 12, "1321": 24, "1322": 12, "1324": 24, "1325": 12, "1327": 36, "1328": 12, "1329": 12, "1331": 12, "1337": 24, "1338": 12, "1339": 12, "1340": 12, "1341": 12, "1344": 12, "1343": 12, "1345": 0, "1347": 12, "1348": 12, "1349": 12, "1333": 12, "1334": 12, "1335": 12, "1353": 0, "1354": 0, "1355": 0, "1356": 0, "1360": 17, "1367": 13, "1368": 0, "1369": 13, "1370": 71, "1371": 58, "1373": 13, "1374": 0, "1375": 0, "1377": 13, "1379": 0, "1378": 0, "1380": 0, "1382": 0, "1383": 13, "1389": 58, "1390": 58, "1391": 12, "1392": 58, "1395": 5, "1396": 5, "1401": 65, "1402": 60, "1403": 65, "1404": 60, "1405": 15, "1406": 5, "1407": 5, "1410": 58, "1413": 0, "1417": 0, "1418": 0, "1419": 0, "1416": 0, "1423": 0, "1424": 0, "1425": 0, "1426": 0, "1427": 0, "1431": 0, "1432": 0, "1433": 0, "1434": 0, "1435": 0, "1436": 0, "1437": 0, "1438": 0, "1440": 0, "1441": 0, "1442": 0, "1443": 0, "1444": 0, "1445": 0, "1446": 0, "1447": 0, "1448": 0, "1452": 0, "1455": 0, "1456": 0, "1457": 0, "1458": 0, "1459": 0, "1460": 0, "1461": 0, "1453": 0, "1465": 0, "1468": 5, "1469": 5, "1470": 0, "1471": 0, "1472": 0, "1473": 0, "1487": 0, "1486": 0, "1488": 0, "1490": 0, "1491": 0, "1494": 0, "1495": 0, "1496": 0, "1497": 0, "1498": 0, "1499": 0, "1500": 0, "1501": 0, "1503": 0, "1504": 0, "1505": 0, "1506": 0, "1507": 0, "1508": 0, "1510": 0, "1511": 0, "1512": 0, "1528": 5, "1526": 20, "1529": 0, "1531": 5, "1532": 5, "1534": 5, "1537": 0, "1539": 5, "1542": 10, "1543": 5, "1545": 5, "1546": 20, "1547": 5, "1548": 5, "1550": 0, "1551": 5, "1552": 0, "1554": 5, "1555": 5, "1556": 10, "1557": 5, "1560": 0, "1561": 10, "1562": 5, "1563": 5, "1564": 5, "1565": 5, "1566": 5, "1567": 5, "1568": 5, "1540": 5, "1583": 0, "1581": 0, "1584": 0, "1586": 0, "1587": 0, "1589": 0, "1592": 0, "1593": 0, "1594": 0, "1596": 0, "1597": 0, "1600": 0, "1601": 0, "1602": 0, "1606": 0, "1607": 0, "1608": 0, "1609": 0, "1610": 0, "1614": 0, "1617": 0, "1618": 0, "1619": 0, "1620": 0, "1636": 0, "1637": 0, "1639": 0, "1641": 0, "1642": 0, "1643": 0, "1645": 0, "1646": 0, "1647": 0, "1648": 0, "1649": 0, "1650": 0, "1651": 0, "1652": 0, "1653": 0, "1654": 0, "1655": 0, "1656": 0, "1657": 0, "1658": 0, "1659": 0, "1660": 0, "1661": 0, "1662": 0, "1638": 0, "1665": 0, "1666": 0, "1667": 0, "1668": 0, "1670": 0, "1671": 0, "1669": 0, "1674": 0, "1675": 0, "1678": 0, "1679": 0, "1680": 0, "1681": 0, "1682": 0, "1683": 0, "1686": 0, "1690": 0, "1693": 0, "1696": 0, "1697": 0, "1698": 0, "1700": 0}}
+ git checkout 694cf458f16b8d340a3195244196980b2dec34fd
M	django/db/backends/base/schema.py
M	django/db/backends/oracle/features.py
M	django/db/backends/sqlite3/schema.py
M	django/db/models/fields/related.py
Note: switching to '694cf458f16b8d340a3195244196980b2dec34fd'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 694cf458f1 Removed 'tests' path prefix in a couple tests.
+ git apply /root/pre_state.patch
error: unrecognized input
