+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git diff HEAD 955e54221008aba577ecbaefa15679f6777d3bf8
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
nothing to commit, working tree clean
+ git show
commit 955e54221008aba577ecbaefa15679f6777d3bf8
Merge: 0215bcd84 29bb0eda2
Author: Bruno Oliveira <nicoddemus@gmail.com>
Date:   Wed Aug 28 08:44:16 2019 -0300

    Merge pull request #5792 from dynatrace-oss-contrib/bugfix/badcase
    
    Fix pytest with mixed up filename casing.

+ git diff 955e54221008aba577ecbaefa15679f6777d3bf8
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Installing build dependencies: started
  Installing build dependencies: finished with status 'done'
  Checking if build backend supports build_editable: started
  Checking if build backend supports build_editable: finished with status 'done'
  Getting requirements to build editable: started
  Getting requirements to build editable: finished with status 'done'
  Preparing editable metadata (pyproject.toml): started
  Preparing editable metadata (pyproject.toml): finished with status 'done'
Requirement already satisfied: py>=1.5.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (1.11.0)
Requirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (23.1)
Requirement already satisfied: attrs>=17.4.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (23.1.0)
Requirement already satisfied: more-itertools>=4.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (10.1.0)
Requirement already satisfied: atomicwrites>=1.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (1.4.1)
Requirement already satisfied: pluggy<1.0,>=0.12 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (0.13.1)
Requirement already satisfied: wcwidth in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest==5.1.2.dev12+g955e54221) (0.2.6)
Building wheels for collected packages: pytest
  Building editable for pytest (pyproject.toml): started
  Building editable for pytest (pyproject.toml): finished with status 'done'
  Created wheel for pytest: filename=pytest-5.1.2.dev12+g955e54221-0.editable-py3-none-any.whl size=4807 sha256=4acf502c1d4f346021eba4d718550ba5150f400ea0d9c5118b5723d65e6990c9
  Stored in directory: /tmp/pip-ephem-wheel-cache-x8i61dsi/wheels/7d/66/67/70d1ee2124ccf21d601c352e25cdca10f611f7c8b3f9ffb9e4
Successfully built pytest
Installing collected packages: pytest
  Attempting uninstall: pytest
    Found existing installation: pytest 5.1.2.dev12+g955e54221
    Uninstalling pytest-5.1.2.dev12+g955e54221:
      Successfully uninstalled pytest-5.1.2.dev12+g955e54221
Successfully installed pytest-5.1.2.dev12+g955e54221
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable. It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git apply -v -
Checking patch src/_pytest/reports.py...
Applied patch src/_pytest/reports.py cleanly.
+ git apply -v -
Checking patch testing/test_coverup_pytest-dev__pytest-5787.py...
Applied patch testing/test_coverup_pytest-dev__pytest-5787.py cleanly.
+ python3 /root/trace.py --timing --trace --count -C coverage.cover --include-pattern '/testbed/(src/_pytest/reports\.py)' -m pytest -rA testing/test_coverup_pytest-dev__pytest-5787.py
['--timing', '--trace', '--count', '-C', 'coverage.cover', '--include-pattern', '/testbed/(src/_pytest/reports\\.py)']
0.12 reports.py(1): from pprint import pprint
0.12 reports.py(2): from typing import Optional
0.12 reports.py(4): import py
0.12 reports.py(6): from _pytest._code.code import ExceptionChainRepr
0.12 reports.py(7): from _pytest._code.code import ExceptionInfo
0.12 reports.py(8): from _pytest._code.code import ReprEntry
0.12 reports.py(9): from _pytest._code.code import ReprEntryNative
0.12 reports.py(10): from _pytest._code.code import ReprExceptionInfo
0.12 reports.py(11): from _pytest._code.code import ReprFileLocation
0.12 reports.py(12): from _pytest._code.code import ReprFuncArgs
0.12 reports.py(13): from _pytest._code.code import ReprLocals
0.12 reports.py(14): from _pytest._code.code import ReprTraceback
0.12 reports.py(15): from _pytest._code.code import TerminalRepr
0.12 reports.py(16): from _pytest.outcomes import skip
0.12 reports.py(17): from _pytest.pathlib import Path
0.12 reports.py(20): def getslaveinfoline(node):
0.12 reports.py(32): class BaseReport:
0.12 reports.py(32): class BaseReport:
0.12 reports.py(33):     when = None  # type: Optional[str]
0.12 reports.py(34):     location = None
0.12 reports.py(36):     def __init__(self, **kw):
0.12 reports.py(39):     def toterminal(self, out):
0.12 reports.py(55):     def get_sections(self, prefix):
0.12 reports.py(60):     @property
0.12 reports.py(61):     def longreprtext(self):
0.12 reports.py(74):     @property
0.12 reports.py(75):     def caplog(self):
0.12 reports.py(84):     @property
0.12 reports.py(85):     def capstdout(self):
0.12 reports.py(94):     @property
0.12 reports.py(95):     def capstderr(self):
0.12 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.12 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.12 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.12 reports.py(108):     @property
0.12 reports.py(109):     def fspath(self):
0.12 reports.py(112):     @property
0.12 reports.py(113):     def count_towards_summary(self):
0.12 reports.py(127):     @property
0.12 reports.py(128):     def head_line(self):
0.12 reports.py(149):     def _get_verbose_word(self, config):
0.12 reports.py(155):     def _to_json(self):
0.12 reports.py(166):     @classmethod
0.12 reports.py(167):     def _from_json(cls, reportdict):
0.12 reports.py(180): def _report_unserialization_failure(type_name, report_class, reportdict):
0.12 reports.py(192): class TestReport(BaseReport):
0.12 reports.py(192): class TestReport(BaseReport):
0.12 reports.py(193):     """ Basic test report object (also used for setup and teardown calls if
0.12 reports.py(197):     __test__ = False
0.12 reports.py(199):     def __init__(
0.12 reports.py(248):     def __repr__(self):
0.12 reports.py(253):     @classmethod
0.12 reports.py(254):     def from_item_and_call(cls, item, call):
0.12 reports.py(297): class CollectReport(BaseReport):
0.12 reports.py(297): class CollectReport(BaseReport):
0.12 reports.py(298):     when = "collect"
0.12 reports.py(300):     def __init__(self, nodeid, outcome, longrepr, result, sections=(), **extra):
0.12 reports.py(308):     @property
0.12 reports.py(309):     def location(self):
0.12 reports.py(312):     def __repr__(self):
0.12 reports.py(318): class CollectErrorRepr(TerminalRepr):
0.12 reports.py(318): class CollectErrorRepr(TerminalRepr):
0.12 reports.py(319):     def __init__(self, msg):
0.12 reports.py(322):     def toterminal(self, out):
0.12 reports.py(326): def pytest_report_to_serializable(report):
0.12 reports.py(333): def pytest_report_from_serializable(data):
0.12 reports.py(344): def _report_to_json(report):
0.12 reports.py(407): def _report_kwargs_from_json(reportdict):
============================= test session starts ==============================
platform linux -- Python 3.9.23, pytest-5.1.2.dev12+g955e54221, py-1.11.0, pluggy-0.13.1
rootdir: /testbed, inifile: tox.ini
0.26 reports.py(301):         self.nodeid = nodeid
0.26 reports.py(302):         self.outcome = outcome
0.26 reports.py(303):         self.longrepr = longrepr
0.26 reports.py(304):         self.result = result or []
0.26 reports.py(305):         self.sections = list(sections)
0.26 reports.py(306):         self.__dict__.update(extra)
0.26 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.26 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.26 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.26 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.27 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.27 reports.py(301):         self.nodeid = nodeid
0.27 reports.py(302):         self.outcome = outcome
0.27 reports.py(303):         self.longrepr = longrepr
0.27 reports.py(304):         self.result = result or []
0.27 reports.py(305):         self.sections = list(sections)
0.27 reports.py(306):         self.__dict__.update(extra)
0.27 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
collected 1 item

testing/test_coverup_pytest-dev__pytest-5787.py 0.27 reports.py(258):         when = call.when
0.27 reports.py(259):         duration = call.stop - call.start
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(261):         excinfo = call.excinfo
0.27 reports.py(262):         sections = []
0.27 reports.py(263):         if not call.excinfo:
0.27 reports.py(264):             outcome = "passed"
0.27 reports.py(265):             longrepr = None
0.27 reports.py(282):         for rwhen, key, content in item._report_sections:
0.27 reports.py(284):         return cls(
0.27 reports.py(285):             item.nodeid,
0.27 reports.py(286):             item.location,
0.27 reports.py(287):             keywords,
0.27 reports.py(288):             outcome,
0.27 reports.py(289):             longrepr,
0.27 reports.py(290):             when,
0.27 reports.py(291):             sections,
0.27 reports.py(292):             duration,
0.27 reports.py(293):             user_properties=item.user_properties,
0.27 reports.py(284):         return cls(
0.27 reports.py(213):         self.nodeid = nodeid
0.27 reports.py(218):         self.location = location
0.27 reports.py(222):         self.keywords = keywords
0.27 reports.py(225):         self.outcome = outcome
0.27 reports.py(228):         self.longrepr = longrepr
0.27 reports.py(231):         self.when = when
0.27 reports.py(235):         self.user_properties = list(user_properties or [])
0.27 reports.py(241):         self.sections = list(sections)
0.27 reports.py(244):         self.duration = duration
0.27 reports.py(246):         self.__dict__.update(extra)
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.27 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.27 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.27 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.28 reports.py(258):         when = call.when
0.28 reports.py(259):         duration = call.stop - call.start
0.28 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.28 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.28 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.28 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.28 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.28 reports.py(261):         excinfo = call.excinfo
0.28 reports.py(262):         sections = []
0.28 reports.py(263):         if not call.excinfo:
0.28 reports.py(267):             if not isinstance(excinfo, ExceptionInfo):
0.28 reports.py(270):             elif excinfo.errisinstance(skip.Exception):
0.28 reports.py(275):                 outcome = "failed"
0.28 reports.py(276):                 if call.when == "call":
0.28 reports.py(277):                     longrepr = item.repr_failure(excinfo)
0.30 reports.py(282):         for rwhen, key, content in item._report_sections:
0.30 reports.py(283):             sections.append(("Captured {} {}".format(key, rwhen), content))
0.30 reports.py(282):         for rwhen, key, content in item._report_sections:
0.30 reports.py(284):         return cls(
0.30 reports.py(285):             item.nodeid,
0.30 reports.py(286):             item.location,
0.30 reports.py(287):             keywords,
0.30 reports.py(288):             outcome,
0.30 reports.py(289):             longrepr,
0.30 reports.py(290):             when,
0.30 reports.py(291):             sections,
0.30 reports.py(292):             duration,
0.30 reports.py(293):             user_properties=item.user_properties,
0.30 reports.py(284):         return cls(
0.30 reports.py(213):         self.nodeid = nodeid
0.30 reports.py(218):         self.location = location
0.30 reports.py(222):         self.keywords = keywords
0.30 reports.py(225):         self.outcome = outcome
0.30 reports.py(228):         self.longrepr = longrepr
0.30 reports.py(231):         self.when = when
0.30 reports.py(235):         self.user_properties = list(user_properties or [])
0.30 reports.py(241):         self.sections = list(sections)
0.30 reports.py(244):         self.duration = duration
0.30 reports.py(246):         self.__dict__.update(extra)
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.30 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.30 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.30 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.30 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
F0.30 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.30 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.30 reports.py(258):         when = call.when
0.30 reports.py(259):         duration = call.stop - call.start
0.30 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.30 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.30 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.30 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.30 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.30 reports.py(261):         excinfo = call.excinfo
0.30 reports.py(262):         sections = []
0.30 reports.py(263):         if not call.excinfo:
0.30 reports.py(264):             outcome = "passed"
0.30 reports.py(265):             longrepr = None
0.30 reports.py(282):         for rwhen, key, content in item._report_sections:
0.30 reports.py(283):             sections.append(("Captured {} {}".format(key, rwhen), content))
0.30 reports.py(282):         for rwhen, key, content in item._report_sections:
0.30 reports.py(284):         return cls(
0.30 reports.py(285):             item.nodeid,
0.30 reports.py(286):             item.location,
0.30 reports.py(287):             keywords,
0.30 reports.py(288):             outcome,
0.30 reports.py(289):             longrepr,
0.30 reports.py(290):             when,
0.30 reports.py(291):             sections,
0.30 reports.py(292):             duration,
0.30 reports.py(293):             user_properties=item.user_properties,
0.30 reports.py(284):         return cls(
0.30 reports.py(213):         self.nodeid = nodeid
0.30 reports.py(218):         self.location = location
0.30 reports.py(222):         self.keywords = keywords
0.30 reports.py(225):         self.outcome = outcome
0.30 reports.py(228):         self.longrepr = longrepr
0.30 reports.py(231):         self.when = when
0.30 reports.py(235):         self.user_properties = list(user_properties or [])
0.30 reports.py(241):         self.sections = list(sections)
0.30 reports.py(244):         self.duration = duration
0.30 reports.py(246):         self.__dict__.update(extra)
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.30 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.30 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.30 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
                        [100%]

=================================== FAILURES ===================================
0.30 reports.py(145):         if self.location is not None:
0.30 reports.py(146):             fspath, lineno, domain = self.location
0.30 reports.py(147):             return domain
_____________________ test_chained_exception_serialization _____________________
0.30 reports.py(40):         if hasattr(self, "node"):
0.30 reports.py(43):         longrepr = self.longrepr
0.30 reports.py(44):         if longrepr is None:
0.30 reports.py(47):         if hasattr(longrepr, "toterminal"):
0.30 reports.py(48):             longrepr.toterminal(out)

    def test_chained_exception_serialization():
        # Simulate a test item and call with chained exceptions
        class FakeItem:
            nodeid = "test_chained_exception"
            location = ("test_file.py", 10, "test_chained_exception")
            keywords = {}
            user_properties = []
            _report_sections = []
    
            def repr_failure(self, excinfo):
                return str(excinfo.value)
    
            def _repr_failure_py(self, excinfo, style):
                return str(excinfo.value)
    
        class Call:
            def __init__(self, when, excinfo):
                self.when = when
                self.excinfo = excinfo
                self.stop = 1
                self.start = 0
    
        # Create a chained exception
        try:
            try:
                raise ValueError(11)
            except Exception as e1:
                raise ValueError(12) from e1
        except Exception as e2:
            excinfo = ExceptionInfo.from_current()
    
        # Create a test report with the exception
        item = FakeItem()
        call = Call("call", excinfo)
        report = TestReport.from_item_and_call(item, call)
    
        # Serialize the report using the function from the codebase
        def pytest_report_to_serializable(report):
            if isinstance(report, TestReport):
                data = report._to_json()
                data['_report_type'] = report.__class__.__name__
                return data
    
        serialized = pytest_report_to_serializable(report)
    
        # Check if the serialized report contains the full exception chain
        # This is the correct behavior we want to enforce
        assert "12" in serialized['longrepr']
>       assert "11" in serialized['longrepr']
E       AssertionError: assert '11' in '12'

testing/test_coverup_pytest-dev__pytest-5787.py:53: AssertionError
----------------------------- Captured stdout call -----------------------------
0.27 reports.py(258):         when = call.when
0.27 reports.py(259):         duration = call.stop - call.start
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(260):         keywords = {x: 1 for x in item.keywords}
0.27 reports.py(261):         excinfo = call.excinfo
0.27 reports.py(262):         sections = []
0.27 reports.py(263):         if not call.excinfo:
0.27 reports.py(267):             if not isinstance(excinfo, ExceptionInfo):
0.27 reports.py(270):             elif excinfo.errisinstance(skip.Exception):
0.27 reports.py(275):                 outcome = "failed"
0.27 reports.py(276):                 if call.when == "call":
0.27 reports.py(277):                     longrepr = item.repr_failure(excinfo)
0.27 reports.py(282):         for rwhen, key, content in item._report_sections:
0.27 reports.py(284):         return cls(
0.27 reports.py(285):             item.nodeid,
0.27 reports.py(286):             item.location,
0.27 reports.py(287):             keywords,
0.27 reports.py(288):             outcome,
0.27 reports.py(289):             longrepr,
0.27 reports.py(290):             when,
0.27 reports.py(291):             sections,
0.27 reports.py(292):             duration,
0.27 reports.py(293):             user_properties=item.user_properties,
0.27 reports.py(284):         return cls(
0.27 reports.py(213):         self.nodeid = nodeid
0.27 reports.py(218):         self.location = location
0.27 reports.py(222):         self.keywords = keywords
0.27 reports.py(225):         self.outcome = outcome
0.27 reports.py(228):         self.longrepr = longrepr
0.27 reports.py(231):         self.when = when
0.27 reports.py(235):         self.user_properties = list(user_properties or [])
0.27 reports.py(241):         self.sections = list(sections)
0.27 reports.py(244):         self.duration = duration
0.27 reports.py(246):         self.__dict__.update(extra)
0.27 reports.py(164):         return _report_to_json(self)
0.27 reports.py(352):     def serialize_repr_entry(entry):
0.27 reports.py(359):     def serialize_repr_traceback(reprtraceback):
0.27 reports.py(366):     def serialize_repr_crash(reprcrash):
0.27 reports.py(369):     def serialize_longrepr(rep):
0.27 reports.py(389):     d = report.__dict__.copy()
0.27 reports.py(390):     if hasattr(report.longrepr, "toterminal"):
0.27 reports.py(398):         d["longrepr"] = report.longrepr
0.27 reports.py(399):     for name in d:
0.27 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.27 reports.py(402):         elif name == "result":
0.27 reports.py(399):     for name in d:
0.27 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.27 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(400):         if isinstance(d[name], (py.path.local, Path)):
0.28 reports.py(402):         elif name == "result":
0.28 reports.py(399):     for name in d:
0.28 reports.py(404):     return d
0.31 reports.py(150):         _category, _short, verbose = config.hook.pytest_report_teststatus(
0.31 reports.py(151):             report=self, config=config
0.31 reports.py(150):         _category, _short, verbose = config.hook.pytest_report_teststatus(
0.31 reports.py(104):     passed = property(lambda x: x.outcome == "passed")
0.31 reports.py(106):     skipped = property(lambda x: x.outcome == "skipped")
0.31 reports.py(105):     failed = property(lambda x: x.outcome == "failed")
0.31 reports.py(153):         return verbose
=========================== short test summary info ============================
FAILED testing/test_coverup_pytest-dev__pytest-5787.py::test_chained_exception_serialization
0.31 reports.py(125):         return True
============================== 1 failed in 0.05s ===============================
+ cat coverage.cover
{"/testbed/src/_pytest/reports.py": {"1": 1, "2": 1, "4": 1, "6": 1, "7": 1, "8": 1, "9": 1, "10": 1, "11": 1, "12": 1, "13": 1, "14": 1, "15": 1, "16": 1, "17": 1, "20": 1, "32": 2, "180": 1, "192": 2, "297": 2, "318": 2, "326": 1, "333": 1, "344": 1, "407": 1, "21": 0, "22": 0, "23": 0, "24": 0, "25": 0, "26": 0, "27": 0, "29": 0, "33": 1, "34": 1, "36": 1, "39": 1, "55": 1, "60": 1, "61": 1, "74": 1, "75": 1, "84": 1, "85": 1, "94": 1, "95": 1, "104": 10, "105": 18, "106": 11, "108": 1, "109": 1, "112": 1, "113": 1, "127": 1, "128": 1, "149": 1, "155": 1, "166": 1, "167": 1, "37": 0, "40": 1, "41": 0, "43": 1, "44": 1, "45": 0, "47": 1, "48": 1, "50": 0, "51": 0, "52": 0, "53": 0, "56": 0, "57": 0, "58": 0, "68": 0, "69": 0, "70": 0, "71": 0, "72": 0, "80": 0, "81": 0, "90": 0, "91": 0, "100": 0, "101": 0, "110": 0, "125": 1, "145": 1, "146": 1, "147": 1, "150": 2, "151": 1, "153": 1, "164": 1, "176": 0, "177": 0, "181": 0, "182": 0, "183": 0, "184": 0, "185": 0, "186": 0, "187": 0, "188": 0, "189": 0, "197": 1, "199": 1, "248": 1, "253": 1, "254": 1, "213": 4, "218": 4, "222": 4, "225": 4, "228": 4, "231": 4, "235": 4, "241": 4, "244": 4, "246": 4, "249": 0, "250": 0, "258": 4, "259": 4, "260": 17, "261": 4, "262": 4, "263": 4, "264": 2, "265": 2, "267": 2, "268": 0, "269": 0, "270": 2, "271": 0, "272": 0, "273": 0, "275": 2, "276": 2, "277": 2, "279": 0, "280": 0, "282": 6, "283": 2, "284": 8, "285": 4, "286": 4, "287": 4, "288": 4, "289": 4, "290": 4, "291": 4, "292": 4, "293": 4, "298": 1, "300": 1, "308": 1, "309": 1, "312": 1, "301": 3, "302": 3, "303": 3, "304": 3, "305": 3, "306": 3, "310": 0, "313": 0, "314": 0, "319": 1, "322": 1, "320": 0, "323": 0, "327": 0, "328": 0, "329": 0, "330": 0, "334": 0, "335": 0, "336": 0, "337": 0, "338": 0, "339": 0, "340": 0, "352": 1, "359": 1, "366": 1, "369": 1, "389": 1, "390": 1, "391": 0, "392": 0, "394": 0, "396": 0, "398": 1, "399": 10, "400": 9, "401": 0, "402": 9, "403": 0, "404": 1, "353": 0, "354": 0, "355": 0, "356": 0, "357": 0, "360": 0, "361": 0, "362": 0, "364": 0, "367": 0, "371": 0, "372": 0, "373": 0, "370": 0, "375": 0, "376": 0, "377": 0, "378": 0, "380": 0, "381": 0, "382": 0, "379": 0, "386": 0, "387": 0, "414": 0, "441": 0, "447": 0, "451": 0, "450": 0, "452": 0, "453": 0, "456": 0, "457": 0, "459": 0, "460": 0, "461": 0, "462": 0, "463": 0, "464": 0, "465": 0, "467": 0, "468": 0, "469": 0, "466": 0, "472": 0, "474": 0, "476": 0, "477": 0, "478": 0, "480": 0, "415": 0, "416": 0, "417": 0, "418": 0, "419": 0, "420": 0, "421": 0, "422": 0, "423": 0, "424": 0, "425": 0, "426": 0, "428": 0, "429": 0, "430": 0, "431": 0, "432": 0, "433": 0, "435": 0, "436": 0, "438": 0, "439": 0, "442": 0, "443": 0, "445": 0, "448": 0}}
+ git checkout 955e54221008aba577ecbaefa15679f6777d3bf8
Note: switching to '955e54221008aba577ecbaefa15679f6777d3bf8'.

You are in 'detached HEAD' state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by switching back to a branch.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -c with the switch command. Example:

  git switch -c <new-branch-name>

Or undo this operation with:

  git switch -

Turn off this advice by setting config variable advice.detachedHead to false

HEAD is now at 955e54221 Merge pull request #5792 from dynatrace-oss-contrib/bugfix/badcase
M	src/_pytest/reports.py
+ git apply /root/pre_state.patch
error: unrecognized input
